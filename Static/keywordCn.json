[{"id":1,"title":"项目介绍","content":"  ______                          _____                              _        \n |  ____|                        / ____|                            | |       \n | |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___ \n |  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n | |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n |______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                          __/ |                                                \n                         |___/                                                \nEasySwoole\n\n\n\n\n\nEasySwoole 是一款基于Swoole Server 开发的常驻内存型的分布式PHP框架，专为API而生，摆脱传统PHP运行模式在进程唤起和文件加载上带来的性能损失。\nEasySwoole 高度封装了 Swoole Server 而依旧维持 Swoole Server 原有特性，支持同时混合监听HTTP、自定义TCP、UDP协议，让开发者以最低的学习成本和精力编写出多进程，可异步，高可用的应用服务。在开发上，我们为您准备了以下常用组件：\n\nhttp 服务服务器\n协程ORM(类似Tp Orm)\n图片验证码\nvalidate验证器\n协程模板渲染引擎\njwt组件\n协程TCP、UDP、WEB_SOCKET 服务端\n协程redis连接池\n协程mysql 连接池\n协程Memcached客户端\n协程通用链接池\n协程kafka客户端\nNSQ协程客户端\n分布式跨平台RPC组件\n协程consul客户端\n协程apollo配置中心\n协程Actor\n协程Smtp客户端\n协程微信公众号与小程序SDK\n协程协程版微信、支付宝支付SDK\n协程elasticsearch客户端\n协程HTTP客户端组件\n协程上下文管理\nIOC、协程上下文管理器\nsnowflake Id生成器\ncrontab 秒级任务\n自定义进程\n自定义消息队列\nTracker链路跟踪\nAtomic限流器\nfast-cache组件\npolicy权限组件\n\n以上组件为常用组件，更多组件请看组件库文档\n生产可用\nEasyswoole从最早的前身EasyPHP-Swoole，到更名为Easyswoole,再到现如今的EasySwoole 3.x版本，多年时间在众多社区小伙伴的共同努力下，EasySwoole的稳定与可靠已经经历了非常多的大企业检验。\n例如：\n\n腾讯公司的IEG部门\nWEGAME部门\n网宿科技（国内CDN厂家）\n360金融\n360小游戏（Actor）\n9377小游戏\n厦门美图网\n蝉大师\n\n等公司都在使用EasySwoole。\n特性\n\n强大的 TCP/UDP Server 框架，多线程，EventLoop，事件驱动，异步，Worker进程组，Task异步任务，毫秒定时器，SSL/TLS隧道加密\nEventLoop API，让用户可以直接操作底层的事件循环，将socket，stream，管道等Linux文件加入到事件循环中\n定时器、协程对象池、HTTP\\SOCK控制器、分布式微服务、RPC支持\n\n优势\n\n简单易用开发效率高\n并发百万TCP连接\nTCP/UDP/UnixSock\n支持异步/同步/协程\n支持多进程/多线程\nCPU亲和性/守护进程\n\n维护团队\n\n作者\n\n如果的如果 admin@fosuss.com   \n\n\n团队成员\n\n阿正 1589789807@qq.com\n会长 2788828128@qq.com\n北溟有鱼 1769360227@qq.com\n机器人 694050314@qq.com\nSiam(宣言) 59419979@qq.com\n仙士可 1067197739@qq.com\n史迪仔 975975398@qq.com\n\n\n\n以上排名不分先后        \n其他\n\n\nGitHub  喜欢记得点个star\n\n\nGitHub for Doc\n\n\nDEMO 暂且没有完全适配新版本,具体看文档.\n\n\nQQ交流群\n\nVIP群 579434607 （本群需要付费599元）\nEasySwoole官方一群 633921431(已满)\nEasySwoole官方二群 709134628(已满)\nEasySwoole官方三群 932625047(已满)\nEasySwoole官方四群 779897753(已满)\nEasySwoole官方五群 853946743\n\n\n\n商业支持：\n\nQQ 291323003\nEMAIL admin@fosuss.com   \n\n\n\n作者微信\n    \n\n\n捐赠\n您的捐赠是对EasySwoole项目开发组最大的鼓励和支持。我们会坚持开发维护下去。 您的捐赠将被用于:\n\n持续和深入地开发\n文档和社区的建设和维护\n\n\n\n\n\n\nif (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) {\n\n}else{\n        if(localStorage.getItem('isNew2') != 1){\n            $.ajax({\n                url: '/Preface/contact.html',\n                method: 'POST',\n                success: function (res) {\n                    var newHtml = $(res);\n                    var newBody = newHtml.find('.markdown-body').eq(0).html();\n                    localStorage.setItem('isNew2',1);\n                    layer.open({\n                      type: 1,\n                      title: '欢迎来到 EasySwoole，欢迎加入 QQ 交流群',\n                      shadeClose: true,\n                      shade: false,\n                      maxmin: true, \n                      area: ['893px', '600px'],\n                      content: \"\"+newBody+\"\"\n                    });                     \n                }\n            });        \n\n        }\n}   \n","link":"/Preface/intro.html"},{"id":2,"title":"交流群","content":"QQ 交流群\n\nVIP群 579434607 （本群需要付费599元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743 \n\n联系作者\n\n微信\n\n\n\n\nQQ \n\n291323003    \n\n\n","link":"/Preface/contact.html"},{"id":3,"title":"捐赠","content":"捐赠\n您的捐赠是对EasySwoole项目开发组最大的鼓励和支持。我们会坚持开发维护下去。 您的捐赠将被用于：\n\n持续和深入地开发\n文档和社区的建设和维护\n\n支付宝\n\n支付宝二维码支持花呗、信用卡分期付款\n微信\n\n通过微信捐赠的用户，请捐赠时留言您的名字，否则不知道您的大名\n捐赠者列表\n\n*章进\n*晓博\n*振宇\n*高明\n*东东\n*佳明\n*亮亮\n*凯峰\n*进国\n*海旋\n*志军\n*成龙\n*玲杰\n*东杰\n*鹏\n*力\n*宾\n*海伟\n*勇辉\n*思杰\n*龙翔\n*洋\n*伟平\n*坤平\n*勇城\n*锐\n*昆标\n*浩斌\n*博文\n*苏维\n*海涛\n*志成\n*磊\n*凯\n*建军\n*浩\n*永健\n*志强\n*少峰\n*坤磊\n*国锴\n*祖兴\n*宇翔\n*慧锋\n*萍萍\n*经国\n*超\n*达庆\n*瑾\n*强\n*民\n*振生\n*张虎\n*西湖\n*洪鐾\n*金发\n*洋\n*成永\n*俊德\n*涛\n*志银\n*科志\n*诚\n*杰\n*洪福\n*星\n*海弟\n*成龙\n*干\n*昌盛\n*坤磊\n*奇峰\n*远东\n*宾干\n*伟东\n*明磊\n*国恒\n*泉\n*进国\n*子华\n*刚\n*鹏亮\n*礼森\n*兵帅\n*旭\n*志超\n*以达\n*鹏鸿\n*航\n*亮\n*向荣\n*胜\n*艺轩\n*诸亮\n*志林\n*少峰\n*伟良\n*恒\n*钢筋\n*银\n*永欢\n*雏清\n*俊\n*凯\n*浩伟\n*亮亮\n*鹏辉\n*强\n*兵\n*金蓉\n*兴龙\n*龙辉\n*武益\n*艺\n\n以上名单为按照时间排序，与捐赠金额无关(多次捐赠者未避免重复也只写一次)，如果您不希望出现在该列表，或者是被遗漏了，请与 291323003@qq.com 联系。","link":"/Preface/donate.html"},{"id":4,"title":"框架更新记录","content":"框架更新记录\n\n框架更新记录仅仅整理自2020年10-24后的记录，其余记录以老版本文档或github记录为准。\n\n3.4.2 - 2020-12-22\n优化\n\n\ntask优化,更加灵活的配置.\n\ncrontab优化,避免极端情况下任务不执行.\n\nhttp-dispatcher优化,更加灵活的注册路由.\n\n3.4.1 - 2020-11-18\n新增\n\n增加SysConst::EXECUTE_COMMAND,此常量可获取主框架内部所执行的command.\n\ninstall命令函数检查symlink和readlink。\n\n修复\n\n修复worker异常退出，没有清理table信息。\n\n移除\n\n移除 command及 bridge 中动态配置 config 的功能，因为 3.4.x 的配置的存储不是使用 swoole-table 来存储。\n\n3.4.0 - 2020-10-24\n与3.3.x不兼容，需进行调整.\n3.3.x -&gt; 3.4.x需要重新执行php vendor/bin/easyswoole install.\n新增\n\n\nCore::getInstance()-&gt;runMode();方法. 可通过此方法修改运行文件,默认dev,也可以通过command进行修改.\n\n变更\n\n\ncommand命令变更.\n\n\n自定义command需进行调整.\n\n\nconfig从swoole-table改为splArray,用户可自行调整.\n\n\nonRequest及afterRequest全局事件\n变更为(initialize注册即可):\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, callback);\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_AFTER_REQUEST, callback);\ncallback为回调函数,注入参数为：\nfunction (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response){}\nonRequest事件需要返回bool,来决定程序是否继续进行dispatcher.\n\n\n移除\n\n\n移除EasySwooleEvent中onRequest及afterRequest全局事件.\n\n\n移除Core::getInstance()-&gt;isDev();方法.\n\n\n移除Core::getInstance()-&gt;globalInitialize();,可自行调用EasySwooleEvent::initialize().\n\n","link":"/Update/main.html"},{"id":5,"title":"组件更新记录","content":"组件更新记录\n\n框架更新记录仅仅整理自2020年10-24后的记录，其余记录以老版本文档或github记录为准。\n\nValidate\n1.2.8 - 2021-01-27\n新增\n\n\nlessThanWithColumn 验证字段的值必须小于with的字段(仅限int)\n\ngreaterThanWithColumn 验证字段的值必须大于with的字段(仅限int)\n\nMysqli\n2.2.8 - 2021-01-27\n新增\n\n支持mysql8.0+锁.\n\n修复\n\n修复拼接sql,+86等字符串被转为86.\n\n错误视图(Whoops)\n3.1.0 - 2021-01-20\n修复\n\n修复错误视图不兼容 template 1.1.0 组件接口，对 Whoops 组件依赖约束版本\n\n辅助类组件(IntStr)\n1.2.2 - 2021-01-08\n新增\n\n新增 IntStr 工具类，实现 字符串 和 数字 的相互转换，可用于 生成短链接，详见 IntStr 工具类\n\n\nPool\n1.0.12 - 2021-01-07\n优化\n\n优化 pool 组件的负载阀值，在并发峰值非持续性情况下，对池内连接进行负载，自动调控池内连接，让 pool 组件并发处理能力更强，详见 pool组件 loadAverageTime参数\n\n\nSnowFlake(雪花算法)\n1.2.0 - 2021-01-05\n优化\n\n缩短数据中心位至 5 bit: 0 ~ 31\n\n增长进程编号位至 7 bit: 0 ~ 127\n\n同毫秒序号为 11 bit: 0 ~ 2047\n\n理论上，当使用一秒一个数据中心，128 进程时，可以允许产生 1 * 128 * 1000 * 2047 = 26201600 个唯一 ID\n\n\nOrm\n1.4.32 - 2020-01-12\n修复\n\n修复where方法传入php内置函数关键字,is_callable为true.\n\n1.4.31 - 2020-12-22\n新增\n\n\nduplicate key支持.\n\ncollection增加toRawArray.\n\nwhere方法支持闭包函数.\n\n变更\n\n\ngetClientPool()方法调整为__getClientPool().\n\nupdate取消预算inc dec,直接为field = filed + 1.\n\n修复\n\n修复字段预定义属性不生效.\n屏蔽KeepMin异常导致进程退出.\n修复循环执行事务不生效问题.\n\n1.4.30 - 2020-11-2\n新增\n\n\nEasySwoole\\ORM\\Exception增加lastQueryResult.\n\n1.4.29 - 2020-10-29\n修复\n\n修复with关联调用setter问题.\n\nRedis-Pool\n2.2.1 - 2020-12-29\n2.1.x -&gt; 2.2.x不兼容,谨慎更新.\n变更\n\n\nclass名字进行合理化修改.\n\nclass参数顺序调整,调用更加合理化.\n调整invoke使用.\n\nRedis\n1.3.7 - 2020-12-24\n修复\n\n\nredis-cluster中,单个节点存在多个slot区间,无法识别问题.\n\n1.3.6 - 2020-12-14\n新增\n\nBZPopMax\nBZPopMin\nZPopMax\nZPopMin\n\n优化\n\nSPop\n\nHttp-Annotation\n1.5.0 - 2021-01-27\n新增\n\n\nParam注解增加lessThanWithColumn验证(validate 1.2.8+)\n\nParam注解增加greaterThanWithColumn验证(validate 1.2.8+)\n\n1.4.6 - 2021-01-05\n优化\n\n优化scanner非php文件.\n\n1.4.5 - 2021-01-02\n新增\n\n\nInject注解,支持注入class且参数传入.\n\n1.4.4 - 2020-12-23\n修复\n\n修复生成注解文档左侧栏标题错误问题.\n\nRpc\n5.0.3 - 2020-12-23\n增加\n\n可设置client中success及fail回调.\n可设置client调用参数.\n\nreqeuest及response中uuid\n\n\nresponse中status2msg.\n\n优化\n\n带权获取节点.\n\n5.0.1 - 2020-12-18\n修复\n\n局域网内udp-broadcast问题.\n\n5.0.0 - 2020-12-17\nrpc组件5.x版本发布.\n\n完善的节点管理机制.\n无主化服务发现.\n允许节点主动上下线.\n调用流程改为Service-Module-Action模式.\n开放全局onRequest.\n优化数据包结构,缩减通讯宽带.\n\nTemplate\n1.1.0 - 2020-12-29\n1.0.x -&gt; 1.1.x不兼容.\n\n数据包结构变更\n\ninterface变更.\n","link":"/Update/component.html"},{"id":6,"title":"文档贡献","content":"文档编写规范事项\n文档风格\n为了保障EasySwoole文档的风格基本统一，方便使用者阅读，请使用下面提供的示例风格编写文档内容。\n多版本\n每个章节文档默认显示最新版本对应的文档。如果组件错在多个版本，或者需要特殊说明。则请在对应章节文档开头处写上对应的版本连接。\n效果如：说明2或者如说明2\n风格1：\n[说明2](/Update/doc2.md)\n风格2：\n&lt;layerOpen href=\"/Update/doc2.md\"&gt;说明2&lt;/layerOpen&gt;\n层级风格\nEasySwoole 文档采用三级目录风格，语言-&gt;模块-&gt;章节 的形式进行组织内容，如某内容并不具体属于某模块，可以省略，具体组织方式如下：\n└── 语言\n    ├── 模块-1\n    │   └── 章节.md\n    ├── 模块-2\n    └── 章节.md\n分层原则\n\n\n语言 毫无争议，目前仅支持zh-cn和en\n\n\n模块 通常为相似功能的集合，或某个较为复杂的组件，新增一个模块应当谨慎\n\n章节 应当强调阅读顺序，从上到下渐进，非模块的章节可以长一些，相反模块的章节不应当过长\n\n关键词风格\n文档系统会对 .md 格式的特定语法进行美化，为了方便大家统一风格，请使用以下语法进行关键词修饰。\n希望用户在终端执行命令\n如果希望用户在终端执行某命令，可以使用 引用 语法。\n&gt; composer require easyswoole/easyswoole=3.x\n效果如下：\n\ncomposer require easyswoole/easyswoole=3.x\n\n如果希望用户在特定的地方执行命令，最好使用 重点 注释说明\n*请在终端执行以下命令*\n&gt; composer require easyswoole/easyswoole=3.x\n效果如下：\n请在终端执行以下命令\n\ncomposer require easyswoole/easyswoole=3.x\n\n高亮关键名词\n如果希望在描述中高亮某些名词，可以使用 反引号 进行修饰\n强大的 `TCP/UDP Server` 框架，`多线程`，`EventLoop`，`事件驱动`，`异步`，`Worker进程组`，`Task异步任务`，`毫秒定时器`，`SSL/TLS隧道加密`\n效果如下：\n强大的 TCP/UDP Server 框架，多线程，EventLoop，事件驱动，异步，Worker进程组，Task异步任务，毫秒定时器，SSL/TLS隧道加密\n描述函数或者 function\n\n描述函数和 function 必须简述其作用和输入输出参数，使用 代码块 指令最方便\n```php\nDbManager::getInstance()-&gt;invoke(callable function(MysqlClient $client));\n希望用户注意或警告用户\n如果希望提醒用户或者警告用户，可以使用扩展语法[^非md语法] tip warning 进行描述\n::: tip\n旧版本的invoke没有return值，请更新orm版本。\n:::\n\n::: warning  \n    注意EasySwoole的Temp目录不在虚拟机与宿主机共享目录下，否则会导致没有权限创建UnixSocket链接\n:::\n效果如下：\n旧版本的invoke没有return值，请更新orm版本。\n注意EasySwoole的Temp目录不在虚拟机与宿主机共享目录下，否则会导致没有权限创建UnixSocket链接\n章节案例\n组件库基本结构\n组件库的章节主要围绕如何让用户快速上手组件，和如果遇到问题如何解决构成的；优秀的文档应该是站在用户的角度进行编写的，提供可运行的代码片段非常重要。\n# 组件名称\n\n在章节开头描述组件的作用和用途，以及依赖的其他组件或者注意事项；以及组件主要是用来做什么的。\n\n## 组件要求\n\n最好在这里说明组件要求，防止用户在安装时遭遇失败。\n\n- php &gt;= 7.1\n- swoole &gt;= 4.4\n\n## 安装方法\n\n&gt; composer require 组件名称\n\n## 仓库地址\n\n在这里给出GitHub的仓库地址 使用[仓库名称](https://github.com/easy-swoole) 来创建一个超链接\n\n## 基本使用\n\n在这里描述组件的常用方法，以及用来做什么，具体怎么使用；给出代码。\n\n## 进阶使用\n\n在这里描述组件的进阶使用方法，比如可以用作其他相关业务，给出示例。\n\n## 相关仓库\n\n在这里给出组件的demo仓库，或基于此组件的开源项目。\n非组件库案例\n非组件案例一般是指常用的核心功能，或者是某个经典案例示例。\n# 功能名称\n\n## 功能介绍\n\n在这里介绍功能的主要用途，和通常适用于什么场景。\n\n## 相关Class位置\n\n在这里给出Class的Github地址，或是完整的`namespace`\n\n- HttpController\n    - [GitHub](https://github.com/easy-swoole/http/blob/master/src/AbstractInterface/Controller.php)\n    - `namespace`: `EasySwoole\\Http\\AbstractInterface`\n\n## 核心方法\n\n在这里给出核心或常用方法的原型；\n\n## 注意事项\n\n在这里给出常见的注意事项\n\n版本痕迹\n如果某个方法是特定版本增加，应当使用 重点 或 tip 语法进行描述。\n*3.3.4新增*\n\n::: tip\n3.3.4新增\n:::\n效果如下：\n3.3.4新增\n3.3.4新增","link":"/Update/doc.html"},{"id":7,"title":"环境要求","content":"环境要求\n满足基本的环境要求才能运行框架，EasySwoole 框架对环境的要求十分简单，只需要满足运行 Swoole 扩展的条件，并且 PHP 版本在 7.1 以上即可\n\n\nGitHub  喜欢记得点个 star\n\n\nGithub for Doc 文档贡献\n\n基础运行环境\n\n保证 PHP 版本大于等于 7.1\n\n保证 Swoole 拓展版本大于等于 4.4.23\n\n需要 pcntl 拓展的任意版本\n使用 Linux / FreeBSD / MacOS 这三类操作系统\n使用 Composer 作为依赖管理工具\n\n参考下面的建议，它们都不是必须的，但是有助于更高效的使用框架和进行开发\n\n使用 Ubuntu14 / CentOS 7.0 或更高版本操作系统\n\n其他\n\n\nQQ 交流群\n\nVIP群 579434607 （本群需要付费599元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743 \n\n\n\n商业支持：\n\nQQ 291323003\nEMAIL admin@fosuss.com\n\n\n\n作者微信\n\n\n\n捐赠 您的捐赠是对EasySwoole项目开发组最大的鼓励和支持。我们会坚持开发维护下去。 您的捐赠将被用于：\n\n持续和深入地开发\n文档和社区的建设和维护\n\n\n\nEasySwoole 的文档使用 EasySwoole 框架 提供服务，采用 MarkDown 格式 和自定义格式编写，若您在使用过程中，发现文档有需要纠正 / 补充的地方，请 fork 项目的文档仓库，进行修改补充，提交 Pull Request 并联系我们。\n\n","link":"/QuickStart/environment.html"},{"id":8,"title":"安装 swoole","content":"安装 Swoole\n下载\n首先进入 Swoole 的 Github 下载地址: https://github.com/swoole/swoole-src/releases\n如果没有特殊需求，请选择最新稳定版本开始下载(我这里是稳定版v4.4.23):   \n## 下载\ntioncico@tioncico-PC:/tmp$ wget https://github.com/swoole/swoole-src/archive/v4.4.23.tar.gz\n\n## 解压到当前目录\ntioncico@tioncico-PC:/tmp$ tar -zvxf v4.4.23.tar.gz\n\n## cd 到解压之后的目录\ntioncico@tioncico-PC:/tmp$ cd swoole-src-4.4.23/ \n\n## 使用 phpize 创建 php 编译检测脚本 ./configure\n##【注意：需要选择 php 对应版本的 phpize，这里使用的是绝对路径，否则编译安装无法生效】\ntioncico@tioncico-PC:/tmp/swoole-src-4.4.23$ /usr/local/php-7.2.2/bin/phpize\n\n## 创建编译文件，第一个 --with，后面是 php-config 的所在路径(这个路径一般和 php 在同一个目录) /usr/local/php-7.2.2/bin/php-config，第二个 --enable，是开启 Swoole 的 ssl 功能，第三个 --enable(可选参数)，是开启 Swoole 支持 http2 相关的功能\ntioncico@tioncico-PC:/tmp/swoole-src-4.4.23$ ./configure --with-php-config=/usr/local/php-7.2.2/bin/php-config --enable-openssl --enable-http2\n\n## 编译 Swoole 并把编译好的文件移动到 php 的扩展目录(前面的配置 php 版本的扩展目录) 需要root权限\ntioncico@tioncico-PC:/tmp/swoole-src-4.4.23$ sudo make &amp;&amp; make install \n\n## 编译成功会显示如下：\nBuild complete.\nDon't forget to run 'make test'.\n\nInstalling shared extensions:     /usr/local/php-7.2.2/lib/php/extensions/no-debug-non-zts-20160303/\nInstalling header files:          /usr/local/php-7.2.2/include/php/\n\n这个时候已经安装成功，需要修改 php 配置文件 php.ini，在最后面增加如下内容:\nextension=swoole.so\n注意：不知道 php.ini 所在目录时，您可以通过运行 php --ini 确定。\n例如，我这里 php.ini 是在 /usr/local/php-7.2.2/etc 目录：\ntioncico@tioncico-PC:/tmp/swoole-src-4.4.23$ php --ini\nConfiguration File (php.ini) Path: /usr/local/php-7.2.2/etc\nLoaded Configuration File:         /usr/local/php-7.2.2/etc/php.ini\nScan for additional .ini files in: (none)\nAdditional .ini files parsed:      (none)\n成功安装 Swoole 之后，通过 php --ri swoole 查看 Swoole 扩展 的信息:\ntioncico@tioncico-PC:/tmp/swoole-src-4.4.23$ php --ri swoole\n\nswoole\n\nSwoole =&gt; enabled\nAuthor =&gt; Swoole Team &lt;team@swoole.com&gt;\nVersion =&gt; 4.4.23\nBuilt =&gt; Jan 23 2021 18:16:30\ncoroutine =&gt; enabled\nepoll =&gt; enabled\neventfd =&gt; enabled\nsignalfd =&gt; enabled\ncpu_affinity =&gt; enabled\nspinlock =&gt; enabled\nrwlock =&gt; enabled\nopenssl =&gt; OpenSSL 1.0.2k-fips  26 Jan 2017\nhttp2 =&gt; enabled\npcre =&gt; enabled\nzlib =&gt; 1.2.7\nmutex_timedlock =&gt; enabled\npthread_barrier =&gt; enabled\nfutex =&gt; enabled\nasync_redis =&gt; enabled\n\nDirective =&gt; Local Value =&gt; Master Value\nswoole.enable_coroutine =&gt; On =&gt; On\nswoole.enable_library =&gt; On =&gt; On\nswoole.enable_preemptive_scheduler =&gt; Off =&gt; Off\nswoole.display_errors =&gt; On =&gt; On\nswoole.use_shortname =&gt; On =&gt; On\nswoole.unixsock_buffer_size =&gt; 8388608 =&gt; 8388608\n到此，Swoole 扩展就安装完毕。\n常见问题\nphpize 命令不存在\n安装phpize \nyum install php-devel ## centos\nsudo apt-get install php-dev  ## ubuntu\n提示 swoole.so.so 类似的报错\n说明你的 phpize 版本和 php-config 设定的版本不一致，请重新编译\nphpize 命令也可以使用绝对路径: php安装路径/bin/phpize 用于执行\n在之后的 --with-php-config 也得使用同样的路径: php安装路径/bin/php-config\n安装成功 php --ri 没有 Swoole 扩展信息\n说明你的 php 命令行版本，和安装 Swoole 的 php 版本不一致，可以通过: php安装路径/bin/php --ri swoole 进行确认是否安装成功","link":"/QuickStart/installSwoole.html"},{"id":9,"title":"框架安装","content":"框架安装\n\n\nGitHub  喜欢记得给我们点个 star\n\n\nGithub for Doc 文档贡献\n\n注意事项，请看完再进行安装\n\n框架使用 Composer 作为依赖管理工具，在开始安装框架前，请确保已经按上一章节的要求配置好环境并安装好了 Composer 工具\n关于 Composer 的安装可以参照 Composer中国全量镜像 的安装教程\n目前推荐的镜像为阿里云或者梯子拉取源站\n在安装过程中，会提示用户选择是否释放框架的 Index.php、Router.php 文件到项目目录(默认不会释放，也不会生成 App 目录)，请保证项目目录有可写入权限\n安装完成之后，如果没有自动生成 App 目录，请自行根据 Hello World 章节 章节进行配置\n\n框架更新说明(安装之前必看)\n\n更新说明\n\n切换阿里云镜像\ncomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\n删除镜像\ncomposer config -g --unset repos.packagist\nComposer 安装\n按下面的步骤进行手动安装\ncomposer require easyswoole/easyswoole=3.x\nphp vendor/easyswoole/easyswoole/bin/easyswoole install\n或者\ncomposer require easyswoole/easyswoole=3.x\nphp vendor/bin/easyswoole install\n如果执行成功，则会有如下界面:\n首次安装，会提示您是否选择释放(release) Index.php、Router.php 和 App 目录到项目目录\nphp vendor/easyswoole/easyswoole/bin/easyswoole install\n ______                          _____                              _        \n|  ____|                        / ____|                            | |       \n| |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___ \n|  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n| |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n|______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                         __/ |                                                \n                        |___/\ndo you want to release Index.php? [ Y / N (default) ] : Y\ndo you want to release Router.php? [ Y / N (default) ] : Y\ninstall success,enjoy!!!\ndont forget run composer dump-autoload !!!\n\n注意，上述输入了 Y 、 Y，表示选择了 release(释放) Index.php、Router.php 和 App 目录在项目根目录，默认 N 、 N 是不释放的，也不会自动生成 App 目录和 App 命名空间。\n\n新版安装注意事项\n\n新版的 EasySwoole 安装默认不会提供 App 命名空间，还有 Index 控制器\n重复安装时需要填写 N，不需要覆盖已经有的 EasySwooleEvent.php、index.php、dev.php、produce.php 等文件\n当提示 exec 函数被禁用时，请自己手动执行 composer dump-autoload 命令更新命名空间\n当提示 symlink 与 readlink 函数被禁用时，请自行修改 php.ini 配置文件取消这些函数的禁用\n\n重复安装时，会提示您是否选择 replace(覆盖) 如下文件 Index.php、Router.php、dev.php、produce.php、bootstrap.php、EasySwooleEvent.php，你可以根据需要选择是否覆盖(replace)，执行界面如下：\nphp vendor/easyswoole/easyswoole/bin/easyswoole install\n ______                          _____                              _        \n|  ____|                        / ____|                            | |       \n| |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___ \n|  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n| |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n|______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                         __/ |                                                \n                        |___/                                                \nIndex.php has already existed, do you want to replace it? [ Y / N (default) ] : N\nRouter.php has already existed, do you want to replace it? [ Y / N (default) ] : N\ndev.php has already existed, do you want to replace it? [ Y / N (default) ] : N\nproduce.php has already existed, do you want to replace it? [ Y / N (default) ] : N\nbootstrap.php has already existed, do you want to replace it? [ Y / N (default) ] : N\nEasySwooleEvent.php has already existed, do you want to replace it? [ Y / N (default) ] : N\ninstall success,enjoy!!!\ndont forget run composer dump-autoload !!!\n安装报错\n当执行安装脚本，出现类似以下错误时：\ndir=$(cd \"${0%[/\\\\]*}\" &gt; /dev/null; cd '../easyswoole/easyswoole/bin' &amp;&amp; pwd)\n\nif [ -d /proc/cygdrive ]; then\n    case $(which php) in\n        $(readlink -n /proc/cygdrive)/*)\n            # We are in Cygwin using Windows php, so the path must be translated\n            dir=$(cygpath -m \"$dir\");\n            ;;\n    esac\nfi\n\n\"${dir}/easyswoole\" \"$@\"\n请检查环境是否为宝塔等其他集成面板，或者是 php.ini 配置项中禁用了 symlink 与 readlink 函数，如果禁用了，请关闭这两个函数的禁用，并删除 vender 目录，然后重新执行 composer require 或者是 composer install 或者是 composer update。\n如果取消了函数禁用并且删除 vendor 目录，并重新执行 composer install 之后。依旧出现以上错误时，大概率是因为虚拟机等权限原因导致软链接失效。可使用 php vendor/easyswoole/easyswoole/bin/easyswoole 命令进行启动框架。或者直接修改项目根目录的 easyswoole 文件，引入 vendor/easyswoole/easyswoole/bin/easyswoole。\n启动框架\n中途没有报错的话，执行：\n# 启动框架\nphp easyswoole server start\n此时可以访问 http://localhost:9501 就看到框架的欢迎页面，表示框架已经安装成功\n可能的问题\n\n\nnot controller class match\n\n\ncomposer.json 注册 App 这个名称空间了吗？\n执行过 composer dump-autoload 了吗？\n存在 Index 控制器，但是文件大小写、路径都对了吗？\n\n\n\ntask socket listen fail\n\n注意，在部分环境下，例如 win10 的 docker 环境中，不可把虚拟机共享目录作为 EasySwoole 的 Temp 目录，否则会因为权限不足无法创建 socket，产生报错：listen xxxxxx.sock fail，为此可以手动在 dev.php 配置文件里把 Temp 目录改为其他路径即可，如：'/Tmp'\n\n\n\n\n其他\n\n\nQQ 交流群\n\nVIP 群 579434607 （本群需要付费599元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743\n\n\n\n商业支持：\n\nQQ 291323003\nEMAIL admin@fosuss.com\n\n\n\n作者微信\n\n\n\n捐赠 您的捐赠是对EasySwoole项目开发组最大的鼓励和支持。我们会坚持开发维护下去。 您的捐赠将被用于：\n\n持续和深入地开发\n文档和社区的建设和维护\n\n\n\n\n        if(localStorage.getItem('isNew') != 1){\n            localStorage.setItem('isNew',1);\n            layer.confirm('是否给 EasySwoole 点个赞',{offset:'c'},function (index) {\n                 layer.msg('感谢您的支持',{offset:'c'});\n                     setTimeout(function () {\n                         window.open('https://github.com/easy-swoole/easyswoole');\n                  },1500);\n             });              \n        }\n","link":"/QuickStart/install.html"},{"id":10,"title":"helloworld","content":"Hello World\n目录检查\n我们在执行完框架的安装步骤后，可以在项目根目录下看到一个自动生成的 App 目录。目录结构如下\n./App\n└── HttpController\n    ├── Index.php\n    └── Router.php\n如果缺少该目录，请返回框架安装步骤。\n自动加载检查\n打开 composer.json 文件，检查是否有注册了 App 命名空间。\n{\n    \"require\": {\n        \"easyswoole/easyswoole\": \"3.4.x\",\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"App\\\\\": \"App/\"\n        }\n    }\n}\n在 composer.json 文件中，如果在 psr-4 处，缺少 App 命名空间的映射，那么请自行手动补充。\n更新自动加载\n执行如下命令用于更新命名空间：\ncomposer dump-autoload\n启动服务\n在项目根目录下执行如下命令以守护模式启动easyswoole\nphp easyswoole server start -d\n在没有修改主服务端口的情况下，EasySwoole 默认的 HTTP 服务端口为 9501。我们可以 CURL 本地端口验证服务是否成功启动。\ncurl -I 127.0.0.1:9501\n\nHTTP/1.1 200 OK\nServer: EasySwoole\nContent-Type: text/html;charset=utf-8\nConnection: keep-alive\nDate: Sat, 18 Jul 2020 03:32:15 GMT\nContent-Length: 13143\n看到 200 状态码说明服务已经成功启动。\n停止服务\n在使用守护模式启动 EasySwoole 的时候，我们可以执行以下命令用于停止服务。\nphp easyswoole server stop\n若没用使用守护模式启动，则按键盘 Ctrl+C 键的时候，服务就会自动停止。若为远程终端，并且没有使用守护模式启动 EasySwoole，则在终端掉线的时候，会导致服务停止，甚至是服务成为僵尸进程，需要执行 killall 命令清除进程。","link":"/QuickStart/helloworld.html"},{"id":11,"title":"基础管理命令","content":"基本管理命令\n框架安装\n\nphp easyswoole install\n\n服务管理\nEasySwoole 框架主命令。  \n可执行 php easyswoole server -h 来查看具体操作。\n服务启动\n\nphp easyswoole server start\n\n守护进程方式启动\n\nphp easyswoole server start -d\n\n指定配置文件启动服务\n默认为 dev\n\nphp easyswoole server start -mode=produce\n\n停止服务\n\nphp easyswoole server stop\n\n强制停止服务\n\nphp easyswoole server stop -force\n\n热重启\n仅会重启 worker 进程\n\nphp easyswoole server reload\n\n重启服务\n-d 可选参数：守护进程\n\nphp easyswoole server restart\n\n服务状态\n\nphp easyswoole server status\n\n进程管理\nEasySwoole 内置对于 Process 的命令行操作，方便开发者友好地去管理 Process。\n可执行 php easyswoole process -h 来查看具体操作。\n显示所有进程\n\nphp easyswoole process show\n\n如果想要以 MB 形式显示：\n\nphp easyswoole process show -d\n\n杀死指定进程(PID)\n\nphp easyswoole process kill --pid=PID\n\n杀死指定进程组(GROUP)\n\nphp easyswoole process kill --group=GROUP_NAME\n\n杀死所有进程\n\nphp easyswoole process killAll\n\n强制杀死进程\n需要带上 -f 参数，例如：\n\nphp easyswoole process kill --pid=PID -f\n\nCrontab管理\nEasySwoole 内置对于 Crontab 的命令行操作，方便开发者友好地去管理 Crontab。\n可执行 php easyswoole crontab -h 来查看具体操作。\n查看所有注册的Crontab\n\nphp easyswoole crontab show\n\n停止指定的Crontab\n\nphp easyswoole crontab stop --name=TASK_NAME\n\n恢复指定的Crontab\n\nphp easyswoole crontab resume --name=TASK_NAME\n\n立即跑一次指定的Crontab\n\nphp easyswoole crontab run --name=TASK_NAME\n\nTask管理\n查看 Task 进程状态\n\nphp easyswoole task status\n\n单元测试\n协程方式\n\nphp easyswoole phpunit tests\n\n非协程方式\n\nphp easyswoole phpunit --no-coroutine\n","link":"/QuickStart/command.html"},{"id":12,"title":"开发者必读","content":"开发者必读\n\n\nGitHub  喜欢记得点个 star\n\n\n社区答疑\n\n\nQQ 交流群 \n\nVIP群 579434607 （本群需要付费599元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743\n\n\n\n商业支持：\n\nQQ 291323003\nEMAIL admin@fosuss.com\n\n\n\n注意事项\n\n不要在代码中执行 sleep 以及其他睡眠函数，这样会导致整个进程阻塞；协程中可以使用 Co::sleep()；\n\nexit/die 是危险的，会导致 Worker 进程退出；\n可通过 register_shutdown_function 来捕获致命错误，在进程异常退出时做一些清理工作；\n\nPHP 代码中如果有异常抛出，必须在回调函数中进行 try/catch 捕获异常，否则会导致工作进程退出；\n\nEasySwoole 不支持 set_exception_handler，必须使用 try/catch 方式处理异常；\n在控制器中不能写共享 Redis 或 MySQL 等网络服务客户端连接的逻辑，每次访问控制器都必须 new 一个连接\n\n类/函数重复定义\n\n新手非常容易犯这个错误，由于 EasySwoole 是常驻内存的，所以加载类/函数定义的文件后不会释放。因此引入类/函数的 php 文件时必须要使用 include_once 或 require_once，否则会发生 cannot redeclare function/class 的致命错误。\n\n建议使用 composer 做自动加载\n进程隔离与内存管理\n进程隔离也是很多新手经常遇到的问题。修改了全局变量的值，为什么不生效？原因就是全局变量在不同的进程，内存空间是隔离的，所以无效。\n所以使用 EasySwoole 开发 Server 程序需要了解 进程隔离 问题。\n\n\n不同的进程中 PHP 变量不是共享，即使是全局变量，在 A 进程内修改了它的值，在 B 进程内是无效的，如果需要在不同的Worker 进程内共享数据，可以用 Redis、MySQL、文件、Swoole\\Table、APCu、shmget 等工具实现 Worker 进程内共享数据\n\n\n不同进程的文件句柄是隔离的，所以在 A 进程创建的 Socket 连接或打开的文件，在 B 进程内是无效，即使是将它的 fd 发送到 B 进程也是不可用的。(句柄不能进程共享)\n\n\n进程克隆。在 Server 启动时，主进程会克隆当前进程状态，此后开始进程内数据相互独立，互不影响。有疑问的新手可以先弄懂PHP 的 pcntl 扩展\n\n\n\nEasySwoole 中对象的4层生命周期\n开发 Swoole 程序与普通 LAMP 下编程有本质区别。在传统的 Web 编程中，PHP 程序员只需要关注 request 到达，request 结束即可。而在 Swoole 程序中程序员可以操控更大范围，变量/对象可以有四种生存周期。\n变量、对象、资源、require/include 的文件等下面统称为对象\n程序全局期\n在 EasySwoole 框架根目录的 bootstrap.php 文件和 EasySwooleEvent.php 文件中的 initialize 事件函数中创建好的对象，我们称之为程序全局生命周期对象。这些变量只要没有被作用域销毁，在程序启动后就会一直存在，直到整个程序结束运行才会销毁。\n有一些服务器程序可能会连续运行数月甚至数年才会关闭/重启，那么程序全局期的对象在这段时间内会持续驻留在内存中的。程序全局期对象所占用的内存是 Worker 进程间共享的，不会额外占用内存。  \n例如:\n\n在 EasySwooleEvent.php 文件中的 initialize 事件函数中使用 Di 注入一个对象，那么在程序开始之后，在EasySwoole 的控制器中，或者其他地方都可以通过 Di 直接调用这个对象\n在 bootstrap.php 中引入一个文件 test.php，该文件定义了一个静态变量，那么在 EasySwoole 的控制器，或者其他地方都可以调用这个静态变量\n\n这部分内存会在写时分离（COW），在 Worker 进程内对这些对象进行写操作时，会自动从共享内存中分离，变为进程全局对象。\n例如:\n\n在 EasySwooleEvent.php 文件中的 initialize 事件函数中使用 Di 注入一个对象，并在用户 A 访问控制器时修改了这个对象的属性，那么其他用户访问控制器的时候，获取这个对象属性时，可能是未改变的状态(因为不同用户访问的控制器所在的进程不同，其他进程不会修改到这个变量，所以需要注意这个问题)；\n在 bootstrap.php 中引入一个文件 test.php，该文件定义了一个静态变量 $a = 1，用户 A 访问控制器时修改了变量 $a = 2，可能在其他用户访问时，依然还是 $a = 1 的状态。\n\n程序全局期 include/require 的代码，必须在整个程序 shutdown 时才会释放，reload 无效\n进程全局期\nSwoole 拥有进程生命周期控制的机制，Worker 进程启动后创建的对象（onWorkerStart 中创建的对象或者在控制器中创建的对象），在这个子进程存活周期之内，是常驻内存的。  \n例如:\n\n程序全局生命周期对象被控制器修改之后，该对象会复制一份出来到控制器所属的进程，这个对象只能被这个进程访问，其他进程访问的依旧是全局对象。\n给服务注册 onWorkerStart 事件(在 EasySwooleEvent.php 中的 mainServerCreate 事件中进行注册 onWorkerStart 事件)时创建的对象，只会在该 Worker 进程才能获取到。\n\n进程全局对象所占用的内存是在当前子进程内存堆的，并非共享内存。对此对象的修改仅在当前 Worker 进程中有效，进程全局期 include/require 的文件，在 reload 后就会重新加载\n会话期\n会话期是在 onConnect 后创建，或者在第一次 onReceive 时创建，onClose 时销毁。一个客户端连接进入后，创建的对象会常驻内存，直到此客户端断开连接才会销毁。  \n在 LAMP 中，一个客户端浏览器访问多次网站，就可以理解为会话期。但传统 PHP 程序，并不能感知到。只有单次访问时使用 session_start，访问 $_SESSION 全局变量才能得到会话期的一些信息。\nSwoole 中会话期的对象直接是常驻内存的，不需要 session_start 之类操作。可以直接访问对象，并执行对象的方法。\n请求期\n请求期是指一个完整的请求发来，也就是 onReceive 收到请求开始处理，直到返回结果发送 response。这个周期所创建的对象，会在请求完成后销毁。\nSwoole 中请求期对象与普通 PHP 程序中的对象就是一样的。请求到来时创建，请求结束后销毁。\nswoole_server 中内存管理机制\nswoole_server 启动后内存管理的底层原理与普通 php-cli 程序一致。具体请参考 Zend VM 内存管理方面的文章。\n局部变量\n在事件回调函数返回后，所有局部对象和变量会全部回收，不需要 unset 。如果变量是一个资源类型，那么对应的资源也会被 PHP 底层释放。\nfunction test()\n{\n    $a = new Object;\n    $b = fopen('/data/t.log', 'r+');\n    $c = new swoole_client(SWOOLE_SYNC);\n    $d = new swoole_client(SWOOLE_SYNC);\n    global $e;\n    $e['client'] = $d;\n}\n$a, $b, $c 都是局部变量，当此函数 return 时，这3个变量会立即释放，对应的内存会立即释放，打开的 IO 资源文件句柄会立即关闭。\n$d 也是局部变量，但是 return 前将它保存到了全局变量 $e，所以不会释放。当执行 unset($e['client']) 时，并且没有任何其他 PHP 变量仍然在引用 $d 变量，那么 $d 就会被释放。\n全局变量\n在 PHP 中，有3类全局变量。\n\n使用 global 关键词声明的变量\n使用 static 关键词声明的类静态变量、函数静态变量\n\nPHP 的超全局变量，包括 $_GET、$_POST、$GLOBALS 等\n\n全局变量和对象，类静态变量，保存在 swoole_server 对象上的变量不会被释放。需要程序员自行处理这些变量和对象的销毁工作。\nclass Test\n{\n    static $array = array();\n    static $string = '';\n}\n\nfunction onReceive($serv, $fd, $reactorId, $data)\n{\n    Test::$array[] = $fd;\n    Test::$string .= $data;\n}\n\n在事件回调函数中需要特别注意非局部变量的 array 类型值，某些操作如 TestClass::$array[] = \"string\" 可能会造成内存泄漏，严重时可能发生爆内存，必要时应当注意清理大数组。\n在事件回调函数中，非局部变量的字符串进行拼接操作是必须小心内存泄漏，如 TestClass::$string .= $data，可能会有内存泄漏，严重时可能发生爆内存。\n\n解决方法\n\n同步阻塞并且请求响应式无状态的 Server 程序可以设置 max_request，当 Worker进程/Task进程 结束运行时或达到任务上限后进程自动退出。该进程的所有变量/对象/资源均会被释放回收。\n程序内在 onClose 或设置定时器及时使用 unset 清理变量，回收资源\n\n内存管理部分参照了 Swoole 官方文档。\n约定规范\n\n项目中类名称与类文件(文件夹)命名，均为大驼峰，变量与类方法为小驼峰。\n在 HTTP 服务响应中，业务逻辑代码中 echo $var 并不会将 $var 内容输出至浏览器页面相应内容中，请调用 Response 实例中的 wirte() 方法实现。\n","link":"/QuickStart/notice.html"},{"id":13,"title":"常见问题","content":"常见问题\n端口占用\n可以通过lsof命令来查询端口占用\n&gt; lsof -i:9501\nCOMMAND PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME\nphp      57 root    3u  IPv4 1744902      0t0  TCP *:9501 (LISTEN)\n可以根据返回的pid使用kill命令来关闭相关进程\n&gt; kill -9 57\n也可以通过修改easyswoole的监听端口的方式启动easyswoole的服务，修改文件在dev.php（线上环境则应在produce.php）中\n&lt;?php\nreturn [\n    'SERVER_NAME' =&gt; \"EasySwoole\",\n    'MAIN_SERVER' =&gt; [\n        'LISTEN_ADDRESS' =&gt; '0.0.0.0',\n        'PORT' =&gt; 9501, //此处修改easyswoole监听端口号\n        ...\n    ],\n    'TEMP_DIR' =&gt; null,\n    'LOG_DIR' =&gt; null\n];\nSocket监听失败\n\n\n判断是否为端口占用所导致的监听失败，这里还是采用lsof命令来查看端口\n&gt; lsof -i:9501\n\n\n1024以下端口需要root权限监听，所以这里要特别注意\n\n\n外网无法访问\n\n\n检查服务监听端口是否为0.0.0.0\n\n\n检查防火墙是否对外开放\n&gt; netstat -anp\n//如果相关端口被防火墙拦截，需要放开\n&gt; firewall-cmd --zone=public --add-port=9501/tcp --permanent\n以上shell命令适用于centos7，其它linux发行版请自行查找相关命令\n\n","link":"/QuickStart/problem.html"},{"id":14,"title":"配置文件","content":"配置文件\nEasySwoole 框架提供了非常灵活自由的全局配置功能，配置文件采用 PHP 返回数组方式定义，对于一些简单的应用，无需修改任何配置，对于复杂的要求，还可以自行扩展自己独立的配置文件和进行动态配置。\n框架安装完成后系统默认的全局配置文件是项目根目录下的 produce.php 、 dev.php 文件，(在 3.1.2 版本之前是 dev.env、produce.env)，3.4.x 版本(最新版)支持在启动 EasySwoole 框架时以指定的配置文件( dev.php / produce.php)运行，详细启动命令请看基本管理命令章节。\n配置文件内容如下:\n&lt;?php\n\nreturn [\n    // 服务名称\n    'SERVER_NAME'   =&gt; \"EasySwoole\",\n    'MAIN_SERVER'   =&gt; [\n        // 监听地址\n        'LISTEN_ADDRESS' =&gt; '0.0.0.0',\n        // 监听端口\n        'PORT'           =&gt; 9501,\n        // 可选 EASYSWOOLE_SERVER,EASYSWOOLE_WEB_SERVER EASYSWOOLE_WEB_SOCKET_SERVER,EASYSWOOLE_REDIS_SERVER\n        'SERVER_TYPE'    =&gt; EASYSWOOLE_WEB_SERVER, \n        // 可选 SWOOLE_TCP SWOOLE_TCP6 SWOOLE_UDP SWOOLE_UDP6 SWOOLE_UNIX_DGRAM SWOOLE_UNIX_STREAM\n        'SOCK_TYPE'      =&gt; SWOOLE_TCP,\n        // 默认 Server 运行模式\n        'RUN_MODEL'      =&gt; SWOOLE_PROCESS,\n        // Swoole_Server 运行配置（ 完整配置可见[Swoole文档](https://wiki.swoole.com/wiki/page/274.html) ）\n        'SETTING'        =&gt; [\n            // 运行的 worker 进程数量\n            'worker_num'            =&gt; 8,\n            // 设置异步重启开关。设置为true时，将启用异步安全重启特性，Worker进程会等待异步事件完成后再退出。\n            'reload_async'          =&gt; true,\n            // 开启后自动在 onTask 回调中创建协程\n            'task_enable_coroutine' =&gt; true,\n            'max_wait_time'         =&gt; 3,\n            // (可选参数）使用 http 上传大文件时可以进行配置\n            // 'package_max_length' =&gt; 100 * 1024 * 1024, // 即 100 M\n\n            // (可选参数) 允许处理静态文件 html 等，详细请看 http://swoole-doc.easyswoole.com/ServerStart/Http/serverSetting.html\n            // 'document_root' =&gt; '/easyswoole/public',\n            // 'enable_static_handler' =&gt; true,\n        ],\n        // 设置 EasySwoole 框架独立实现的 Task 任务组件的配置\n        'TASK'=&gt;[\n            'workerNum'     =&gt; 4,\n            'maxRunningNum' =&gt; 128,\n            'timeout'       =&gt; 15\n        ]\n    ],\n    // 临时文件存放的目录\n    'TEMP_DIR'      =&gt; null,\n    // 日志文件存放的目录\n    'LOG_DIR'       =&gt; null,\n];\n上述参数补充说明：\n\nMAIN_SERVER.SERVER_TYPE: \n\nEASYSWOOLE_WEB_SERVER: 表示框架主服务为 Http 服务(框架默认提供的服务类型)\nEASYSWOOLE_SERVER: 表示框架主服务为 Tcp 服务\nEASYSWOOLE_WEB_SOCKET_SERVER: 表示框架主服务为 WebSocket 服务\nEASYSWOOLE_REDIS_SERVER: 表示框架主服务为 Redis 服务\n\n\n\nEASYSWOOLE_SERVER、EASYSWOOLE_WEB_SOCKET_SERVER类型，都需要在 EasySwooleEvent.php 的 mainServerCreate 事件中自行设置回调( receive 或 message )，否则将出错。具体设置对应的回调的方式请参考 Tcp服务章节 和 WebSocket服务章节。\n框架的配置驱动默认为 SplArray，自定义配置驱动可查看本文最后章节\n配置操作类\n配置操作类为 \\EasySwoole\\EasySwoole\\Config 类，使用方式非常简单，具体请看下面的代码示例，操作类还提供了 load 方法重载全部配置，基于这个方法，可以自己定制更多的高级操作\n设置和获取配置项都支持点语法分隔，具体请看下面获取配置的代码示例\n&lt;?php\n\n$instance = \\EasySwoole\\EasySwoole\\Config::getInstance();\n\n// 获取配置 按层级用点号分隔\n$instance-&gt;getConf('MAIN_SERVER.SETTING.task_worker_num');\n\n// 设置配置 按层级用点号分隔\n$instance-&gt;setConf('DATABASE.host', 'localhost');\n\n// 获取全部配置\n$conf = $instance-&gt;getConf();\n\n// 用一个数组覆盖当前配置项\n$conf['DATABASE'] = [\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 13306\n];\n$instance-&gt;load($conf);\n需要注意的是 由于进程隔离的原因，在 Server 启动后，动态新增修改的配置项，只对执行操作的进程生效，如果需要全局共享配置需要自己进行扩展\n添加用户配置项\n每个用户都有自己的配置项，添加自己的配置项非常简单，其中一种方法是直接在配置文件中添加即可，如下面的例子:\n下面示例中添加了自定义的 MySQL 和 Redis 配置。\n&lt;?php\nreturn [\n    'SERVER_NAME' =&gt; \"EasySwoole\",\n    'MAIN_SERVER' =&gt; [\n        'LISTEN_ADDRESS' =&gt; '0.0.0.0',\n        'PORT' =&gt; 9501,\n        'SERVER_TYPE' =&gt; EASYSWOOLE_WEB_SERVER, //可选为 EASYSWOOLE_SERVER  EASYSWOOLE_WEB_SERVER EASYSWOOLE_WEB_SOCKET_SERVER,EASYSWOOLE_REDIS_SERVER\n        'SOCK_TYPE' =&gt; SWOOLE_TCP,\n        'RUN_MODEL' =&gt; SWOOLE_PROCESS,\n        'SETTING' =&gt; [\n            'worker_num' =&gt; 8,\n            'reload_async' =&gt; true,\n            'max_wait_time'=&gt;3,\n            'document_root'            =&gt; EASYSWOOLE_ROOT . '/Static',\n            'enable_static_handler'    =&gt; true,\n        ],\n        'TASK'=&gt;[\n            'workerNum'=&gt;0,\n            'maxRunningNum'=&gt;128,\n            'timeout'=&gt;15\n        ]\n    ],\n    'TEMP_DIR' =&gt; null,\n    'LOG_DIR' =&gt; null,\n\n    // 添加 MySQL 及对应的连接池配置\n    /*################ MYSQL CONFIG ##################*/\n    'MYSQL' =&gt; [\n        'host'          =&gt; '192.168.75.1', // 数据库地址\n        'port'          =&gt; '3306', // 数据库端口\n        'user'          =&gt; 'root', // 数据库用户名\n        'timeout'       =&gt; '5', // 数据库连接超时时间\n        'charset'       =&gt; 'utf8mb4', // 数据库字符编码\n        'password'      =&gt; 'root', // 数据库用户密码\n        'database'      =&gt; 'cry', // 数据库名\n        'POOL_MAX_NUM'  =&gt; '20', // 数据库连接池 最大连接池数量\n        'POOL_TIME_OUT' =&gt; '0.1', // 数据库连接池 超时时间\n    ],\n\n    // 添加 Redis 及对应的连接池配置\n    /*################ REDIS CONFIG ##################*/\n    'REDIS' =&gt; [\n        'host'          =&gt; '127.0.0.1', // Redis地址\n        'port'          =&gt; '6379', // Redis端口\n        'auth'          =&gt; '', // Redis密码\n        'POOL_MAX_NUM'  =&gt; '20', // Redis连接池 最大连接池数量\n        'POOL_MIN_NUM'  =&gt; '5', // Redis连接池 最小连接池数量\n        'POOL_TIME_OUT' =&gt; '0.1', // Redis连接池 连接超时时间\n    ],\n];\n生产与开发配置分离\n在php easyswoole start命令下,默认为开发模式,加载 dev.php (3.1.2之前为 dev.env)\n运行 php easyswoole start produce 命令时,为生产模式,加载 produce.php (3.1.2之前为 produce.env)\nDI注入配置\nes3.x提供了几个Di参数配置,可自定义配置脚本错误异常处理回调,控制器命名空间,最大解析层级等\n&lt;?php\nDi::getInstance()-&gt;set(SysConst::ERROR_HANDLER,function (){}); // 配置错误处理回调\nDi::getInstance()-&gt;set(SysConst::SHUTDOWN_FUNCTION,function (){}); // 配置脚本结束回调\nDi::getInstance()-&gt;set(SysConst::HTTP_CONTROLLER_NAMESPACE,'App\\\\HttpController\\\\');// 配置控制器命名空间\nDi::getInstance()-&gt;set(SysConst::HTTP_CONTROLLER_MAX_DEPTH,5); // 配置http控制器最大解析层级\nDi::getInstance()-&gt;set(SysConst::HTTP_EXCEPTION_HANDLER,function (){}); // 配置http控制器异常回调\nDi::getInstance()-&gt;set(SysConst::HTTP_CONTROLLER_POOL_MAX_NUM,15); // http控制器对象池最大数量\n动态配置\n当你在控制器(worker进程)中修改某一项配置时,由于进程隔离,修改的配置不会在其他进程生效,所以我们可以使用动态配置:\n动态配置将配置数据存储在swoole_table中,取/修改配置数据时是从swoole_table直接操作,所有进程都可以使用\n由于swoole_table的特性,不适合存储大量/大长度的配置,如果是存储支付秘钥,签名等大长度字符串,建议使用类常量方法定义,而不是通过dev.php存储\n如果你非得用配置文件存储,请看本文下文的  自定义config驱动\n自定义Config驱动\nEasySwoole在3.2.5版本后,默认配置驱动存储 从SplArray改为了swoole_table,修改配置之后,所有进程同时生效\n\\EasySwoole\\Config\\AbstractConfig\nAbstractConfig 抽象类提供了以下几个方法,用于给其他config驱动继承\n\n__construct(bool $isDev = true)\n传入是否为开发环境的参数,根据该参数去加载dev.php或者produce.php\nisDev()\n可通过该方法获得当前运行环境是否为开发环境\nabstract function getConf($key = null);\n获取一个配置\nabstract function setConf($key,$val):bool ;\n设置一个参数\nabstract function load(array $array):bool ;\n重新加载配置项\nabstract function merge(array $array):bool ;\n合并配置项\nabstract function clear():bool ;\n清除所有配置项\n\n自定义配置\n在EasySwoole中,自带了SplArray和swoole_table驱动实现,可自行查看源码了解.\n默认驱动为swoole_table  \n如需要修改存储驱动,步骤如下:  \n\n继承 AbstractConfig 实现各个方法\n在bootstrap事件事件中修改config驱动(直接在文件中加入这行代码即可)\n\n&lt;?php\n\n\\EasySwoole\\EasySwoole\\Config::getInstance(new \\EasySwoole\\Config\\SplArrayConfig());\n由于bootstrap事件是由easyswoole启动脚本执行,当你需要写cli脚本需要初始化easyswoole框架基础组件时,需要自行引入bootstrap.php文件\n动态配置问题\n由于swoole是多进程的,如果使用SplArray方式存储,在单个进程修改配置后,其他进程将不会生效,使用swoole_table方式的则会全部生效,需要注意\n其他\n\n\nQQ 交流群\n\nVIP群 579434607 （本群需要付费 599 元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743 \n\n\n\n商业支持：\n\nQQ 291323003\nEMAIL admin@fosuss.com\n\n\n\n作者微信\n\n\n\n捐赠\n您的捐赠是对EasySwoole项目开发组最大的鼓励和支持。我们会坚持开发维护下去。 您的捐赠将被用于:\n\n持续和深入地开发\n文档和社区的建设和维护\n\n\n\neasySwoole 的文档采用 GitBook 作为文档撰写工具，若您在使用过程中，发现文档有需要纠正 / 补充的地方，请 fork 项目的文档仓库，进行修改补充，提交 Pull Request 并联系我们\n\n","link":"/QuickStart/config.html"},{"id":15,"title":"反向代理","content":"Proxy\n由于 Swoole Server 对 HTTP 协议的支持并不完整，建议仅将 EasySwoole 作为后端服务，并且在前端增加 NGINX 或 APACHE 作为代理，参照下面的例子添加转发规则\nNginx\nserver {\n    root /data/wwwroot/;\n    server_name local.swoole.com;\n    location / {\n        proxy_http_version 1.1;\n        proxy_set_header Connection \"keep-alive\";\n        proxy_set_header X-Real-IP $remote_addr;\n        if (!-f $request_filename) {\n             proxy_pass http://127.0.0.1:9501;\n        }\n    }\n}\n代理之后,可通过$request->getHeader('x-real-ip')[0]获取客户端真实ip \nApache\n&lt;IfModule mod_rewrite.c&gt;\n  Options +FollowSymlinks\n  RewriteEngine On\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteCond %{REQUEST_FILENAME} !-f\n  #RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]  fcgi下无效\n  RewriteRule ^(.*)$  http://127.0.0.1:9501/$1 [QSA,P,L]\n   #请开启 proxy_mod proxy_http_mod request_mod\n&lt;/IfModule&gt;\n其他\n\n\n项目文档仓库\n\n\nDEMO\n\n\nQQ 交流群\n\nVIP群 579434607 （本群需要付费 599 元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743\n\n\n\n商业支持：\n\nQQ 291323003\nEMAIL admin@fosuss.com\n\n\n\n作者微信\n\n\n\n捐赠 您的捐赠是对 EasySwoole 项目开发组最大的鼓励和支持。我们会坚持开发维护下去。 您的捐赠将被用于:\n\n持续和深入地开发\n文档和社区的建设和维护\n\n\n\nEasySwoole 的文档使用 EasySwoole 框架 提供服务，采用 MarkDown 格式 和自定义格式编写，若您在使用过程中，发现文档有需要纠正 / 补充的地方，请 fork 项目的文档仓库，进行修改补充，提交 Pull Request 并联系我们。\n\n","link":"/QuickStart/proxy.html"},{"id":16,"title":"什么是协程","content":"协程\n协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。   \n一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。而多个线程相对独立，有自己的上下文，切换受系统控制；\n而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。\n\n协程执行顺序\n原生php代码:\n&lt;?php\nfunction task1(){\n    for ($i=0;$i&lt;=300;$i++){\n        //写入文件,大概要3000微秒\n        usleep(3000);\n        echo \"写入文件{$i}\\n\";\n    }\n}\nfunction task2(){\n    for ($i=0;$i&lt;=500;$i++){\n        //发送邮件给500名会员,大概3000微秒\n        usleep(3000);\n        echo \"发送邮件{$i}\\n\";\n    }\n}\nfunction task3(){\n    for ($i=0;$i&lt;=100;$i++){\n        //模拟插入100条数据,大概3000微秒\n        usleep(3000);\n        echo \"插入数据{$i}\\n\";\n    }\n}\ntask1();\ntask2();\ntask3();\n在这个代码中，我们主要做了3件事:写入文件、发送邮件、及插入数据。\n再看下面这段代码：\n&lt;?php\nfunction task1($i)\n{\n    //使用$i标识 写入文件,大概要3000微秒\n    if ($i &gt; 300) {\n        return false;//超过300不用写了\n    }\n    echo \"写入文件{$i}\\n\";\n    usleep(3000);\n    return true;\n}\n\nfunction task2($i)\n{\n    //使用$i标识 发送邮件,大概要3000微秒\n    if ($i &gt; 500) {\n        return false;//超过500不用发送了\n    }\n    echo \"发送邮件{$i}\\n\";\n    usleep(3000);\n    return true;\n}\n\nfunction task3($i)\n{\n    //使用$i标识 插入数据,大概要3000微秒\n    if ($i &gt; 100) {\n        return false;//超过100不用插入\n    }\n    echo \"插入数据{$i}\\n\";\n    usleep(3000);\n    return true;\n}\n\n$i           = 0;\n$task1Result = true;\n$task2Result = true;\n$task3Result = true;\nwhile (true) {\n    $task1Result &amp;&amp; $task1Result = task1($i);\n    $task2Result &amp;&amp; $task2Result = task2($i);\n    $task3Result &amp;&amp; $task3Result = task3($i);\n    if($task1Result === false &amp;&amp; $task2Result === false &amp;&amp; $task3Result === false){\n        break;//全部任务完成,退出循环\n    }\n    $i++;\n}\n这段代码也是做了3件事，写入文件、发送邮件、及插入数据。但是和上面的不同的是，这段代码将这3件事交叉执行，每个任务执行完一次之后，切换到另一个任务，如此循环。类似于这样的执行顺序，就是协程。\n\n协程是指一种用代码实现任务交叉执行的逻辑，协程可以使得代码1中的3个函数交叉运行，在实现了协程的框架中，我们不需要通过代码2的方法实现任务交叉执行。直接可让代码1中的while(1)，执行一次后切换。\n\n协程的实现\n在php中,实现协程主要使用2种方式: \n\nyield生成器实现 (详细原理可查看http://www.php20.cn/article/148)\nswoole扩展实现\n\nswoole实现协程代码:\n&lt;?php\nfunction task1(){\n    for ($i=0;$i&lt;=300;$i++){\n        //写入文件,大概要3000微秒\n        usleep(3000);\n        echo \"写入文件{$i}\\n\";\n        Co::sleep(0.001);//挂起当前协程,0.001秒后恢复//相当于切换协程\n    }\n}\nfunction task2(){\n    for ($i=0;$i&lt;=500;$i++){\n        //发送邮件给500名会员,大概3000微秒\n        usleep(3000);\n        echo \"发送邮件{$i}\\n\";\n        Co::sleep(0.001);//挂起当前协程,0.001秒后恢复//相当于切换协程\n    }\n}\nfunction task3(){\n    for ($i=0;$i&lt;=100;$i++){\n        //模拟插入100条数据,大概3000微秒\n        usleep(3000);\n        echo \"插入数据{$i}\\n\";\n        Co::sleep(0.001);//挂起当前协程,0.001秒后恢复//相当于切换协程\n    }\n}\n$pid1 = go('task1');//go函数是swoole的开启协程函数,用于开启一个协程\n$pid2 = go('task2');\n$pid3 = go('task3');\n以上代码,即可实现切换函数。\n\n为什么要用sleep挂起协程实现切换呢？因为swoole的协程是自动的,当协程内遇上I/O操作(mysql,redis)等时，swoole的协程会自动切换，运行到下一个协程任务中(切换后,I/O继续执行)，直到下一个协程任务完成或者被切换(遇上I/O)，如此反复，直到所有协程任务完成，则任务完成。\n\n协程与进程\n由上面的协程执行顺序中的代码2,我们很容易发现,协程其实只是运行在一个进程中的函数,只是这个函数会被切换到下一个执行,可以这么说:\n\n协程只是一串运行在进程中的任务代码，只是这些任务代码可以交叉运行。\n注意，协程并不是多任务并行，属于多任务串行，每个进程在一个时间只执行了一个任务。\n","link":"/QuickStart/Coroutine/introduction.html"},{"id":17,"title":"创建协程","content":"协程\n从 4.0 版本开始 Swoole 提供了完整的协程（Coroutine）+ 通道（Channel）特性，带来全新的 CSP 编程模型。应用层可使用完全同步的编程方式，底层自动实现异步IO。\n协程可以理解为纯用户态的线程，其通过协作而不是抢占来进行切换。相对于进程或者线程，协程所有的操作都可以在用户态完成，创建和切换的消耗更低。Swoole 可以为每一个请求创建对应的协程，根据 IO 的状态来合理的调度协程，这会带来了以下优势：\n\n开发者可以无感知的用同步的代码编写方式达到 异步IO 的效果和性能，避免了传统异步回调所带来的离散的代码逻辑和陷入多层回调中导致代码无法维护；\n同时由于底层封装了协程，所以对比传统的 PHP 层协程框架，开发者不需要使用 yield 关键词来标识一个 协程IO操作，所以不再需要对 yield 的语义进行深入理解以及对每一级的调用都修改为 yield，这极大地提高了开发效率；\n可以满足大部分开发者的需求。对于私有协议，开发者可以使用协程的 TCP 或者 UDP 接口去方便的封装。\n\n注意事项\n\n全局变量：协程使得原有的异步逻辑同步化，但是在协程中的切换是隐式发生的，所以在协程中切换的前后不能保证 全局变量 以及 static 变量 的一致性。\n与 xdebug、xhprof、blackfire 等 zend 扩展不兼容，例如不能使用 xhprof 对 协程 server 进行性能分析采样。\n\n创建协程\n&lt;?php\ngo(function () {\n    co::sleep(0.5);\n    echo \"hello\";\n});\ngo(\"test\");\ngo([$object, \"method\"]);","link":"/QuickStart/Coroutine/coroutineCreate.html"},{"id":18,"title":"注意事项","content":"协程注意事项\n变量使用\n\n在协程中，需要特别注意，不要使用$_GET，$_POST，$GLOBALS等超全局变量，尤其是需要修改变量值并读取时，将造成协程间变量数据错乱。  \n协程中访问外部变量必须使用use关键字，或者传形参方式，不能引用变量。  \n如果需要做多协程之间的通信，可使用channel方式通信。\n\n扩展冲突\n\n与xdebug、xhprof、blackfire等zend扩展不兼容，例如不能使用xhprof对协程server进行性能分析采样。\n\n退出协程\n在Swoole&gt;=v4.1.0之后，使用exit退出将只退出当前协程，并在当前协程抛出一个Swoole\\ExitException。\n在Swoole&lt;v4.1.0时，如果使用exit，将会造成整个进程退出，禁止使用。  \n通过拦截Swoole\\ExitException异常，可获得这次退出的信息。\n&lt;?php\ngo(function (){\n    try{\n        test();\n    }catch (\\Swoole\\ExitException $exception){\n        var_dump($exception);\n    }\n});\n\nfunction test(){\n    test2();\n}\nfunction test2(){\n    exit(2);\n}","link":"/QuickStart/Coroutine/notice.html"},{"id":19,"title":"waitgroup等待","content":"waitgroup\n示例代码：\n&lt;?php\ngo(function (){\n    $ret = [];\n\n    $wait = new \\EasySwoole\\Component\\WaitGroup();\n\n    $wait-&gt;add();\n    go(function ()use($wait,&amp;$ret){\n        \\co::sleep(0.1);\n        $ret[] = time();\n        $wait-&gt;done();\n    });\n\n    $wait-&gt;add();\n    go(function ()use($wait,&amp;$ret){\n        \\co::sleep(2);\n        $ret[] = time();\n        $wait-&gt;done();\n    });\n\n    $wait-&gt;wait();\n\n    var_dump($ret);\n});","link":"/QuickStart/Coroutine/waitGroup.html"},{"id":20,"title":"csp并发","content":"Csp 并发模式\n当我们需要并发执行某些不相干的请求，并得到结果的时候，例如：\n$sql1-&gt;exec();\n$sql2-&gt;exec();\n$sql2-&gt;exec();\n在以上的代码中，我们没办法最大的节约时间，因为sql语句都是顺序执行的，因此我们引入了Csp并发编程的概念。\n示例代码\ngo(function (){\n    $channel = new \\Swoole\\Coroutine\\Channel();\n    go(function ()use($channel){\n        //模拟执行sql\n        \\co::sleep(0.1);\n        $channel-&gt;push(1);\n    });\n    go(function ()use($channel){\n        //模拟执行sql\n        \\co::sleep(0.1);\n        $channel-&gt;push(2);\n    });\n    go(function ()use($channel){\n        //模拟执行sql\n        \\co::sleep(0.1);\n        $channel-&gt;push(3);\n    });\n\n    $i = 3;\n    while ($i--){\n        var_dump($channel-&gt;pop());\n    }\n});\n当然，在以上的代码中，我们没有充分的考虑超时等情况\n进一步封装\ngo(function (){\n    $csp = new \\EasySwoole\\Component\\Csp();\n    $csp-&gt;add('t1',function (){\n        \\co::sleep(0.1);\n       return 't1 result';\n    });\n    $csp-&gt;add('t2',function (){\n        \\co::sleep(0.1);\n        return 't2 result';\n    });\n\n    var_dump($csp-&gt;exec());\n});\nexec方法提供了一个默认参数：超时时间(默认为5s)，当调用$csp->exec()后，最长等待5s左右会返回结果。如果你在t2函数中co::sleep(6)，那么5s后，返回的数据中不会包含t2函数的返回数据。","link":"/QuickStart/Coroutine/csp.html"},{"id":21,"title":"上下文管理器","content":"Context上下文管理器\n在Swoole中，由于多个协程是并发执行的，因此不能使用类静态变量/全局变量保存协程上下文内容。使用局部变量是安全的，因为局部变量的值会自动保存在协程栈中，其他协程访问不到协程的局部变量。\n因Swoole属于常驻内存，在特殊情况下声明变量，需要进行手动释放，释放不及时，会导致非常大的内存开销，使服务宕掉。\nContextManager上下文管理器存储变量会自动释放内存，避免开发者不小心而导致的内存增长。\n原理\n\n通过当前协程id以key来存储该变量。\n注册defer函数。\n协程退出时，底层自动触发defer进行回收。\n\n安装\nEasySwoole默认加载该组件，无须开发者引入。在非EasySwoole框架中使用，开发者可自行引入。\n\ncomposer require easyswoole/component\n\n基础例子\nuse EasySwoole\\Component\\Context\\ContextManager;\ngo(function (){\n    ContextManager::getInstance()-&gt;set('key','key in parent');\n    go(function (){\n        ContextManager::getInstance()-&gt;set('key','key in sub');\n        var_dump(ContextManager::getInstance()-&gt;get('key').\" in\");\n    });\n    \\co::sleep(1);\n    var_dump(ContextManager::getInstance()-&gt;get('key').\" out\");\n});\n以上利用上下文管理器来实现协程上下文的隔离。\n自定义处理项\n例如，当有一个key，希望在协程环境中，get的时候执行一次创建，在协程退出的时候可以进行回收，就可以注册一个上下文处理项来实现。该场景可以用于协程内数据库短连接管理。\nuse EasySwoole\\Component\\Context\\ContextManager;\nuse EasySwoole\\Component\\Context\\ContextItemHandlerInterface;\n\nclass Handler implements ContextItemHandlerInterface\n{\n\n    function onContextCreate()\n    {\n        $class = new \\stdClass();\n        $class-&gt;time = time();\n        return $class;\n    }\n\n    function onDestroy($context)\n    {\n        var_dump($context);\n    }\n}\n\nContextManager::getInstance()-&gt;registerItemHandler('key',new Handler());\n\ngo(function (){\n    go(function (){\n        ContextManager::getInstance()-&gt;get('key');\n    });\n    \\co::sleep(1);\n    ContextManager::getInstance()-&gt;get('key');\n});","link":"/Components/Component/context.html"},{"id":22,"title":"php-fpm进程模型","content":"php-fpm进程模型\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/php-fpm%E4%BB%8B%E7%BB%8D.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\nphp多进程模型介绍(附录)\nphp多进程模型介绍(WorkMan作者公开的pdf)","link":"/Video/Basic/php-fpmProcessModel.html"},{"id":23,"title":"swoole进程模型","content":"swoole进程模型\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/swoole%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%7E2.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Basic/swooleProcessModel.html"},{"id":24,"title":"swoole生命周期","content":"swoole生命周期\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/swoole%E5%8F%98%E9%87%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Basic/swooleLifeCycle.html"},{"id":25,"title":"协程简介","content":"协程简介\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/%E5%8D%8F%E7%A8%8B%E7%AE%80%E4%BB%8B.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Basic/coroutineIntroduction.html"},{"id":26,"title":"协程带来的影响","content":"协程带来的影响\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/%E5%8D%8F%E7%A8%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Basic/impactOfCoroutine.html"},{"id":27,"title":"序章","content":"序章\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/install/0-1-%e5%ba%8f%e7%ab%a0.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Install/prologue.html"},{"id":28,"title":"安装git","content":"安装Git\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/install/1-1-%e5%ae%89%e8%a3%85Git.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n附录\nGit的下载地址","link":"/Video/Install/installGit.html"},{"id":29,"title":"安装virtualbox和vagrant","content":"安装VirtualBox和Vagrant\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/install/1-2-%e5%ae%89%e8%a3%85VirtualBox%e5%92%8cVagrant.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n附录\nVirtualBox下载地址\nVagrant下载地址\nVagrant的安装及使用-简书-陈小陌丿","link":"/Video/Install/installVagrant.html"},{"id":30,"title":"配置vagrantfile","content":"配置Vagrantfile\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/install/1-3-%e9%85%8d%e7%bd%aeVagrantfile.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n附录\nVagrant的安装及使用-简书-陈小陌丿\nVagrant-CentOs7.6.box下载地址-微云\n密码：easysw","link":"/Video/Install/configureVagrantFile.html"},{"id":31,"title":"安装运行环境","content":"安装运行环境\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/install/1-4-%e5%ae%89%e8%a3%85%e8%bf%90%e8%a1%8c%e7%8e%af%e5%a2%83.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n附录\n宝塔-官方网站","link":"/Video/Install/installEnvironment.html"},{"id":32,"title":"安装swoole","content":"安装Swoole\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/install/1-5-%e5%ae%89%e8%a3%85Swoole.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n附录\nSwoole-GitHub-releases","link":"/Video/Install/installSwoole.html"},{"id":33,"title":"安装composer并配置共享目录","content":"安装Composer并设置共享目录\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/install/1-6-%e5%ae%89%e8%a3%85composer%e5%92%8c%e8%ae%be%e7%bd%ae%e5%85%b1%e4%ba%ab%e7%9b%ae%e5%bd%95.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n附录\nComposer官方下载地址  不太推荐很慢\nComposer阿里云下载地址","link":"/Video/Install/installComposer.html"},{"id":34,"title":"安装easyswoole","content":"安装EasySwoole\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/install/1-7-%e5%ae%89%e8%a3%85EasySwoole%e6%a1%86%e6%9e%b6.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Install/installEasySwoole.html"},{"id":35,"title":"http解析与路由","content":"Http解析与路由\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/EasySwooleHttp%E8%A7%A3%E6%9E%90%E5%92%8C%E8%B7%AF%E7%94%B1%E7%AE%80%E4%BB%8B.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/HttpRelated/route.html"},{"id":36,"title":"controller对象简介和池模型介绍","content":"Controller对象简介和池模型介绍\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/EasySwooleController%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B%E5%92%8C%E6%B1%A0%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/HttpRelated/controllerCharacteristic.html"},{"id":37,"title":"异常处理","content":"异常处理\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/HTTP%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/HttpRelated/exception.html"},{"id":38,"title":"安装及配置信息注册","content":"安装及配置信息注册\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/es-orm/1.+%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E6%B3%A8%E5%86%8C.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/install.html"},{"id":39,"title":"定义模型","content":"定义模型\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/es-orm/2.%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/defineModel.html"},{"id":40,"title":"查询","content":"查询\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/es-orm/3.%E6%9F%A5%E8%AF%A2.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/search.html"},{"id":41,"title":"新增","content":"新增\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/es-orm/4.%E6%96%B0%E5%A2%9E.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/add.html"},{"id":42,"title":"删除","content":"删除\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/es-orm/6.%E5%88%A0%E9%99%A4.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/del.html"},{"id":43,"title":"更新","content":"更新\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/es-orm/7.%E6%9B%B4%E6%96%B0.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/update.html"},{"id":44,"title":"模型结果","content":"模型结果\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/es-orm/8.%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%9C.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/modelResult.html"},{"id":45,"title":"读写分离","content":"读写分离\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/es-orm/9.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E3%80%82.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/readWrite.html"},{"id":46,"title":"聚合","content":"聚合\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/es-orm/10.%E8%81%9A%E5%90%88.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/aggr.html"},{"id":47,"title":"事务","content":"事务\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/es-orm/11.%E4%BA%8B%E5%8A%A1.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/trans.html"},{"id":48,"title":"修改器、获取器","content":"修改器、获取器\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/es-orm/13.%E4%BF%AE%E6%94%B9%E5%99%A8%E3%80%81%E8%8E%B7%E5%8F%96%E5%99%A8.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/setterGetter.html"},{"id":49,"title":"invoke","content":"invoke\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/es-orm/14.invoke.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/invoke.html"},{"id":50,"title":"并发查询","content":"并发查询\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9F%A5%E8%AF%A2.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/ExtraVideo/concurrentQuery.html"},{"id":51,"title":"csp编程","content":"Csp编程\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/%E5%85%A5%E9%97%A8csp.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/ExtraVideo/Csp.html"},{"id":52,"title":"异步任务","content":"异步任务\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/task.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/ExtraVideo/asyncTask.html"},{"id":53,"title":"自定义进程","content":"自定义进程\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%9B%E7%A8%8B.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n\n文档传送门 👉 自定义进程","link":"/Video/ExtraVideo/customProcess.html"},{"id":54,"title":"http上传","content":"Http上传\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/fileupload.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/ExtraVideo/httpUpload.html"},{"id":55,"title":"words-match文本检测","content":"Words-match\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://video-oss.easyswoole.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/words-match.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/ExtraVideo/words-match.html"},{"id":56,"title":"启动流程","content":"框架启动流程\n一、自动加载\n我们在执行如下命令的时候：\nphp easyswoole server start\n项目目录下的 easyswoole 这个文件，会搜索项目目录下是否存在 composer 所生成的 autoload.php 这个文件，用于实现 psr-4 自动加载，当文件不存在的时候，则终止框架启动。\n二、基础常量定义\n在搜索到了 autoload.php 文件后，框架启动脚本则会认定为已经成功注册了 composer 的自动加载机制，随后，会根据autoload.php 所在的位置，进行如下几个常量的预定义。\n\n\nIN_PHAR\n定义规则为 defined('IN_PHAR') or define('IN_PHAR', boolval(\\Phar::running(false)));，该常量可以用于判定当前服务是否在 PHAR 环境中。\n\n\nRUNNING_ROOT\n定义规则为 defined('RUNNING_ROOT') or define('RUNNING_ROOT', $realCwd);，该常量可以用于定义当前服务运行的根目录，是一个绝对路径。\n\n\nEASYSWOOLE_ROOT\n定义规则为 defined('EASYSWOOLE_ROOT') or define('EASYSWOOLE_ROOT', IN_PHAR ? \\Phar::running() : $realCwd);，该常量用于定义当前项目所在路径的根目录，是一个绝对路径。\n\n\n三、bootstrap 文件引入\nEasySwoole 启动脚本会判断在项目根目录下，也就是 EASYSWOOLE_ROOT.'/bootstrap.php' 这个文件是否存在，如果存在，那么则会执行一次 require_once。用户可以在框架没有做任何的真实初始化之前，做自己的预处理或者是预定义。(注：3.4.x及以上版本在框架安装时会自动生成一个 bootstrap 文件在项目根目录，3.4.x 之前的版本需要用户自行添加。)\n四、启动命令解析\nEasySwoole 主框架定义了一个命令容器，完整命名空间为 \\EasySwoole\\EasySwoole\\Command\\CommandRunner，这个是一个单例对象，是对 \\EasySwoole\\Command\\CommandManager 对象的进一步调用封装。在对象的构造函数中，默认注册了 EasySwoole 自带的几个命令：\n\nCrontab\nInstall\nPhpUnit\nProcess\nServer\nTask\n\n以如下启动命令为例：\nphp easyswoole server start -d\n\n-d 可选，为守护启动参数\n\nCommandRunner 会执行 server 命令的 start 行为，其中，server 命令的完整实现在 \\EasySwoole\\EasySwoole\\Command\\DefaultCommand\\Server。\nServer 主命令\nserver 主命令被执行时，做了以下操作：\n\n判断是否指定了运行模式\n$mode = CommandManager::getInstance()-&gt;getOpt('mode');\nif(!empty($mode)){\n  Core::getInstance()-&gt;runMode($mode);\n}\n\n执行框架的初始化\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()\n\n\nStart 行为\n在 start 行为中，做了如下两件事：\n\n获取配置对象并设置运行时必须参数\n执行框架的最终启动\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;createServer()-&gt;start();\n\n","link":"/FrameDesign/start.html"},{"id":57,"title":"servermanager.php","content":"ServerManager\nServerManager 是 EasySwoole 框架中，用于全局存储 Swoole 对象实例 所用的一个单例对象。完整的代码实现在 \\EasySwoole\\EasySwoole\\ServerManager。\n关键函数\n__construct\n在构造函数中，ServerManager 实例化了一个事件注册器 \\EasySwoole\\EasySwoole\\Swoole\\EventRegister，本质上这是一个数组容器。该容器用于存储注册给 Swoole 实例的事件回调。\ncreateSwooleServer\n该函数会根据所传递的参数与配置项，创建一个 Swoole 实例，并把该实例赋值存储到 ServerManager 对象 的 swooleServer 属性中。\naddServer\n该函数用于调用 Swoole 实例 的 addlistener 方法，创建一个 Swoole的子服务，并返回该主服务的事件注册器 EventRegister，注意该注册器的作用域仅仅在对应的子服务中。\nstart\n该函数用于调用 Swoole 实例 的 start 方法，也就是实质性地启动一个 Swoole 服务。该函数做了如下事情：\n\n注册主实例的事件回调\n注册各个子服务的事件回调\n启动服务\n\n其他函数\n\n\n\n名称\n参数\n功能描述\n\n\n\n\ngetSwooleServer\nstring $serverName = null\n用于获取当前的 Swoole 实例 或者是对应子服务的 subPort 对象\n\n\ngetEventRegister\nstring $serverName = null\n用于获取 主Swoole实例 或者是对应子服务的subPort对象 的事件回调注册容器\n\n\nisStart\n-\n用于判断当前服务是否已经启动\n\n\n","link":"/FrameDesign/serverManager.html"},{"id":58,"title":"core.php","content":"Core\nCore 是 EasySwoole 框架中核心的基础架构对象，这是一个单例对象，它的完整实现在 \\EasySwoole\\EasySwoole\\Core。\n关键函数\n__construct\n在构造函数中，做了以下两件事：\n\n常量定义\n\ndefined('SWOOLE_VERSION') or define('SWOOLE_VERSION', intval(phpversion('swoole')));\ndefined('EASYSWOOLE_ROOT') or define('EASYSWOOLE_ROOT', realpath(getcwd()));\ndefined('EASYSWOOLE_SERVER') or define('EASYSWOOLE_SERVER', 1);\ndefined('EASYSWOOLE_WEB_SERVER') or define('EASYSWOOLE_WEB_SERVER', 2);\ndefined('EASYSWOOLE_WEB_SOCKET_SERVER') or define('EASYSWOOLE_WEB_SOCKET_SERVER', 3);\n\n\n全局 EasySwooleEvent.php 事件引入\n\n\n在该构造函数中尝试重新定义 EASYSWOOLE_ROOT 常量是为了支持用户自定义脚本启动\n\nrunMode\n可以通过调用此函数获取框架当前运行的模式，默认模式为 dev。可在框架启动时指定模式和要加载的配置文件，详细见 基础管理命令。然后在框架任何地方调用此函数以获取当前运行的模式，方便调试。\n使用示例：在控制器中调用\nif (\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;runMode() == 'dev') {\n    // 开发模式下执行的逻辑\n}\ninitialize\n框架核心骨架初始化，做了以下几件事\n\n根据运行模式加载配置文件\n初始化临时目录和日志目录\n初始化错误处理器\n调用全局 EasySwooleEvent.php 中的 initialize 事件\n\ncreateServer\n根据配置文件，调用 ServerManager 初始化对应的 Swoole实例，并执行以下事情：\n\n调用全局 EasySwooleEvent.php 中的 mainServerCreate 事件\n注册框架系统默认的事件回调\n附加处理，例如注册 CronTab 进程、注册 Task 进程等\n\nstart\n根据配置文件中设置的服务名称，设置服务名称和进程的名称，调用 ServerManager，启动框架。","link":"/FrameDesign/core.html"},{"id":59,"title":"全局事件","content":"全局事件\nbootstrap 事件\nbootstrap 事件允许在框架未初始化之前，先进行初始化其他需要的业务代码。该事件是在 EasySwoole 3.2.5版本之后 新增的。\n在框架安装之后产生的 easyswoole 启动脚本文件中，将会自动判断框架根目录下是否有 bootstrap.php 文件，如果有则加载此文件。\n目前框架最新版本的 bootstrap.php(即 bootstrap 事件)会在框架安装时在项目根目录中自动生成。所以如果用户想要执行自己需要的初始化业务代码：如 注册命令行支持、全局通用函数、启动前调用协程 API等功能，就可以在 bootstrap.php 中进行编写实现。\n\n注：EasySwoole 3.4.x 版本之前 bootstrap.php 文件需要用户在项目根目录下自行创建该文件 bootstrap.php。\n注：如果你是框架旧版升级到框架新版，需要删除框架根目录的 easyswoole 文件，然后重新运行 php ./vendor/easyswoole/easyswoole/bin/easyswoole install 进行重新安装(报错或者其他原因请重新看 框架安装章节-执行安装步骤)，重新安装完成之后，即可正常使用 bootstrap 事件\n\n在框架启用前(在 bootstrap 事件中)调用协程 API\n开发者在 EasySwoole 主服务启动前调用协程 api，必须使用如下操作：\n$scheduler = new \\Swoole\\Coroutine\\Scheduler();\n$scheduler-&gt;add(function() {\n    /* 调用协程API */\n});\n$scheduler-&gt;start();\n// 清除全部定时器\n\\Swoole\\Timer::clearAll();\n具体使用示例如下：\n&lt;?php\n// 全局 bootstrap 事件\ndate_default_timezone_set('Asia/Shanghai');\n\nuse Swoole\\Coroutine\\Scheduler;\n$scheduler = new Scheduler();\n$scheduler-&gt;add(function() {\n    /* 调用协程 API */\n});\n$scheduler-&gt;start();\n// 清除全部定时器\n\\Swoole\\Timer::clearAll();\ninitialize 事件\n框架初始化事件，在执行 initialize 初始化事件时，EasySwoole 框架此刻已经完成了如下工作：\n\n加载配置文件\n初始化 Log/Temp 目录，完成系统默认 Log/Temp 目录的定义\n\n函数原型\npublic static function initialize(): void\n{\n}\n开发者自定义处理\n开发者可以在 initialize 事件可以进行如下修改：\n\n修改框架默认使用的 error_report 级别，使用自定义的 error_report 级别\n修改框架默认使用的 Logger 处理器，使用自定义的 Logger 处理器\n修改框架默认使用的 Trigger 处理器，使用自定义的 Trigger 处理器\n修改框架默认使用的 Error 处理器，使用自定义的 Error 处理器\n修改框架默认使用的 Shutdown 处理器，使用自定义的 Shutdown 处理器\n修改框架默认使用的 HttpException 全局处理器，使用自定义的 HttpException 全局处理器\n设置 Http 全局 OnRequest 及 AfterRequest 事件\n注册数据库、Redis 连接池\n\n具体可查看 SysConst.php\n使用示例代码：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n\n        // 开发者自定义设置 错误级别\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::ERROR_REPORT_LEVEL, E_ALL);\n\n        // 开发者自定义设置 日志处理类(该类需要实现 \\EasySwoole\\Log\\LoggerInterface，开发者可自行查看并实现，方便开发者自定义处理日志)\n        $logDir = EASYSWOOLE_LOG_DIR; // 定义日志存放目录\n        $loggerHandler = new \\EasySwoole\\Log\\Logger($logDir); // 定义日志处理对象\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(SysConst::LOGGER_HANDLER, $loggerHandler);\n\n        // 开发者自定义设置 Trace 追踪器(该类需要实现 \\EasySwoole\\Trigger\\TriggerInterface，开发者可自行查看并实现，方便开发者自定义处理 Trace 链路)\n        // Trace 追踪器需要依据上面的 logger_handler\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(SysConst::TRIGGER_HANDLER, new \\EasySwoole\\Trigger\\Trigger($loggerHandler));\n\n        // 开发者自定义设置 error_handler\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::ERROR_HANDLER, function ($errorCode, $description, $file = null, $line = null) {\n            // 开发者对错误进行处理\n        });\n\n        // 开发者自定义设置 shutdown\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::SHUTDOWN_FUNCTION, function () {\n            // 开发者对 shutdown 进行处理\n        });\n\n        // 开发者自定义设置 HttpException 全局处理器\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_EXCEPTION_HANDLER, function ($throwable, Request $request, Response $response) {\n            $response-&gt;withStatus(\\EasySwoole\\Http\\Message\\Status::CODE_INTERNAL_SERVER_ERROR);\n            $response-&gt;write(nl2br($throwable-&gt;getMessage() . \"\\n\" . $throwable-&gt;getTraceAsString()));\n            Trigger::getInstance()-&gt;throwable($throwable);\n        });\n\n        // 开发者自定义设置 onRequest v3.4.x+\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response) {\n            // v3.4.x 之前的版本 onRequest 事件在 EasySwoolEvent.php 中已定义，不必重新设置\n        });\n\n        // 开发者自定义设置 afterRequest v3.4.x+\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_AFTER_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response) {\n            // v3.4.x 之前的版本 afterRequest 事件在 EasySwoolEvent.php 中已定义，不必重新设置\n        });\n\n        // 注册数据库连接及连接池(详见：https://www.easyswoole.com/Components/Orm/install.html)\n        // 注册 Redis 连接及连接池(详见：https://www.easyswoole.com/Components/Redis/introduction.html)\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\n启用前(在 initialize 事件中)调用协程 API\n开发者在 EasySwoole 主服务启动前调用协程 api，必须使用如下操作：\n$scheduler = new \\Swoole\\Coroutine\\Scheduler();\n$scheduler-&gt;add(function() {\n    /* 调用协程API */\n});\n$scheduler-&gt;start();\n// 清除全部定时器\n\\Swoole\\Timer::clearAll();\n具体使用示例：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n\n        $scheduler = new \\Swoole\\Coroutine\\Scheduler();\n        $scheduler-&gt;add(function() {\n            /* 调用协程API */\n        });\n        $scheduler-&gt;start();\n        // 清除全部定时器\n        \\Swoole\\Timer::clearAll();\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\n在 initialize 事件中调用连接池\ninitialize 事件在 EasySwoole 生命周期中属于 主进程，因此在主进程中创建了连接池可能会导致以下问题：\n\n创建了全局的定时器\n创建了全局的 EventLoop\n\n创建的连接被跨进程公用，因此我们以服务启动前调用数据库 ORM 为例：\n\n服务启动前调用数据库 ORM：\n\n下文 \\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL') 获取的 MYSQL 配置，详细参考 配置文件\n\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n        $config = new \\EasySwoole\\ORM\\Db\\Config(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n        \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;addConnection(new \\EasySwoole\\ORM\\Db\\Connection($config));\n        // 创建一个协程调度器\n        $scheduler = new \\Swoole\\Coroutine\\Scheduler();\n        $scheduler-&gt;add(function () {\n            $builder = new \\EasySwoole\\Mysqli\\QueryBuilder();\n            $builder-&gt;raw('select version()');\n            \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;query($builder, true);\n            // 这边重置 ORM 连接池的 pool，避免连接被克隆到子进程，造成连接跨进程公用。\n            // DbManager 如果有注册多库连接，请记得一起 getConnection($name) 获取全部的 pool 去执行 reset\n            // 其他的连接池请获取到对应的 pool，然后执行 reset() 方法\n\n            // ORM 1.4.31 版本之前请使用 getClientPool() \n            // DbManager::getInstance()-&gt;getConnection()-&gt;getClientPool()-&gt;reset();\n            \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;getConnection()-&gt;__getClientPool()-&gt;reset();\n        });\n        //执行调度器内注册的全部回调\n        $scheduler-&gt;start();\n        //清理调度器内可能注册的定时器，不要影响到swoole server 的event loop\n        \\Swoole\\Timer::clearAll();\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\nmainServerCreate 事件(即主服务创建事件)\n函数原型\n/**\n * @param \\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register\n */\npublic static function mainServerCreate(EventRegister $register)\n{\n\n}\n已完成工作\n在执行主服务创建事件时，框架此时已经完成的工作有：\n\n\nbootstrap/initialize 事件加载完成\n主 SwooleServer 创建成功\n主 SwooleServer 注册了默认的 onRequest/onWorkerStart/onWorkerStop/onWorkerExit 事件。\n\n开发者可进行的操作有：\n\n注册主服务回调事件\n添加子服务监听\nSwooleTable/Atomic\n创建自定义进程\n启用前(在 mainServerCreate 事件中)调用协程 API\n\n注册主服务回调事件\n例如：为主服务注册 onWorkerStart 回调事件：\n/** @var \\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register **/\n$register-&gt;add($register::onWorkerStart, function (\\Swoole\\Server $server,int $workerId){\n     var_dump($workerId . 'start');\n});\n例如：为主服务增加 onMessage 回调事件（前提是主服务类型为 WebSocket 服务）：\n// 给 server 注册相关事件，在 WebSocket 服务模式下 message 事件必须注册 \n/** @var \\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register **/\n$register-&gt;set($register::onMessage,function (\\Swoole\\WebSocket\\Server $server, \\Swoole\\WebSocket\\Frame $frame){\n\n});\nset 方法和 add 方法是不同的, set 将会覆盖之前配置的事件回调, 而 add 是增加一个新的回调。\n添加子服务监听\n例如：添加一个 tcp 子服务监听\n/** @var \\Swoole\\Server\\Port $subPort **/\n$subPort = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer()-&gt;addListener('0.0.0.0', 9503, SWOOLE_TCP);\n$subPort-&gt;on('receive', function (\\Swoole\\Server $server, int $fd, int $reactor_id, string $data){\n    var_dump($data);\n});\n// 配置 具体查看 Swoole 文档\n$subPort-&gt;set([\n\n]);\n\n具体可参考 TCP\n\nTable &amp;&amp; Atomic\n具体调用方式请看具体章节：\nTable\nAtomic\n创建自定义进程\n\n具体详细操作可到 基础使用 -&gt; 自定义进程中查看\n\n\\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new Test('test_process'));\n\nTest 是 EasySwoole\\Component\\Process\\AbstractProcess 抽象类的子类\n\n启用前(在 mainServerCreate 事件中)调用协程 API\n开发者在 EasySwoole 主服务启动前调用协程 api，必须使用如下操作：\n$scheduler = new \\Swoole\\Coroutine\\Scheduler();\n$scheduler-&gt;add(function() {\n    /* 调用协程API */\n});\n$scheduler-&gt;start();\n// 清除全部定时器\n\\Swoole\\Timer::clearAll();","link":"/FrameDesign/event.html"},{"id":60,"title":"timer定时器","content":"Timer定时器\n框架对Swoole毫秒级定时器进行了封装，方便开发者快速上手。\n注意⚠️：定时器传入的时间参数为毫秒，若开启了 reload_async 配置时，请将定时器移动到自定义进程内，否则会导致worker进程无法reload。\n循环执行\n设置一个间隔时钟定时器，每隔一定的时间定时触发，直到进行 clear 操作才会停止，对应 Swoole 原生的定时器函数为 swoole_timer_tick\n函数原型\n/**\n* 循环调用\n* @param int      $ms 循环执行的间隔毫秒数 传入整数型\n* @param \\Closure $callback 定时器需要执行的操作 传入一个闭包\n* @param string    $name 定时器名称,用于取消该定时器\n* @param mixed ...$params 传入定时器的参数\n* @return int 返回整数型的定时器编号 可以用该编号停止定时器\n*/\npublic function loop(int $ms, callable $callback, $name = null, ...$params)\n示例代码\n// 每隔 10 秒执行一次\n\\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(10 * 1000, function () {\n    echo \"this timer runs at intervals of 10 seconds\\n\";\n});\n延时执行\n设置一个延时定时器，延时指定的时间后触发对应的操作，只会执行一次操作，对应Swoole 原生的定时器函数为 swoole_timer_after\n函数原型\n/**\n* 延时调用\n* @param int      $ms 需要延迟执行的时间\n* @param \\Closure $callback 定时器需要执行的操作 传入一个闭包\n* @param mixed ...$params 传入定时器的参数\n* @return int 返回整数型的定时器编号 \n*/\npublic function after(int $ms, callable $callback, ...$params)\n示例代码\n// 10 秒后执行一次\n\\EasySwoole\\Component\\Timer::getInstance()-&gt;after(10 * 1000, function () {\n    echo \"ten seconds later\\n\";\n});\n清除定时器\n注意: 该操作不能用于清除其他进程的定时器，只作用于当前进程\n定时器创建成功时，会返回一个整数型编号，调用本函数传入该编号，即可提前停止定时器，对应 Swoole 原生的定时器函数为 swoole_timer_clear\n函数原型\n/**\n* 清除定时器\n* @param mixed $timerIdOrName 定时器编号或名称\n* @return bool\n*/\npublic function clear($timerIdOrName)\n示例代码\n// 创建一个2秒定时器\n$timerId = \\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(2 * 1000, function () {\n    echo \"timeout\\n\";\n},'time');\n\n// 清除该定时器\nvar_dump(\\EasySwoole\\Component\\Timer::getInstance()-&gt;clear($timerId)); // bool(true)\nvar_dump($timerId); // int(1)\n\n// 定时器得不到执行 不输出：timeout\n应用实例\n注意：定时器不能在服务启动之前使用。在服务启动以后，添加的定时器仅在当前进程中有效。在 WorkerStart 事件中添加定时器时，请注意判断需要添加定时器的workerId，否则该定时器在每个进程中均会被执行。\n// 为第一个 Worker 添加定时器\nif ($workerId == 0) {\n    \\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(10 * 1000, function () {\n        echo \"timer in the worker number 0\\n\";\n    });\n}\npublic static function mainServerCreate(EventRegister $register)\n{\n    $register-&gt;add(EventRegister::onWorkerStart, function (\\swoole_server $server, $workerId) {\n        //如何避免定时器因为进程重启而丢失\n        //例如在第一个进程 添加一个10秒的定时器\n        if ($workerId == 0) {\n            \\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(10 * 1000, function () {\n                // 从数据库，或者是redis中，去获取下个就近10秒内需要执行的任务\n                // 例如:2秒后一个任务，3秒后一个任务 代码如下\n                \\EasySwoole\\Component\\Timer::getInstance()-&gt;after(2 * 1000, function () {\n                    //为了防止因为任务阻塞，引起定时器不准确，把任务给异步进程处理\n                    Logger::getInstance()-&gt;console(\"time 2\", false);\n                });\n                \\EasySwoole\\Component\\Timer::getInstance()-&gt;after(3 * 1000, function () {\n                    //为了防止因为任务阻塞，引起定时器不准确，把任务给异步进程处理\n                    Logger::getInstance()-&gt;console(\"time 3\", false);\n                });\n            });\n        }\n    });\n}\n经典案例-订单状态超时监控\n场景说明：在很多抢购的场景中，订单下单完成后，需要限制其付款时间，或者是在棋牌游戏中，需要对房间状态进行监控。那么我们可以先把待监控的订单或者是房间压入redis 队列中。那么就可以利用 定时器 + 异步进程，去实现对订单状态的循环监控。","link":"/Components/Component/timer.html"},{"id":61,"title":"crontab定时任务","content":"定时任务\n开发者执行定时任务会通过Linux的Crontab去实现，不方便去管理。EasySwoole提供了根据Linux下Crontab规则的定时任务，最小粒度为1分钟。\n创建一个定时任务\n需要定义一个定时任务类继承EasySwoole\\EasySwoole\\Crontab\\AbstractCronTask。\n定义执行规则\npublic static function getRule(): string\n{\n    // 定义执行规则 根据Crontab来定义\n    return '*/1 * * * *';\n}\n定义Crontab名称\npublic static function getTaskName(): string\n{\n    // 定时任务的名称\n    return 'custom crontab';\n}\n定义执行逻辑\npublic function run(int $taskId, int $workerIndex)\n{\n    // 定时任务的执行逻辑\n\n    // 开发者可投递给task异步处理\n    TaskManager::getInstance()-&gt;async(function (){\n        // todo some thing\n    });\n}\n定义异常捕获\npublic function onException(\\Throwable $throwable, int $taskId, int $workerIndex)\n{\n    // 捕获run方法内所抛出的异常\n}\n注册Crontab\n在EasySwoole全局的mainServerCreate事件中进行进程注册\n\nCrontab::getInstance()-&gt;addTask(CustomCrontab::class);\n\n完整示例代码\n&lt;?php\n\nnamespace App\\Crontab;\n\nuse EasySwoole\\EasySwoole\\Crontab\\AbstractCronTask;\nuse EasySwoole\\EasySwoole\\Task\\TaskManager;\n\nclass CustomCrontab extends AbstractCronTask\n{\n    public static function getRule(): string\n    {\n        // 定义执行规则 根据Crontab来定义\n        return '*/1 * * * *';\n    }\n\n    public static function getTaskName(): string\n    {\n        // 定时任务的名称\n        return 'CustomCrontab';\n    }\n\n    public function run(int $taskId, int $workerIndex)\n    {\n        // 定时任务的执行逻辑\n\n        // 开发者可投递给task异步处理\n        TaskManager::getInstance()-&gt;async(function (){\n            // todo some thing\n        });\n    }\n\n    public function onException(\\Throwable $throwable, int $taskId, int $workerIndex)\n    {\n        // 捕获run方法内所抛出的异常\n    }\n}\nCrontab表达式\n通用表达式：\n    *    *    *    *    *\n    -    -    -    -    -\n    |    |    |    |    |\n    |    |    |    |    |\n    |    |    |    |    +----- day of week (0 - 7) (Sunday=0 or 7)\n    |    |    |    +---------- month (1 - 12)\n    |    |    +--------------- day of month (1 - 31)\n    |    +-------------------- hour (0 - 23)\n    +------------------------- min (0 - 59)\n特殊表达式：\n@yearly                    每年一次 等同于(0 0 1 1 *) \n@annually                  每年一次 等同于(0 0 1 1 *)\n@monthly                   每月一次 等同于(0 0 1 * *) \n@weekly                    每周一次 等同于(0 0 * * 0) \n@daily                     每日一次 等同于(0 0 * * *) \n@hourly                    每小时一次 等同于(0 * * * *)\nCrontab管理\nEasySwoole内置对于Crontab的命令行操作，方便开发者友好的去管理Crontab。\n可执行php easyswoole crontab -h来查看具体操作。\n查看所有注册的Crontab\n\nphp easyswoole crontab show\n\n停止指定的Crontab\n\nphp easyswoole crontab stop --name=TASK_NAME\n\n恢复指定的Crontab\n\nphp easyswoole crontab resume --name=TASK_NAME\n\n立即跑一次指定的Crontab\n\nphp easyswoole crontab run --name=TASK_NAME\n\n版本强调\nEasySwoole3.3.0如何定义：\n&lt;?php\nnamespace App\\Crontab;\n\nuse EasySwoole\\EasySwoole\\Crontab\\AbstractCronTask;\n\nclass TaskOne extends AbstractCronTask\n{\n\n    public static function getRule(): string\n    {\n        // TODO: Implement getRule() method.\n        // 定时周期 （每小时）\n        return '@hourly';\n    }\n\n    public static function getTaskName(): string\n    {\n        // TODO: Implement getTaskName() method.\n        // 定时任务名称\n        return 'taskOne';\n    }\n\n    static function run(\\swoole_server $server, int $taskId, int $fromWorkerId,$flags=null)\n    {\n        // TODO: Implement run() method.\n        // 定时任务处理逻辑\n        var_dump('run once per hour');\n    }\n}","link":"/BaseUsage/crontab.html"},{"id":62,"title":"日志","content":"日志\n日志可以快速帮助开发者快速定位问题的根源、追踪程序执行的过程、追踪数据变化、数据统计和性能分析等。\n使用\nlog\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;log('log level info',\\EasySwoole\\EasySwoole\\Logger::LOG_LEVEL_INFO,'DEBUG');\ninfo\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;info('log level info');\nwaring\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;waring('log level waring');\nconsole\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;console('console',\\EasySwoole\\EasySwoole\\Logger::LOG_LEVEL_INFO,'DEBUG');\nnotice\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;notice('log level notice');\nerror\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;error('log level error');\nevent\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;onLog()-&gt;set('myHook',function ($msg,$logLevel,$category){\n    //增加日志写入之后的回调函数\n});\n在非框架中使用，例如是单元测试脚本，请执行EasySwoole\\EasySwoole\\Core::getInstance()->initialize(); 用于初始化日志。\n在3.3.7+，initialize事件调用改为：EasySwoole\\EasySwoole\\Core::getInstance()->initialize()->globalInitialize();。\n自定义处理器\n需要实现EasySwoole\\Log\\LoggerInterface即可：\n&lt;?php\n\nnamespace App\\Log;\n\nuse EasySwoole\\Log\\LoggerInterface;\n\nclass LogHandel implements LoggerInterface\n{\n\n    private $logDir;\n\n    function __construct(string $logDir = null)\n    {\n        if(empty($logDir)){\n            $logDir = getcwd();\n        }\n        $this-&gt;logDir = $logDir;\n    }\n\n    function log(?string $msg,int $logLevel = self::LOG_LEVEL_INFO,string $category = 'debug'):string\n    {\n        $date = date('Y-m-d H:i:s');\n        $levelStr = $this-&gt;levelMap($logLevel);\n        $filePath = $this-&gt;logDir.\"/log_{$category}.log\";\n        $str = \"自定义日志:[{$date}][{$category}][{$levelStr}] : [{$msg}]\\n\";\n        file_put_contents($filePath,\"{$str}\",FILE_APPEND|LOCK_EX);\n        return $str;\n    }\n\n    function console(?string $msg,int $logLevel = self::LOG_LEVEL_INFO,string $category = 'console')\n    {\n        $date = date('Y-m-d H:i:s');\n        $levelStr = $this-&gt;levelMap($logLevel);\n        $temp = \"自定义日志:[{$date}][{$category}][{$levelStr}]:[{$msg}]\\n\";\n        fwrite(STDOUT,$temp);\n    }\n\n    private function levelMap(int $level)\n    {\n        switch ($level)\n        {\n            case self::LOG_LEVEL_INFO:\n                return 'info';\n            case self::LOG_LEVEL_NOTICE:\n                return 'notice';\n            case self::LOG_LEVEL_WARNING:\n                return 'warning';\n            case self::LOG_LEVEL_ERROR:\n                return 'error';\n            default:\n                return 'unknown';\n        }\n    }\n}\n在initialize事件中注入自定义logger处理器：\n\n\\EasySwoole\\EasySwoole\\Logger::getInstance(new \\App\\Log\\LogHandel());\n\n日志中心\n通常在一些情况下，会把数据往日志中心推送进行数据分析，在onLog回调，把日志信息，推送到日志中心即可。","link":"/BaseUsage/log.html"},{"id":63,"title":"异常","content":"Trigger\nEasySwoole\\EasySwoole\\Trigger触发器，用于主动触发错误或者异常而不中断程序继续执行。\n使用\n拦截异常并记录\n比如：在控制器的OnException中：\nprotected function onException(\\Throwable $throwable): void\n{\n    //拦截错误进日志,使控制器继续运行\n    \\EasySwoole\\EasySwoole\\Trigger::getInstance()-&gt;throwable($throwable);\n    $this-&gt;writeJson(\\EasySwoole\\Http\\Message\\Status::CODE_INTERNAL_SERVER_ERROR, null, $throwable-&gt;getMessage());\n}\n直接记录\n\\EasySwoole\\EasySwoole\\Trigger::getInstance()-&gt;error('test error');\n回调接管注册\n通常出现重大异常（支付失败等）需要进行报警处理，在全局的mainServerCreate事件中进行注册：\n\\EasySwoole\\EasySwoole\\Trigger::getInstance()-&gt;onException()-&gt;set('notify',function (\\Throwable $throwable){\n    // 自行实现通知代码\n});\n\n\\EasySwoole\\EasySwoole\\Trigger::getInstance()-&gt;onError()-&gt;set('notify',function ($msg){\n    // 自行实现通知代码\n});\n自定义处理类\n需要开发者实现EasySwoole\\Trigger\\TriggerInterface：\n&lt;?php\n\nnamespace App\\Exception;\n\nuse EasySwoole\\EasySwoole\\Logger;\nuse EasySwoole\\Trigger\\Location;\nuse EasySwoole\\Trigger\\TriggerInterface;\n\nclass TriggerHandel implements TriggerInterface\n{\n    public function error($msg, int $errorCode = E_USER_ERROR, Location $location = null)\n    {\n        Logger::getInstance()-&gt;console('这是自定义输出的错误:'.$msg);\n        // TODO: Implement error() method.\n    }\n\n    public function throwable(\\Throwable $throwable)\n    {\n        Logger::getInstance()-&gt;console('这是自定义输出的异常:'.$throwable-&gt;getMessage());\n        // TODO: Implement throwable() method.\n    }\n}\n在initialize事件中注入自定义trigger处理器：\n\n\\EasySwoole\\EasySwoole\\Trigger::getInstance(new \\App\\Exception\\TriggerHandel());\n","link":"/BaseUsage/trigger.html"},{"id":64,"title":"单元测试","content":"Phpunit\nEasyswoole/Phpunit 是对Phpunit的协程定制化封装，主要为解决自动协程化入口的问题。并屏蔽了Swoole ExitException。\n安装\n\ncomposer require easyswoole/phpunit\n\n使用\n\n./vendor/bin/co-phpunit tests\n\n或者使用以下方式：\n\nphp easyswoole phpunit tests\n\n默认采用协程容器去执行测试用例，使用非协程采用以下方式：\n\nphp easyswoole phpunit --no-coroutine\n\n注：test为测试目录。\n预处理\neasyswoole/phpunit支持在项目目录下定义一个phpunit.php，用户可以在该文件下进行统一的测试前预处理，其他测试与phpunit一致。\n如何进行单元测试\n这里以ORM组件为测试演示：\n连接注册\n请在Easyswoole全局的initialize事件中注册。\npublic static function initialize()\n{\n    // TODO: Implement initialize() method.\n    date_default_timezone_set('Asia/Shanghai');\n    $config = new Config(GlobalConfig::getInstance()-&gt;getConf(\"MYSQL\"));\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n}\n预处理\n请在EasySwoole项目根目录下创建phpunit.php文件。\n&lt;?php\nuse EasySwoole\\EasySwoole\\Core;\nCore::getInstance()-&gt;initialize()-&gt;globalInitialize();\n注：在3.3.7+，initialize事件调用改为：EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()-&gt;globalInitialize();。\n编写测试用例\nnamespace Test;\nuse EasySwoole\\Mysqli\\QueryBuilder;\nuse PHPUnit\\Framework\\TestCase;\nuse EasySwoole\\ORM\\DbManager;\n\nclass DbTest extends TestCase\n{\n    function testCon()\n    {\n        $builder = new QueryBuilder();\n        $builder-&gt;raw('select version()');\n        $ret = DbManager::getInstance()-&gt;query($builder,true)-&gt;getResult();\n        $this-&gt;assertArrayHasKey('version()',$ret[0]);\n    }\n}\n注：请注册composer.json下Test命名空间与tests目录的映射关系。\n执行\n\n./vendor/bin/co-phpunit tests\n","link":"/Components/phpunit.html"},{"id":65,"title":"异步任务","content":"Task\nEasySwoole3.3.0+异步任务放弃了Swoole的原生task，采用独立组件实现实现。\n相对于原生swoole task，easyswoole/task组件实现了以下功能：\n\n可以投递闭包任务\n可以在TaskWorker等其他自定义进程继续投递任务\n实现任务限流与状态监控  \n\n安装\n\ncomposer require easyswoole/task\n\n框架中使用\n同步调用：\n\\EasySwoole\\EasySwoole\\Task\\TaskManager::getInstance()-&gt;sync(function (){\n    echo 'sync';\n});\n异步调用：\n\\EasySwoole\\EasySwoole\\Task\\TaskManager::getInstance()-&gt;async(function (){\n    echo 'async';\n},function ($reply,$taskId,$workerIndex){\n    // $reply 返回的执行结果\n    // $taskId 任务id\n    echo 'async success';\n});\n由于php本身就不能序列化闭包，该闭包投递是通过反射该闭包函数，获取php代码直接序列化php代码，然后直接eval代码实现的。\n所以投递闭包无法使用外部的对象引用，以及资源句柄,复杂任务请使用任务模板方法。\n任务模版\n自定义一个任务模版\n&lt;?php\n\nnamespace App\\Task;\n\nuse EasySwoole\\Task\\AbstractInterface\\TaskInterface;\n\nclass CustomTask implements TaskInterface\n{\n    protected $data;\n\n    public function __construct($data)\n    {\n        // 保存投递过来的数据\n        $this-&gt;data = $data;\n    }\n\n    public function run(int $taskId, int $workerIndex)\n    {\n        // 执行逻辑\n    }\n\n    public function onException(\\Throwable $throwable, int $taskId, int $workerIndex)\n    {\n        // 异常处理\n    }\n}\n如何使用\n$task = \\EasySwoole\\EasySwoole\\Task\\TaskManager::getInstance();\n$task-&gt;async(new CustomTask(['user'=&gt;'custom']));\n$data =  $task-&gt;sync(new CustomTask(['user'=&gt;'custom']));\n投递返回值\n\n\n&gt;0 投递成功(异步任务专属,返回taskId,同步任务直接返回return值)\n\n-1 task进程繁忙,投递失败(已经到达最大运行数量maxRunningNum)\n\n-2 投递数据解包失败,当投递数据传输时数据异常时会报错,此错误为组件底层错误,一般不会出现\n\n-3 任务出错(该任务执行时出现异常错误,被组件拦截并输出错误)\n\n独立使用\n该组件可独立使用，代码如下：\nuse EasySwoole\\Task\\Config;\nuse EasySwoole\\Task\\Task;\n\n/*\n    配置项中可以修改工作进程数、临时目录，进程名，最大并发执行任务数，异常回调等\n*/\n$config = new Config();\n$task = new Task($config);\n//添加swoole 服务\n$http = new \\Swoole\\Http\\Server(\"0.0.0.0\", 9501);\n//注入swoole服务,进行创建task进程\n$task-&gt;attachToServer($http);\n//在onrequest事件中调用task(其他地方也可以,这只是示例)\n$http-&gt;on(\"request\", function (Swoole\\Http\\Request  $request, $response)use($task){\n    if(isset($request-&gt;get['sync'])){\n        //同步调用task\n        $ret = $task-&gt;sync(function ($taskId,$workerIndex){\n            return \"{$taskId}.{$workerIndex}\";\n        });\n        $response-&gt;end(\"sync result \".$ret);\n    }else if(isset($request-&gt;get['status'])) {\n        var_dump($task-&gt;status());\n    }else{\n        //异步调用task\n        $id = $task-&gt;async(function ($taskId,$workerIndex){\n            \\co::sleep(1);\n            var_dump(\"async id {$taskId} task run\");\n        });\n        $response-&gt;end(\"async id {$id} \");\n    }\n});\n//启动服务\n$http-&gt;start();\n版本强调\n框架低版本升级为EasySwoole3.3.0+，需要手动进行配置修改。\n需要删除MAIN_SERVER.SETTING.task_worker_num，MAIN_SERVER.SETTING.task_enable_coroutine配置项。\n请在MAIN_SERVER配置项中，增加TASK子配置项：\n[\n    'MAIN_SERVER' =&gt; [\n        'TASK'=&gt;[\n            'workerNum'=&gt;4,\n            'maxRunningNum'=&gt;128,\n            'timeout'=&gt;15\n            ],\n    ],\n];\nTask管理\n查看所有Task进程的状态\n\nphp easyswoole task status\n","link":"/Components/Component/task.html"},{"id":66,"title":"自定义进程","content":"自定义进程\nPHP自带的pcntl存在许多不足，不支持重定向标准输入和输出及进程间通信的功能，且容易使用错误。\nEasySwoole基于Swoole的Process模块进行了封装，来创建工作进程，用于处理耗时任务，消息队列，等其它的特殊任务。\n在EasySwoole启动时，会自动创建注册的进程，并执行进程指定的逻辑代码，进程意外退出时，会被重新拉起。\n创建一个自定义进程\n需要定义一个进程类继承EasySwoole\\Component\\Process\\AbstractProcess。\n定义进程内执行逻辑回调\nprotected function run($arg)\n{\n    // TODO: Implement run() method.\n    $this-&gt;getProcessName(); // 获取注册进程名称\n\n    $this-&gt;getProcess(); // 获取进程实例 \\Swoole\\Process\n\n    $this-&gt;getPid(); // 获取当前进程Pid\n\n    $this-&gt;getArg(); // 获取注册时传递的参数\n}\n进程间通信Pipe回调\nprotected function onPipeReadable(Process $process)\n{\n    // 该回调可选\n    // 当主进程对子进程发送消息的时候 会触发\n    $process-&gt;read(); // 读取消息\n}\n进程间异常回调\nprotected function onException(\\Throwable $throwable, ...$args)\n{\n    // 该回调可选\n    // 捕获run方法内抛出的异常\n    // 这里可以通过记录异常信息来帮助更加方便的知道出现问题的代码\n}\n进程信号回调\nprotected function onSigTerm()\n{\n    // 当进程接收到 SIGTERM 信号触发该回调\n}\n进程意外退出回调\nprotected function onShutDown()\n{\n    // 该回调可选\n    // 进程意外退出 触发此回调\n    // 大部分用于清理工作\n}\n注册进程\n在 EasySwoole 全局的 mainServerCreate 事件中进行进程注册\n$processConfig = new \\EasySwoole\\Component\\Process\\Config([\n    'processName' =&gt; 'CustomProcess', // 设置 自定义进程名称\n    'processGroup' =&gt; 'Custom', // 设置 自定义进程组名称\n    'arg' =&gt; [\n        'arg1' =&gt; 'this is arg1!'\n    ], // 【可选参数】设置 注册进程时要传递给自定义进程的参数，可在自定义进程中通过 $this-&gt;getArg() 进行获取\n    'enableCoroutine' =&gt; true, // 设置 自定义进程自动开启协程\n]);\n\n\\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new CustomProcess($processConfig));\n推荐使用 \\EasySwoole\\Component\\Process\\Manager 类进行注册自定义进程，注册方式示例代码如上所示。如果您的框架版本过低，不支持 \\EasySwoole\\Component\\Process\\Manager 类，可使用如下方式进行注册自定义进程: \\EasySwoole\\EasySwoole\\ServerManager::getInstance()->getSwooleServer()->addProcess((new TickProcessnew CustomProcess($processConfig));\n完整示例代码\n1. 定义自定义进程类示例\n首先，我们定义一个自定义进程类继承 \\EasySwoole\\Component\\Process\\AbstractProcess 类，示例代码如下：\n&lt;?php\nnamespace App\\Process;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse Swoole\\Process;\n\nclass CustomProcess extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        // TODO: Implement run() method.\n        $processName = $this-&gt;getProcessName(); // 获取 注册进程名称\n        $swooleProcess = $this-&gt;getProcess(); // 获取 注册进程的实例 \\Swoole\\Process\n        $processPid = $this-&gt;getPid(); // 获取 当前进程 Pid\n        $args = $this-&gt;getArg(); // 获取 注册进程时传递的参数\n\n        var_dump('### 开始运行自定义进程 start ###');\n        var_dump($processName, $swooleProcess, $processPid, $args);\n        var_dump('### 运行自定义进程结束 end ###');\n    }\n\n    protected function onPipeReadable(Process $process)\n    {\n        // 该回调可选\n        // 当主进程对子进程发送消息的时候 会触发\n        $recvMsgFromMain = $process-&gt;read(); // 用于获取主进程给当前进程发送的消息\n        var_dump('收到主进程发送的消息: ');\n        var_dump($recvMsgFromMain);\n    }\n\n    protected function onException(\\Throwable $throwable, ...$args)\n    {\n        // 该回调可选\n        // 捕获 run 方法内抛出的异常\n        // 这里可以通过记录异常信息来帮助更加方便地知道出现问题的代码\n    }\n\n    protected function onShutDown()\n    {\n        // 该回调可选\n        // 进程意外退出 触发此回调\n        // 大部分用于清理工作\n    }\n\n    protected function onSigTerm()\n    {\n        // 当进程接收到 SIGTERM 信号触发该回调\n    }\n}\n2. 注册进程示例\n然后在 mainServerCreate 事件中进行注册进程，示例代码如下：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        $processConfig = new \\EasySwoole\\Component\\Process\\Config([\n            'processName' =&gt; 'CustomProcess', // 设置 进程名称为 TickProcess\n            'processGroup' =&gt; 'Custom', // 设置 进程组名称为 Tick\n            'arg' =&gt; [\n                'arg1' =&gt; 'this is arg1!',\n            ], // 传递参数到自定义进程中\n            'enableCoroutine' =&gt; true, // 设置 自定义进程自动开启协程环境\n        ]);\n\n        // 【推荐】使用 \\EasySwoole\\Component\\Process\\Manager 类注册自定义进程\n        $customProcess = (new \\App\\Process\\CustomProcess($processConfig));\n        // 【可选操作】把 tickProcess 的 Swoole\\Process 注入到 Di 中，方便在后续控制器等业务中给自定义进程传输信息(即实现主进程与自定义进程间通信)\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set('customSwooleProcess', $customProcess-&gt;getProcess());\n        // 注册进程\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess($customProcess);\n\n        /*\n        #【针对于低版本不支持 \\EasySwoole\\Component\\Process\\Manager 类】可使用 \\EasySwoole\\EasySwoole\\ServerManager 类注册自定义进程\n        $customProcess = (new \\App\\Process\\CustomProcess($processConfig))-&gt;getProcess();\n        // 【可选操作】把 tickProcess 的 Swoole\\Process 注入到 Di 中，方便在后续控制器等业务中给自定义进程传输信息(即实现主进程与自定义进程间通信)\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set('customSwooleProcess', $customProcess);\n        // 注册进程\n        \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer()-&gt;addProcess($customProcess);\n        */\n    }\n}\n3. 向自定义进程中传递消息\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Component\\Di;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        // 获取 Di 中注入的 自定义进程\n        $customProcess = Di::getInstance()-&gt;get('customSwooleProcess');\n        // 向自定义进程中传输信息，会触发自定义进程的 onPipeReadable 回调\n        $customProcess-&gt;write('this is test!');\n    }\n}\n进程管理命令说明\nEasySwoole 内置了对于 Process 的命令行操作，方便开发者非常友好地去管理 Process。\n可执行 php easyswoole process -h 来查看具体操作。\n显示所有进程\n\nphp easyswoole process show\n\n如果想要以 MB 形式显示：\n\nphp easyswoole process show -d\n\n杀死指定进程(PID)\n\nphp easyswoole process kill --pid=PID\n\n杀死指定进程组(GROUP)\n\nphp easyswoole process kill --group=GROUP_NAME\n\n杀死所有进程\n\nphp easyswoole process killAll\n\n强制杀死进程\n需要带上 -f 参数，例如：\n\nphp easyswoole process kill --pid=PID -f\n","link":"/Components/Component/process.html"},{"id":67,"title":"ioc 容器","content":"依赖注入\nDependency Injection  依赖注入\nEasySwoole 实现了简单版的 IOC 容器，使用 IOC 容器 可以很方便地存储/获取资源，实现解耦。\n使用依赖注入，最重要的一点好处就是有效地分离了对象和它所需要的外部资源，使得它们松散耦合，有利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。\n在我们的日常开发中，创建对象的操作随处可见，以至于对其十分熟悉的同时又感觉十分繁琐，每次需要对象都需要亲手将其 new 出来，甚至某些情况下由于坏编程习惯还会造成对象无法被回收，这是相当糟糕的。但更为严重的是，我们一直倡导的松耦合、少入侵原则，这种情况下变得一无是处。于是前辈们开始谋求改变这种编程陋习，考虑如何使用编码更加解耦合，由此而来的解决方案是面向接口的编程。\n注意：在服务启动后，对 IOC容器 的获取/注入仅限当前进程有效。不对其他 worker 进程产生影响。\n方法列表\ngetInstance\n用于获取依赖注入组件 IoC 容器 对象。\n使用示例：\n$di = \\EasySwoole\\EasySwoole\\Di::getInstance();\nset\n用于向 IoC 容器 中注入内容。\n函数原型：set($key, $obj, ...$arg): void\n\n\n$key: 键名。\n\n\n$obj: 要注入的内容。支持注入对象名、对象实例、闭包、资源、字符串等各种常见变量。\n\n\n$arg: 若注入的内容为 is_callable 类型，则可以设置该参数以供 callable 执行时传入。\n\n\n使用示例：\n$di-&gt;set('test', new TestClass());\n$di-&gt;set('test', TestClass::class);\n\n// set 的时候储存的是[类名, 方法名]的数组，需要自己手动调用 call_user_func() 执行（不要被错误与异常章节的 demo 误解为会自动执行)\n$di-&gt;set('test', [TestClass::class,'testFunction']);\n\n// set 的时候传递了类名，get 的时候才去 new 对象，并且将可变变量传递进构造函数，返回实例化后的对象\n$di-&gt;set('test', TestClass::class, $arg_one, $arg_tow);\nDi 的 set 方法为懒惰加载模式，若 set 一个对象名或者闭包，则该对象不会马上被创建。\nget\n用户获取 IoC 容器 中某个注入的内容。\n函数原型：get($key)\n\n$key: 调用 set 方法时设置的键名。\n\n使用示例：\n$val = $di-&gt;get('test');\ndelete\n用户删除 IoC 容器 中某个注入的内容。\n函数原型：delete($key): void\n\n$key: 调用 set 方法时设置的键名。\n\n使用示例：\n$di-&gt;delete('test');\nclear\n用于清空 IoC 容器 的所有内容。\n函数原型：clear($key): void\n\n$key: 调用 set 方法时设置的键名。\n","link":"/Components/Component/ioc.html"},{"id":68,"title":"控制器","content":"控制器\n功能介绍\n毫无疑问控制器层是负责处理客户端请求，转发给响应模型，并将结果返回，es使用了对象池复用模式降低对象创建、销毁的开销，注入request和response对象来完成客户端与服务端之间的交互。\n示例\n\n在App/HttpController/目录下增加User.php\n\n代码\n&lt;?php\n/**\n * @CreateTime:   2020/8/19 12:30 上午\n * @Author:       huizhang  &lt;2788828128@qq.com&gt;\n * @Copyright:    copyright(2020) Easyswoole all rights reserved\n * @Description:  用户控制器\n */\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass User extends Controller\n{\n\n    /**\n     * 用户信息\n     *\n     * @return string\n     * CreateTime: 2020/8/19 12:37 上午\n     */\n    public function userInfo()\n    {\n        // 获取get参数\n        $name = $this-&gt;request()-&gt;getQueryParam('name');\n\n        // 输出到终端\n        var_dump($name);\n\n        // 返回给客户端\n        $this-&gt;response()-&gt;write($name.PHP_EOL);\n\n        // return返回的值会让框架在此进行控制器方法调度\n        return '/User/requestTotal';\n    }\n\n    /**\n     * 接口请求量\n     *\n     * CreateTime: 2020/8/19 12:37 上午\n     */\n    public function requestTotal()\n    {\n        $this-&gt;response()-&gt;write('请求数+1'.PHP_EOL);\n\n        // 还可以return，但不要两个方法互相调用，会死循环\n    }\n\n    /**\n     * 此控制器抛异常时会执行此方法\n     *\n     * @param \\Throwable $throwable\n     * @throws \\Throwable\n     * CreateTime: 2020/8/19 12:48 上午\n     */\n    public function onException(\\Throwable $throwable): void\n    {\n        parent::onException($throwable); // TODO: Change the autogenerated stub\n    }\n\n    /**\n     * gc 方法将在执行方法,afterAction完之后自动调用,可自行覆盖实现其他的gc回收逻辑.\n     *\n     * CreateTime: 2020/8/19 12:52 上午\n     */\n    public function gc()\n    {\n        parent::gc(); // TODO: Change the autogenerated stub\n    }\n\n    /**\n     * 当控制器方法执行结束之后将调用该方法,可自定义数据回收等逻辑\n     *\n     * @param string|null $actionName\n     * CreateTime: 2020/8/19 12:51 上午\n     */\n    public function afterAction(?string $actionName): void\n    {\n        parent::afterAction($actionName); // TODO: Change the autogenerated stub\n    }\n\n    /**\n     * 当请求方法未找到时,自动调用该方法,可自行覆盖该方法实现自己的逻辑\n     *\n     * @param string|null $action\n     * CreateTime: 2020/8/19 12:51 上午\n     */\n    public function actionNotFound(?string $action)\n    {\n        parent::actionNotFound($action); // TODO: Change the autogenerated stub\n    }\n\n    /**\n     * 当控制器逻辑抛出异常时将调用该方法进行处理异常(框架默认已经处理了异常)可覆盖该方法,进行自定义的异常处理\n     *\n     * @param string|null $action\n     * @return bool|null\n     * CreateTime: 2020/8/19 12:52 上午\n     */\n    public function onRequest(?string $action): ?bool\n    {\n        return parent::onRequest($action); // TODO: Change the autogenerated stub\n    }\n\n}\n\n执行过程\n\n启动easyswoole\n\nphp easyswoole server start\n\n访问\n\ncurl http://localhost:9501/user/userInfo?name=easyswoole\n执行结果\n\n服务端输出\n\n➜  doc-new git:(master) ✗ php easyswoole server start\n#!/usr/bin/env php\n  ______                          _____                              _\n |  ____|                        / ____|                            | |\n | |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___\n |  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n | |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n |______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                          __/ |\n                         |___/\n\nmain server                   SWOOLE_WEB\nlisten address                0.0.0.0\nlisten port                   9501\nworker_num                    8\nreload_async                  true\nmax_wait_time                 3\ndocument_root                 /Users/guoyuzhao/sites/doc-new/Static\nenable_static_handler         true\npid_file                      /Users/guoyuzhao/sites/doc-new/Temp/pid.pid\nlog_file                      /Users/guoyuzhao/sites/doc-new/Log/swoole.log\nuser                          guoyuzhao\nswoole version                4.5.2\nphp version                   7.4.8\neasyswoole version            3.4.0-dev\nrun mode                      dev\ntemp dir                      /Users/guoyuzhao/sites/doc-new/Temp\nlog dir                       /Users/guoyuzhao/sites/doc-new/Log\nstring(10) \"easyswoole\"\n客户端输出\n➜  ssh curl http://localhost:9501/user/userInfo\\?name\\=easyswoole\n\neasyswoole\n请求数+1\n控制器方法\n\nes 在控制器基类中实现了几个通用方法，当然用户也可根据需要进行方法重写实现自己的逻辑 \n\nonRequest\n\n所有控制器请求都会先经过该方法，如果此方法返回false则请求不继续往下执行，可用于权限验证\n\nprotected function onRequest(?string $action): ?bool\n{\n    return true;\n}\nafterAction\n\n当action执行结束后调用该方法，可自定义数据回收等逻辑\n\nprotected function afterAction(?string $actionName): void\n{\n\n}\nactionNotFound\n\n当请求方法未找到时，自动调用此方法\n\nprotected function actionNotFound(?string $action)\n{\n    $class = static::class;\n    $this-&gt;writeJson(\\EasySwoole\\Http\\Message\\Status::CODE_NOT_FOUND,null,\"{$class} has not action for {$action}\");\n}\ngc\n\ngc方法在afterAction执行完后调用\n\nprotected function gc()\n{\n    //恢复默认值\n    foreach ($this-&gt;defaultProperties as $property =&gt; $value) {\n        $this-&gt;{$property} = $value;\n    }\n}\n注意事项\n\n只有第一次请求时才会调用构造函数\n对象池模式只重置非静态public属性\n对象池复用模式只针对单一进程，多个work进程不共享\n文件夹、文件、类名为大驼峰，变量与类方法小驼峰(规范)\naction返回的字符串将会被url解析规则以及route路由规则解析\n两个action的return不能互相调用，否则死循环\n","link":"/HttpServer/contorller.html"},{"id":69,"title":"请求对象","content":"Request对象\n接收客户端的HTTP请求对象\n生命周期\nRequest对象在系统中以单例模式存在，自收到客户端HTTP请求时自动创建，直至请求结束自动销毁。Request对象完全符合PSR7中的所有规范。\n核心方法\ngetRequestParam()\n用于获取用户通过POST或者GET提交的参数（注意：若POST与GET存在同键名参数，则以GET为准）。\n示例：\n// 在控制器中 可以通过 $this-&gt;request() 获取到Request对象\n// $request = $this-&gt;request()；\n\n$data = $request-&gt;getRequestParam();\nvar_dump($data);\n\n$orderId = $request-&gt;getRequestParam('orderId');\nvar_dump($orderId);\n\n$mixData = $request-&gt;getRequestParam(\"orderId\",\"type\");\nvar_dump($mixData);\ngetSwooleRequest()\n获取当前的swoole_http_request对象。\ngetCookieParams()\n获取HTTP请求中的cookie信息\n$all = $request-&gt;getCookieParams();\nvar_dump($all);\n$who = $request-&gt;getCookieParams('who');\nvar_dump($who);\ngetUploadedFiles()\n获取客户端上传的全部文件信息。\n$img_file = $request-&gt;getUploadedFile('img');//获取一个上传文件,返回的是一个\\EasySwoole\\Http\\Message\\UploadFile的对象\n$data = $request-&gt;getUploadedFiles();//获取全部上传文件返回包含\\EasySwoole\\Http\\Message\\UploadFile对象的数组\nvar_dump($data);\n#### \\EasySwoole\\Http\\Message\\UploadFile对象:\n点击查看UploadFile对象\ngetBody()\n获取以非form-data或x-www-form-urlenceded编码格式POST提交的原始数据，相当于PHP中的$HTTP_RAW_POST_DATA。\n获得get内容\n$get = $request-&gt;getQueryParams();\n获得post内容\n$post = $request-&gt;getParsedBody();\n获得raw内容\n$content = $request-&gt;getBody()-&gt;__toString();\n$raw_array = json_decode($content, true);\n获得头部\n$header = $request-&gt;getHeaders();\n获得server\n$server = $request-&gt;getServerParams();\n获得cookie\n$cookie = $request-&gt;getCookieParams();","link":"/HttpServer/request.html"},{"id":70,"title":"响应对象","content":"Response对象\n响应客户端的请求\n生命周期\nResponse对象在系统中以单例模式存在，自收到客户端HTTP请求时自动创建，直至请求结束自动销毁。Response对象完全符合PSR7中的所有规范。\n其他细节方法，有兴趣的同学可以在IDE中查看对应的代码。\n核心方法\nwrite\n向客户响应数据。\n$this-&gt;response()-&gt;write('hello world');\nredirect\n将请求重定向至指定的URL\n$this-&gt;response()-&gt;redirect(\"/newURL/index.html\");\nsetCookie\n向客户端设置一个Cookie，用法与原生的setCookie一致。\ngetSwooleResponse\n获取原始的swoole_http_response实例。\nend\n结束对该次HTTP请求响应,结束之后,无法再次向客户端响应数据.\nisEndResponse\n判断该次HTTP请求是否结束响应,当你不知道是否已经结束响应时,可通过该方法判断是否能再次向客户端响应数据:\nif(!$this-&gt;response()-&gt;isEndResponse()){\n    $this-&gt;response()-&gt;write('继续发送数据');\n}\nwithStatus\n向客户端发送HTTP状态码。\n$this-&gt;response()-&gt;withStatus($statusCode);\n注意：$statusCode必须为标准的HTTP允许状态码，具体请见Http Message中的Status对象。\nwithHeader\n用于向HTTP客户端发送一个header。\n$this-&gt;response()-&gt;withHeader('Content-type','application/json;charset=utf-8');","link":"/HttpServer/response.html"},{"id":71,"title":"静态路由","content":"静态路由\n静态路由是直接通过URl映射，因此效率高，但作用也是有限的。\nURL解析规则\n仅支持PATHINFO模式的 URL 解析，且与控制器名称(方法)保持一致，控制器搜索规则为优先完整匹配模式\n解析规则\n在没有路由干预的情况下，内置的解析规则支持无限级嵌套目录，如下方两个例子所示\n\n\nhttp://serverName/api/auth/login\n对应执行的方法为 \\App\\HttpController\\Api\\Auth::login()\n\n\nhttp://serverName/a/b/c/d/f\n\n\n如果 f 为控制器名，则执行的方法为 \\App\\HttpController\\A\\B\\C\\D\\F::index()\n\n\n如果 f 为方法名，则执行的方法为 \\App\\HttpControllers\\A\\B\\C\\D::f()\n\n\n如果最后的路径为index时,底层会自动忽略,并直接调用控制器的默认方法(也就是index)\n\n\n\n\n解析层级\n理论上 EasySwoole 支持无限层级的URL -&gt; 控制器映射，但出于系统效率和防止恶意 URL 访问， 系统默认为3级，若由于业务需求，需要更多层级的URL映射匹配，请于框架初始化事件中向 DI 注入常量SysConst::HTTP_CONTROLLER_MAX_DEPTH ，值为 URL 解析的最大层级，如下代码，允许 URL 最大解析至5层\npublic static function initialize()\n{\n    Di::getInstance()-&gt;set(SysConst::HTTP_CONTROLLER_MAX_DEPTH,5);\n}\n特殊情况\n当控制器和方法都为index时,可直接忽略不写\n\n\n如果方法为index,则可以忽略:\n如果对应执行方法名为 \\App\\HttpController\\Api\\User::index()\nurl可直接写 http://serverName/api/User  \n\n\n如果控制器和方法都为Index,则可以忽略\n如果对应执行方法名为 \\App\\HttpController\\Index::index()\nurl可直接写 http://serverName/   \n\n\nindex忽略规则理论支持无限层级,根据解析层级最大进行逐层查找\n\n\n注意，EasySwoole的URL路径区分大小写,控制器首字母支持小写转换","link":"/HttpServer/staticRoute.html"},{"id":72,"title":"动态路由","content":"动态路由\n动态路由就是把url的请求优雅的对应到你想要执行的操作方法。\nES的动态路由是基于FastRoute实现，与其路由规则保持一致。 \n示例代码:\n新建文件App\\HttpController\\Router.php:  \n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/8/15\n * Time: 上午10:39\n */\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\AbstractRouter;\nuse FastRoute\\RouteCollector;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        $routeCollector-&gt;get('/user', '/index.html');\n        $routeCollector-&gt;get('/rpc', '/Rpc/index');\n\n        $routeCollector-&gt;get('/', function (Request $request, Response $response) {\n            $response-&gt;write('this router index');\n        });\n        $routeCollector-&gt;get('/test', function (Request $request, Response $response) {\n            $response-&gt;write('this router test');\n            return '/a';//重新定位到/a方法\n        });\n        $routeCollector-&gt;get('/user/{id:\\d+}', function (Request $request, Response $response) {\n            $response-&gt;write(\"this is router user ,your id is {$request-&gt;getQueryParam('id')}\");//获取到路由匹配的id\n            return false;//不再往下请求,结束此次响应\n        });\n\n    }\n}\n访问127.0.0.1:9501/rpc,对应为App\\HttpController\\Rpc.php-&gt;index()  \n如果使用回调函数方式处理路由,return false 代表不继续往下请求\n路由分组\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        $routeCollector-&gt;addGroup('/admin',function (RouteCollector $collector){\n            $collector-&gt;addRoute('GET','/index.html',function (Request $request,Response $response){\n                $version = $request-&gt;getQueryParam('version');\n                // 这里可以根据version参数判断返回新路径\n                if($version == 1){\n                    $path = '/V1'.$request-&gt;getUri()-&gt;getPath();\n                }else{\n                    $path = '/V2'.$request-&gt;getUri()-&gt;getPath();\n                }\n                //返回新的构造的path\n                return $path;\n            });\n        });\n    }\n}\n全局模式拦截\n在Router.php加入以下代码,即可开启全局模式拦截\n$this-&gt;setGlobalMode(true);\n全局模式拦截下,路由将只匹配Router.php中的控制器方法响应,将不会执行框架的默认解析\n异常错误处理\n通过以下2个方法,可设置路由匹配错误以及未找到方法的回调:\n&lt;?php\n$this-&gt;setMethodNotAllowCallBack(function (Request $request,Response $response){\n    $response-&gt;write('未找到处理方法');\n    return false;//结束此次响应\n});\n$this-&gt;setRouterNotFoundCallBack(function (Request $request,Response $response){\n    $response-&gt;write('未找到路由匹配');\n    return 'index';//重定向到index路由\n});\n该回调函数只针对于fastRoute未匹配状况,如果回调里面不结束该请求响应,则该次请求将会继续进行Dispatch并尝试寻找对应的控制器进行响应处理。  \nFastRoute使用\naddRoute方法\n定义路由的addRoute方法原型如下，该方法需要三个参数，下面围绕这三个参数我们对路由组件进行更深一步的了解\n$routeCollector-&gt;addRoute($httpMethod, $routePattern, $handler)\nhttpMethod\n该参数需要传入一个大写的HTTP方法字符串，指定路由可以拦截的方法，单个方法直接传入字符串，需要拦截多个方法可以传入一个一维数组，如下面的例子：\n// 拦截GET方法\n$routeCollector-&gt;addRoute('GET', '/router', '/Index');\n\n// 拦截POST方法\n$routeCollector-&gt;addRoute('POST', '/router', '/Index');\n\n// 拦截多个方法\n$routeCollector-&gt;addRoute(['GET', 'POST'], '/router', '/Index');\n\nroutePattern\n传入一个路由匹配表达式，符合该表达式要求的路由才会被拦截并进行处理，表达式支持{参数名称:匹配规则}这样的占位符匹配，用于限定路由参数\n基本匹配\n下面的定义将会匹配 http://localhost:9501/users/info\n$routeCollector-&gt;addRoute('GET', '/users/info', 'handler');\n绑定参数\n下面的定义将/users/后面的部分作为参数，并且限定参数只能是数字[0-9]\n// 可以匹配: http://localhost:9501/users/12667\n// 不能匹配: http://localhost:9501/users/abcde\n\n$routeCollector-&gt;addRoute('GET', '/users/{id:\\d+}', 'handler');\n\n下面的定义不做任何限定，仅将匹配到的URL部分获取为参数\n// 可以匹配: http://localhost:9501/users/12667\n// 可以匹配: http://localhost:9501/users/abcde\n\n$routeCollector-&gt;addRoute('GET', '/users/{name}', 'handler');\n有时候路由的部分位置是可选的，可以像下面这样定义\n// 可以匹配: http://localhost:9501/users/to\n// 可以匹配: http://localhost:9501/users/to/username\n\n$routeCollector-&gt;addRoute('GET', '/users/to[/{name}]', 'handler');\n绑定的参数将由框架内部进行组装到get数据之中,调用方法:\n&lt;?php\n$routeCollector-&gt;get('/user/{id:\\d+}', function (Request $request, Response $response) {\n    $response-&gt;write(\"this is router user ,your id is {$request-&gt;getQueryParam('id')}\");\n    return false;\n});\nhandler\n指定路由匹配成功后需要处理的方法，可以传入一个闭包，当传入闭包时一定要注意处理完成之后要处理结束响应否则请求会继续Dispatch寻找对应的控制器来处理，当然如果利用这一点，也可以对某些请求进行处理后再交给控制器执行逻辑\n// 传入闭包的情况\n$routeCollector-&gt;addRoute('GET', '/router/{id:\\d+}', function (Request $request, Response $response) {\n    $id = $request-&gt;getQueryParam('id');\n    $response-&gt;write('Userid : ' . $id);\n    return false;\n});\n\n也可以直接传入控制器路径\n$routeCollector-&gt;addRoute('GET', '/router2/{id:\\d+}', '/Index');","link":"/HttpServer/dynamicRoute.html"},{"id":73,"title":"权限与中间件","content":"请求拦截\nEasyswoole的控制器并没有提供类似中间件的说法，而是提供了控制器中的onRequest事件进行验证。\n例如，我们需要对/api/user/*下的路径进行cookie验证。那么有以下两种方案.\n全局Request及Response事件\n在initialize中注册.\n// onRequest v3.4.x+\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST,function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response){\n    $cookie = $this-&gt;request()-&gt;getCookieParams('user_cookie');\n    //对cookie进行判断，比如在数据库或者是redis缓存中，存在该cookie信息，说明用户登录成功\n    $isLogin = true;\n    if($isLogin){\n        //返回true表示继续往下执行控制器action\n        return  true;\n    }else{\n        //这一步可以给前端响应数据，告知前端未登录\n        $this-&gt;writeJson(401,null,'请先登录');\n        //返回false表示不继续往下执行控制器action\n        return  false;\n    }\n});\n// afterRequest v3.4.x+\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_AFTER_REQUEST,function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response){\n\n});\n3.4.x版本之前：可在EasySwooleEvent中看到onRequest及afterRequest方法.\n定义Base控制器\nnamespace App\\HttpController\\Api\\User;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nabstract class Base extends Controller\n{\n    protected function onRequest(?string $action): ?bool\n    {\n        $cookie = $this-&gt;request()-&gt;getCookieParams('user_cookie');\n        //对cookie进行判断，比如在数据库或者是redis缓存中，存在该cookie信息，说明用户登录成功\n        $isLogin = true;\n        if($isLogin){\n            //返回true表示继续往下执行控制器action\n            return  true;\n        }else{\n            //这一步可以给前端响应数据，告知前端未登录\n            $this-&gt;writeJson(401,null,'请先登录');\n            //返回false表示不继续往下执行控制器action\n            return  false;\n        }\n    }\n}\n\n后续，只要/api/user/*下路径的控制器，都继承自Base控制器，都可以实现自动的cookie拦截了\n\n行为权限校验也是如此，可以判断某个用户是否对该控制器的action或者请求路径有没有权限\n","link":"/HttpServer/interception.html"},{"id":74,"title":"异常处理","content":"错误与异常拦截\nhttp控制器错误异常\n在http控制器中出现错误，系统将使用默认异常处理进行输出至客户端，代码如下：\n&lt;?php\nprotected function hookThrowable(\\Throwable $throwable,Request $request,Response $response)\n{\n    if(is_callable($this-&gt;httpExceptionHandler)){\n        call_user_func($this-&gt;httpExceptionHandler,$throwable,$request,$response);\n    }else{\n        $response-&gt;withStatus(Status::CODE_INTERNAL_SERVER_ERROR);\n        $response-&gt;write(nl2br($throwable-&gt;getMessage().\"\\n\".$throwable-&gt;getTraceAsString()));\n    }\n}\n可直接在控制器重写onException方法：\n&lt;?php\nnamespace App\\HttpController;\n\nuse App\\ViewController;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Http\\Message\\Status;\n\nclass Base extends ViewController\n{\n\n    function index()\n    {\n        // TODO: Implement index() method.\n        $this-&gt;actionNotFound('index');\n    }\n\n    function onException(\\Throwable $throwable): void\n    {\n        var_dump($throwable-&gt;getMessage());\n    }\n\n    protected function actionNotFound(?string $action): void\n    {\n        $this-&gt;response()-&gt;withStatus(Status::CODE_NOT_FOUND);\n        $this-&gt;response()-&gt;write('action not found');\n    }\n}\n自定义异常处理\n开发者可自定义异常处理文件：\n&lt;?php\nnamespace App;\n\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass ExceptionHandler\n{\n    public static function handle( \\Throwable $exception, Request $request, Response $response )\n    {\n        var_dump($exception-&gt;getTraceAsString());\n    }\n}\n在initialize事件中DI注册异常处理:\npublic static function initialize()\n{\n    Di::getInstance()-&gt;set(SysConst::HTTP_EXCEPTION_HANDLER,[ExceptionHandler::class,'handle']);\n}","link":"/HttpServer/exception.html"},{"id":75,"title":"session","content":"EasySwoole Session组件\n由于在 Swoole 协程下，php 自带的 session 函数是不能使用的。为此，EasySwoole 提供了独立的 session 组件，实现 php 的 session 功能。\n组件要求\n\nphp : &gt;=7.1.0\neasyswoole/spl : ^1.3\neasyswoole/utility : ^1.1\neasyswoole/component : ^2.1\n\n安装方法\n\ncomposer require easyswoole/session=2.x\n\n仓库地址\neasyswoole/session=2.x\n基本使用\n注册 session handler\n使用 session 前，需要先注册 session handler。接下来的示例使用的 session handler 是 EasySwoole 内置的 session handler，开箱即用。\n注册步骤：\n修改 EasySwoole 全局的 event文件(框架根目录的 EasySwooleEvent.php 文件)，在 mainServerCreate 和 HTTP 的 全局 HTTP_GLOBAL_ON_REQUEST 事件中注册 session handler。\n具体实现代码如下:\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\Component\\Di;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\Session\\Session;\nuse EasySwoole\\Session\\SessionFileHandler;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, function (Request $request, Response $response): bool {\n            // TODO: 注册 HTTP_GLOBAL_ON_REQUEST 回调，相当于原来的 onRequest 事件\n            $cookie = $request-&gt;getCookieParams('easy_session');\n            if (empty($cookie)) {\n                $sid = Session::getInstance()-&gt;sessionId();\n                $response-&gt;setCookie('easy_session', $sid);\n            } else {\n                Session::getInstance()-&gt;sessionId($cookie);\n            }\n            return true;\n        });\n\n        Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_AFTER_REQUEST, function (Request $request, Response $response): void {\n            // TODO: 注册 HTTP_GLOBAL_AFTER_REQUEST 回调，相当于原来的 afterRequest 事件\n        });\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // 可以自己实现一个标准的session handler\n        $handler = new SessionFileHandler(EASYSWOOLE_TEMP_DIR);\n        // 表示c ookie name   还有 save path\n        Session::getInstance($handler, 'easy_session', 'session_dir');\n    }\n}\n在 EasySwoole 中使用 session\n\n注册 session handler 之后，我们就可以在 EasySwoole 控制器 的任意位置使用了。\n简单使用示例代码如下:\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Session\\Session;\n\nclass Index extends Controller\n{\n\n    public function index()\n    {\n        if (Session::getInstance()-&gt;get('a')) {\n            var_dump(Session::getInstance()-&gt;get('a'));\n        } else {\n            Session::getInstance()-&gt;set('a', time());\n        }\n    }\n\n    function des()\n    {\n        Session::getInstance()-&gt;destroy();\n    }\n}\n然后访问 http://127.0.0.1:9501/index (示例请求地址)就可以进行测试设置 session，访问 http://127.0.0.1:9501/des (示例请求地址)就可以销毁 session","link":"/HttpServer/session.html"},{"id":76,"title":"视图","content":"模板引擎\n渲染驱动\nEasySwoole引入模板渲染驱动的形式，把需要渲染的数据，通过协程客户端投递到自定义的同步进程中进行渲染并返回结果。为何要如此处理，原因在于，市面上的一些模板引擎在Swoole协程下存在变量安全问题。例如以下流程：\n\nrequest A reached, static A assign requestA-data\ncompiled template \nwrite compiled template (yiled current coroutine)\nrequest B reached，static A assign requestB-data\n\nrender static A data into complied template file\n以上流程我们可以发现，A请求的数据，被B给污染了。为了解决该问题，EasySwoole引入模板渲染驱动模式。\n\n\n安装\n\ncomposer require easyswoole/template\n\n基础实现讲解\n实现渲染引擎\nuse EasySwoole\\Template\\Config;\nuse EasySwoole\\Template\\Render;\nuse EasySwoole\\Template\\RenderInterface;\n\nclass R implements RenderInterface\n{\n\n    public function render(string $template, ?array $data = [], ?array $options = []):?string\n    {\n        return 'todo some thing';\n    }\n\n    public function afterRender(?string $result, string $template, array $data = [], array $options = [])\n    {\n        // TODO: Implement afterRender() method.\n    }\n\n    public function onException(Throwable $throwable, $arg):string\n    {\n        return $throwable-&gt;getMessage();\n    }\n}\n\n自定义HTTP服务中调用\nclass MyRender implements \\EasySwoole\\Template\\RenderInterface {\n\n    public function render(string $template, ?array $data = null, ?array $options = null): ?string\n    {\n        return \"your template is {$template} and data is \".json_encode($data);\n    }\n\n    public function onException(\\Throwable $throwable, $arg): string\n    {\n        return $throwable-&gt;getTraceAsString();\n    }\n}\n\\EasySwoole\\Template\\Render::getInstance()-&gt;getConfig()-&gt;setRender(new MyRender());\n\n$http = new swoole_http_server(\"0.0.0.0\", 9501);\n$http-&gt;on(\"request\", function ( $request,  $response){\n    $ret = \\EasySwoole\\Template\\Render::getInstance()-&gt;render('index.html',['easyswoole'=&gt;'hello']);\n    $response-&gt;end($ret);\n});\n\n\\EasySwoole\\Template\\Render::getInstance()-&gt;attachServer($http);\n\n$http-&gt;start();\n重启渲染引擎\n由于某些模板引擎会缓存模板文件\n导致可能出现以下情况：\n× 用户A请求1.tpl 返回‘a’\n× 开发者修改了1.tpl的数据，改成了‘b’\n× 用户B，C，D在之后的请求中，可能会出现‘a’，‘b’两种不同的值\n那是因为模板引擎已经缓存了A所在进程的文件，导致后面的请求如果也分配到了A的进程，就会获取到缓存的值\n解决方案如下：\n\n1:重启easyswoole服务，即可解决\n2:模板渲染引擎实现了重启方法restartWorker，直接调用即可\n\nRender::getInstance()-&gt;restartWorker();\n用户可根据自己的逻辑，自行调用restartWorker方法进行重启\n例如在控制器新增reload方法：\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Template\\Render;\n\nclass Index extends Controller\n{\n\n    public function index()\n    {\n        $this-&gt;response()-&gt;write(Render::getInstance()-&gt;render('index.tpl',[\n            'user'=&gt;'easyswoole',\n            'time'=&gt;time()\n        ]));\n    }\n\n    public function reload(){\n        Render::getInstance()-&gt;restartWorker();\n        $this-&gt;response()-&gt;write(1);\n    }\n}\n示例\nSmarty 渲染\n引入Smarty\n\ncomposer require smarty/smarty\n\n实现渲染引擎\nuse EasySwoole\\Template\\RenderInterface;\n\nclass Smarty implements RenderInterface\n{\n\n    private $smarty;\n    function __construct()\n    {\n        $temp = sys_get_temp_dir();\n        $this-&gt;smarty = new \\Smarty();\n        $this-&gt;smarty-&gt;setTemplateDir(EASYSWOOLE_ROOT.'/View/');\n        $this-&gt;smarty-&gt;setCacheDir(\"{$temp}/smarty/cache/\");\n        $this-&gt;smarty-&gt;setCompileDir(\"{$temp}/smarty/compile/\");\n    }\n\n    public function render(string $template, ?array $data = [], ?array $options = []): ?string\n    {\n        foreach ($data as $key =&gt; $item){\n            $this-&gt;smarty-&gt;assign($key,$item);\n        }\n        return $this-&gt;smarty-&gt;fetch($template,$cache_id = null, $compile_id = null, $parent = null, $display = false,\n            $merge_tpl_vars = true, $no_output_filter = false);\n    }\n\n    public function afterRender(?string $result, string $template, array $data = [], array $options = [])\n    {\n\n    }\n\n    public function onException(\\Throwable $throwable, $arg): string\n    {\n        $msg = \"{$throwable-&gt;getMessage()} at file:{$throwable-&gt;getFile()} line:{$throwable-&gt;getLine()}\";\n        trigger_error($msg);\n        return $msg;\n    }\n}\nHTTP服务中调用\n在全局mainServerCreate事件中注册：\n\\EasySwoole\\Template\\Render::getInstance()-&gt;getConfig()-&gt;setRender(new Smarty());\n\\EasySwoole\\Template\\Render::getInstance()-&gt;getConfig()-&gt;setTempDir(EASYSWOOLE_TEMP_DIR);\n\\EasySwoole\\Template\\Render::getInstance()-&gt;attachServer(\\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer());\n在控制器层响应：\n$this-&gt;response()-&gt;write(\\EasySwoole\\Template\\Render::getInstance()-&gt;render('View/custom.html', ['name' =&gt; 'easyswoole']));\n支持常用的模板引擎\n下面列举一些常用的模板引擎包方便引入使用:\nsmarty/smarty\nSmarty是一个使用PHP写出来的模板引擎,是目前业界最著名的PHP模板引擎之一\ncomposer require smarty/smarty=~3.1\nleague/plates\n使用原生PHP语法的非编译型模板引擎，更低的学习成本和更高的自由度\ncomposer require league/plates=3.*\nduncan3dc/blade\nLaravel框架使用的模板引擎\ncomposer require duncan3dc/blade=^4.5\ntopthink/think-template\nThinkPHP框架使用的模板引擎\ncomposer require topthink/think-template","link":"/Components/Component/template.html"},{"id":77,"title":"验证码","content":"EasySwoole 验证码组件\nEasySwoole提供了独立的 验证码组件 ,几行代码即可实现输出一个验证码\n组件要求\n\nphp: &gt;=7.1\next-gd: *\neasyswoole/spl: ^1.0\n\n安装方法\n\ncomposer require easyswoole/verifycode=3.x\n\n仓库地址\neasyswoole/verifycode=3.x\n基本使用\n配置\n生成验证码前需要传入Config的对象实例\nConfig类实例化后会有默认配置,无需配置也可生成验证码图片\n&lt;?php\n// +----------------------------------------------------------------------\n// | easySwoole [ use swoole easily just like echo \"hello world\" ]\n// +----------------------------------------------------------------------\n// | WebSite: https://www.easyswoole.com\n// +----------------------------------------------------------------------\n// | Welcome Join QQGroup 633921431\n// +----------------------------------------------------------------------\n\nnamespace EasySwoole\\VerifyCode;\n\nuse EasySwoole\\Spl\\SplBean;\n\n/**\n * 验证码配置文件\n * Class VerifyCodeConf\n * @author  : evalor &lt;master@evalor.cn&gt;\n * @package Vendor\\VerifyCode\n */\nclass Conf extends SplBean\n{\n\n    public $charset   = '1234567890AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'; // 字母表\n    public $useCurve  = false;         // 混淆曲线\n    public $useNoise  = false;         // 随机噪点\n    public $useFont   = null;          // 指定字体\n    public $fontColor = null;          // 字体颜色\n    public $backColor = null;          // 背景颜色\n    public $imageL    = null;          // 图片宽度\n    public $imageH    = null;          // 图片高度\n    public $fonts     = [];            // 额外字体\n    public $fontSize  = 25;            // 字体大小\n    public $length    = 4;             // 生成位数\n    public $mime      = MIME::PNG;     // 设置类型\n    public $temp      = '/tmp';  // 设置缓存目录\n\n    public function setTemp($temp){\n        if (!is_dir($temp)) mkdir($temp,0755) &amp;&amp; chmod($temp,0755);\n        $this-&gt;temp = $temp;\n    }\n\n    /**\n     * 设置图片格式\n     * @param $MimeType\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return Conf\n     */\n    public function setMimeType($MimeType)\n    {\n        $allowMime = [ MIME::PNG, MIME::GIF, MIME::JPG ];\n        if (in_array($MimeType, $allowMime)) $this-&gt;mime = $MimeType;\n        return $this;\n    }\n\n    /**\n     * 设置字符集\n     * @param string $charset\n     * @return Conf\n     */\n    public function setCharset($charset)\n    {\n        is_string($charset) &amp;&amp; $this-&gt;charset = $charset;\n        return $this;\n    }\n\n    /**\n     * 开启混淆曲线\n     * @param bool $useCurve\n     * @return Conf\n     */\n    public function setUseCurve($useCurve = true)\n    {\n        is_bool($useCurve) &amp;&amp; $this-&gt;useCurve = $useCurve;\n        return $this;\n    }\n\n    /**\n     * 开启噪点生成\n     * @param bool $useNoise\n     * @return Conf\n     */\n    public function setUseNoise($useNoise = true)\n    {\n        is_bool($useNoise) &amp;&amp; $this-&gt;useNoise = $useNoise;\n        return $this;\n    }\n\n    /**\n     * 使用自定义字体\n     * @param string $useFont\n     * @return Conf\n     */\n    public function setUseFont($useFont)\n    {\n        is_string($useFont) &amp;&amp; $this-&gt;useFont = $useFont;\n        return $this;\n    }\n\n    /**\n     * 设置文字颜色\n     * @param array|string $fontColor\n     * @return Conf\n     */\n    public function setFontColor($fontColor)\n    {\n        if (is_string($fontColor)) $this-&gt;fontColor = $this-&gt;HEXToRGB($fontColor);\n        if (is_array($fontColor)) $this-&gt;fontColor = $fontColor;\n        return $this;\n    }\n\n    /**\n     * 设置背景颜色\n     * @param null $backColor\n     * @return Conf\n     */\n    public function setBackColor($backColor)\n    {\n        if (is_string($backColor)) $this-&gt;backColor = $this-&gt;HEXToRGB($backColor);\n        if (is_array($backColor)) $this-&gt;backColor = $backColor;\n        return $this;\n    }\n\n    /**\n     * 设置图片宽度\n     * @param int|string $imageL\n     * @return Conf\n     */\n    public function setImageWidth($imageL)\n    {\n        $this-&gt;imageL = intval($imageL);\n        return $this;\n    }\n\n    /**\n     * 设置图片高度\n     * @param null $imageH\n     * @return Conf\n     */\n    public function setImageHeight($imageH)\n    {\n        $this-&gt;imageH = intval($imageH);\n        return $this;\n    }\n\n    /**\n     * 设置字体集\n     * @param array|string $fonts\n     * @return Conf\n     */\n    public function setFonts($fonts)\n    {\n        if (is_string($fonts)) array_push($this-&gt;fonts, $fonts);\n        if (is_array($fonts) &amp;&amp; !empty($fonts)) {\n            if (empty($this-&gt;fonts)) {\n                $this-&gt;fonts = $fonts;\n            } else {\n                array_merge($this-&gt;fonts, $fonts);\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * 设置字体尺寸\n     * @param int $fontSize\n     * @return Conf\n     */\n    public function setFontSize($fontSize)\n    {\n        $this-&gt;fontSize = intval($fontSize);\n        return $this;\n    }\n\n    /**\n     * 设置验证码长度\n     * @param int $length\n     * @return Conf\n     */\n    public function setLength($length)\n    {\n        $this-&gt;length = intval($length);\n        return $this;\n    }\n\n    /**\n     * 获取配置值\n     * @param $name\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        return $this-&gt;$name;\n    }\n\n    /**\n     * 十六进制转RGB\n     * @param $hexColor\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return array\n     */\n    function HEXToRGB($hexColor)\n    {\n        $color = str_replace('#', '', $hexColor);\n        if (strlen($color) &gt; 3) {\n            $rgb = array(\n                hexdec(substr($color, 0, 2)),\n                hexdec(substr($color, 2, 2)),\n                hexdec(substr($color, 4, 2))\n            );\n        } else {\n            $color = $hexColor;\n            $r = substr($color, 0, 1) . substr($color, 0, 1);\n            $g = substr($color, 1, 1) . substr($color, 1, 1);\n            $b = substr($color, 2, 1) . substr($color, 2, 1);\n            $rgb = array(\n                hexdec($r),\n                hexdec($g),\n                hexdec($b)\n            );\n        }\n        return $rgb;\n    }\n}\n验证码生成\nVerifyCode验证码操作类,如果不传入Config实例,则自动实例化一个\n$config = new Conf();\n$code = new \\EasySwoole\\VerifyCode\\VerifyCode($config);\n$code-&gt;DrawCode();//生成验证码,返回一个Result对象\n验证码结果类\n验证码结果类,由VerifyCode验证码操作类调用 DrawCode() 方法时创建并返回  \n    /**\n     * 获取验证码图片\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return mixed\n     */\n    function getImageByte()\n    {\n        return $this-&gt;CaptchaByte;\n    }\n\n    /**\n     * 返回图片Base64字符串\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return string\n     */\n    function getImageBase64()\n    {\n        $base64Data = base64_encode($this-&gt;CaptchaByte);\n        $Mime = $this-&gt;CaptchaMime;\n        return \"data:{$Mime};base64,{$base64Data}\";\n    }\n\n    /**\n     * 获取验证码内容\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return mixed\n     */\n    function getImageCode()\n    {\n        return $this-&gt;CaptchaCode;\n    }\n\n    /**\n     * 获取Mime信息\n     * @author : evalor &lt;master@evalor.cn&gt;\n     */\n    function getImageMime()\n    {\n        return $this-&gt;CaptchaMime;\n    }\n\n    /**\n     * 获取验证码文件路径\n     * @author: eValor &lt; master@evalor.cn &gt;\n     */\n    function getImageFile()\n    {\n        return $this-&gt;CaptchaFile;\n    }\n使用示例\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Apple\n * Date: 2018/11/12 0012\n * Time: 16:30\n */\n\nnamespace App\\HttpController;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\VerifyCode\\Conf;\n\nclass VerifyCode extends Controller\n{\n    function index()\n    {\n        $config = new Conf();\n        $code = new \\EasySwoole\\VerifyCode\\VerifyCode($config);\n        $this-&gt;response()-&gt;withHeader('Content-Type','image/png');\n        $this-&gt;response()-&gt;write($code-&gt;DrawCode()-&gt;getImageByte());\n    }\n\n    function getBase64(){\n        $config = new Conf();\n        $code = new \\EasySwoole\\VerifyCode\\VerifyCode($config);\n        $this-&gt;response()-&gt;write($code-&gt;DrawCode()-&gt;getImageBase64());\n    }\n}\n进阶使用\n生成二维码图片并返回\n&lt;?php\n/**\n *\n * User: luffyQAQ\n * Date: 2019/9/5 15:29\n * Email: &lt;1769360227@qq.com&gt;\n */\n\nnamespace App\\HttpController\\Api\\Common;\n\nuse App\\Service\\Common\\VerifyCodeService;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\Utility\\Random;\nuse EasySwoole\\VerifyCode\\Conf;\n\nclass VerifyCode extends CommonBase\n{\n    static $VERIFY_CODE_TTL = 120;\n    static $VERIFY_CODE_LENGTH = 4;\n\n    public function verifyCode()\n    {\n        $config = new Conf();\n        $code = new \\EasySwoole\\VerifyCode\\VerifyCode($config);\n        //获取随机数\n        $random = Random::character(self::$VERIFY_CODE_LENGTH,'1234567890abcdefghijklmnopqrstuvwxyz');\n        $code = $code-&gt;DrawCode($random);\n        $time = time();\n        $result = [\n            'verifyCode' =&gt; $code-&gt;getImageBase64(),\n            'verifyCodeTime' =&gt; $time,\n        ];\n\n        $this-&gt;response()-&gt;setCookie(\"verifyCodeHash\", VerifyCodeService::getVerifyCodeHash($random, $time), $time + self::$VERIFY_CODE_TTL, '/');\n        $this-&gt;response()-&gt;setCookie('verifyCodeTime', $time, $time + self::$VERIFY_CODE_TTL, '/');\n        $this-&gt;writeJson(Status::CODE_OK, $result, 'success');\n\n    }\n}\n调用对应的路径接口，即可实现前台验证码显示","link":"/Components/verifyCode.html"},{"id":78,"title":"验证器","content":"EasySwoole 验证器组件\nEasySwoole 提供了独立的 验证器组件，几行代码即可实现对请求参数进行验证。常用于对 HTTP 等请求中的请求参数的验证。\n另外框架还提供了在注解中对 HTTP 请求参数进行校验的组件，可以很方便地对 HTTP 请求参数的合法性进行校验。在注解中就可以设置请求参数的验证规则，使得代码更简洁，详细使用见 参数注解校验。\n组件要求\n\nphp: &gt;= 7.1.0\neasyswoole/spl: ^1.0\npsr/http-message: ^1.0\n\n安装方法\n框架 3.4.x 及以上版本自带 validate 组件，所以不需要单独安装。3.4.x 之前的版本请单独安装，安装方法如下：\n\ncomposer require easyswoole/validate\n\n仓库地址\neasyswoole/validate\n默认提供的验证错误信息提示说明\nvalidate 验证器组件提供了默认验证错误信息的规则，详细如下：\nprivate $defaultErrorMsg = [\n    'activeUrl'     =&gt; ':fieldName必须是可访问的网址',\n    'alpha'         =&gt; ':fieldName只能是字母',\n    'between'       =&gt; ':fieldName只能在 :arg0 - :arg1 之间',\n    'bool'          =&gt; ':fieldName只能是布尔值',\n    'dateBefore'    =&gt; ':fieldName必须在日期 :arg0 之前',\n    'dateAfter'     =&gt; ':fieldName必须在日期 :arg0 之后',\n    'equal'         =&gt; ':fieldName必须等于:arg0',\n    'float'         =&gt; ':fieldName只能是浮点数',\n    'func'          =&gt; ':fieldName自定义验证失败',\n    'inArray'       =&gt; ':fieldName必须在 :arg0 范围内',\n    'integer'       =&gt; ':fieldName只能是整数',\n    'isIp'          =&gt; ':fieldName不是有效的IP地址',\n    'notEmpty'      =&gt; ':fieldName不能为空',\n    'numeric'       =&gt; ':fieldName只能是数字类型',\n    'notInArray'    =&gt; ':fieldName不能在 :arg0 范围内',\n    'length'        =&gt; ':fieldName的长度必须是:arg0',\n    'lengthMax'     =&gt; ':fieldName长度不能超过:arg0',\n    'lengthMin'     =&gt; ':fieldName长度不能小于:arg0',\n    'max'           =&gt; ':fieldName的值不能大于:arg0',\n    'min'           =&gt; ':fieldName的值不能小于:arg0',\n    'regex'         =&gt; ':fieldName不符合指定规则',\n    'required'      =&gt; ':fieldName必须填写',\n    'timestamp'     =&gt; ':fieldName必须是一个有效的时间戳',\n    'url'           =&gt; ':fieldName必须是合法的网址',\n    'allowFile'     =&gt; ':fieldName文件扩展名必须在:arg0内',\n    'allowFileType' =&gt; ':fieldName文件类型必须在:arg0内',\n    'isArray'       =&gt; ':fieldName类型必须为数组'\n];\n基本使用\n使用组件提供的默认的验证错误信息提示\n使用示例如下：\n&lt;?php\nrequire_once __DIR__ . \"/vendor/autoload.php\";\n\n$data = [\n    'name' =&gt; 'blank',\n    'age' =&gt; 25\n]; // 要验证的数据\n$validate = new \\EasySwoole\\Validate\\Validate();\n$validate-&gt;addColumn('name')-&gt;required(); // 给字段加上验证规则(验证数据中 name 字段不能没有)\n$validate-&gt;addColumn('age')-&gt;required()-&gt;max(18); // 给字段加上验证规则(验证数据中 age 字段不能没有且值不能大于18)\n$bool = $validate-&gt;validate($data); // 验证结果：验证通过返回true 反之返回false\nif ($bool) {\n    var_dump(\"验证通过\");\n} else {\n    // 输出验证错误信息：\n    var_dump($validate-&gt;getError()-&gt;__toString());\n}\n/*\n * 输出结果： string(23) \"age的值不能大于18\"\n */\n使用自定义的验证错误信息提示\n使用示例如下：\n&lt;?php\nrequire_once __DIR__ . \"/vendor/autoload.php\";\n\n$data1 = [\n    'name' =&gt; 'easyswoole',\n    'age' =&gt; 25\n]; // 要验证的数据\n$validate1 = new \\EasySwoole\\Validate\\Validate();\n$validate1-&gt;addColumn('name', '名字')-&gt;required('参数不能缺少!'); // 给字段加上验证规则(验证数据中 name 字段不能没有)\n$validate1-&gt;addColumn('age', '年龄')-&gt;required('参数不能缺少!')-&gt;max(18, '不能大于18周岁'); // 给字段加上验证规则(验证数据中 age 字段不能没有且值不能大于18)\n$bool = $validate1-&gt;validate($data1); // 验证结果：验证通过返回true 反之返回false\nif ($bool) {\n    var_dump(\"验证通过\");\n} else {\n    // 输出验证错误信息：\n    $fieldName = $validate1-&gt;getError()-&gt;getFieldAlias(); // 获取验证规则中设置的字段别名 '年龄'\n    $errorMsg = $validate1-&gt;getError()-&gt;__toString(); // 获取验证错误信息 '不能大于18周岁'\n    var_dump($fieldName . $errorMsg);\n}\n/**\n * 输出结果：string(26) \"年龄不能大于18周岁\"\n */\n\n注意：验证器组件的验证顺序是按照添加验证规则时的 添加字段的先后顺序 和 验证规则的先后顺序 逐个进行验证的，先添加的验证规则不通过则直接返回验证失败，然后就可以获取对应的验证错误信息。例如上述示例中，会优先验证 name 字段是否存在。\n\n在控制器中封装使用\n先定义一个带有 validateRule 方法的基础控制器。示例代码如下：\n&lt;?php\nnamespace App\\HttpController\\Api;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\Validate\\Validate;\n\nclass BaseController extends Controller\n{\n    protected function validate(Validate $validate)\n    {\n        return $validate-&gt;validate($this-&gt;request()-&gt;getRequestParam());\n    }\n\n    protected function onRequest(?string $action): ?bool\n    {\n        $ret = parent::onRequest($action);\n        if ($ret === false) {\n            return false;\n        }\n        $v = $this-&gt;validateRule($action);\n        if ($v) {\n            $ret = $this-&gt;validate($v);\n            if ($ret == false) {\n                $this-&gt;writeJson(Status::CODE_BAD_REQUEST, null, \"{$v-&gt;getError()-&gt;getField()}@{$v-&gt;getError()-&gt;getFieldAlias()}:{$v-&gt;getError()-&gt;getErrorRuleMsg()}\");\n                return false;\n            }\n        }\n        return true;\n    }\n\n    protected function validateRule(?string $action): ?Validate\n    {\n\n    }\n}\n然后在需要验证的控制器方法中，我们给对应的 action 添加对应的校验规则，即可实现自动校验，这样控制器方法就只需要关注实现逻辑。示例代码如下：\n&lt;?php\nnamespace App\\HttpController;\n\nuse App\\HttpController\\Api\\BaseController;\nuse EasySwoole\\Validate\\Validate;\n\nclass Common extends BaseController\n{\n\n    function sms()\n    {\n        $phone = $this-&gt;request()-&gt;getRequestParam('phone');\n    }\n\n    protected function validateRule(?string $action): ?Validate\n    {\n        $v = new Validate();\n        switch ($action) {\n            case 'sms':\n                {\n                    $v-&gt;addColumn('phone', '手机号')-&gt;required('不能为空')-&gt;length(11, '长度错误');\n                    $v-&gt;addColumn('verifyCode', '验证码')-&gt;required('不能为空')-&gt;length(4, '长度错误');\n                    break;\n                }\n        }\n        return $v;\n    }\n}\n然后访问 http://ip:9501/common/sms(示例请求地址) 就可以得到参数校验的结果：{\"code\":400,\"result\":null,\"msg\":\"phone@手机号:不能为空\"}\n方法列表\n获取验证错误相关信息(getError())\n用于获取验证错误(Error)的相关信息（验证字段名称、验证字段别名、验证错误信息）。\n函数原型\nfunction getError(): ?\\EasySwoole\\Validate\\Error\n具体使用示例：\n&lt;?php\nrequire_once __DIR__ . \"/vendor/autoload.php\";\n$data1 = [\n    'age' =&gt; 18,\n]; // 要验证的数据\n$validate1 = new \\EasySwoole\\Validate\\Validate();\n$validate1-&gt;addColumn('name', '名字')-&gt;required('参数不能缺少!'); // 给字段加上验证规则(验证数据中 name 字段不能没有)\n$bool = $validate1-&gt;validate($data1);\nif ($bool) {\n    var_dump(\"验证通过\");\n} else {\n    // 获取验证错误字段的别名\n    $fieldAliasName = $validate1-&gt;getError()-&gt;getFieldAlias(); // 获取验证规则中设置的字段别名 '名字'\n\n    // 获取验证错误字段的名称\n    $fieldName = $validate1-&gt;getError()-&gt;getField(); // 获取验证规则中设置的字段名称 'name'\n\n    // 获取验证错误信息\n    $errorMsg = $validate1-&gt;getError()-&gt;__toString(); // 获取验证错误信息 '参数不能缺少!'\n\n    var_dump($fieldName . '@' . $fieldAliasName . $errorMsg);\n}\n/**\n * 输出结果：\n * string(30) \"name@名字参数不能缺少!\"\n */\n\n给字段添加验证规则(addColumn())\n用于给字段添加验证规则。\n函数原型\n\n组件 1.1.9 版本到目前：\n\npublic function addColumn(string $name, ?string $alias = null, bool $reset = false): \\EasySwoole\\Validate\\Rule\n\nstring $name   字段 key\nstring $alias  字段别名\nbool $reset    重置规则\n\n针对 1.1.8 之前版本的函数参数说明如下：\n\n1.1.0 版本到 1.1.8 版本\n\npublic function addColumn(string $name, ?string $alias = null): \\EasySwoole\\Validate\\Rule\n\nstring $name  字段 key\nstring $alias 字段别名\n\n\n1.0.1 版本\n\npublic function addColumn(string $name,?string $errorMsg = null,?string $alias = null): \\EasySwoole\\Validate\\Rule\n\nstring $name     字段 key\nstring $errorMsg 验证错误提示信息\nstring $alias    别名\n\n\n1.0.0 版本\n\npublic function addColumn(string $name,?string $alias = null,?string $errorMsg = null):EasySwoole\\Validate\\Rule\n\nstring $name     字段 key\nstring $alias    别名\nstring $errorMsg 错误信息\n\n返回一个 Rule 对象可以添加自定义规则。\n验证数据是否合法(validate())\n用于验证数据是否合法。\n函数原型：\nfunction validate(array $data)\n验证规则用法说明\n以下验证规则中，不设置验证错误时提示消息时，则默认使用组件提供的默认的错误提示信息。\nactiveUrl\n验证 url 是否可以通讯\n函数原型\nfunction activeUrl($msg = null)\n\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'url' =&gt; 'https://www.easyswoole.com/'\n];\n$validate-&gt;addColumn('url')-&gt;activeUrl();\n$bool = $validate-&gt;validate($data);\nalpha\n验证给定的参数值是否是字母 即 [a-zA-Z]\n函数原型\nfunction alpha($msg = null)\n\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 'easyswoole'\n];\n$validate-&gt;addColumn('param')-&gt;alpha();\n$bool = $validate-&gt;validate($data);\nallDigital\n验证给定的参数中字符串是否由数字构成\n函数原型\nfunction allDigital($msg = null)\n\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2022\n];\n$validate-&gt;addColumn('param')-&gt;allDigital();\n$bool = $validate-&gt;validate($data);\nallowFile\n验证给定参数中的文件的 文件扩展名 是否是在允许的文件扩展名范围数组内\n函数原型\nfunction allowFile(array $type, $isStrict = false, $msg = null)\n\narray $type    允许的文件扩展名范围数组\nbool $isStrict 是否使用严格等于，默认不使用\nstring $msg    验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'file' =&gt; $this-&gt;request()-&gt;getUploadedFile('file')\n];\n$validate-&gt;addColumn('file')-&gt;allowFile(['png','jpg']);\n$bool = $validate-&gt;validate($data);\nallowFileType\n验证给定的参数中的文件的 文件类型 是否是在允许的文件类型范围数组\n函数原型\nfunction allowFileType(array $type, $isStrict = false, $msg = null)\n\narray $type    允许的文件类型范围数组\nbool $isStrict 是否使用严格等于，默认不使用\nstring $msg    验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'file' =&gt; $this-&gt;request()-&gt;getUploadedFile('file')\n];\n$validate-&gt;addColumn('param')-&gt;allowFileType(['image/png','image/jpeg']);\n$bool = $validate-&gt;validate($data);\nalphaNum\n验证给定的参数值是否是由字母或数字组成 即 [a-zA-Z0-9]\n函数原型\nfunction alphaNum($msg = null)\n\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 'easyswoole2020'\n];\n$validate-&gt;addColumn('param')-&gt;alphaNum();\n$bool = $validate-&gt;validate($data);\nalphaDash\n验证给定的参数值是否是由字母、数字、下划线或破折号组成 即[a-zA-Z0-9-_]\n函数原型\nfunction alphaDash($msg = null)\n\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 'easyswoole_2020'\n];\n$validate-&gt;addColumn('param')-&gt;alphaDash();\n$bool = $validate-&gt;validate($data);\nbetween\n验证给定的参数值是否在 $min - $max 之间\n函数原型\nfunction between($min, $max, $msg = null)\n\ninteger $min 最小值 包含该值\ninteger $max 最小值 包含该值\nstring $msg  验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; '2020'\n];\n$validate-&gt;addColumn('param')-&gt;between(2016, 2020);\n$bool = $validate-&gt;validate($data);\nbool\n验证给定的参数值是否为布尔值(1/0/true/false)\n函数原型\nfunction bool($msg = null)\n\nstring $msg  验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 1\n];\n$validate-&gt;addColumn('param')-&gt;bool();\n$bool = $validate-&gt;validate($data);\ncallUserRule\n调用自定义验证规则验证数据\n函数原型\nfunction callUserRule(\\EasySwoole\\Validate\\ValidateInterface $rule, $msg = null, ...$args)\n\n\\EasySwoole\\Validate\\ValidateInterface $rule 实现了 \\EasySwoole\\Validate\\ValidateInterface 接口的自定义验证规则类\nstring $msg  验证错误时提示消息\nmixed $args  可选参数\n\n使用示例\n先定义一个自定义验证规则类 CustomValidator 并且实现 \\EasySwoole\\Validate\\ValidateInterface 接口，具体实现代码如下：\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: easyswoole\n * Date: 2021/1/13\n * Time: 23:48\n */\nnamespace App\\Utility;\nuse EasySwoole\\Spl\\SplArray;\nuse EasySwoole\\Validate\\ValidateInterface;\n\nclass CustomValidator implements ValidateInterface\n{\n    /**\n     * 返回当前校验规则的名字\n     * @return string\n     */\n    public function name(): string\n    {\n        return 'mobile';\n    }\n\n    /**\n     * 检验失败返回错误信息即可\n     * @param SplArray $spl\n     * @param $column\n     * @param mixed ...$args\n     * @return string|null\n     */\n    public function validate(SplArray $spl, $column, ...$args): ?string\n    {\n        $regular = '/^((13[0-9])|(14[5,7,9])|(15[^4])|(18[0-9])|(17[0,1,3,5,6,7,8]))\\\\d{8}$/';\n        if (!preg_match($regular, $spl-&gt;get($column))) {\n            return '手机号验证未通过';\n        }\n        return null;\n    }\n}\n调用自定义验证规则类验证数据，具体实现如下：\n&lt;?php\nrequire_once __DIR__ . \"/vendor/autoload.php\";\n\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'mobile' =&gt; '13312345678_',\n];\n$validate-&gt;addColumn('mobile')-&gt;callUserRule(new \\App\\Utility\\CustomValidator());\n$bool = $validate-&gt;validate($data);\nif ($bool) {\n    var_dump(\"验证通过\");\n} else {\n    // 获取验证错误信息\n    $errorMsg = $validate-&gt;getError()-&gt;__toString();\n    var_dump($errorMsg);\n}\n/**\n * 输出结果：\n * string(24) \"手机号验证未通过\"\n */\ndecimal\n验证给定的参数值是否合格的小数\n函数原型\nfunction decimal(?int $precision = null, $msg = null)\n\ninteger $precision 规定小数点后位数。默认参数为null，表示不规定小数点后位数\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 1.1\n];\n$validate-&gt;addColumn('param')-&gt;decimal();\n$bool = $validate-&gt;validate($data);\ndateBefore\n验证给定参数的日期是否在某日期之前\n函数原型\nfunction dateBefore(?string $date = null, $msg = null)\n\nstring $date 需要对比的日期，默认验证日期是否在当天之前\nstring $msg  验证错误时提示消息\n\n使用示例\n// 验证 param 参数日期是否在当天日期之前\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; '2020-06-28'\n];\n$validate-&gt;addColumn('param')-&gt;dateBefore('2021-01-14');\n$bool = $validate-&gt;validate($data);\n\n// 验证 param 参数日期是否在 2021-01-14 之前\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; '2020-06-28'\n];\n$validate-&gt;addColumn('param')-&gt;dateBefore('2021-01-14');\n$bool = $validate-&gt;validate($data);\ndateAfter\n验证给定参数的日期是否在某日期之后\n函数原型\nfunction dateAfter(?string $date = null, $msg = null)\n\nstring $date 需要对比的日期，默认验证日期是否在当天之后\nstring $msg  验证错误时提示消息\n\n使用示例\n// 验证 param 参数日期是否在当天日期之后\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; '2020-06-28'\n];\n$validate-&gt;addColumn('param')-&gt;dateAfter('2021-01-14');\n$bool = $validate-&gt;validate($data);\n\n// 验证 param 参数日期是否在 2021-01-14 之后\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; '2021-06-28'\n];\n$validate-&gt;addColumn('param')-&gt;dateAfter('2021-01-14');\n$bool = $validate-&gt;validate($data);\nequal\n验证给定参数的值与某个值是否相等\n函数原型\nfunction equal($compare, bool $strict = false, $msg = null)\n\nmixed $compare 要判断的某个值\nbool $strict   是否使用严格等于，默认不使用\nstring $msg    验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2020\n];\n$validate-&gt;addColumn('param')-&gt;equal(2020);\n$bool = $validate-&gt;validate($data);\ndifferent\n验证给定参数的值与某个值是否不相等\n函数原型\nfunction different($compare, bool $strict = false, $msg = null)\n\nmixed $compare 要判断的某个值\nbool $strict   是否使用严格等于，默认不使用\nstring $msg    验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2020\n];\n$validate-&gt;addColumn('param')-&gt;different(2021);\n$bool = $validate-&gt;validate($data);\nequalWithColumn\n验证给定参数中的值与给定参数中的某列值是否相等\n函数原型\nfunction equalWithColumn($fieldName, bool $strict = false, $msg = null)\n\nstring $fieldName 给定参数中的某列的字段名\nbool $strict      是否使用严格等于，默认不使用\nstring $msg       验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2020,\n    'test'  =&gt; 2020\n];\n$validate-&gt;addColumn('param')-&gt;equalWithColumn('test');\n$bool = $validate-&gt;validate($data);\ndifferentWithColumn\n验证给定参数中的值与给定参数中的某列值是否不相等\n函数原型\nfunction differentWithColumn($fieldName, bool $strict = false, $msg = null)\n\nstring $fieldName 给定参数中的某列的字段名\nbool $strict      是否使用严格等于，默认不使用\nstring $msg       验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2020,\n    'test'  =&gt; 2021\n];\n$validate-&gt;addColumn('param')-&gt;differentWithColumn('test');\n$bool = $validate-&gt;validate($data);\nfloat\n验证给定参数中的值是否是一个浮点数\n函数原型\nfunction float($msg = null)\n\nstring $msg       验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2020.1\n];\n$validate-&gt;addColumn('param')-&gt;float();\n$bool = $validate-&gt;validate($data);\nfunc\n调用自定义的闭包验证数据，闭包中返回 false 视为验证失败，返回 true 视为验证通过。\n函数原型\nfunction func(callable $func, $msg = null)\n\ncallable $func 自定义闭包类型\nstring $msg    验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$validate-&gt;addColumn('username')-&gt;func(function ($data, $name) {\n    var_dump($data); // 待验证的数据 ['username' =&gt; 'admin']\n    var_dump($name); // 验证规则中设置的字段名称 'username'\n    return false; // 视为验证失败\n}, '用户不存在');\n\n$bool = $validate-&gt;validate(['username' =&gt; 'admin']);\nisArray\n验证给定参数中的值是否是一个数组\n函数原型\nfunction isArray($msg = null)\n\nstring $msg  验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; ['hi', 'easyswoole']    \n];\n$validate-&gt;addColumn('param')-&gt;isArray();\n$bool = $validate-&gt;validate($data);\ninArray\n验证给定参数中的值是否在数组中\n函数原型\nfunction inArray(array $array, $isStrict = false, $msg = null)\n\narray $array 允许的范围数组\nbool $strict 值是否使用严格等于，默认不使用\nstring $msg  验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2020\n];\n$validate-&gt;addColumn('param')-&gt;inArray([2020, 2021]);\n$bool = $validate-&gt;validate($data);\ninteger\n验证给定参数中的值是否是一个整数值\n函数原型\nfunction integer($msg = null)\n\nstring $msg  验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2020\n];\n$validate-&gt;addColumn('param')-&gt;integer();\n$bool = $validate-&gt;validate($data);\nisIp\n验证给定参数中的值是否一个有效的IP\n函数原型\nfunction isIp($msg = null)\n\nstring $msg  验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'ip' =&gt; '127.0.0.1'\n];\n$validate-&gt;addColumn('ip')-&gt;isIp();\n$bool = $validate-&gt;validate($data);\nnotEmpty\n验证给定参数中的值是否不为空(注意和 require() 规则区分开，require() 规则要求是必须存在于给定参数中，详细看下面 require() 规则的介绍)。除了 0/'0'/empty($value)为假 这些值被验证为不为空(验证通过)，其他都被验证为空(验证错误)。 \n函数原型\nfunction notEmpty($msg = null)\n\nstring $msg  验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; ''\n];\n$validate-&gt;addColumn('param')-&gt;notEmpty();\n$bool = $validate-&gt;validate($data);\nnumeric\n验证给定参数中的值是否是一个数字值\n函数原型\nfunction numeric($msg = null)\n\nstring $msg  验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2020\n];\n$validate-&gt;addColumn('param')-&gt;numeric();\n$bool = $validate-&gt;validate($data);\nnotInArray\n验证给定参数中的值是否不在数组中\n函数原型\nfunction notInArray(array $array, $isStrict = false, $msg = null)\n\narray $array 值不允许出现的范围数组\nbool $strict 值是否使用严格等于，默认不使用\nstring $msg  验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2022\n];\n$validate-&gt;addColumn('param')-&gt;notInArray([2020, 2021]);\n$bool = $validate-&gt;validate($data);\nlength\n验证给定参数中的 数组 或 字符串 或者 文件 的大小是否与规定的大小值一致\n函数原型\nfunction length(int $len, $msg = null)\n\nint $len    规定的长度大小值\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'string' =&gt; 2022,\n    'array'  =&gt; [0, 1, 2],\n    'file'   =&gt; $this-&gt;request()-&gt;getUploadedFile('file')\n];\n$validate-&gt;addColumn('string')-&gt;length(4);\n$validate-&gt;addColumn('array')-&gt;length(3);\n$validate-&gt;addColumn('file')-&gt;length(4); // 此处 length 为文件的 size\n$bool = $validate-&gt;validate($data);\nlengthMax\n验证给定参数中的 数组 或 字符串 或者 文件 的大小是否 超出 规定的大小值，最大不能超过这个值。\n函数原型\nfunction lengthMax(int $lengthMax, $msg = null)\n\nint $lengthMax 规定的最大长度大小值\nstring $msg    验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'string' =&gt; 2022,\n    'array'  =&gt; [0, 1, 2],\n    'file'   =&gt; $this-&gt;request()-&gt;getUploadedFile('file')\n];\n$validate-&gt;addColumn('string')-&gt;lengthMax(4);\n$validate-&gt;addColumn('array')-&gt;lengthMax(3);\n$validate-&gt;addColumn('file')-&gt;lengthMax(4); // 此处 length 为文件的 size\n$bool = $validate-&gt;validate($data);\nlengthMin\n验证给定参数中的 数组 或 字符串 或者 文件 的大小是否 达到 规定的最小长度大小值，最小也不能低于这个值。\n函数原型\nfunction lengthMin(int $lengthMin, $msg = null)\n\nint $lengthMax 规定的最小长度大小值\nstring $msg    验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'string' =&gt; 2022,\n    'array'  =&gt; [0, 1, 2],\n    'file'   =&gt; $this-&gt;request()-&gt;getUploadedFile('file')\n];\n$validate-&gt;addColumn('string')-&gt;lengthMin(4);\n$validate-&gt;addColumn('array')-&gt;lengthMin(3);\n$validate-&gt;addColumn('file')-&gt;lengthMin(4); // 此处 length 为文件的 size\n$bool = $validate-&gt;validate($data);\nbetweenLen\n验证给定参数中的 数组 或 字符串 或者 文件 的大小是否在一个区间内\n函数原型\nfunction betweenLen(int $min, int $max, $msg = null)\n\nint $min    最小值 包含该值\nint $max    最大值 包含该值\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'string' =&gt; 2022,\n    'array'  =&gt; [0, 1, 2],\n    'file'   =&gt; $this-&gt;request()-&gt;getUploadedFile('file')\n];\n$validate-&gt;addColumn('string')-&gt;betweenLen(1, 4);\n$validate-&gt;addColumn('array')-&gt;betweenLen(1, 4);\n$validate-&gt;addColumn('file')-&gt;betweenLen(1, 4); // 此处length为文件的size\n$bool = $validate-&gt;validate($data);\nmax\n验证给定参数中的值 不大于 某个值(相等视为通过)\n函数原型\nmax(int $max, ?string $msg = null): Rule\n\nint $max    需要对比的某个值\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2022\n];\n$validate-&gt;addColumn('param')-&gt;max(2022);\n$bool = $validate-&gt;validate($data);\nmin\n验证给定参数中的值 不小于 某个值(相等视为通过)\n函数原型\nfunction min(int $min, ?string $msg = null): Rule\n\nint $min    需要对比的某个值\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2022\n];\n$validate-&gt;addColumn('param')-&gt;min(2022);\n$bool = $validate-&gt;validate($data);\nmoney\n验证给定参数中的值是否一个合法的金额\n函数原型\nfunction money(?int $precision = null, string $msg = null): Rule\n\nint $precision 规定小数点后的位数，默认不规定\nstring $msg    验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 2022.22\n];\n$validate-&gt;addColumn('param')-&gt;money();\n$bool = $validate-&gt;validate($data);\nregex\n验证给定参数中的值是否匹配某个正则表达式\n函数原型\nfunction regex($reg, $msg = null)\n\nstring $reg 需要匹配的正则表达式\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 'easyswoole'\n];\n$validate-&gt;addColumn('param')-&gt;regex('/^[a-zA-Z]+$/');\n$bool = $validate-&gt;validate($data);\nrequired\n验证给定参数中的某字段必须存在，不存在则视为不通过。可用于检测请求参数中是否存在某个字段。与 PHP 中的 isset 判断规则一致。(注意和上面的 notEmpty() 规则区分开)\n函数原型\nfunction required($msg = null)\n\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n];\n$validate-&gt;addColumn('param')-&gt;required();\n$bool = $validate-&gt;validate($data);\noptional\n验证给定参数中的某字段是可选字段，不用必须存在，和上面的 required() 验证规则刚好相反。\n函数原型\nfunction optional()\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n];\n$validate-&gt;addColumn('param')-&gt;optional();\n$bool = $validate-&gt;validate($data);\ntimestamp\n验证给定参数中的时间戳是否是一个合法的时间戳\n函数原型\nfunction timestamp($msg = null)\n\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 1593315393\n];\n$validate-&gt;addColumn('param')-&gt;timestamp();\n$bool = $validate-&gt;validate($data);\ntimestampBeforeDate\n验证给定参数中的时间戳是否是在某个指定日期之前\n函数原型\nfunction timestampBeforeDate($date, $msg = null)\n\nstring $date 需要对比的日期\nstring $msg  验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 1593315393\n];\n$validate-&gt;addColumn('param')-&gt;timestampBeforeDate('2020-06-29');\n$bool = $validate-&gt;validate($data);\ntimestampBeforeDate\n验证给定参数中的时间戳是否是在某个指定日期之后\n函数原型\nfunction timestampAfterDate($date, $msg = null)\n\nstring $date 需要对比的日期\nstring $msg  验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 1593315393\n];\n$validate-&gt;addColumn('param')-&gt;timestampAfterDate('2020-06-27');\n$bool = $validate-&gt;validate($data);\ntimestampBefore\n验证给定参数中的时间戳是否是在某个时间戳之前\n函数原型\nfunction timestampBefore($beforeTimestamp, $msg = null)\n\nstring|integer $beforeTimestamp 需要对比的时间戳\nstring $msg                     验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 1593315393\n];\n$validate-&gt;addColumn('param')-&gt;timestampBefore(1593315394);\n$bool = $validate-&gt;validate($data);\ntimestampAfter\n验证给定参数中的时间戳是否是在某个时间戳之后\n函数原型\nfunction timestampAfter($afterTimestamp, $msg = null)\n\nstring|integer $afterTimestamp 需要对比的时间戳\nstring $msg                     验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'param' =&gt; 1593315393\n];\n$validate-&gt;addColumn('param')-&gt;timestampAfter(1593315392);\n$bool = $validate-&gt;validate($data);\nurl\n验证给定参数中的值是一个合法的链接\n函数原型\nfunction url($msg = null)\n\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'url' =&gt; 'https://www.easyswoole.com/'\n];\n$validate-&gt;addColumn('param')-&gt;url();\n$bool = $validate-&gt;validate($data);\nlessThanWithColumn\n验证字段的值必须小于with的字段(仅限int)\n函数原型\nfunction lessThanWithColumn($fieldName, $msg = null)\n\nstring $filedName 需要比较的字段\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'foo' =&gt; 10,\n    'bar' =&gt; 9\n];\n$validate-&gt;addColumn('bar')-&gt;lessThanWithColumn('foo');\n$bool = $validate-&gt;validate($data);\ngreaterThanWithColumn\n验证字段的值必须大于with的字段(仅限int)\n函数原型\nfunction greaterThanWithColumn($fieldName, $msg = null)\n\nstring $filedName 需要比较的字段\nstring $msg 验证错误时提示消息\n\n使用示例\n$validate = new \\EasySwoole\\Validate\\Validate();\n$data = [\n    'foo' =&gt; 10,\n    'bar' =&gt; 9\n];\n$validate-&gt;addColumn('foo')-&gt;greaterThanWithColumn('bar');\n$bool = $validate-&gt;validate($data);","link":"/Components/validate.html"},{"id":79,"title":"文件上传","content":"UploadFile对象\n基于Psr规范封装的UploadFile。\n在控制器内获取上传的文件：\n&lt;?php\n$request=  $this-&gt;request();\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file = $request-&gt;getUploadedFile('file');//获取一个上传文件,返回的是一个\\EasySwoole\\Http\\Message\\UploadFile的对象\n$files = $request-&gt;getUploadedFiles();\n获取临时文件名\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;getTempName();\n获取Stream\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;getStream();\n移动到指定位置\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;moveTo('/xxx/xxx/xxx.png'); // 失败这里会抛出异常 \\EasySwoole\\Http\\Exception\\FileException\n获取文件大小\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;getSize();\n获取错误码\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;getError();\n获取客户端文件名\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;getClientFilename();\n获取文件类型\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;getClientMediaType();","link":"/HttpServer/uploadFile.html"},{"id":80,"title":"全局变量","content":"全局变量\n在swoole协程当中，我们都知道类似$_GET,$_SESSION,这样的全局变量是不能安全使用的。原因是协程切换下会带来数据污染问题。\n惊喜\nEasyswoole在spl包中，实现了一个SplContextArray,并在主进程的位置，替换了这些全局变量，使得，这些数据的访问是安全的，并在请求结束后自动清理。从而我们可以尽可能的去使用一些FPM包\n注册\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\GlobalParamHook;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\Session\\SessionFileHandler;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        $handler = new SessionFileHandler(EASYSWOOLE_TEMP_DIR);\n        GlobalParamHook::getInstance()-&gt;hookDefault();\n        //如果不需要session请勿注册\n        GlobalParamHook::getInstance()-&gt;hookSession($handler,'easy_session','session_dir');\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        GlobalParamHook::getInstance()-&gt;onRequest($request,$response);\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        // TODO: Implement afterAction() method.\n    }\n}\n\n事件注册完毕后，即可使用$_GET,$_SESSION,$_POST,$_COOKIE\n\n使用\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    function index()\n    {\n        var_dump($_GET['a']);\n        if(isset($_SESSION['b'])){\n            var_dump('last session is '.$_SESSION['b']);\n        }\n        $_SESSION['b'] = time();\n    }\n}\n注意\n该特性需要1.6版本以上的http组件库\n\"easyswoole/http\": \"^1.6\"","link":"/HttpServer/global.html"},{"id":81,"title":"i18n多语言","content":"i18n\nI18N国际多语言，允许让您的项目支持多种语言\n组件要求\n\neasyswoole/component: ^2.2\n\n安装方法\n\ncomposer require easyswoole/i18n\n\n仓库地址\neasyswoole/i18n\n基本使用\nuse EasySwoole\\I18N\\AbstractDictionary;\nuse EasySwoole\\I18N\\I18N;\n//定义一个词典。const值请务必于const变量名一致，这样是避免用户手敲词条名称出错\nclass Dictionary extends AbstractDictionary\n{\n    const HELLO = 'HELLO';\n    const GOOD_MORNING = 'GOOD_MORNING';\n    const HOME = 'HOME';\n\n}\n//定义一个语言包  \nclass Chinese extends Dictionary{\n    const HELLO = '你好';\n    const HOME = '主页';\n}\n//定义一个语言包  \nclass English extends Dictionary\n{\n    const HELLO = 'hello';\n    const GOOD_MORNING = 'Hi,good morning';\n    const HOME = 'home page';\n}\n//注册语言包\nI18N::getInstance()-&gt;addLanguage(new Chinese(),'Cn');\nI18N::getInstance()-&gt;addLanguage(new English(),'En');\n//设置默认语言包\nI18N::getInstance()-&gt;setDefaultLanguage('Cn');\n//使用\n$ret = I18N::getInstance()-&gt;translate(Dictionary::HELLO);\nvar_dump($ret);//你好\n$ret = I18N::getInstance()-&gt;translate(Dictionary::GOOD_MORNING);\nvar_dump($ret);//GOOD_MORNING\n$ret = I18N::getInstance()-&gt;sprintf('%s ! 欢迎到 %s !!!!',Dictionary::HELLO,Dictionary::HOME);\nvar_dump($ret);//\"你好 ! 欢迎到 主页 !!!!\n//setLanguage 仅仅会影响当前协程的语言\n$ret = I18N::getInstance()-&gt;setLanguage('En')-&gt;translate(Dictionary::GOOD_MORNING);\nvar_dump($ret);//Hi,good morning\n\n提示\n\n可以在Easyswoole的初始化事件中做好语言包的注册和默认语言的注册。\n可以在全局的onRequest，根据header或者是其他参数，调用setLanguage方法修改当次请求的语言\n","link":"/Components/i18n.html"},{"id":82,"title":"常见问题","content":"常见问题\n如何处理静态资源\nApache URl rewrite\n&lt;IfModule mod_rewrite.c&gt;\n  Options +FollowSymlinks\n  RewriteEngine On\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteCond %{REQUEST_FILENAME} !-f\n  #RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]  fcgi下无效\n  RewriteRule ^(.*)$  http://127.0.0.1:9501/$1 [QSA,P,L]\n   #请开启 proxy_mod proxy_http_mod request_mod\n&lt;/IfModule&gt;\nNginx URl rewrite\nserver {\n    root /data/wwwroot/;\n    server_name local.swoole.com;\n    location / {\n        proxy_http_version 1.1;\n        proxy_set_header Connection \"keep-alive\";\n        proxy_set_header X-Real-IP $remote_addr;\n        if (!-f $request_filename) {\n             proxy_pass http://127.0.0.1:9501;\n        }\n    }\n}\nSwoole静态文件处理器\n[       \n    'document_root' =&gt; EASYSWOOLE_ROOT.'/Static/',\n    'enable_static_handler' =&gt; true,\n]\n\n假设你的项目根目录有个Static目录是用来放置静态文件的。\n\n关于跨域处理\n在initialize中注册.\n// onRequest v3.4.x+\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST,function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response){\n    $response-&gt;withHeader('Access-Control-Allow-Origin', '*');\n    $response-&gt;withHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n    $response-&gt;withHeader('Access-Control-Allow-Credentials', 'true');\n    $response-&gt;withHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');\n    if ($request-&gt;getMethod() === 'OPTIONS') {\n        $response-&gt;withStatus(\\EasySwoole\\Http\\Message\\Status::CODE_OK);\n        return false;\n    }\n    return true;\n});\n3.4.x版本之前：可在EasySwooleEvent中看到onRequest及afterRequest方法.\n如何获取$HTTP_RAW_POST_DATA\n$content = $this-&gt;request()-&gt;getBody()-&gt;__toString();\n$raw_array = json_decode($content, true);\n如何获取客户端IP\n举例，如何在控制器中获取客户端IP\n//真实地址\n$ip = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer()-&gt;connection_info($this-&gt;request()-&gt;getSwooleRequest()-&gt;fd);\nvar_dump($ip);\n//header 地址，例如经过nginx proxy后\n$ip2 = $this-&gt;request()-&gt;getHeaders();\nvar_dump($ip2);\nHTTP 状态码总为500\n自 swoole 1.10.x 和 2.1.x 版本起，执行http server回调中，若未执行response-&gt;end(),则全部返回500状态码\n如何setCookie\n调用response对象的setCookie方法即可设置cookie\n  $this-&gt;response()-&gt;setCookie('name','value');\n更多操作可看Response对象\n如何自定义App名称\n只需要修改composer.json的命名空间注册就行\n    \"autoload\": {\n        \"psr-4\": {\n            \"App\\\\\": \"Application/\"\n        }\n    }\n如何启用Https\n通常建议使用Nginx 或者Lb来配置证书，将https请求解析为http 反代到swoole\n如果你仅测试使用，可以在配置文件中添加和修改以下配置来启用https\n'MAIN_SERVER' =&gt; [\n        'SOCK_TYPE' =&gt; SWOOLE_TCP | SWOOLE_SSL, // 默认是 SWOOLE_TCP\n        'SETTING' =&gt; [\n            'ssl_cert_file' =&gt; '证书路径，仅支持.pem格式',\n            'ssl_key_file' =&gt; '私钥路径',\n        ]\n    ],\n\nDNS Lookup resolve timeout错误\n该错误一般存在与 http客户端并发时产生,原因是dns效率慢,导致多线程获取dns时超时,包括不限于以下场景:  \n\nmysql host设置为域名形式,并且设置最小连接高于2(很难看到,一般是10才会偶尔报错)\nHTTPClient 多个协程同时并发\ncsp并发编程\n等  \n解决方法为:\n在并发之前,预先使用Swoole\\Coroutine::gethostbyname('www.baidu.com'); 去查询一次dns ip,swoole底层才会自动缓存该ip\n\n\n例如:\n    Swoole\\Coroutine::gethostbyname('www.baidu.com');\n    for ($j = 0; $j &lt; 100; $j++) {\n        go(function () use ($j) {\n            for ($i = 0; $i &lt; 1000; $i++) {\n                $client = new Swoole\\Coroutine\\Http\\Client('www.baidu.com',443,true);\n                $client-&gt;get('/');\n                if (empty($client-&gt;errMsg)){\n//var_dump($client-&gt;getBody());\n                }else{\n                    var_dump($client-&gt;errMsg);\n                }\n            }\n        });\n    }","link":"/HttpServer/problem.html"},{"id":83,"title":"安装","content":"安装\ncomposer require easyswoole/http-annotation\n实现原理\n注解控制器，完整命名空间为EasySwoole\\HttpAnnotation\\AnnotationController，是继承自\nuse EasySwoole\\Http\\AbstractInterface\\Controller的子类。它重写了父类的__construct和__exec方法，从而实现的注解支持。\n__construct\n在构造方法中。默认实例化了自带的注解解析器EasySwoole\\HttpAnnotation\\Annotation\\Parser，并解析了当前class的注解标签。\n__exec\n该方法是承接Dispatcher与控制器实体逻辑的桥梁。在该方法中，注解控制器做了以下事情\n\n检查并执行成员变量注解逻辑\n检查onRequest函数注解参数并执行注解参数逻辑校验\n检查目的action所注解标签并进行参数校验与逻辑校验\n\n基础例子\nnamespace App\\HttpController;\n\nuse EasySwoole\\EasySwoole\\Trigger;\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Param;\nuse EasySwoole\\HttpAnnotation\\Exception\\Annotation\\ParamValidateError;\n\nclass Index extends AnnotationController\n{\n    /**\n     * @Param(name=\"name\",required=\"\")\n     * @Param(name=\"age\",integer=\"\")\n     */\n    function index()\n    {\n        $data = $this-&gt;request()-&gt;getRequestParam();\n        $this-&gt;response()-&gt;write(\"your name is {$data['name']} and age {$data['age']}\");\n    }\n\n    function onException(\\Throwable $throwable): void\n    {\n        if($throwable instanceof ParamValidateError){\n            $this-&gt;response()-&gt;withHeader('Content-type','text/html;charset=utf-8');\n            $this-&gt;response()-&gt;write(\"字段【{$throwable-&gt;getValidate()-&gt;getError()-&gt;getField()}】校验错误\");\n        }else{\n            Trigger::getInstance()-&gt;throwable($throwable);\n        }\n    }\n}\n在以上代码中，会自动对name和age字段进行校验，当校验失败时，抛出一个异常，校验成功则进入action逻辑。具体请看参数注解章节。","link":"/HttpServer/Annotation/install.html"},{"id":84,"title":"参数注解","content":"参数注解校验\nEasyswoole控制器总共有三个参数注解标签，分别是\n\n@Param EasySwoole\\HttpAnnotation\\AnnotationTag\\Param\n\n@ApiAuth EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiAuth\n\n@ApiGroupAuth EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupAuth\n\n\n其中，ApiAuth与ApiGroupAuth均继承自Param，对于任意一个参数注解，都要求填写注解的name字段。Param对象实际上是对Easyswoole/Validate参数验证组件验证规则的封装，底层是调用该组件进行参数校验。当校验失败的时候，则会抛出一个EasySwoole\\HttpAnnotation\\Exception\\Annotation\\ParamValidateError异常，可以在控制器的onExcepion中进行处理。\n@Param\n基础参数注解，作用域在控制器的actionMethod与onRequest均为有效。例如在以下代码中：\n/**\n* @Param(name=\"name\",required=\"\",lengthMax=\"25\")\n* @Param(name=\"age\",integer=\"\")\n*/\nfunction index()\n{\n    $data = $this-&gt;request()-&gt;getRequestParam();\n    $this-&gt;response()-&gt;write(\"your name is {$data['name']} and age {$data['age']}\");\n}\n那么则规定了index这个action需要name与age这两个参数，且校验规则分别为required=\"\",lengthMax=\"25\"与integer=\"\"\n参数的接收\n在控制器的Request对象中得到的参数值，为客户端提交的原始值，参数的注解校验或者预处理，并不会影响原始值。但是通过控制器自动传参或者是上下文注解标签得到的参数，则为经过预处理后的参数。\n自动传参\n/**\n* @Param(name=\"name\",required=\"\",lengthMax=\"25\",from={GET,POST})\n* @Param(name=\"age\",type=\"int\")\n*/\nfunction index($age,$name)\n{\n   $data = $this-&gt;request()-&gt;getRequestParam();\n   $this-&gt;response()-&gt;write(\"your name is {$name} and age {$age}\");\n}\n当某个action定义了参数，且有注解的时候，那么控制器会利用反射机制，根据函数定义的参数名，去取对应的参数。\n注解传参数\n/**\n* @Param(name=\"name\",required=\"\",lengthMax=\"25\",from={GET,POST})\n* @Param(name=\"age\",type=\"int\")\n* @InjectParamsContext(key=\"data\")\n*/\nfunction index()\n{\n    $data = ContextManager::getInstance()-&gt;get('data');\n    $this-&gt;response()-&gt;write(\"your name is {$data['name']} and age {$data['age']}\");\n}\n通过@InjectParamsContext标签，完整命名空间是EasySwoole\\HttpAnnotation\\AnnotationTag\\InjectParamsContext，我们可以把通过验证的参数，设置到指定的协成上下文中，并通过上下文管理器EasySwoole\\Component\\Context\\ContextManager得到对应的参数。其中，除了必填的key字段，还有如下几个字段：\n\n\nonlyParamTag\n忽略@ApiAuth与@ApiGroupAuth定义的参数\n\n\nfilterNull\n忽略值为null的参数\n\n\nfilterEmpty\n忽略值被empty()判定为true的参数，注意数字0或者是字符串0与空字符串等问题\n\n\n附加字段\n@Param注解除了name字段为必填项，还有以下几个辅助字段。\nfrom\n例如在以下注解中：\n* @Param(name=\"name\",required=\"\",lengthMax=\"25\",from={GET,POST})\n* @Param(name=\"age\",integer=\"\",from={POST})\n则规定了name字段允许的取参顺序为：GET =&gt; POST，而age参数就仅仅允许为GET传参。目前from的允许值为：\nPOST，GET，COOKIE,HEADER,FILE,DI,CONTEXT,RAW。在无规定from字段时，默认以$request-&gt;getRequestParam($paramName)方法获得参数值。具体实现可以在EasySwoole\\HttpAnnotation\\AnnotationController的__handleMethodAnnotation方法中查看。\ntype\n例如以下注解中：\n* @Param(name=\"age\",type=\"int\")\n通过函数自动传参，或者是@InjectParamsContext得到的参数时，会对age这个参数进行intval()处理。type字段可选值为：string，int,double,real,float，bool，object，array，具体可以在EasySwoole\\HttpAnnotation\\AnnotationTag\\Param的typeCast方法中查看。\ndefaultValue\n在客户端没有传递该参数的值时，可以用该字段进行默认值的定义。\npreHandler\n该字段是用于对某个参数值不为null时进行预处理。preHandler需要是一个callable，例如\n* @Param(name=\"password\",preHandler=\"md5\")\ndescription\n该字段主要用户自动生成文档时，参数的描述说明。\n则通过函数自动传参，或者是@InjectParamsContext得到的参数时，password会被自动执行md5()\n@ApiAuth\n@ApiAuth注解标签，完整的命名空间是EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiAuth，作用域在控制器的actionMethod与onRequest均为有效，本质与@Param标签并无区别，仅仅是在自动生成文档的时候，@Param被描述为请求参数，而@ApiAuth则会被描述为权限参数。\n控制器全局参数\n全局注解标签是@ApiGroupAuth，完整的命名空间是EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupAuth,作用域在整个控制器。\nnamespace App\\HttpController;\n\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupAuth;\n\n/**\n * Class Index\n * @ApiGroupAuth(name=\"token\",required=\"\")\n * @package App\\HttpController\n */\nclass Index extends AnnotationController\n{\n\n}\n这样的注解表示，Index控制器下的任何请求，都需要token这个参数。\n参数覆盖优先顺序\n@Param &gt; @ApiAuth &gt; @ApiGroupAuth","link":"/HttpServer/Annotation/param.html"},{"id":85,"title":"行为注解","content":"Action注解\n@Api\n\n\nname 注解文档的api标题.\n\npath 路由（可注册到fast-route）\n\nversion api版本号（暂时没用）\n\ndescription api描述（新版本建议使用@ApiDescription）\n\ndeprecated 注解文档标注此api为废弃\n\n@ApiDescription\n\n\nvalue api描述\n\n@Method\n\n\nallow 验证请求方法\n\n注入fast-route\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\AbstractRouter;\nuse EasySwoole\\HttpAnnotation\\Utility\\Scanner;\nuse FastRoute\\RouteCollector;\n\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        $scanner = new Scanner();\n        $scanner-&gt;mappingRouter($routeCollector, EASYSWOOLE_ROOT . '/App/HttpController', 'App\\HttpController');\n    }\n}\n\n这样就可以把@Api注解中的path注入到fast-route,具体用法查看动态路由\n\nexample\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Api;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiDescription;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Method;\n\n/**\n * Class Test\n * @package App\\HttpController\n */\nclass Test extends AnnotationController\n{\n\n    /**\n     * @Api(name=\"test-index\",path=\"/test/index\",version=\"1.0\")\n     * @ApiDescription(\"test-index-action\")\n     */\n    public function index()\n    {\n\n    }\n\n    /**\n     * @Api(name=\"test-deprecated\",path=\"/test/index\",version=\"1.0\",deprecated=true)\n     */\n    public function deprecated()\n    {\n\n    }\n\n    /**\n     * @Api(name=\"test-post\")\n     * @Method(allow={POST,PUT})\n     */\n    public function post(){\n\n    }\n}","link":"/HttpServer/Annotation/action.html"},{"id":86,"title":"成员属性注解","content":"成员属性注解\n我们直接查看以下例子：\nnamespace App\\HttpController;\n\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Context;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Di;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Inject;\n\nclass Test\n{\n    public function __construct($a, $b)\n    {\n    }\n}\n\nclass Index extends AnnotationController\n{\n    /**\n     * @Di(key=\"di\")\n     */\n    public $di;\n    /**\n     * @Context(key=\"context\")\n     */\n    public $context;\n\n    /**\n     * @var \\EasySwoole\\HttpAnnotation\\Tests\\TestController\\Test $inject\n     * @Inject(className=\"\\EasySwoole\\HttpAnnotation\\Tests\\TestController\\Test\", args={1,{1,2}})\n     */\n    public $inject;\n\n}\n@Di\n@Di标签，完整命名空间是EasySwoole\\HttpAnnotation\\AnnotationTag\\Di，用于在每次请求进来的时候，从IOC中取数据，并赋值到对应的属性中，以上等价于:\n$this-&gt;di = EasySwoole\\Component\\Di::getInstance()-&gt;get(di)\n@Context\n@Context标签，完整命名空间是EasySwoole\\HttpAnnotation\\AnnotationTag\\Context，用于在每次请求进来的时候，从上下文管理器中取数据，并赋值到对应的属性中，以上等价于:\n$this-&gt;context = EasySwoole\\Component\\ContextManager::getInstance()-&gt;get(context)\n@Inject\n@Inject标签，完整命令空间是EasySwoole\\HttpAnnotation\\AnnotationTag\\Inject，可注入类并且传入构造函数参数，以上等价于: \nnew className(...$args)","link":"/HttpServer/Annotation/property.html"},{"id":87,"title":"自动注解文档","content":"注解文档\nEasyswoole允许通过注解控制器的注解标签，生成文档。\n控制器输出文档\nnamespace App\\HttpController;\n\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\Utility\\AnnotationDoc;\n\nclass Index extends AnnotationController\n{\n    function index()\n    {\n        $doc = new AnnotationDoc();\n        $string = $doc-&gt;scan2Html(EASYSWOOLE_ROOT.'/App/HttpController');\n        $this-&gt;response()-&gt;withAddedHeader('Content-type',\"text/html;charset=utf-8\");\n        $this-&gt;response()-&gt;write($string);\n    }\n}\n例如在以上的代码中，我们就是直接扫描Easyswoole默认的控制器目录下的全部注解并输出对应文档，用户可以自己去做文档权限控制，或者是对应的目录限制。\n生成离线文档\n在项目根目录下执行如下命令：\nphp vendor/bin/easy-doc App/HttpController\n即可生成对应的离线文档。\n\n注意，仅当有@Api标记的控制器方法才会被渲染到文档中。\n\n注意事项\n有的同学在注解@ApiSuccess中,写入了plainText和jsonArray,会导致注解失败.有以下注意事项:\n执行composer info需保证\neasyswoole/annotation版本&gt;=2.0.3\nplaintText用法为：\nMyAnnotation(myProperty=r\"{\"code\":200}\")\n也就是格式为\nr\"{RAW}\"\n字母r+双引号。\njson Array用法为：\n@PropertyTag(input={\"code\":2,\"result\":[{\"name\":1}]})\n可以直接解析为完整的数组。\n注解示例1\nnamespace App\\HttpController;\n\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Api;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiDescription;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiFail;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroup;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupAuth;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupDescription;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiRequestExample;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiSuccess;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Param;\n\n/**\n * Class Api\n * @package App\\HttpController\n * @ApiGroup(groupName=\"Api\")\n * @ApiGroupDescription(\"这是我的API全局描述\")\n * @ApiGroupAuth(name=\"userToken\",from={POST},required=\"\",description=\"用户登录后，服务端返回的token,用于API鉴权\")\n */\nclass UserApi extends AnnotationController\n{\n    /**\n     * @Api(name=\"update\",path=\"/userApi/update\")\n     * @ApiDescription(\"更新用户基础资料\")\n     * @ApiRequestExample(\"curl http://127.0.0.1:9501/userApi/update?name=es&amp;age=11\")\n     * @Param(name=\"userId\",description=\"用户id\")\n     * @Param(name=\"account\",description=\"用户account\")\n     * @ApiSuccess({\"code\":200,\"result\":{\"userId\":2,\"account\":\"zyf\",\"username\":\"es\",\"phone\":\"xxxx\",\"avatar\":null,\"createTime\":1595837009,\"isDelete\":null,\"deleteTime\":null,\"user_token\":\"2-bc429ab40a7a2ebc-1596008468\"},\"msg\":\"登录成功\"})\n     * @ApiFail({\"code\":400,\"result\":null,\"msg\":\"字段非法\"})\n     */\n    function update()\n    {\n\n    }\n}\n注解示例2\n\nuse EasySwoole\\Component\\Context\\ContextManager;\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Api;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiAuth;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiDescription;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiFail;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiFailParam;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroup as ApiGroupTag;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupAuth;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupDescription;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiRequestExample;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiSuccess;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiSuccessParam;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\CircuitBreaker;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Context;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Di;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\InjectParamsContext;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Method;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Param;\nuse EasySwoole\\HttpAnnotation\\Exception\\Annotation\\ParamValidateError;\n\n/**\n * Class ControllerA\n * @package EasySwoole\\HttpAnnotation\\Tests\\TestController\n * @ApiGroupTag(groupName=\"GroupA\")\n * @ApiGroupDescription(\"GroupA desc\")\n * @ApiGroupAuth(name=\"groupParamA\",required=\"\")\n * @ApiGroupAuth(name=\"groupParamB\",required=\"\")\n */\nclass Annotation extends AnnotationController\n{\n\n    /**\n     * @Di(key=\"di\")\n     */\n    public $di;\n    /**\n     * @Context(key=\"context\")\n     */\n    public $context;\n\n    /**\n     * @Api(path=\"/apiGroup/func\",name=\"func\")\n     * @ApiAuth(name=\"apiAuth1\")\n     * @ApiAuth(name=\"apiAuth2\")\n     * @ApiDescription(\"func desc\")\n     * @ApiFail(\"func fail example1\")\n     * @ApiFail(\"func fail example2\")\n     * @ApiFailParam(name=\"failParam1\")\n     * @ApiFailParam(name=\"failParam2\")\n     * @ApiRequestExample(\"func request example1\")\n     * @ApiRequestExample(\"func request example2\")\n     * @ApiSuccess(\"func success example1\")\n     * @ApiSuccess(\"func success example2\")\n     * @ApiSuccessParam(name=\"successParam1\")\n     * @ApiSuccessParam(name=\"successParam2\")\n     * @CircuitBreaker(timeout=5.0)\n     * @InjectParamsContext(key=\"requestData\")\n     * @Method(allow={POST,GET})\n     * @Param(name=\"param1\")\n     * @Param(name=\"param2\")\n     */\n    function func()\n    {\n\n    }\n}","link":"/HttpServer/Annotation/doc.html"},{"id":88,"title":"ddl定义","content":"DDL\n数据库模式定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。Easyswoole提供了一个DDL库，方便用户用于定义一个数据库表结构。\n组件要求\n\neasyswoole / spl：^ 1.2\n\n安装方法\n\ncomposer require easyswoole/ddl\n\n仓库地址\neasyswoole/ddl\n基本使用\n创建表(CreateTable)\nuse EasySwoole\\DDL\\Blueprint\\Create\\Table as CreateTable;\nuse EasySwoole\\DDL\\DDLBuilder;\nuse EasySwoole\\DDL\\Enum\\Character;\nuse EasySwoole\\DDL\\Enum\\Engine;\n\n$scoreSql = DDLBuilder::create('score', function (CreateTable $table) {\n    $table-&gt;setIfNotExists()-&gt;setTableComment('成绩表');          //设置表名称\n    $table-&gt;setTableCharset(Character::UTF8MB4_GENERAL_CI);     //设置表字符集\n    $table-&gt;setTableEngine(Engine::INNODB);                     //设置表引擎\n    $table-&gt;int('id')-&gt;setIsUnsigned()-&gt;setIsAutoIncrement()-&gt;setIsPrimaryKey()-&gt;setColumnComment('自增ID');\n    $table-&gt;int('stu_id')-&gt;setIsUnsigned()-&gt;setColumnComment('学生id');\n    $table-&gt;int('course_id')-&gt;setIsUnsigned()-&gt;setZeroFill()-&gt;setColumnComment('课程id');\n    $table-&gt;float('score', 3, 1)-&gt;setColumnComment('成绩');\n    $table-&gt;int('created_at', 10)-&gt;setColumnComment('创建时间');\n    $table-&gt;foreign(null,'stu_id','student','stu_id')\n        -&gt;setOnDelete(Foreign::CASCADE)-&gt;setOnUpdate(Foreign::CASCADE);\n});\necho $scoreSql;\n\n//结果如下：\n\nCREATE TABLE IF NOT EXISTS `score` (\n  `id` int UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '自增ID',\n  `stu_id` int UNSIGNED NOT NULL COMMENT '学生id',\n  `course_id` int UNSIGNED ZEROFILL NOT NULL COMMENT '课程id',\n  `score` float(3,1) NOT NULL COMMENT '成绩',\n  `created_at` int(10) NOT NULL COMMENT '创建时间',\n  FOREIGN KEY (`stu_id`) REFERENCES `student` (`stu_id`) ON DELETE CASCADE ON UPDATE CASCADE\n)\nENGINE = INNODB DEFAULT COLLATE = 'utf8mb4_general_ci' COMMENT = '成绩表';\n\n修改表(AlterTable)\nuse EasySwoole\\DDL\\Blueprint\\Alter\\Table as AlterTable;\nuse EasySwoole\\DDL\\DDLBuilder;\n\n$alterStuScoreSql = DDLBuilder::alter('score', function (AlterTable $table) {\n    $table-&gt;setRenameTable('student_score')-&gt;setTableComment('学生成绩表');\n    $table-&gt;modifyIndex('ind_score')-&gt;normal('ind_score', 'score')-&gt;setIndexComment('学生成绩--普通索引');\n    $table-&gt;modifyForeign('fk_stu_id')-&gt;foreign('fk_stu_id', 'stu_id', 'student_info', 'stu_id');\n});\necho $alterStuScoreSql;\n\n//结果如下：\n\nALTER TABLE `score` RENAME TO `student_score`;\nALTER TABLE `student_score` \nCOMMENT = '学生成绩表',\nDROP INDEX `ind_score`,\nADD INDEX `ind_score` (`score`) COMMENT '学生成绩--普通索引';\nALTER TABLE `student_score` DROP FOREIGN KEY `fk_stu_id`;\nALTER TABLE `student_score` ADD CONSTRAINT `fk_stu_id` FOREIGN KEY (`stu_id`) REFERENCES `student_info` (`stu_id`);\n\n删除表(DropTable)\nuse EasySwoole\\DDL\\DDLBuilder;\n\n$dropStuScoreSql = DDLBuilder::drop('student_score');\necho $dropStuScoreSql;\n\n//结果如下：\n\nDROP TABLE `student`;","link":"/Components/ddl.html"},{"id":89,"title":"安装和使用","content":"Mysqli\n安装\ncomposer require easyswoole/mysqli\nClient 用法\n$config = new \\EasySwoole\\Mysqli\\Config([\n    'host'          =&gt; '',\n    'port'          =&gt; 3300,\n    'user'          =&gt; '',\n    'password'      =&gt; '',\n    'database'      =&gt; '',\n    'timeout'       =&gt; 5,\n    'charset'       =&gt; 'utf8mb4',\n]);\n\n$client = new \\EasySwoole\\Mysqli\\Client($config);\n\ngo(function ()use($client){\n    //构建sql\n    $client-&gt;queryBuilder()-&gt;get('user_list');\n    //执行sql\n    var_dump($client-&gt;execBuilder());\n});\n需要调用execBuilder()才会执行","link":"/Components/Mysqli/install.html"},{"id":90,"title":"基础示例","content":"GET\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// 获取全表\n$builder-&gt;get('getTable');\n\n// 表前缀\n$builder-&gt;setPrefix('easyswoole_')-&gt;get('getTable');\n\n// 获取总数。下面两个结果相同\n$builder-&gt;withTotalCount()-&gt;where('col1', 1, '&gt;')-&gt;get('getTable');\n$builder-&gt;setQueryOption('SQL_CALC_FOUND_ROWS')-&gt;where('col1', 1, '&gt;')-&gt;get('getTable');\n\n// fields。支持一维数组或字符串\n$builder-&gt;fields('col1, col2')-&gt;get('getTable');\n$builder-&gt;get('getTable', null, ['col1','col2']);\n\n// limit 1。下面两个结果相同\n$builder-&gt;get('getTable', 1)\n$builder-&gt;getOne('getTable')\n\n// offset 1, limit 10\n$builder-&gt;get('getTable',[1, 10])\n\n// 去重查询。\n$builder-&gt;get('getTable', [2,10], ['distinct col1','col2']);\n\n// where查询\n$builder-&gt;where('col1', 2)-&gt;get('getTable');\n\n// where查询2\n$builder-&gt;where('col1', 2, '&gt;')-&gt;get('getTable');\n\n// 多条件where\n$builder-&gt;where('col1', 2)-&gt;where('col2', 'str')-&gt;get('getTable');\n\n// whereIn, whereNotIn, whereLike，修改相应的operator(IN, NOT IN, LIKE)\n$builder-&gt;where('col3', [1,2,3], 'IN')-&gt;get('getTable');\n\n// orWhere\n$builder-&gt;where('col1', 2)-&gt;orWhere('col2', 'str')-&gt;get('getTable');\n\n// 复杂where\n// 生成大概语句：where status = 1 AND (id &gt; 10 or id &lt; 2)\n$builder-&gt;where('status', 1)-&gt;where(' (id &gt; 10 or id &lt;2) ')-&gt;get('getTable');\nJOIN\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// join。默认INNER JOIN\n$builder-&gt;join('table2', 'table2.col1 = getTable.col2')-&gt;get('getTable');\n$builder-&gt;join('table2', 'table2.col1 = getTable.col2', 'LEFT')-&gt;get('getTable');\n\n// join Where\n$builder-&gt;join('table2','table2.col1 = getTable.col2')-&gt;where('table2.col1', 2)-&gt;get('getTable');\nGROUPBY HAVING\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// groupBy. \n$builder-&gt;groupBy('col1')-&gt;get('getTable');\n$builder-&gt;where('col1',2)-&gt;groupBy('col1')-&gt;get('getTable');\n\n// having\n$builder-&gt;groupBy('col1')-&gt;having('col1')-&gt;get('getTable');\n$builder-&gt;groupBy('col1')-&gt;having('col1', 1, '&gt;')-&gt;get('whereGet');\n\n// and having. having第4个参数默认是 `AND`，默认多having是`且`关系\n$builder-&gt;groupBy('col1')-&gt;having('col1', 1, '&gt;')-&gt;having('col2', 1, '&gt;')-&gt;get('whereGet');\n\n// or having. 下面两种方法效果相等\n$builder-&gt;groupBy('col1')-&gt;having('col1', 1, '&gt;')-&gt;orHaving('col2', 1, '&gt;')-&gt;get('whereGet');\n$builder-&gt;groupBy('col1')-&gt;having('col1', 1, '&gt;')-&gt;having('col2', 1, '&gt;', 'OR')-&gt;get('whereGet');\nORDERBY\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// orderBy. 默认DESC\n$builder-&gt;orderBy('col1', 'ASC')-&gt;get('getTable');\n$builder-&gt;where('col1',2)-&gt;orderBy('col1', 'ASC')-&gt;get('getTable');\n\nUNION\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// union. 相当于 adminTable UNION userTable\n$builder-&gt;union((new QueryBuilder)-&gt;where('userName', 'user')-&gt;get('userTable'))\n    -&gt;where('adminUserName', 'admin')-&gt;get('adminTable');\nUPDATE\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// update \n$builder-&gt;update('updateTable', ['a' =&gt; 1]);\n\n// limit update\n$builder-&gt;update('updateTable', ['a' =&gt; 1], 5);\n\n// where update\n$builder-&gt;where('whereUpdate', 'whereValue')-&gt;update('updateTable', ['a' =&gt; 1]);\nDELETE\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// delete all\n$builder-&gt;delete('deleteTable');\n\n// limit delete\n$builder-&gt;delete('deleteTable', 1);\n\n// where delete\n$builder-&gt;where('whereDelete', 'whereValue')-&gt;delete('deleteTable');\n\nINSERT\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// insert into\n$builder-&gt;insert('insertTable', ['a' =&gt; 1, 'b' =&gt; \"b\"]);\n\n// replace into\n$builder-&gt;replace('replaceTable', ['a' =&gt; 1]);\n\nSUBQUERY\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// 单一where条件子查询\n// 等同于 SELECT * FROM users WHERE id in ((SELECT userId FROM products WHERE  qty &gt; 2))\n$sub = $this-&gt;builder::subQuery();\n$sub-&gt;where(\"qty\", 2, \"&gt;\");\n$sub-&gt;get(\"products\", null, \"userId\");\n$builder-&gt;where(\"id\", $sub, 'in')-&gt;get('users');\n\n// 多where条件子查询\n// 等同于 SELECT * FROM users WHERE col2 = 1 AND id in ((SELECT userId FROM products WHERE  qty &gt; 2))\n$sub = $this-&gt;builder::subQuery();\n$sub-&gt;where (\"qty\", 2, \"&gt;\");\n$sub-&gt;get (\"products\", null, \"userId\");\n$this-&gt;builder-&gt;where('col2',1)-&gt;where (\"id\", $sub, 'in')-&gt;get('users');\n\n// INSERT 包含子结果集\n// 等同于 INSERT INTO products (`productName`, `userId`, `lastUpdated`) VALUES ('test product', (SELECT name FROM users WHERE  id = 6  LIMIT 1), NOW())\n$userIdQ = $this-&gt;builder::subQuery();\n$userIdQ-&gt;where (\"id\", 6);\n$userIdQ-&gt;getOne (\"users\", \"name\");\n$data = Array (\n    \"productName\" =&gt; \"test product\",\n    \"userId\" =&gt; $userIdQ,\n    \"lastUpdated\" =&gt; $this-&gt;builder-&gt;now()\n);\n$this-&gt;builder-&gt;insert (\"products\", $data);\nLOCK\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// FOR UPDATE 排它锁。下面两个方法效果相同\n$builder-&gt;setQueryOption(\"FOR UPDATE\")-&gt;get('getTable');\n$builder-&gt;selectForUpdate(true)-&gt;get('getTable');\n\n//  LOCK IN SHARE MODE。共享锁\n$builder-&gt;lockInShareMode()-&gt;get('getTable');\n$builder-&gt;setQueryOption(['LOCK IN SHARE MODE'])-&gt;get('getTable');\n\n// LOCK TABLES 获取表锁\n$builder-&gt;lockTable('table');\n\n// UNLOCK TABLES 释放表锁\n$builder-&gt;unlockTable('table');\n","link":"/Components/Mysqli/mysqli.html"},{"id":91,"title":"基本使用","content":"查询构造器\nQueryBuilder是一个SQL构造器，用来构造prepare sql。例如：\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n//执行条件构造逻辑\n$builder-&gt;where('col1',2)-&gt;get('my_table');\n\n//获取最后的查询参数\necho $builder-&gt;getLastQueryOptions();\n\n//获取子查询\necho $builder-&gt;getSubQuery();\n\n//获取上次条件构造的预处理sql语句\necho $builder-&gt;getLastPrepareQuery();\n// SELECT  * FROM whereGet WHERE  col1 = ? \n\n//获取上次条件构造的预处理sql语句所以需要的绑定参数\necho $builder-&gt;getLastBindParams();\n//[2]\n\n//获取上次条件构造的sql语句\necho $builder-&gt;getLastQuery();\n//SELECT  * FROM whereGet WHERE  col1 = 2 \n\n// 获取最后插入的insert_id 使用客户端从swoole mysql获取\n$client-&gt;mysqlClient()-&gt;insert_id","link":"/Components/Mysqli/builder.html"},{"id":92,"title":"查询数据","content":"查询数据\n基本查询\n用id查询一条用户数据：\n$client-&gt;queryBuilder()-&gt;where('id', 1)-&gt;getOne('user_list');\n查询多条数据：\n$client-&gt;queryBuilder()-&gt;where('is_vip', 1)-&gt;get('user_list');\nget/getOne返回值查看链式操作里的详细文档\n在使用 get 和 getOne 等操作方法前可以任意使用链式操作方法","link":"/Components/Mysqli/query.html"},{"id":93,"title":"添加数据","content":"添加数据\nINSERT INTO\n$client-&gt;queryBuilder()-&gt;insert('insertTable', ['a' =&gt; 1, 'b' =&gt; \"b\"]);\nREPLACE INTO\n$builder-&gt;replace('replaceTable', ['a' =&gt; 1]);","link":"/Components/Mysqli/insert.html"},{"id":94,"title":"更新数据","content":"更新数据\nWHERE UPDATE\n$client-&gt;queryBuilder()-&gt;where('whereUpdate', 'whereValue')-&gt;update('updateTable', ['a' =&gt; 1]);\nLIMIT UPDATE\n$client-&gt;queryBuilder()-&gt;update('updateTable', ['a' =&gt; 1], 5);\n快捷更新\n$client-&gt;queryBuilder()\n    -&gt;where('whereUpdate', 'whereValue')\n    -&gt;update('updateTable', [\n        'age'    =&gt; QueryBuilder::inc(1),\n        'number' =&gt; QueryBuilder::dec(3),\n    ]);","link":"/Components/Mysqli/update.html"},{"id":95,"title":"删除数据","content":"删除数据\nLIMIT DELETE\n$client-&gt;queryBuilder()-&gt;delete('user_list', 3);\nWHERE DELETE\n$client-&gt;queryBuilder()-&gt;where('whereUpdate', 'whereValue')-&gt;delete('user_list');","link":"/Components/Mysqli/delete.html"},{"id":96,"title":"limit","content":"limit\nlimit方法主要用于指定查询和操作的数量，特别在分页查询的时候使用较多。\n查询数量\n查询10个用户数据：\n$builder-&gt;limit(10)-&gt;get('user_list');\n传参说明\n方法原型\nfunction limit(int $one, ?int $two = null)\n\n$one 若第二个参数不传，则代表取多少条数据；若第二个参数传递，则代表从第几行开始\n$two 可不传，若传递，则代表从$one开始，取$two行数据\n","link":"/Components/Mysqli/Chain/limitMethod.html"},{"id":97,"title":"fields","content":"fields\n主要目的是查询时标识要返回的字段值\n指定字段\n$builder-&gt;fields(['id','title'])-&gt;get('user_list');\n设置别名\n$builder-&gt;fields(['id','title as notice'])-&gt;get('user_list');\n使用SQL函数\n$builder-&gt;fields(['id','SUM(score)'])-&gt;get('user_list');\n传参说明\n方法原型\nfunction fields($fields)\n\n$fields array|string 如果非数组时，只可传入一个字段名\n","link":"/Components/Mysqli/Chain/fieldsMethod.html"},{"id":98,"title":"where","content":"where\n快速完成条件语句构建。where方法的参数支持字符串和数组。\n普通查询+\n$builder-&gt;where('col1', 2)-&gt;get('getTable');\n字符串语句\n可以使用字符串语句构建比较复杂的条件\n// 生成大概语句：where status = 1 AND (id &gt; 10 or id &lt; 2)\n$builder-&gt;where('status', 1)-&gt;where(' (id &gt; 10 or id &lt;2) ')-&gt;get('getTable');\nnull 条件\n\n$builder = new \\EasySwoole\\Mysqli\\QueryBuilder();\n$builder-&gt;where('status', null,'is')-&gt;get('getTable');\n$builder-&gt;where('status is null')-&gt;get('getTable');\n$builder-&gt;where('status', null,'is not')-&gt;get('getTable');\n特殊操作符\n$builder-&gt;where('id', [1,2,3], 'IN')-&gt;get('getTable');\n$builder-&gt;where('age', 12, '&gt;')-&gt;get('getTable');\n连接条件\norWhere\n$builder-&gt;where('is_vip', 1)-&gt;where('id', [1,2], '=', 'OR')-&gt;get('getTable');\n$builder-&gt;where('is_vip', 1)-&gt;orWhere('id', [1,2])-&gt;get('getTable');\n传参说明\n方法原型\nfunction where($whereProp, $whereValue = 'DBNULL', $operator = '=', $cond = 'AND')\n\n$whereProp string 支持索引数组、kv数组、或直接传递字符串\n$whereValue string 条件值\n$operator string 操作符\n$cond string 连接条件\n","link":"/Components/Mysqli/Chain/whereMethod.html"},{"id":99,"title":"orwhere","content":"orWhere\n快速完成条件语句构建\n下面两种方法等价\n$builder-&gt;where('is_vip', 1)-&gt;where('id', 1, '=', 'OR')-&gt;get('getTable');\n$builder-&gt;where('is_vip', 1)-&gt;orWhere('id', 1)-&gt;get('getTable');\n传参说明\n方法原型\nfunction orWhere($whereProp, $whereValue = 'DBNULL', $operator = '=')\n\n$whereProp string 支持索引数组、kv数组、或直接传递字符串\n$whereValue string 条件值\n$operator string 操作符\n","link":"/Components/Mysqli/Chain/orWhereMethod.html"},{"id":100,"title":"orderby","content":"orderBy\n用于对操作的结果排序。\n基本用法\n默认DESC排序规则\n$builder-&gt;orderBy('col1', 'ASC')-&gt;get('getTable');\n$builder-&gt;where('col1',2)-&gt;orderBy('col1', 'ASC')-&gt;get('getTable');\nORDER BY FIELD\n可以通过第三个参数实现\n$array = [\n    'a',\n    'b'\n];\n$builder-&gt;orderBy('', 'DESC', $array)-&gt;get('getTable');\n实现原理\nif (is_array($customFieldsOrRegExp)) {\n    foreach ($customFieldsOrRegExp as $key =&gt; $value) {\n        $customFieldsOrRegExp[$key] = preg_replace(\"/[^\\x80-\\xff-a-z0-9\\.\\(\\),_` ]+/i\", '', $value);\n    }\n    $orderByField = 'FIELD (' . $orderByField . ', \"' . implode('\",\"', $customFieldsOrRegExp) . '\")';\n}\nORDER BY REGEXP\n可以通过第三个参数实现\n实现原理\nif (is_string($customFieldsOrRegExp)) {\n    $orderByField = $orderByField . \" REGEXP '\" . $customFieldsOrRegExp . \"'\";\n}\n传参说明\n方法原型\nfunction orderBy($orderByField, $orderbyDirection = \"DESC\", $customFieldsOrRegExp = null)\n\n$orderByField 排序字段\n$orderbyDirection 排序规则\n$customFieldsOrRegExp 其他条件\n","link":"/Components/Mysqli/Chain/orderbyMethod.html"},{"id":101,"title":"groupby","content":"groupBy\n通常用于结合合计函数，根据一个或多个列对结果集进行分组 。\ngroup方法只有一个参数，并且只能使用字符串。\n使用\n$builder-&gt;groupBy('is_vip')-&gt;get('getTable');\n$builder-&gt;groupBy('is_vip,level')-&gt;get('getTable');\n传参说明\n方法原型\nfunction groupBy($groupByField)\n\n$groupByField string 分组字段\n","link":"/Components/Mysqli/Chain/groupbyMethod.html"},{"id":102,"title":"having","content":"having\n用于配合group方法完成从分组的结果中筛选（通常是聚合条件）数据。\n使用\n$builder-&gt;groupBy('user_id')-&gt;having('times', 3,'&gt;')-&gt;get('getTable');\n传参说明\n方法原型\nfunction having($havingProp, $havingValue = 'DBNULL', $operator = '=', $cond = 'AND')\n\n$havingProp 条件\n$havingValue 值\n$operator string 操作符\n$cond string 连接条件\n","link":"/Components/Mysqli/Chain/havingMethod.html"},{"id":103,"title":"orhaving","content":"orHaving\n用于配合group方法完成从分组的结果中筛选（通常是聚合条件）数据。\n使用\n$builder-&gt;groupBy('user_id')-&gt;orHaving('times', 3,'&gt;')-&gt;get('getTable');\n等同于\n$builder-&gt;groupBy('user_id')-&gt;having('times', 3,'&gt;'，'OR')-&gt;get('getTable');\n传参说明\n方法原型\nfunction orHaving($havingProp, $havingValue = 'DBNULL', $operator = '=')\n\n$havingProp 条件\n$havingValue 值\n$operator string 操作符\n","link":"/Components/Mysqli/Chain/orHavingMethod.html"},{"id":104,"title":"join","content":"Join\njoin通常有下面几种类型，不同类型的join操作会影响返回的数据结果。\n\nINNER JOIN: 等同于 JOIN（默认的JOIN类型）,如果表中有至少一个匹配，则返回行\nLEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行\nRIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行\nFULL JOIN: 只要其中一个表中存在匹配，就返回行\n\n基本使用\n$builder-&gt;join('table2','table2.col1 = getTable.col2')-&gt;get('getTable');\n指定类型\n$builder-&gt;join('table2','table2.col1 = getTable.col2','LEFT')-&gt;get('getTable');\n传参说明\n方法原型\nfunction join($joinTable, $joinCondition, $joinType = '')\n\n$joinTable 表名\n$joinCondition 条件\n$joinType 类型\n","link":"/Components/Mysqli/Chain/joinMethod.html"},{"id":105,"title":"joinwhere","content":"joinWhere\n传参说明\n方法原型\nfunction joinWhere($whereJoin, $whereProp, $whereValue = 'DBNULL', $operator = '=', $cond = 'AND')","link":"/Components/Mysqli/Chain/joinWhereMethod.html"},{"id":106,"title":"joinorwhere","content":"joinOrWhere\n传参说明\n方法原型\nfunction joinOrWhere($whereJoin, $whereProp, $whereValue = 'DBNULL', $operator = '=')","link":"/Components/Mysqli/Chain/joinOrWhereMethod.html"},{"id":107,"title":"union","content":"union\n构建UNION语句\n传参说明\n方法原型\nfunction union($cond, $isUnionAll = false)\n\n$cond   条件\n$isUnionAll\n","link":"/Components/Mysqli/Chain/unionMethod.html"},{"id":108,"title":"lockinsharemode","content":"LockInShareModel\nLockInShareModel锁定(InnoDb)\n传参说明\n方法原型\nfunction lockInShareMode($isLock = true)\n\n$isLock   \n","link":"/Components/Mysqli/Chain/lockInShareModeMethod.html"},{"id":109,"title":"selectforupdate","content":"selectForUpdate\nSELECT FOR UPDATE锁定(InnoDb)\n传参说明\n方法原型\nfunction selectForUpdate($isLock = true, string $option = null)\n\n$isLock   \n$option NOWAIT,WAIT 5,SKIP LOCKED\n","link":"/Components/Mysqli/Chain/selectForUpdateMethod.html"},{"id":110,"title":"setlocktablemode","content":"setLockTableMode\n锁表模式(读/写)\n传参说明\n方法原型\nfunction  setLockTableMode($method)\n\n$method  读/写\n","link":"/Components/Mysqli/Chain/setLockTableModeMethod.html"},{"id":111,"title":"locktable","content":"lockTable\n获得表锁\n传参说明\n方法原型\nfunction lockTable($table)\n\n$table  表名称\n","link":"/Components/Mysqli/Chain/lockTableMethod.html"},{"id":112,"title":"unlocktable","content":"unlockTable\n释放表锁\n传参说明\n方法原型\nfunction unlockTable()","link":"/Components/Mysqli/Chain/unlockTableMethod.html"},{"id":113,"title":"setqueryoption","content":"setQueryOption\n设置查询条件\n用法\n$builder-&gt;setQueryOption(\"FOR UPDATE\")-&gt;where('whereUpdate', 'whereValue')-&gt;update('updateTable', ['a' =&gt; 1], 2);\n传参说明\n方法原型\nfunction setQueryOption($options)","link":"/Components/Mysqli/Chain/setQueryOptionMethod.html"},{"id":114,"title":"setprefix","content":"setPrefix\n设置表前缀\n传参说明\n方法原型\nfunction setPrefix($prefix = '')","link":"/Components/Mysqli/Chain/setPrefixMethod.html"},{"id":115,"title":"withtotalcount","content":"withTotalCount\n统计结果行数\n查询用法\n查询用户行数：\n$builder-&gt;withTotalCount()-&gt;get(\"user\",null,\"*\");\n传参说明\n方法原型\nfunction withTotalCount(): QueryBuilder","link":"/Components/Mysqli/Chain/withTotalCountMethod.html"},{"id":116,"title":"replace","content":"replace\nreplace插入\n传参说明\n方法原型\nfunction replace($tableName, $insertData)\n\n$tableName 表名\n$insertData 需要插入的数据\n","link":"/Components/Mysqli/Chain/replaceMethod.html"},{"id":117,"title":"onduplicate","content":"onDuplicate\nonDuplicate插入\n传参说明\n方法原型\nfunction onDuplicate($updateColumns, $lastInsertId = null)\n\n$updateColumns 更新的列\n$lastInsertId 可不传，若传入，更新$lastInsertId行数据\n","link":"/Components/Mysqli/Chain/onDuplicateMethod.html"},{"id":118,"title":"安装","content":"ORM\nEasyswoole提供的一个全新协程安全的ORM封装。\n安装\n依赖关系\n\nswoole &gt;= 4.4.8\n\nEasyswoole  &gt;=3.3.2 \nmysqli &gt; 2.x\n\n\n\ncomposer require easyswoole/orm\n\n配置信息注册\nORM 的连接配置信息（数据库连接信息）需要注册到连接管理器中。\n数据库连接管理器\nORM的连接管理由EasySwoole\\ORM\\DbManager类完成，它是一个单例类。\nuse EasySwoole\\ORM\\DbManager;\n\nDbManager::getInstance();\n注册数据库连接配置\n你可以在框架 initialize 主服务创建事件中注册连接\nuse EasySwoole\\ORM\\DbManager;\nuse EasySwoole\\ORM\\Db\\Connection;\nuse EasySwoole\\ORM\\Db\\Config;\n\npublic static function initialize()\n{\n    $config = new Config();\n    $config-&gt;setDatabase('easyswoole_orm');\n    $config-&gt;setUser('root');\n    $config-&gt;setPassword('');\n    $config-&gt;setHost('127.0.0.1');\n\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n\n    // 设置指定连接名称 后期可通过连接名称操作不同的数据库\n    DbManager::getInstance()-&gt;addConnection(new Connection($config),'write');\n}\n数据库连接自带连接池说明\n在默认实现中，ORM自带了一个基于连接池实现的连接类\nEasySwoole\\ORM\\Db\\Connection 实现了连接池的使用\nuse EasySwoole\\ORM\\DbManager;\nuse EasySwoole\\ORM\\Db\\Connection;\nuse EasySwoole\\ORM\\Db\\Config;\n\npublic static function initialize()\n{\n    $config = new Config();\n    $config-&gt;setDatabase('easyswoole_orm');\n    $config-&gt;setUser('root');\n    $config-&gt;setPassword('');\n    $config-&gt;setHost('127.0.0.1');\n    //连接池配置\n    $config-&gt;setGetObjectTimeout(3.0); //设置获取连接池对象超时时间\n    $config-&gt;setIntervalCheckTime(30*1000); //设置检测连接存活执行回收和创建的周期\n    $config-&gt;setMaxIdleTime(15); //连接池对象最大闲置时间(秒)\n    $config-&gt;setMinObjectNum(5); //设置最小连接池存在连接对象数量\n    $config-&gt;setMaxObjectNum(20); //设置最大连接池存在连接对象数量\n    $config-&gt;setAutoPing(5); //设置自动ping客户端链接的间隔\n\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n}\n开发者必读\n此部分对于ORM的学习和使用非常重要，遇到使用问题请先确保有认真看完和排查后再进行提问和反馈。\n设计思想\nORM全称：object relational mapping，目的是想像操作对象一样操作数据库，是符合面向对象开发思想的。\n如将一条数据的插入，映射成一个对象的实例化。\n$user = UserModel::create();\n$user-&gt;data([\n    'attr' =&gt; 'value'\n]);\n$user-&gt;save();\n常见问题汇总\n重复使用Model对象\n一个对象映射一条数据，此时会有很多用习惯了db封装组件的小伙伴把Model当成了db封装使用，重复调用一个Model对象，如下\n// 错误使用\n\n// 假设id自增\n$user = UserModel::create();\n\n// 插入一条新用户\n$user-&gt;data([\n    'attr' =&gt; 'value'\n]);\n$user-&gt;save();\n\n// 插入第二条新用户，此时由于重复调用同一个对象，产生报错，自增id主键重复\n$user-&gt;data([\n    'attr' =&gt; 'value2'\n]);\n$user-&gt;save();\nORM生成复杂sql\n1.ORM是基于 mysqli 2.x组件完成，内部引用 mysqli中的 QueryBuilder类完成sql构造，并且在查询章节注明了闭包函数使用方式（可直接使用mysqli中的绝大部分连贯操作，如 having 等特殊条件）\n2.如果mysqli的连贯操作也无法满足，你有以下几种方式解决该问题\n\n使用自定义sql执行\n尝试给组件贡献代码，新增功能特性\n提出反馈，在精力允许和大众所需时，我们会维护组件升级\n\n优雅删除数据\n在ORM设计思想中，对数据的操作映射为对对象的操作，如果按照此原则，那么需要我们先查询出对象，然后再调用对象的destroy()方法进行删除。\n但是对于执行效率的消耗来说，此次查询在部分业务场景下是无用的。\n那么我们到底是否需要遵守设计原则？一般情况下是在操作前需要校验数据是否存在时遵守，无需校验则直接传参删除条件即可。\n设计原则代表思想，在某些场景下遵守它需要付出一定代价，自己根据喜好去决定它。\n$user = User::create()-&gt;get($param['id']);\n\nif (!$user){\n    return '操作数据不存在，请检查再试';\n}\n$res = $user-&gt;destroy();\n连接预热\n为了避免链接空档期突如其来的高并发，我们可以做数据库链接预热，也就是worker启动的是时候，提前准备好链接。\n&lt;?php\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\ORM\\DbManager;\nuse EasySwoole\\ORM\\Db\\Connection;\nuse EasySwoole\\ORM\\Db\\Config;\nuse EasySwoole\\EasySwoole\\Config as GlobalConfig;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n        $config = new Config(GlobalConfig::getInstance()-&gt;getConf(\"MYSQL\"));\n        DbManager::getInstance()-&gt;addConnection(new Connection($config));\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        $register-&gt;add($register::onWorkerStart,function (){\n            // 链接预热\n            // ORM 1.4.31 版本之前请使用 getClientPool() \n            // DbManager::getInstance()-&gt;getConnection()-&gt;getClientPool()-&gt;keepMin();\n\n            DbManager::getInstance()-&gt;getConnection()-&gt;__getClientPool()-&gt;keepMin();\n        });\n    }\n}\n断线问题\n为什么会断线？\n在连接池模式下，一个连接创建后，并不会因为因为请求结束而断开，就好比php-fpm下的pconnect特性一样。而一个连接\n建立后，可能会因为太久没有使用(执行sql),而被mysql服务端主动断了连接，或者是因为链路问题，切断了连接。而被切断的时候。我们并不知道这件事。因此就导致了我们用了\n一个断线的连接去执行sql，从而出现断线错误或者是异常。\n如何解决\n与java全家桶的原理一致，我们需要做的事情就是：\n\n定时检查连接是否可用\n定时检查连接的最后一次使用状态\n\n因此我们在EasySwoole的orm中，我们的IntervalCheckTime配置项目指定的就是多久做一次周期检查，\nMaxIdleTime指的是如果一个连接超过这个时间没有使用，则会被回收。AutoPing指的是多久执行一个select 1用来触发这个连接，使得被mysql服务端标记为活跃而不会被回收。\n如果经常出现断线，可以适当缩短时间。\n百分百不会断线了?\n理论上，做了上面的步骤，出现使用断线连接的概率是非常低的，但是、并不是真的就百分百稳了，比如极端情况，mysql服务重启，或者是链路断线了。\n因此，我们一定要做以下类似事情：\ntry{\n    $client = $pool-&gt;getClient()\n    $cilient-&gt;query(xxxxxx);\n}catch(\\Throwable $t){}\n\n也就是，任何orm的使用，一定要try。至于为何，请参考java为何强制对任何数据库io作try.\n为何不能做自动重连\n我们可以看到，在某些自以为很聪明的框架中，有这样的操作\n$client = $pool-&gt;getClient();\ntry{\n    return  $client-&gt;query();\n}catch(\\Throwable $t){\n     //2006 2002 为断线\n    if($client-&gt;getError() == '2006'){\n        $client-&gt;connect();\n        return $client-&gt;query();\n    }else{\n        throw $t;\n    }\n}\n乍一看，没有什么问题。实际上,按照上面的重连，我们来看看：\n$client = $pool-&gt;getClient();\n$client-&gt;startTransaction();\n$client-&gt;query(query one);\n//client disconnect case network\n$client-&gt;reconnect();\n$client-&gt;query(query two);\n$client-&gt;commit();\n这样，在极端情况下，会导致query one结果丢失，但是query two却执行了，这对于事务来说，是不可原谅的。\n此刻又会有人说，那我判断下链接是不是在事务中不就好了。实际上，远远没这么简单。为此，最好的方式就是我们养成良好的习惯。任何的数据库io，都做try操作，与java一致。","link":"/Components/Orm/install.html"},{"id":119,"title":"核心文件","content":"核心文件\n本章节对核心Config、Connection、DbManager源码分析，方便开发者快速上手。\nConfig\nOrm自带连接池，因此继承了EasySwoole\\Pool\\Config，并且父级继承了EasySwoole\\Spl\\SplBean具有对类属性快速赋值的操作。\n实例\n$config = new \\EasySwoole\\ORM\\Db\\Config();\n基本配置\n设置host\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setHost('127.0.0.1');\n$config-&gt;setHost('127.0.0.1:3306');\n设置port\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setPort(3306);\n设置用户名\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setUser('root');\n设置密码\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setPassword('easyswoole');\n设置数据库\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setDatabase('easyswoole');\n设置charset\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setCharset('utf8');\n设置严格模式\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setStrictType(true);\n设置fetchMode\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setFetchMode(true);\n设置返回结果为结果集\n可以快速all()-&gt;toArray()\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setReturnCollection(true);\n连接池配置\n设置获取连接池对象超时时间\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setGetObjectTimeout(3.0);\n设置检测连接存活执行回收和创建的周期\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setIntervalCheckTime(30*1000);\n连接池对象最大闲置时间(秒)\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setMaxIdleTime(15);\n设置最小连接池存在连接对象数量\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setMinObjectNum(5);\n设置最大连接池存在连接对象数量\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setMaxObjectNum(15);\n设置自动ping客户端链接的间隔\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setAutoPing(5);\n快速设置\n$config = new \\EasySwoole\\ORM\\Db\\Config([\n    'host' =&gt; '127.0.0.1',\n    'autoPing' =&gt; 5\n]);\nConnection\n实例\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$connection = new \\EasySwoole\\ORM\\Db\\Connection($config);\n获取池\n/** @var \\EasySwoole\\ORM\\Db\\Connection $connection **/\n$connection-&gt;getClientPool();\ndefer\ntimeout参数为空 默认获取config的timeout，此方法会自动回收对象，用户无需关心。\n/** @var \\EasySwoole\\ORM\\Db\\Connection $connection **/\n$connection-&gt;defer();\n$connection-&gt;defer(3.0);\n获取注入的config\n/** @var \\EasySwoole\\ORM\\Db\\Connection $connection **/\n$connection-&gt;getConfig();\nDbManager\nDbManager采用单例，注意：进程间数据是隔离的。\n实例\n\\EasySwoole\\ORM\\DbManager::getInstance();\n回调事件\n具体注入参数请看回调事件\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;onQuery(function (){\n\n});\n注入连接池\n参数：\n\n\n$connection 连接池对象\n\n$connectionName 连接池名称 默认default 可进行读写分离配置\n\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$connection = new \\EasySwoole\\ORM\\Db\\Connection($config);\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;addConnection($connection);\n\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;addConnection($connection,'write');\n获取连接池\n参数：\n\n\n$connectionName 连接池名称\n\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;getConnection();\nquery\n参数：\n\n\n$builder QueryBuilder\n\n$raw 是否raw执行，否则预处理\n\n$connection 指定连接池名称 或者 连接\n\n$timeout 超时时间\n\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;query(new \\EasySwoole\\Mysqli\\QueryBuilder());\n事务\n注意事务协程上下文。\n参数：\n\n\n$con 指定连接池名称 或者 连接\n\n$timeout 超时时间\n\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;startTransaction();\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;commit();\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;rollback();\ninvoke\n使用invoke方式，让ORM查询结束后马上归还资源，可以提高资源的利用率。\n参数：\n\n\n$call 回调函数\n\n$connectionName 指定连接池名称\n\n$timeout 超时时间\n\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;invoke(function (\\EasySwoole\\ORM\\Db\\ClientInterface $client){\n\n    \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;startTransaction($client);\n    \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;commit($client);\n    \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;rollback($client);\n\n});\n查询该连接是否处于事务上下文\n/** @var \\EasySwoole\\ORM\\Db\\ClientInterface $client **/\n\\EasySwoole\\ORM\\DbManager::isInTransaction($client);","link":"/Components/Orm/core.html"},{"id":120,"title":"定义模型","content":"Model\n基础定义\n基本模型\n定义一个模型基础的模型，必须继承EasySwoole\\ORM\\AbstractModel类\nnamespace App\\Models;\n\nuse EasySwoole\\ORM\\AbstractModel;\n\n/**\n * 用户商品模型\n * Class UserShop\n */\nclass UserShop extends AbstractModel\n{\n\n}\n数据表名称\n必须在Model中定义 $tableName 属性，指定完整表名，否则将会产生错误Table name is require for model\nnamespace App\\Models;\n\nuse EasySwoole\\ORM\\AbstractModel;\n\n/**\n * 用户商品模型\n * Class UserShop\n */\nclass UserShop extends AbstractModel\n{\n     /**\n      * @var string \n      */\n     protected $tableName = 'user_shop';\n}\n定义表结构\n自动生成表结构\n$model = new User();\n$table = $model-&gt;schemaInfo();\n使用模型中的schemaInfo()方法可以获取当前模型指定数据表的结构返回一个EasySwoole\\ORM\\Utility\\Schema\\Table对象\n模型本身会自动生成表结构,但每次启动Easyswoole,都会去重新获取一次表结构信息,并且在这次服务中缓存,直到Easyswoole服务停止或者重启\n如果不希望每次重启都去请求一次数据库,可自行定义该方法,返回Table对象\n自定义表结构\n在模型类中，我们实现一个getSchemaInfo方法，要求返回一个EasySwoole\\ORM\\Utility\\Schema\\Table实例化对象\nuse EasySwoole\\ORM\\Utility\\Schema\\Table;\nuse EasySwoole\\ORM\\AbstractModel;\n\nclass User extends AbstractModel\n{\n    protected $tableName = 'user';\n\n    /**\n     * 表的获取\n     * 此处需要返回一个 EasySwoole\\ORM\\Utility\\Schema\\Table\n     * @return Table\n     */\n    public function schemaInfo(bool $isCache = true): Table\n    {\n        $table = new Table($this-&gt;tableName);\n        $table-&gt;colInt('id')-&gt;setIsPrimaryKey(true);\n        $table-&gt;colChar('name', 255);\n        $table-&gt;colInt('age');\n        return $table;\n    }\n}\n\n表字段\n在Table中，有colX系列方法，用于表示表字段的类型，如以上示例的Int,Char\n$table-&gt;colInt('id');\n$table-&gt;colChar('name', 255);\n表主键\n如果需要将某个字段指定为主键 则用连贯操作方式，在后续继续指定即可。\n$table-&gt;colInt('id')-&gt;setIsPrimaryKey(true);\n指定连接名\n从 安装 章节，我们已经知道了，在注册配置信息的时候，可以给这份配置指定一个连接名\n可以通过模型类自定义属性 connectionName 来指定使用的连接配置，默认为 default\n假设已经通过 配置信息注册 章节注册了一个 read 连接名的配置\n那么我们可以在Model中定义指定read连接名\nClass AdminModel extends \\EasySwoole\\ORM\\AbstractModel \n{\n    protected $connectionName = 'read';\n}\n可以继续查看 读写分离 章节，进一步查看如何使用不同数据库配置。\n时间戳\n在ORM组件版本 &gt;= 1.0.18 后，增加自动时间戳特性支持。\n用于：自动写入创建和更新的时间字段。\n\n在插入数据的时候，自动设置插入时间为当前，\n在更新数据的时候，自动设置更新时间为当前。\n\n使用方式\nuse \\EasySwoole\\ORM\\AbstractModel ;\n\nClass AdminModel extends AbstractModel\n{\n    // 都是非必选的，默认值看文档下面说明\n    protected $autoTimeStamp = true;\n    protected $createTime = 'create_at';\n    protected $updateTime = 'update_at';\n}\nautoTimeStamp\n是否开启自动时间戳，默认值 false\n可选值： \n\ntrue 字段默认为int类型 储存时间戳\nint  字段为int类型 储存时间戳\ndatetime  字段为datetime类型  Y-m-d H:i:s\n\ncreateTime\n数据创建时间 字段名，默认值 create_time \n可选值\n\n任意字符串，对应为表中要储存创建时间的字段名\nfalse，不处理创建时间字段\n\nupdateTime\n数据更新时间 字段名，默认值 update_time \n可选值\n\n任意字符串，对应为表中要储存创建时间的字段名\nfalse，不处理更新时间字段\n\n字段预定义属性\n版本要求：orm &gt;= 1.4.9\n利用cast定义可以实现：在取出时自动转换为数组、在存储时自动转换为json字符\n数据库储存一般是以文本格式，php擅长的是数组、对象等，达到灵活使用的目的。\n也可以定义字段为int、小数、时间戳等\n定义方式\n\nclass TestCastsModel extends AbstractModel\n{\n    protected $casts = [\n        'age'           =&gt; 'int',\n        'id'            =&gt; 'float',\n        'addTime'       =&gt; 'timestamp',\n        'state'         =&gt; 'bool',\n        // 在join中自定义的\n        'test_json'     =&gt; 'json',\n        'test_array'    =&gt; 'array',\n        'test_date'     =&gt; 'date',\n        'test_datetime' =&gt; 'datetime',\n        'test_string'   =&gt; 'string',\n    ];\n}\n支持类型\n\n\n\n类型\n设置值\n\n\n\n\n整数\nint、 integer\n\n\n浮点\nreal、float、double\n\n\n字符串\nstring\n\n\n布尔值\nbool、boolean\n\n\n数组\narray  相当于json_decode($data, true)\n\n\n对象\njson、object   相当于json_decode($data)\n\n\n日期 Y-m-d\ndate\n\n\n日期 Y-m-d H:i:s\ndatetime\n\n\n时间戳\ntimestamp\n\n\n自定义日期格式\n未完成\n\n\n自定义小数类型\n未完成\n\n\n\n示例代码\n以下代码为orm组件的单元测试脚本 \n\n    public function testFloat()\n    {\n        $test = TestCastsModel::create([\n            'id' =&gt; 1\n        ]);\n        $this-&gt;assertIsFloat($test-&gt;id);\n    }\n\n    public function testInt()\n    {\n        $test = TestCastsModel::create([\n            'age' =&gt; \"21\"\n        ]);\n        $this-&gt;assertIsInt($test-&gt;age);\n    }\n\n    public function testTimestamp()\n    {\n        $test = TestCastsModel::create([\n            'addTime' =&gt; \"2020-6-4 16:45:04\"\n        ]);\n        $this-&gt;assertIsInt($test-&gt;addTime);\n    }\n\n    public function testBool()\n    {\n        $test = TestCastsModel::create([\n            'state' =&gt; 0\n        ]);\n        $this-&gt;assertIsBool($test-&gt;state);\n    }\n\n    public function testString()\n    {\n        $test = TestCastsModel::create();\n        $test-&gt;setAttr('test_string', 1);\n        $this-&gt;assertIsString($test-&gt;test_string);\n    }\n\n    public function testJson()\n    {\n        $test = TestCastsModel::create();\n        $test-&gt;setAttr('test_json', [\n            'name' =&gt; 'siam'\n        ]);\n\n        $this-&gt;assertInstanceOf(\\stdClass::class, $test-&gt;test_json);\n    }\n\n    public function testArray()\n    {\n        $test = TestCastsModel::create();\n        $test-&gt;setAttr('test_array', [\n            'name' =&gt; 'siam'\n        ]);\n\n        $this-&gt;assertIsArray($test-&gt;test_array);\n    }\n\n    public function testDate()\n    {\n        $test = TestCastsModel::create();\n        $test-&gt;setAttr('test_date', time());\n        $this-&gt;assertEquals(date(\"Y-m-d\"), $test-&gt;test_date);\n    }\n    public function testDateTime()\n    {\n        $test = TestCastsModel::create();\n        $test-&gt;setAttr('test_datetime', time());\n        $this-&gt;assertEquals(date(\"Y-m-d H:i:s\"), $test-&gt;test_datetime);\n    }\n","link":"/Components/Orm/definitionModel.html"},{"id":121,"title":"invoke执行","content":"orm invoke\n在高并发情况下，资源浪费的占用时间越短越好，可以提高程序的服务效率。\n在ORM默认情况下是使用defer方法获取pool内的连接资源，并在协程退出时自动归还，在此情况下，在带来便利的同时，会造成不必要资源的浪费。\n我们可以使用invoke方式，让ORM查询结束后马上归还资源，可以提高资源的利用率。\n$value = DbManager::getInstance()-&gt;invoke(function ($client){\n    $testUserModel = Model::invoke($client);\n    $testUserModel-&gt;state = 1;\n    $testUserModel-&gt;name = 'Siam';\n    $testUserModel-&gt;age = 18;\n    $testUserModel-&gt;addTime = date('Y-m-d H:i:s');\n    $data = $testUserModel-&gt;save();\n    return $data;\n});\nvar_dump($value);\n旧版本的invoke没有return值，请更新orm版本。\n方法支持\n在此种模式下，主要有两个方法需要讲解。\n\nDbManager下的invoke方法 （从连接池内获取一个连接，并在闭包完成时归还连接）\nModel的invoke方法 （注入客户端连接，不再从连接池内defer获取）\n\ninvoke中调试sql\n版本&gt;=1.2.12提供特性\n关于lastQueryResult、lastQuery返回内容，请查看章节模型执行结果、最后执行语句\n$client-&gt;lastQueryResult();\n$client-&gt;lastQuery();\n指定连接名和超时时间\nDbManager的invoke方法可以有3个传参\n\n第一个参数为闭包，在以上示例中已经体现\n第二个参数为连接名，非必选，可以指定要从哪个池中拿出链接\n第三个参数为超时时间，非必选，默认为3秒\n","link":"/Components/Orm/invoke.html"},{"id":122,"title":"自定义sql执行","content":"自定义SQL执行\n有时候你可能需要在查询中使用原生表达式。你可以使用 QueryBuilder 构造一个原生 SQL 表达式\nORM 内部依赖的是 mysqli 组件的QueryBuilder\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$queryBuild = new QueryBuilder();\n// 支持参数绑定 第二个参数非必传\n$queryBuild-&gt;raw(\"select * from test where name = ?\", ['siam']);\n// $queryBuild-&gt;raw(\"select * from test where name = 'siam'\");\n\n// 第二个参数 raw  指定true，表示执行原生sql\n// 第三个参数 connectionName 指定使用的连接名，默认 default\n$data = DbManager::getInstance()-&gt;query($queryBuild, true, 'default');\n\n通过Model执行\nuse EasySwoole\\Mysqli\\QueryBuilder;\n// 需要注意的是，这里的sql语句仅仅是示例\n// 正确推荐的做法应该仍然是查询Model类对应的表，得到表结构字段的数据\n$data = Model::create()-&gt;func(function ($builder){\n    $builder-&gt;where('userId',1)-&gt;get('user_list');\n});\n\n注意，func可以返回bool类型，当返回 true的时候，表示该builder 需要以raw 模式执行。\n\nuse EasySwoole\\Mysqli\\QueryBuilder;\n// 需要注意的是，这里的sql语句仅仅是示例\n// 正确推荐的做法应该仍然是查询Model类对应的表，得到表结构字段的数据\n$data = Model::create()-&gt;func(function ($builder){\n    $builder-&gt;raw('select * from user_list where userId = ?',[1]);\n    return true;\n});\n原生 SQL 表达式将会被当做字符串注入到查询中，因此你应该小心使用，避免创建 SQL 注入的漏洞。","link":"/Components/Orm/customSqlExecution.html"},{"id":123,"title":"模型执行结果","content":"执行结果\n当model执行一个语句之后,会将该次执行的结果保存到$model-&gt;lastQueryResult()中,该方法将返回一个EasySwoole\\ORM\\Db\\Result对象\n&lt;?php\n$model = new AdminModel();\n$model-&gt;all();\n//获取查询结果对象\n$lastResult = $model-&gt;lastQueryResult();\n//获取查询数据总数,查询时需要调用`withTotalCount`才可以使用该方法\nvar_dump($lastResult-&gt;getTotalCount());\n//获得最后插入的id\nvar_dump($lastResult-&gt;getLastInsertId());\n//获取执行影响的数据条数  update,delete等方法使用\nvar_dump($lastResult-&gt;getAffectedRows());\n//获取错误code\nvar_dump($lastResult-&gt;getLastErrorNo());\n//获取错误消息\nvar_dump($lastResult-&gt;getLastError());\n//获取执行mysql返回的结果\nvar_dump($lastResult-&gt;getResult());\n\n// 以下内容在版本&gt;=1.2.2后提供\n\n// 获取结果中的第一条\nvar_dump($lastResult-&gt;getResultOne());\n// 获取结果中某列\nvar_dump($lastResult-&gt;getResultColumn(string $column));\n// 获取结果中某列的第一条数据\nvar_dump($lastResult-&gt;getResultScalar(string $column));\n// 以某一个字段名为key 返回结果数组\nvar_dump($lastResult-&gt;getResultIndexBy(string $column));\n\n// 以下快速获取方式在版本&gt;=1.2.12后提供\nDbManager::getInstance()-&gt;getConnection()-&gt;defer()-&gt;lastQueryResult();\nAdminModel::defer()-&gt;lastQueryResult();\n当$model执行get,all,save等类似方法出错时,可通过调用getLastError方法获取错误消息用于调试","link":"/Components/Orm/lastResult.html"},{"id":124,"title":"最后执行语句","content":"最后执行语句\n当model执行一个语句之后,会将该次执行的语句对象保存到$model-&gt;lastQuery()中:\n&lt;?php\n$model = new AdminModel();\n//执行all查询\nvar_dump($model-&gt;all());\n//打印最后执行的`EasySwoole\\Mysqli\\QueryBuilder` 对象\nvar_dump($model-&gt;lastQuery());\n//打印最后执行的sql语句\nvar_dump($model-&gt;lastQuery()-&gt;getLastQuery());\n\n// 新版本orm提供\n$lastQuery = DbManager::getInstance()-&gt;getLastQuery()-&gt;getLastQuery(); // 第一个lastQuery是对象，第二次是从对象中取出语句\n$model->lastQuery() 返回的是query对象,具体文档可查看:查询构造器 文档","link":"/Components/Orm/lastQuery.html"},{"id":125,"title":"事务操作","content":"事务操作\n\nDbManager 链接管理器提供\n\nDbManager操作事务\n传参说明（代码示例看下文）\n\n\n\n参数类型\n参数说明\n\n\n\n\nstring或array\n值为connectionName，代表当前协程下连接名相符的mysql链接执行事务\n\n\nClientInterface\n在invoke闭包中直接传入client，代表直接操作指定客户端\n\n\n\n返回说明：bool  开启成功则返回true，开启失败则返回false\n\nDbManager-&gt;startTransaction($connection  = 'default' ); // 参数名默认为default\nDbManager-&gt;commit($connection = 'default'); // 如果不传，则提交当前协程下连接名称为default的事务\nDbManager-&gt;rollback($connection = 'default'); // 如果不传，则回滚当前协程下连接名称为default的事务\n\nClient 直接管理\n无需传参\n返回说明：bool  开启成功则返回true，开启失败则返回false\n\nClientInterface-&gt;startTransaction();\nClientInterface-&gt;commit();\nClientInterface-&gt;rollback();\n\n代码示例1\nDbManager 管理事务 ，可以开启多个连接名下的客户端事务，进行多连接事务管理\ntry{\n    //开启事务\n    DbManager::getInstance()-&gt;startTransaction();\n    $res = $model-&gt;update(['is_vip'=&gt;1]);\n} catch(\\Throwable  $e){\n    //回滚事务\n    DbManager::getInstance()-&gt;rollback();\n} finally {\n    //提交事务\n    DbManager::getInstance()-&gt;commit();\n}\n代码示例2\nDbManager 管理事务，传递参数为ClientInterface类型，指定操作客户端\n效果等同于示例3，直接操作客户端\n// 指定取出 write 连接名下的客户端，并且执行开启事务\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;invoke(function (EasySwoole\\ORM\\Db\\ClientInterface $client){\n    // 开启事务\n    \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;startTransaction($client);\n    // ...\n}, 'write');","link":"/Components/Orm/transactionOperations.html"},{"id":126,"title":"读写分离","content":"读写分离\n注册读写链接配置信息\n首先，我们需要按照 安装 注册 读 / 写 两个链接的信息\n主要代码大概如下\nDbManager::getInstance()-&gt;addConnection($con, 'read');\nDbManager::getInstance()-&gt;addConnection($con2, 'write');\n指定使用链接\n有两种方式可以使用 可以根据自己的需求选择\n主要利用AbstractModel提供的connection()方法\nfunction connection(string $name, bool $isTemp = false)\n第二个参数需要传入为true，表示临时使用，否则该认定为固定使用 建议只在临时使用时设置该方式，如果要固定使用则从Model类文件中定义。\nModel继承定义\nclass Test extends AbstractModel{\n    /** 这里因为不是使用默认的配置链接名 所以需要指定 */\n    protected $connectionName = 'write';\n\n    /** get 方法使用读链接 */\n    public function get($where = null, bool $returnAsArray)\n    {\n        $this-&gt;connection('read', true);\n        return parent::get($where, $returnAsArray);\n    } \n}\n外部使用\nTest::create()-&gt;connection('read',true)-&gt;all();","link":"/Components/Orm/readWriteSeparation.html"},{"id":127,"title":"查询","content":"查询\n查询一行\n\nget($where)\n\n查询多行\n\nall($where)\n\n返回值说明\n\n\nget返回的是一个 EasySwoole\\ORM\\AbstractModel 实例，可以复用进行模型的其他操作 当没有查询结果时返回 null \n\nall返回的是一个数组，里面的每一个元素都是  EasySwoole\\ORM\\AbstractModel 实例\n\n多种传参方式\n在以上方法列表中，最重要的是$where参数，可以实现多种使用方式\n// 通过主键\n$res = UserModel::create()-&gt;get(1);\n// 通过key=&gt;value 数组\n$res = UserModel::create()-&gt;get([\n  'u_id'    =&gt; 1,\n  'u_state' =&gt; 0,\n  'is_vip'  =&gt; 1\n]);\n// 通过闭包方式，构造复杂的sql\n// 这是一种很强大灵活的方式，闭包的参数是一个mysqli组件的查询构造器，可以调用所有连贯操作\n// http://www.easyswoole.com/Components/Mysqli/builder.html\n$res = UserModel::create()-&gt;get(function(QueryBuilder $queryBuilder){\n    $queryBuilder-&gt;where('u_state', 1);\n    $queryBuilder-&gt;where('age', 12, '&gt;');// 各种特殊操作符  between like != 等等都可以完成\n    $queryBuilder-&gt;order('u_id');\n});\n// 连贯操作，继续可以往下查看ORM的文档\n$res = UserModel::create()-&gt;where('u_id', 1)-&gt;get();\n分页\nlimit和withTotalCount，获取分页列表数据以及总条数。\n下面模拟获取分页列表数据，page为页码，limit为每页显示多少条数。\n$page = 1;          // 当前页码\n$limit = 10;        // 每页多少条数据\n\n$model = AdminModel::create()-&gt;limit($limit * ($page - 1), $limit)-&gt;withTotalCount();\n\n// 列表数据\n$list = $model-&gt;all(null);\n\n$result = $model-&gt;lastQueryResult();\n\n// 总条数\n$total = $result-&gt;getTotalCount();\n快速查询\n获取查询结果某一列的值，如果 $column 为空，则会返回查询结果的第一列\n\ncolumn(?string $column = null): ?array\n\n获取查询结果某一列第一行的值，如果 $column 为空，则会返回查询结果的第一列第一行的值\n\nscalar(?string $column = null): ?array\n\n获取结果并使用某一列的作为索引\n\nindexBy(string $column): ?array\n\n$nameList = UserListModel::create()-&gt;column('name');\n/*\n会返回类似这样的数组\n[\n  'tom',\n  'tony',\n  'alex'\n  'ben'\n]\n */\n\n$name = UserListModel::create()-&gt;scalar('name');\n$age = UserListModel::create()-&gt;limit(1)-&gt;scalar('age');\n/*\n会返回单个值\n$name = 'tom';\n$age = 12;\n*/\n\n$userList = UserListModel::create()-&gt;indexBy('age');\n/*\n会返回类似这样的数组\n[\n  '12' =&gt; [\n    'tom',\n    'tony'\n  ],\n  '13' =&gt; [\n    'alex',\n  ]\n  '14' =&gt; [\n    'ben',\n  ]\n]\n */\n\ncolumn，scalar，indexBy 这三个方法都是对 all 方法的封装。\nscalar 方法只是返回查询结果当中的某一列第一行的值， 条件语句中不会自动加上 LIMIT 1 条件。\ncolumn，scalar，indexBy 这三个方法在获取数据失败时会返回 null ，获取数据失败时不一定查询失败，也可能返回的数据里没有对应的列名\n\nnull条件查询\n如果需要查询 为null/不为null 的数据.\n$model = new \\App\\Model\\RequestLogModel();\n$model-&gt;where('a',null,'is')-&gt;get();\n$model-&gt;where('a',null,'is not')-&gt;get();","link":"/Components/Orm/query.html"},{"id":128,"title":"转换数组","content":"结果转换数组\n查询后将对象转为数组\n传参\ntoArray和toRawArray传参一致\n\n\n\n参数名\n参数说明\n\n\n\n\nnotNull\n是否过滤空，bool类型 默认false，当为true时，只返回非空字段\n\n\nstrict\n严格模式，bool类型 默认true，当为true时，只返回当前模型对应数据表的字段，其他field别名等不返回。\n\n\n\n示例\n经过获取器\n$model = Model::create()-&gt;get(1);\n$array = $model-&gt;toArray();\n\n$model = Model::create()-&gt;all();\nforeach($model as $one){\n    var_dump($one-&gt;toArray());\n}\n不经过获取器\n$model = Model::create()-&gt;get(1);\n$array = $model-&gt;toRawArray();\n\n$model = Model::create()-&gt;all();\nforeach($model as $one){\n    var_dump($one-&gt;toRawArray());\n}\n筛选\norm &gt; 1.4.4\n在调用toArray或toRawArray之前。可以通过调用field()和hidden()方法进行返回数据的筛选\n两个方法的传参为array|string,string代表只过滤一个字段\n$field = $model-&gt;field(['user_list'])-&gt;toArray(false, false); // 返回的数组里只有user_list一个元素\n$hidden = $model-&gt;hidden('user_list')-&gt;toArray(false, false); // 返回的数组里过滤了user_list元素\n\ntoArray数据集\n如果设置了returnCollection为true，无需进行foreach。可直接：\n\\EasySwoole\\ORM\\Tests\\models\\TestUserModel::create()-&gt;all()-&gt;toArray();\n追加\n追加非模型字段的属性，必须设置获取器。\n\\EasySwoole\\ORM\\Tests\\models\\TestUserModel::create()-&gt;all()-&gt;append(['a' =&gt; 1])-&gt;toArray();\n显示\n显示指定字段。\n\\EasySwoole\\ORM\\Tests\\models\\TestUserModel::create()-&gt;all()-&gt;visible(['username','password'])-&gt;toArray();\n隐藏\n隐藏指定字段。\n\\EasySwoole\\ORM\\Tests\\models\\TestUserModel::create()-&gt;all()-&gt;hidden(['password'])-&gt;toArray();","link":"/Components/Orm/toArray.html"},{"id":129,"title":"快捷查询","content":"快捷查询\n依赖关系\n\nmysqli &gt;=2.1.2\nORM &gt;= 1.2.5\n\n查询单行指定字段值\n\nval(string $column)\nscalar(?string $column = null)\n\n查询多行指定字段值\n\ncolumn(?string $column = null)\nindexBy(string $column)\n\n返回值说明\n\n\nval 当存在该行数据并字段存在时，返回该字段值。\n字段不存在时，返回该行数据数组。\n该行不存在时，返回null\n\n\nscalar 当符合条件数据存在时，返回首条数据字段值。\n当符合条件不存在时，返回空数组。\n当不传参数时，默认返回主键值。\n\n\ncolumn 返回该字段值的数组。\n当参数不传时，默认返回主键数组。\n\n\nindexBy返回以指定字段为Key的数据数组。\n\n\n示例\n\n// val 直接返回某一行的某一列\n$res = UserModel::create()-&gt;val('loginName');\nvar_dump($res);\n\n// column 快速查询结果的某一列\n$res = UserModel::create()-&gt;column('loginName');\nvar_dump($res);\n\n// scalar 快速查询结果的某一列的第一条数据\n$res = UserModel::create()-&gt;scalar('loginName');\nvar_dump($res);\n\n// indexBy 以某个字段名的数据返回结果数组\n$res = UserModel::create()-&gt;indexBy('loginName');\nvar_dump($res);\n","link":"/Components/Orm/quickQuery.html"},{"id":130,"title":"特殊条件查询","content":"特殊条件查询\nfind_in_set\n生成条件  find_in_set(1, name)\n? 代表参数绑定，可以直接写明条件，第二个参数不传递即可，但需要注意防范注入风险\n$data = Model::create()-&gt;where(\"find_in_set(?, name)\", [1])-&gt;get();\n复杂where or\n// 生成大概语句：where status = 1 AND (id &gt; 10 or id &lt; 2)\nModel::create()-&gt;where('status', 1)-&gt;where(' (id &gt; 10 or id &lt;2) ')-&gt;get();\nlock table\nModel::create()-&gt;func(function ($builder){\n  // ...\n  $builder-&gt;lockTable(\"tableName\");\n  // ...\n});\n释放表锁\nModel::create()-&gt;func(function ($builder){\n  // ...\n  $builder-&gt;unlockTable();\n  // ...\n});\nselect for update\nModel::create()-&gt;get(function ($builder){\n  // ...\n  $builder-&gt;selectForUpdate();\n  // ...\n});","link":"/Components/Orm/specialQuery.html"},{"id":131,"title":"新增","content":"新增\n要往数据库新增一条记录，先创建新模型实例，给实例设置属性，然后调用 save 方法：\n$model = new UserModel();\n// 不同设置值的方式\n$model-&gt;setAttr('id', 7);\n$model-&gt;name = 'name';\n$model['name'] = 'name';\n\n$res = $model-&gt;save();\nvar_dump($res); // 返回自增id 或者主键的值  失败则返回null\n在这个示例中，我们将 id 和 name 赋值给了 UserModel 模型实例的 id 和 name 属性。当调用 save 方法时，将会插入一条新记录\n数组赋值\n可以传入数组[字段名=&gt;字段值] 再调用 save 方法保存\n$model = UserModel::create([\n    'name' =&gt; 'siam',\n    'age'  =&gt; 21,\n]);\n\n$res = $model-&gt;save();\n// data($data, $setter = true)  \n// 第二个参数 可以决定是否要调用修改器（如果要设置的话   下面的文档有说明）\n$user = UserModel::create()-&gt;data([\n    'name' =&gt; 'siam',\n    'age'  =&gt; 21,\n], false)-&gt;save();\n批量插入\nsaveAll可以传递二维数组，批量插入数据，但由于ORM的工作职责，他需要将数据映射为对象，所以在内部处理中还是通过遍历处理，而非一条sql插入\n（如果有此需求的用户请自行自定义执行sql语句）（mysqli组件中提供了 insertMulti `方法，ORM可以使用func方式调用）\nfunction saveAll($data, $replace = true, $transaction = true)\n参数说明\n\n数据，二维数组\n是否覆盖，意思为：如果在数组中包含了pk主键的值，那么则操作为更新 if ( $replace &amp;&amp; isset($row[$pk]) )\n\n是否开启事务，默认为true，如果是已经手动开启过事务，并在中间调用saveAll，则需要关闭这里的事务，否则因为内部代码的开启事务，导致你的程序执行逻辑异常。\n","link":"/Components/Orm/add.html"},{"id":132,"title":"删除","content":"删除\n删除记录使用 destroy 方法, 方法可以传入多种表达类型参数. 执行后返回影响的记录数\n通过 已有Model\n这种方式是我们最推荐的，也是ORM这种组件的核心思想，把数据的操作映射为对对象的操作。\n$user = UserModel::create()-&gt;get(1);\n$user-&gt;destroy();\n通过 主键\n$res = UserModel::create()-&gt;destroy(1); //通过直接指定主键(如果存在)\n$res = UserModel::create()-&gt;destroy('2,4,5');//指定多个参数每个参数为不同主键\n$res = UserModel::create()-&gt;destroy([3, 7]);//数组指定多个主键\n通过 where 条件\n$res = UserModel::create()-&gt;destroy(['age' =&gt; 21]);//数组指定 where 条件结果来删除\n$res = UserModel::create()-&gt;destroy(function (QueryBuilder $builder) {\n    $builder-&gt;where('id', 1);\n});\n删除全表数据\n如果你需要清空表，你可以使用 destroy 方法传入 (null,true)，它将删除所有行\n$res = UserModel::create()-&gt;destroy(null,true);","link":"/Components/Orm/delete.html"},{"id":133,"title":"更新","content":"更新\n\nOrm的功能是依赖于mysqli 2.x组件的，update的$data参数将会传递给mysqli构造sql。\n所以我们可以直接使用大部分mysqli的功能\n\n通过 已有Model\n这种方式是我们最推荐的，也是ORM这种组件的核心思想，把数据的操作映射为对对象的操作。\n$user = UserModel::create()-&gt;get(1);\n$user-&gt;update([\n  'is_vip' =&gt; 1\n]);\n\n$user = UserModel::create()-&gt;get(1);\n//获取后指定字段赋值\n$user-&gt;is_vip = 1;\n$user-&gt;update();\n通过 where 更新\nupdate 参数1传入更新数组[字段名=&gt;字段值],参数2传递 where 条件数组\n$res = UserModel::create()-&gt;update([\n    'name' =&gt; 'new'\n], ['id' =&gt; 1]);\n实际更新影响的行数\nupdate返回的是执行语句是否成功,只有mysql语句出错时才会返回false,否则都为true\n,所以需要getAffectedRows来判断是否更新成功\n$user = UserModel::create()-&gt;get(1);\n$user-&gt;update([\n  'is_vip' =&gt; 1\n]);\nvar_dump($user-&gt;lastQueryResult()-&gt;getAffectedRows());\n获取具体语法错误\nupdate如果返回了false,那么代表你的语句有错误,可通过getLastError获取具体错误信息\n$user = UserModel::create()-&gt;get(1);\n$suc = $user-&gt;update([\n  'is_vip' =&gt; 1\n]);\nif($suc=== false){\n    var_dump($user-&gt;lastQueryResult()-&gt;getLastError());\n}\n生效字段说明\n模型内数据分为正常数据、附属数据两种。\n如果是表结构拥有字段的数据，则属于正常数据，其他则属于附属数据。\n推荐更新用法\n先通过model映射出正确的数据对象，然后再改变值，更新。\n将会自动生效表结构内的字段。其他附属数据不会组成update sql。\n$user = UserModel::create()-&gt;get(1);\n$user-&gt;is_vip = 1;\n$user['vip_time'] = 15;\n$res = $user-&gt;update();\n批量更新\n通过这种方式，不会过滤非表结构字段的数据，全部组成sql，可能造成mysql错误。\n$res = UserModel::create()-&gt;update([\n  'is_vip' =&gt; 0,\n  'test' =&gt; 3333,// 表结构不存在的字段\n], [\n  'vip_time' =&gt; 0\n]);\n快捷更新\nTestUserModel::create()-&gt;update([\n    'age' =&gt; QueryBuilder::inc(3), // 自增3\n    'test' =&gt; QueryBuilder::dec(4), // 自降4\n], [\n    'name' =&gt; 'Siam222'\n]);","link":"/Components/Orm/update.html"},{"id":134,"title":"连贯操作","content":"连贯操作\nORM提供的链式操作方法，可以有效的提高数据存取的代码清晰度和开发效率。\nwhere\n你可以使用 where 方法。调用 where 最基本的方式是需要传递一个参数\n这个参数可以传递多种不同表现:\n主键\n// 主键\n$user = UserListModel::create()-&gt;where(1)-&gt;get();\n\n// 多个主键\n$user = UserListModel::create()-&gt;where([1,2,3])-&gt;all();\n数组\n// [字段名=&gt; 字段值]数组方式\n$user = UserListModel::create()-&gt;where(['state' =&gt; 1])-&gt;get();\n\n// 复杂条件数组\n$user = UserListModel::create()-&gt;where([\n    'age'  =&gt; [[18,23], 'between'],\n    'name' =&gt; ['siam', 'like', 'or'],\n])\n原生sql\n$user = UserListModel::create()-&gt;where(\"sql 语句 需要自己注意注入风险\")-&gt;get();\n其他Mysqli链式操作里的where传参\nORM where 操作也可以实现 EasySwoole\\Mysqli\\QueryBuilder 中的 where 操作\n更多操作还可以查阅Mysqli链式操作里的where章节\n// 走builder原生的where\n$getCoherent5 = UserListModel::create()-&gt;where('id', 1, '=')-&gt;get();\n$getCoherent6 = UserListModel::create()-&gt;where('id', 1, '!=')-&gt;get();\n$getCoherent6 = UserListModel::create()-&gt;where('id', 1, 'like')-&gt;get();\nalias\nalias用于设置当前数据表的别名\n$res = TestUserListModel::create()-&gt;alias('siam')-&gt;where(['siam.name' =&gt; 'test'])-&gt;all();\ngroup\ngroup 方法可以将结果分组。\n$group = TestUserListModel::create()-&gt;field('sum(age) as age, `name`')-&gt;group('name')-&gt;all(null);\norder\norder 方法可用于将原生字符串设置为 order by 子句的值：\n$order = TestUserListModel::create()-&gt;order('id', 'DESC')-&gt;get();\njoin\njoin通常有下面几种类型，不同类型的join操作会影响返回的数据结果。\n\nINNER JOIN: 等同于 JOIN（默认的JOIN类型）,如果表中有至少一个匹配，则返回行\nLEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行\nRIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行\nFULL JOIN: 只要其中一个表中存在匹配，就返回行\n\nobject join ( mixed $joinTable , string $joinCondition = null [, string $type = 'INNER'] )\n$joinTable 要关联的（完整）表名以及别名\n$joinCondition 关联条件.\n$type 关联类型。可以为:'LEFT', 'RIGHT', 'OUTER', 'INNER', 'LEFT OUTER', 'RIGHT OUTER', 'NATURAL'，不区分大小写，默认为INNER(数据库软件 默认)。\n$join = TestUserListModel::create()-&gt;join('table2','table2.col1 = user_list.col2')-&gt;get();\n\n$join2 = TestUserListModel::create()-&gt;alias('list')-&gt;join('table2 as t2','t2.col1 = list.col2')-&gt;get();","link":"/Components/Orm/coherentOperation.html"},{"id":135,"title":"聚合","content":"聚合\nORM 还提供了各种聚合方法，比如 count, max，min， avg，还有 sum。你可以在构造查询后调用任何方法：\nmax\n$max = TestUserListModel::create()-&gt;max('age');\nmin\n$min = TestUserListModel::create()-&gt;min('age');\ncount\n// count 不必传字段名\n$count = TestUserListModel::create()-&gt;count();\navg\n$avg = TestUserListModel::create()-&gt;avg('age');\nsum\n$sum = TestUserListModel::create()-&gt;sum('age');","link":"/Components/Orm/aggregation.html"},{"id":136,"title":"获取器","content":"获取器\n获取器的作用是在获取数据的字段值后自动进行处理\n若要定义一个获取器，则须在你的模型上创建一个 「get 字段名 Attr」 方法。\n要访问的字段的获取器方法需使用「小驼峰」来命名。在这个例子中，我们将为 status 属性定义一个访问器。\n数据表的字段会在使用获取器时自动转换为驼峰法访问\n当 ORM实例 尝试获取 status 的值时，将会自动调用此访问器：\nclass UserModel extends AbstractModel\n{ \n    /**\n     * $value mixed 是原值\n     * $data  array 是当前model所有的值 \n     */\n    protected function getStatusAttr($value, $data)\n    {\n        $status = [-1=&gt;'删除',0=&gt;'禁用',1=&gt;'正常',2=&gt;'待审核'];\n        return $status[$value];\n    }\n}\n获取器还可以定义数据表中不存在的字段，例如：\nprotected function getEasyswooleAttr($value,$data)\n{\n  return 'Easyswoole用户-'.$data['id'];\n}\n那么在外部我们就可以使用这个easyswoole字段了\n$res = UserModel::create()-&gt;get(4);\nvar_dump($res-&gt;easyswoole);","link":"/Components/Orm/getter.html"},{"id":137,"title":"修改器","content":"修改器\n修改器的作用是在模型实例修改字段赋值时自动进行处理\n若要定义一个修改器，则须在你的模型上创建一个 「set 字段名 Attr」 方法。\n要定义的修改器方法需使用「小驼峰」来命名。在这个例子中，我们将为 name 属性定义一个修改器。\n数据表的字段会在使用获取器时自动转换为驼峰法访问\n当 模型实例 尝试修改 name字段的值时，将会自动调用此修改器：\nclass UserModel extends AbstractModel\n{\n    /**\n     * $value mixed 是原值\n     * $data  array 是当前model所有的值 \n     */\n    protected function setNameAttr($value, $data)\n    {\n        return $value.\"_加一个统一后缀\";\n    }\n}\n如下代码在设置保存的时候将会被修改器处理后保存\n$model = new UserModel([\n    'name' =&gt; 'siam',\n    'age'  =&gt; 21,\n]);\n$model-&gt;save();\n//name 存入后值为: siam_加一个统一后缀","link":"/Components/Orm/modifier.html"},{"id":138,"title":"示例","content":"ORM关联查询示例\n简单介绍一下关联查询的使用场景和方法\n表结构和数据准备\nusers 用户表\n| user_id | user_name  |\n| ------- | ---------- |\n| 1       | Siam(宣言) |\nphones 手机信息表\n| phone_id | can_use | user_id | phone_name |\n| -------- | ------- | ------- | ---------- |\n| 1        | 1       | 1       | 诺基亚A1   |\n| 2        | 0       | 1       | 苹果11     |\n| 3        | 1       | 2       | 三星ZD     |\n定义模型的步骤就不说了，这是ORM的基础使用。\n应用场景\n我们现在需要提供一个接口，根据user_id来查询用户的信息，以及这个用户名下的所有手机信息\n正常我们需要new两个模型、手动传参来获取手机信息，但是使用关联查询，可以简化这个过程\n定义关联关系\n首先我们需要在模型文件中定义两者的关系（用于查询时自动构建条件语句）\n\nclass Users extends AbstractModel\n{\n    protected $tableName = 'users';\n\n    public function phones(){\n        // users的phones方法，指向Phones模型，也就是phones表\n        // 第二个参数用于更灵活的筛选目标数据，不修改则传递null\n        // 第三个参数代表：根据Users模型的user_id字段的值去获取目标数据\n        // 第四个参数代表：Phones表上当做条件语句的字段名\n        // 构建的语句大概为  select * from phones where user_id(第四个参数) = $Users.user_id (第三个参数)\n        return $this-&gt;hasMany(Phones::class, function ($builder){\n        }, 'user_id', 'user_id');\n    }\n}\n使用，返回的数据就是拥有手机信息列表的\n$user   = Users::create()-&gt;get(1);\n$phones = $user-&gt;phones(); // 这一步可以用预查询完成 简化语句\n\n$this-&gt;response()-&gt;write(json_encode($user));\n更灵活的筛选数据方式\n第二个参数是一个闭包，可以很灵活地调用mysqli中的QueryBuilder方法\n//状态正常的手机信息\npublic function phones(){\n    return $this-&gt;hasMany(Phones::class, function ($builder){\n        $builder-&gt;where('can_use', 1);\n    }, 'user_id', 'user_id'); // 这里填写主表字段的值储存在附表的哪个字段上\n}\n// 排序\npublic function phones_desc(){\n    return $this-&gt;hasMany(Phones::class, function ($builder){\n        $builder-&gt;orderBy('phone_id', \"DESC\");\n    }, 'user_id', 'user_id'); // 这里填写主表字段的值储存在附表的哪个字段上\n}\n// 返回部分数据\npublic function phones_limit(){\n    return $this-&gt;hasMany(Phones::class, function ($builder){\n        $builder-&gt;limit(1);\n    }, 'user_id', 'user_id'); // 这里填写主表字段的值储存在附表的哪个字段上\n}\n\n// where筛选\npublic function iphone(){\n    return $this-&gt;hasOne(Phones::class, function($builder){\n        $builder-&gt;where('phone_name', \"苹果11\");\n    }, 'user_id', 'user_id');\n}\n\n// 返回指定字段\npublic function iphone_field(){\n    return $this-&gt;hasOne(Phones::class, function($builder){\n        $builder-&gt;where('phone_name', \"苹果11\");\n        $builder-&gt;fields(\"phone_name, user_id\");\n    }, 'user_id', 'user_id');\n}","link":"/Components/Orm/Associat/example.html"},{"id":139,"title":"一对一关联","content":"一对一关联\n定义\n例如，一个 User 模型可能关联一个 Relation 模型。\n为了定义这个关联，我们要在 User 模型中写一个 relation 方法。在 relation 方法内部调用 hasOne 方法并返回其结果:\nhasOne 方法的第一个参数是关联模型的类名。\npublic function relation()\n{\n    return $this-&gt;hasOne(Relation::class);\n}\n模型关联方法允许你向关联加入自定义限制\n以下案例表示：Relation表中的u_id等于当前模型(假设为User)的id值\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\npublic function settingWhere()\n{\n    return $this-&gt;hasOne(Relation::class, function(QueryBuilder $query){\n        $query-&gt;where('u_id', $this-&gt;id);\n        $query-&gt;where('status', 1);\n        return $query;\n    });\n}\nORM 会自动基于关联模型的主键列进行关联。\n在这种情况下，会自动使用 Relation id 主键。如果你想覆盖这个约定，可以传递第三个参数和第四个参数给 hasOne 方法：\n第三个参数为当前模型的 column, 第四个参数为关联模型的对应 column\npublic function settingWhere()\n{\n    return $this-&gt;hasOne(Relation::class, null, 'id', 'user_id');\n}\n使用\n一旦定义了模型关联，我们就可以使用 ORM 动态属性获得相关的记录。动态属性允许你访问关系方法就像访问模型中定义的属性一样：\n如果查询不到则为null  查询得到则为一个模型类的实例 可以继续调用ORM的方式 快速更新 删除等\n$res = User::create()-&gt;get(1);\n$hasOneRelation = $res-&gt;relation; //访问实际是 relation 方法处理后的结果; 返回的是Relation模型对象\n\n$userid = $hasOneRelation-&gt;user_id;","link":"/Components/Orm/Associat/oneToOneAssociations.html"},{"id":140,"title":"一对多关联","content":"一对多关联\n定义\n例如，一个 User 模型可能关联多个 Relation 模型。\n为了定义这个关联，我们要在 User 模型中写一个 relation 方法。在 relation 方法内部调用 hasMany 方法并返回其结果:\nhasMany 方法的第一个参数是关联模型的类名。\npublic function relation()\n{\n    return $this-&gt;hasMany(Relation::class);\n}\n模型关联方法允许你向关联加入自定义限制\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\npublic function settingWhere()\n{\n    return $this-&gt;hasMany(Relation::class, function(QueryBuilder $query){\n        $query-&gt;where('u_id', $this-&gt;id);\n        $query-&gt;where('status', 1);\n        return $query;\n    });\n}\nORM 会自动基于关联模型的主键列进行关联。\n在这种情况下，会自动使用 Relation id 主键。如果你想覆盖这个约定，可以传递第三个参数和第四个参数给 hasMany 方法：\n第三个参数为当前模型的 column, 第四个参数为关联模型的对应 column\npublic function settingWhere()\n{\n    return $this-&gt;hasMany(Relation::class, null, 'id', 'user_id');\n}\n使用\n一旦定义了模型关联，我们就可以使用 ORM 动态属性获得相关的记录。动态属性允许你访问关系方法就像访问模型中定义的属性一样：\n如果查询不到则为null  查询得到则为一个数组, 每个数组元素都是模型类的实例 可以继续调用ORM的方式 快速更新 删除等\n$userModel = User::create()-&gt;get(1);\n$hasManyRelation = $userModel-&gt;relation; //访问实际是 relation 方法处理后的结果; 返回的是数组 每个数组元素都是 Relation 模型对象\n\n$userId = [];\nforeach($res-&gt;relation as $relationModel) {\n    $userId[] = $relationModel-&gt;user_id;\n}","link":"/Components/Orm/Associat/oneToManyAssociations.html"},{"id":141,"title":"关联预查询","content":"关联预查询\n在普通关联中，我们在Model类文件中定义了关系后，即可快速关联查询数据。\n但在此时仍然需要我们手动获取该关联名才会执行。\n预查询提供了一种主数据查询后，马上自动查询关联数据的用法。\norm版本需要&gt;= 1.2.0\nwith方法\nwith方法传入一个数组，内容为已经在类文件中定义好的关联名\n$res = Model::create()-&gt;with(['user_list', 'user_store'])-&gt;get(1);\n\nvar_dump($res); // 此时已经有user_list,user_sotre两个关联字段的数据，不再需要先手动调用一次。\n支持传参数操作：\norm &gt;= 1.4.25\n\n$res = Model::create()-&gt;with(['user_list' =&gt; ['a' =&gt; 1, 'b' =&gt; 2]])-&gt;get(1);\n$res = Model::create()-&gt;with(['user_list' =&gt; 'test'])-&gt;get(1);\n\n// 伪代码\nfunction user_list($data){\n    var_dump($data); // a =&gt; 1 b=&gt; 2 or test\n}","link":"/Components/Orm/Associat/preWithQuery.html"},{"id":142,"title":"回调事件","content":"回调事件\n针对全局 onQuery\n针对全局设置回调事件方式如下:\n// 注册ORM时, 调用回调函数\npublic static function mainServerCreate(EventRegister $register)\n{\n    ...\n\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n    DbManager::getInstance()-&gt;onQuery(function ($res, $builder, $start) {\n        // 打印参数 OR 写入日志\n    });\n}\nonQuery回调会注入三个参数\n\n\nres查询结果对象, 类名为EasySwoole\\ORM\\Db\\Result\n\n\n可以参考 执行结果 文档, 以获取更多的结果内容\n\n\nbuilder查询语句对象, 类名为EasySwoole\\Mysqli\\QueryBuilder\n\n\nstart开始查询时间戳, 单位为s, 类型为float\n\n\n如果查询过程中调用withTotalCount()方法, 那么还会产生第二个回调结果\n需要注意的是, 此回调方法务必在注册ORM时调用, 否则不会产生任何结果\n针对特定模型 onQuery\n如果不想使用全局性的onQuery, 我们可以在执行操作的时候调用onQuery方法, 以此来实现针对特定模型的回调\n$res = User::create()-&gt;onQuery(function ($res, $builder, $start) {\n    // 打印参数 OR 写入日志\n})-&gt;get(1);\n回调注入的三个参数与全局性onQuery相同\n记录慢日志\n我们可以通过手动判断执行时间, 来实现一个记录慢日志的功能\npublic static function mainServerCreate(EventRegister $register)\n{\n    ...\n\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n    DbManager::getInstance()-&gt;onQuery(function ($res, $builder, $start) {\n        $queryTime = 查询时间阈值;\n        if (bcsub(time(), $start, 3) &gt; $queryTime) {\n            // 写入日志\n        }\n    });\n}","link":"/Components/Orm/Event/onQuery.html"},{"id":143,"title":"模型事件","content":"模型事件\n模型事件是指模型在执行写入, 修改, 删除操作的时候触发的行为事件\n方法列表\n\n\n\n事件名称\n事件说明\n参数\n\n\n\n\nonBeforeInsert\n插入前事件\n$model\n\n\nonAfterInsert\n插入后事件\n$model, $res\n\n\nonBeforeUpdate\n更新前事件\n$model\n\n\nonAfterUpdate\n更新后事件\n$model, $res\n\n\nonBeforeDelete\n删除前事件\n$model\n\n\nonAfterDelete\n删除后事件\n$model, $res\n\n\n\n\n$model 当前模型实例\n$res 当前行为执行结果, 当执行失败时类型统一为bool型false, 当执行成功时有两种情况:\n执行onAfterDelete事件: int型 影响记录数, 其他事件: bool型 true\n\n如果ORM版本低于1.1.19将无法使用模型事件\nclass User extends AbstractModel\n{\n    /**\n     * @var string\n     */\n    protected $tableName = 'users';\n\n    public static $insert = false;\n    public static $update = false;\n    public static $delete = false;\n\n    protected static function onBeforeInsert($model)\n    {\n        return self::$insert;\n    }\n\n    protected static function onAfterInsert($model, $res)\n    {\n\n    }\n\n    protected static function onBeforeUpdate($model)\n    {\n        return self::$update;\n    }\n\n    protected static function onAfterUpdate($model, $res)\n    {\n\n    }\n\n    protected static function onBeforeDelete($model)\n    {\n        return self::$delete;\n    }\n\n    public static function onAfterDelete($model, $res)\n    {\n\n    }\n}","link":"/Components/Orm/Event/model.html"},{"id":144,"title":"tcp服务","content":"TCP\nEasySwoole创建TCP服务器，有两种以下方式：\n主服务\n修改配置文件MAIN_SERVER.SERVER_TYPE为EASYSWOOLE_SERVER。\nEasySwooleEvent中mainServerCreate事件进行回调注册：\npublic static function mainServerCreate(\\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register)\n{\n    $register-&gt;add($register::onConnect, function (\\Swoole\\Server $server, int $fd, int $reactor_id) {\n        echo \"fd {$fd} connected\";\n    });\n\n    $register-&gt;add($register::onReceive, function (\\Swoole\\Server  $server, int $fd, int $reactor_id, string $data) {\n        echo \"fd:{$fd} send:{$data}\\n\";\n    });\n\n    $register-&gt;add($register::onClose, function (\\Swoole\\Server  $server, int $fd, int $reactor_id) {\n            echo \"fd {$fd} closed\";\n    });\n}\n子服务\n顾名思义：另开一个端口进行tcp监听。\nEasySwooleEvent中mainServerCreate事件，进行子服务监听：\npublic static function mainServerCreate(\\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register)\n{\n    $server = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer();\n\n    $subPort = $server-&gt;addlistener('0.0.0.0', 9502, SWOOLE_TCP);\n    $subPort-&gt;set([\n        // swoole 相关配置\n        'open_length_check' =&gt; false,\n    ]);\n    $subPort-&gt;on($register::onConnect, function (\\Swoole\\Server $server, int $fd, int $reactor_id) {\n            echo \"fd {$fd} connected\";\n    });\n\n    $subPort-&gt;on($register::onReceive, function (\\Swoole\\Server  $server, int $fd, int $reactor_id, string $data) {\n        echo \"fd:{$fd} send:{$data}\\n\";\n    });\n\n    $subPort-&gt;on($register::onClose, function (\\Swoole\\Server  $server, int $fd, int $reactor_id) {\n            echo \"fd {$fd} closed\";\n    });\n}","link":"/Socket/tcp.html"},{"id":145,"title":"tcp服务器处理粘包","content":"TCP 服务器处理粘包\n粘包问题\n由于tcp的特性,可能会出现数据粘包情况,例如   \n\nA连接Server\nA发送 hello \nA又发送了一条 hello\nServer可能会一次性收到一条&quot;hellohello&quot;的数据\nServer也可能收到&quot;he&quot; ,&quot;llohello&quot;类似这样的中断数据\n\n粘包解决\n\n通过标识EOF,例如http协议,通过\\r\\n\\r\\n 的方式去表示该数据已经完结,我们可以自定义一个协议,例如当接收到 &quot;结尾666&quot; 字符串时,代表该字符串已经结束,如果没有获取到,则存入缓冲区,等待结尾字符串,或者如果获取到多条,则通过该字符串剪切出其他数据\n定义消息头,通过特定长度的消息头进行获取,例如我们定义一个协议,前面10位字符串都代表着之后数据主体的长度,那么我们传输数据时,只需要000000000512346(前10位为协议头,表示了这条数据的大小,后面的为数据),每次我们读取只先读取10位,获取到消息长度,再读取消息长度那么多的数据,这样就可以保证数据的完整性了.(但是为了不被混淆,协议头也得像EOF一样标识)\n通过pack二进制处理,相当于于方法2,将数据通过二进制封装拼接进消息中,通过验证二进制数据去读取信息,sw采用的就是这种方式\n\n可查看swoole官方文档:https://wiki.swoole.com/wiki/page/287.html\n实现粘包处理\n服务端:\n&lt;?php\n$subPort2 = $server-&gt;addlistener('0.0.0.0', 9503, SWOOLE_TCP);\n$subPort2-&gt;set(\n    [\n        'open_length_check'     =&gt; true,\n        'package_max_length'    =&gt; 81920,\n        'package_length_type'   =&gt; 'N',\n        'package_length_offset' =&gt; 0,\n        'package_body_offset'   =&gt; 4,\n    ]\n);\n$subPort2-&gt;on('connect', function (\\swoole_server $server, int $fd, int $reactor_id) {\n    echo \"tcp服务2  fd:{$fd} 已连接\\n\";\n    $str = '恭喜你连接成功服务器2';\n    $server-&gt;send($fd, pack('N', strlen($str)) . $str);\n});\n$subPort2-&gt;on('close', function (\\swoole_server $server, int $fd, int $reactor_id) {\n    echo \"tcp服务2  fd:{$fd} 已关闭\\n\";\n});\n$subPort2-&gt;on('receive', function (\\swoole_server $server, int $fd, int $reactor_id, string $data) {\n    echo \"tcp服务2  fd:{$fd} 发送原始消息:{$data}\\n\";\n    echo \"tcp服务2  fd:{$fd} 发送消息:\" . substr($data, '4') . \"\\n\";\n});\n客户端:\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/3/6 0006\n * Time: 16:22\n */\ninclude \"../vendor/autoload.php\";\ndefine('EASYSWOOLE_ROOT', realpath(dirname(getcwd())));\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n//::: warning \n//在3.3.7版本后,initialize事件调用改为:`EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()-&gt;globalInitialize();`\n//:::\n/**\n * tcp 客户端2,验证数据包,并处理粘包\n */\ngo(function () {\n    $client = new \\Swoole\\Client(SWOOLE_SOCK_TCP);\n    $client-&gt;set(\n        [\n            'open_length_check'     =&gt; true,\n            'package_max_length'    =&gt; 81920,\n            'package_length_type'   =&gt; 'N',\n            'package_length_offset' =&gt; 0,\n            'package_body_offset'   =&gt; 4,\n        ]\n    );\n    if (!$client-&gt;connect('127.0.0.1', 9503, 0.5)) {\n        exit(\"connect failed. Error: {$client-&gt;errCode}\\n\");\n    }\n    $str = 'hello world';\n    $client-&gt;send(encode($str));\n    $data = $client-&gt;recv();//服务器已经做了pack处理\n    var_dump($data);//未处理数据,前面有4 (因为pack 类型为N)个字节的pack\n    $data = decode($data);//需要自己剪切解析数据\n    var_dump($data);\n//    $client-&gt;close();\n});\n\n/**\n * 数据包 pack处理\n * encode\n * @param $str\n * @return string\n * @author Tioncico\n * Time: 9:50\n */\nfunction encode($str)\n{\n    return pack('N', strlen($str)) . $str;\n}\n\nfunction decode($str)\n{\n    $data = substr($str, '4');\n    return $data;\n}","link":"/Socket/tcpSticky.html"},{"id":146,"title":"websocket服务","content":"WebSocket\nWebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n修改配置文件MAIN_SERVER.SERVER_TYPE为EASYSWOOLE_WEB_SOCKET_SERVER。\nEasySwooleEvent中mainServerCreate事件进行回调注册：\npublic static function mainServerCreate(\\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register)\n{\n    $register-&gt;set($register::onOpen, function ($ws, $request) {\n        var_dump($request-&gt;fd, $request-&gt;server);\n        $ws-&gt;push($request-&gt;fd, \"hello, welcome\\n\");\n    });\n\n    $register-&gt;set($register::onMessage, function (\\Swoole\\WebSocket\\Server $server, \\Swoole\\WebSocket\\Frame $frame) {\n        echo \"Message: {$frame-&gt;data}\\n\";\n        $server-&gt;push($frame-&gt;fd, \"server: {$frame-&gt;data}\");\n    });\n\n    $register-&gt;set($register::onClose, function ($ws, $fd) {\n        echo \"client-{$fd} is closed\\n\";\n    });\n}","link":"/Socket/webSocket.html"},{"id":147,"title":"udp服务","content":"UDP\nUDP为应用程序提供了一种无需建立连接就可以发送封装的IP数据包的方法。\nEasySwooleEvent中mainServerCreate事件，进行子服务监听：\npublic static function mainServerCreate(\\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register)\n{\n    $server = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer();\n\n    $subPort = $server-&gt;addlistener('0.0.0.0', 9503, SWOOLE_UDP);\n    $subPort-&gt;on($register::onPacket, function (\\Swoole\\Server $server, string $data, array $clientInfo) {\n           $server-&gt;sendto($clientInfo['address'], $clientInfo['port'], 'Server：' . $data);\n    });\n}","link":"/Socket/udp.html"},{"id":148,"title":"常见问题","content":"如何遍历全部链接\nuse EasySwoole\\EasySwoole\\ServerManager;\n$server = ServerManager::getInstance()-&gt;getSwooleServer();\n$start_fd = 0;\nwhile(true)\n{\n    $conn_list = $server-&gt;getClientList($start_fd, 10);\n    if ($conn_list===false or count($conn_list) === 0)\n    {\n        echo \"finish\\n\";\n        break;\n    }\n    $start_fd = end($conn_list);\n    var_dump($conn_list);\n    foreach($conn_list as $fd)\n    {\n        $server-&gt;send($fd, \"broadcast\");\n    }\n}\nhttps://wiki.swoole.com/wiki/page/p-connection_list.html\n如何获取链接信息\nuse EasySwoole\\EasySwoole\\ServerManager;\n$server = ServerManager::getInstance()-&gt;getSwooleServer();\n$fdinfo = $server-&gt;getClientInfo($fd);\nhttps://wiki.swoole.com/wiki/page/p-connection_info.html\nSocket有哪些开发场景?\nh5即时游戏\n网页聊天室\n物联网开发\n服务器udp广播\n车联网\n智能家居\nweb网页服务器","link":"/Socket/problem.html"},{"id":149,"title":"websocket协议","content":"websocket\nwebsocket是html5中提出的一个协议规范,它允许浏览器与服务器中相互主动通信.  \nhttp\n在讲websocket之前,我们必须先了解http协议\nhttp协议是基于tcp实现的协议,它的请求步骤为: \n\n浏览器与服务器建立tcp协议\n浏览器发送请求\n服务端接收请求,回复消息\n浏览器接收消息\ntcp连接关闭\n\nhttp协议的特点就是即连即关,每次接收到消息就关闭连接,并且需要浏览器主动请求服务器才能获取到消息\nhttp痛点\n在平常需求中,http协议并没有什么问题,用户输入链接,浏览器请求服务器,服务器返回数据,浏览器获得消息,用户查看网页.是一个很正常的步骤.\n但是,http协议限制了,用户获得数据必须主动去请求服务器,才能获取到数据,在聊天室,网页对战游戏中,并不是只有用户与服务器的交互,还存在了用户与用户之间的交互.\n那么,在websocket之前,http是怎么实现用户与用户之间的交互的呢?\n举个例子,在聊天室需求中,A和B互相通信的实现:  \n\nA不断的请求服务器,B有没有给我发送消息(主动请求服务器,询问有没有新消息)\nB不断的请求服务器,A有没有给我发送消息(主动请求服务器,询问有没有新消息)\nA请求服务器,发送数据:&quot;向B发送一条消息XXXX&quot;\nB不断的请求服务器,服务器返回:&quot;A向你发送了一条消息&quot;\n...\n\n在这个例子中,我们发现,A和B如果需要获取到对方是否有没有发送消息,必须不断的请求服务器,主动询问服务器是否有消息.\n那么,不断的间隔是多少呢?1秒10次?10秒一次?1秒10次不断的请求服务器,服务器能承受住吗?10秒一次?那A发送一条消息,B就得10秒后才能收到,消息延时太过于厉害.\n那么,有没有办法,使得服务器主动给浏览器发消息呢?这就是websocket了\nwebsocket\nwebsocket作为全双工通信协议,只要连接成功之后,浏览器和服务器就可以互相主动发送消息,那么,刚刚的聊天室需求就会变成:  \n\nA与服务器建立连接\nB与服务器建立连接\nA请求服务器,发送数据:&quot;向B发送一条消息XXXX&quot;\n服务器接收到消息,主动向B推送:&quot;A向你发送了一条消息&quot;\nB收到服务器推送\n\nwebsocket 的应用场景就是如此,在需要即时返回消息/频繁请求 的需求中,\nwebsocket协议可以长连接保持当前连接,不用像http一样每次请求都得重新发起一次消息.\n双方可以相互主动推送消息,消息可以即时送达,避免了消息延迟  \nwebsocket协议\n前面讲到了websocket的应用场景,那么为什么websocket可以做即时消息呢?那websocket为什么可以做即时消息,http却不能呢?\nwebsocket协议实现步骤为:  \n\n先使用http协议连接服务端(没错,websocket是基于http协议的)\n第一个步骤额外补充,在使用http协议时,附带了(我要升级websocket协议)的数据\n服务端如果支持websocket,将会给客户端返回(升级成功),如果不支持,则会输出正常的http数据\n客户端接收服务端返回的消息,如果支持,则连接保持,不支持则报错并断开\n连接保持,这时候,客户端和服务端即可互相发消息  \n\nwebsocket详细协议了解可查看: http://noobcourse.php20.cn/NoobCourse/NetworkrPotocol/tcp/websocket.html \nwebsocket示例\n前端示例\nwebsocket代码该怎么写呢?以下是前端的简单例子实现:  \n//先new 一个websocket对象,地址是localhost+端口9501 ws是前面的协议声明,类似于http://xx.cn\nvar ws = new WebSocket(\"ws://localhost:9501\");\n//定义 打开事件 的回调,当连接ws成功后,会调用执行这个回调函数\nws.onopen = function() {\n  console.log(\"client：打开连接\");\n  ws.send(\"client：hello，服务端\");\n};\n//定义 服务器发送消息 的回调,当服务器主动发送消息到客户端时,会调用执行这个回调函数\nws.onmessage = function(e) {\n  console.log(\"client：接收到服务端的消息 \" + e.data);\n  setTimeout(() =&gt; {\n    ws.close();\n  }, 5000);\n};\n//定义 关闭连接 的回调,当连接关闭(服务端关闭,客户端关闭,网络断开等原因),会调用执行这个回调函数 \nws.onclose = function(params) {\n  console.log(\"client：关闭连接\");\n};\nphp实现websocket服务端\n本文采用swoole扩展,实现websocket服务端:\n&lt;?php\n$server = new Swoole\\WebSocket\\Server(\"0.0.0.0\", 9501);\n\n$server-&gt;on('open', function (Swoole\\WebSocket\\Server $server, $request) {\n    echo \"握手成功 fd{$request-&gt;fd}\\n\";\n});\n\n$server-&gt;on('message', function (Swoole\\WebSocket\\Server $server, $frame) {\n    echo \"接收客户端消息: {$frame-&gt;fd}:{$frame-&gt;data},opcode:{$frame-&gt;opcode},fin:{$frame-&gt;finish}\\n\";\n    $server-&gt;push($frame-&gt;fd, \"this is server\");\n});\n\n$server-&gt;on('close', function ($ser, $fd) {\n    echo \"客户端 {$fd} 关闭\\n\";\n});\necho  \"websocket服务器启动成功\\n\";\n\n$server-&gt;start();\n测试情况\nphp cli模式执行php代码,启动服务器\n[root@localhost IM]# php websocket.php \nwebsocket服务器启动成功\n在浏览器中运行js代码,将输出:   \nclient：打开连接\nVM93:10 client：接收到服务端的消息 this is server\nVM93:17 client：关闭连接\n服务端将输出:   \n[root@localhost IM]# php websocket.php \nwebsocket服务器启动成功\n握手成功 fd1\n接收客户端消息: 1:client：hello，服务端,opcode:1,fin:1\n客户端 1 关闭","link":"/Socket/websocketProtocol.html"},{"id":150,"title":"安装与使用示例","content":"Socket\n安装\n\ncomposer require easyswoole/socket\n\n独立使用\n此组件可脱离主框架使用，方便开发者自行创建服务进行调度，属于socket事件调度器。\nuse EasySwoole\\Socket\\AbstractInterface\\Controller;\nuse EasySwoole\\Socket\\AbstractInterface\\ParserInterface;\nuse EasySwoole\\Socket\\Bean\\Response;\nuse EasySwoole\\Socket\\Bean\\Caller;\n\nclass C extends Controller{\n\n    private $hit = 0;\n    protected $hitTime = 0;\n\n    function __construct()\n    {\n        var_dump('controller create  '.spl_object_hash($this));\n        parent::__construct();\n    }\n\n    protected function onRequest(?string $actionName): bool\n    {\n\n        $this-&gt;hit++;\n        $this-&gt;hitTime = time();\n        return true;\n    }\n\n    function test()\n    {\n        var_dump($this-&gt;hit,$this-&gt;hitTime);\n//        co::sleep(10);\n        $this-&gt;response()-&gt;setMessage('time:'.time());\n    }\n\n    protected function gc()\n    {\n        parent::gc(); // TODO: Change the autogenerated stub\n        var_dump('controller has ben gc');\n    }\n}\n\nclass Parser implements ParserInterface{\n\n    public function decode($raw, $client): ?Caller\n    {\n        // TODO: Implement decode() method.\n        $ret =  new Caller();\n        $ret-&gt;setControllerClass(C::class);\n        $ret-&gt;setAction('test');\n        return $ret;\n    }\n\n    /*\n     * 如果这里返回null，则不给客户端任何数据\n     */\n    public function encode(Response $response, $client): ?string\n    {\n        // TODO: Implement encode() method.\n        return $response-&gt;__toString();\n    }\n\n}\n\n$server = new \\Swoole\\Server(\"127.0.0.1\", 9501);\n$server-&gt;set([\n    'worker_num'=&gt;1\n]);\n\n$conf = new \\EasySwoole\\Socket\\Config();\n$conf-&gt;setType($conf::TCP);\n$conf-&gt;setParser(new Parser());\n$conf-&gt;setMaxPoolNum(2);\n$conf-&gt;setOnExceptionHandler(function (\\swoole_server $server,\\Throwable $throwable,string $raw,$client,Response $response){\n    $response-&gt;setStatus('error');\n    $response-&gt;setStatus($response::STATUS_RESPONSE_AND_CLOSE);\n});\n\n$dispatch = new \\EasySwoole\\Socket\\Dispatcher($conf);\n$server-&gt;on('receive', function ($server, $fd, $reactor_id, $data)use($dispatch) {\n    $dispatch-&gt;dispatch($server,$data,$fd,$reactor_id);\n});\n$server-&gt;on('close', function ($server, $fd) {\n    echo \"connection close: {$fd}\\n\";\n});\n$server-&gt;start();\n框架内使用\n具体demo\nTcp\n控制器\n&lt;?php\n\nnamespace App\\TcpController;\n\nuse EasySwoole\\Socket\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        $this-&gt;response()-&gt;setMessage('this is index');\n    }\n}\n解析器\n&lt;?php\n\nnamespace App\\Parser;\n\nuse EasySwoole\\Socket\\AbstractInterface\\ParserInterface;\nuse EasySwoole\\Socket\\Bean\\Caller;\nuse EasySwoole\\Socket\\Bean\\Response;\n\nclass TcpParser implements ParserInterface\n{\n    public function decode($raw, $client): ?Caller\n    {\n        $data = substr($raw, '4');\n        $data = json_decode($data, true);\n        $caller = new Caller();\n        $controller = !empty($data['controller']) ? $data['controller'] : 'Index';\n        $action = !empty($data['action']) ? $data['action'] : 'index';\n        $param = !empty($data['param']) ? $data['param'] : [];\n        $controller = \"App\\\\TcpController\\\\{$controller}\";\n        $caller-&gt;setControllerClass($controller);\n        $caller-&gt;setAction($action);\n        $caller-&gt;setArgs($param);\n        return $caller;\n    }\n\n    public function encode(Response $response, $client): ?string\n    {\n        return pack('N', strlen($response-&gt;getMessage())) . $response-&gt;getMessage();\n    }\n}\n注册\nmainServerCreate\n$config = new \\EasySwoole\\Socket\\Config();\n$config-&gt;setType($config::TCP);\n$config-&gt;setParser(TcpParser::class);\n$dispatcher = new \\EasySwoole\\Socket\\Dispatcher($config);\n$config-&gt;setOnExceptionHandler(function (\\Swoole\\Server $server, \\Throwable $throwable, string $raw, \\EasySwoole\\Socket\\Client\\Tcp $client, \\EasySwoole\\Socket\\Bean\\Response $response) {\n    $response-&gt;setMessage('system error!');\n    $response-&gt;setStatus($response::STATUS_RESPONSE_AND_CLOSE);\n});\n$register-&gt;set($register::onReceive, function (\\Swoole\\Server $server, int $fd, int $reactorId, string $data) use ($dispatcher) {\n    $dispatcher-&gt;dispatch($server, $data, $fd, $reactorId);\n});\nUdp\n控制器\n&lt;?php\n\nnamespace App\\UdpController;\n\nuse EasySwoole\\Socket\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        $this-&gt;response()-&gt;setMessage('this is index');\n    }\n}\n解析器\n&lt;?php\n\nnamespace App\\Parser;\n\nuse EasySwoole\\Socket\\AbstractInterface\\ParserInterface;\nuse EasySwoole\\Socket\\Bean\\Caller;\nuse EasySwoole\\Socket\\Bean\\Response;\n\nclass UdpParser implements ParserInterface\n{\n    public function decode($raw, $client): ?Caller\n    {\n        $data = json_decode($raw, true);\n        $caller = new Caller();\n        $controller = !empty($data['controller']) ? $data['controller'] : 'Index';\n        $action = !empty($data['action']) ? $data['action'] : 'index';\n        $param = !empty($data['param']) ? $data['param'] : [];\n        $controller = \"App\\\\UdpController\\\\{$controller}\";\n        $caller-&gt;setControllerClass($controller);\n        $caller-&gt;setAction($action);\n        $caller-&gt;setArgs($param);\n        return $caller;\n    }\n\n    public function encode(Response $response, $client): ?string\n    {\n        return json_encode($response-&gt;getMessage());\n    }\n}\n注册\nmainServerCreate\n$config = new \\EasySwoole\\Socket\\Config();\n$config-&gt;setType($config::UDP);\n$config-&gt;setParser(UdpParser::class);\n$dispatcher = new \\EasySwoole\\Socket\\Dispatcher($config);\n$config-&gt;setOnExceptionHandler(function (\\Swoole\\Server $server, \\Throwable $throwable, string $raw, \\EasySwoole\\Socket\\Client\\Udp $client, \\EasySwoole\\Socket\\Bean\\Response $response) {\n    $response-&gt;setMessage('system error!');\n    $response-&gt;setStatus($response::STATUS_RESPONSE_AND_CLOSE);\n});\n$server = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer();\n$udpServer = $server-&gt;addListener('0.0.0.0', '9511', SWOOLE_UDP);\n$udpServer-&gt;on($register::onPacket, function (\\Swoole\\Server $server, string $data, array $clientInfo) use ($dispatcher) {\n    $dispatcher-&gt;dispatch($server, $data, $clientInfo['server_socket'], $clientInfo['address'], $clientInfo['port']);\n});\nWebsocket\n控制器\n&lt;?php\n\nnamespace App\\WebSocketController;\n\nuse EasySwoole\\Socket\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        $this-&gt;response()-&gt;setMessage('this is index');\n    }\n}\n解析器\n&lt;?php\n\nnamespace App\\Parser;\n\nuse EasySwoole\\Socket\\AbstractInterface\\ParserInterface;\nuse EasySwoole\\Socket\\Bean\\Caller;\nuse EasySwoole\\Socket\\Bean\\Response;\n\nclass WebSocketParser implements ParserInterface\n{\n    public function decode($raw, $client): ?Caller\n    {\n        $data = json_decode($raw, true);\n        $caller = new Caller();\n        $controller = !empty($data['controller']) ? $data['controller'] : 'Index';\n        $action = !empty($data['action']) ? $data['action'] : 'index';\n        $param = !empty($data['param']) ? $data['param'] : [];\n        $controller = \"App\\\\WebSocketController\\\\{$controller}\";\n        $caller-&gt;setControllerClass($controller);\n        $caller-&gt;setAction($action);\n        $caller-&gt;setArgs($param);\n        return $caller;\n    }\n\n    public function encode(Response $response, $client): ?string\n    {\n        return json_encode($response-&gt;getMessage());\n    }\n}\n自定义握手\n&lt;?php\n\nnamespace App;\n\nclass WebSocketEvent\n{\n    /**\n     * @param \\Swoole\\Http\\Request $request\n     * @param \\Swoole\\Http\\Response $response\n     * @return bool\n     */\n    public function onHandShake(\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response)\n    {\n        /** 此处自定义握手规则 返回 false 时中止握手 */\n        if (!$this-&gt;customHandShake($request, $response)) {\n            $response-&gt;end();\n            return false;\n        }\n\n        /** 此处是  RFC规范中的WebSocket握手验证过程 必须执行 否则无法正确握手 */\n        if ($this-&gt;secWebsocketAccept($request, $response)) {\n            $response-&gt;end();\n            return true;\n        }\n\n        $response-&gt;end();\n        return false;\n    }\n\n    /**\n     * @param \\Swoole\\Http\\Request $request\n     * @param \\Swoole\\Http\\Response $response\n     * @return bool\n     */\n    protected function customHandShake(\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response): bool\n    {\n        /**\n         * 这里可以通过 http request 获取到相应的数据\n         * 进行自定义验证后即可\n         * (注) 浏览器中 JavaScript 并不支持自定义握手请求头 只能选择别的方式 如get参数\n         */\n        $headers = $request-&gt;header;\n        $cookie = $request-&gt;cookie;\n\n        // if (如果不满足我某些自定义的需求条件，返回false，握手失败) {\n        //    return false;\n        // }\n        return true;\n    }\n\n    /**\n     * RFC规范中的WebSocket握手验证过程\n     * 以下内容必须强制使用\n     *\n     * @param \\Swoole\\Http\\Request $request\n     * @param \\Swoole\\Http\\Response $response\n     * @return bool\n     */\n    protected function secWebsocketAccept(\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response): bool\n    {\n        // ws rfc 规范中约定的验证过程\n        if (!isset($request-&gt;header['sec-websocket-key'])) {\n            // 需要 Sec-WebSocket-Key 如果没有拒绝握手\n            var_dump('shake fai1 3');\n            return false;\n        }\n        if (0 === preg_match('#^[+/0-9A-Za-z]{21}[AQgw]==$#', $request-&gt;header['sec-websocket-key'])\n            || 16 !== strlen(base64_decode($request-&gt;header['sec-websocket-key']))\n        ) {\n            //不接受握手\n            var_dump('shake fai1 4');\n            return false;\n        }\n\n        $key = base64_encode(sha1($request-&gt;header['sec-websocket-key'] . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11', true));\n        $headers = array(\n            'Upgrade' =&gt; 'websocket',\n            'Connection' =&gt; 'Upgrade',\n            'Sec-WebSocket-Accept' =&gt; $key,\n            'Sec-WebSocket-Version' =&gt; '13',\n            'KeepAlive' =&gt; 'off',\n        );\n\n        if (isset($request-&gt;header['sec-websocket-protocol'])) {\n            $headers['Sec-WebSocket-Protocol'] = $request-&gt;header['sec-websocket-protocol'];\n        }\n\n        // 发送验证后的header\n        foreach ($headers as $key =&gt; $val) {\n            $response-&gt;header($key, $val);\n        }\n\n        // 接受握手 还需要101状态码以切换状态\n        $response-&gt;status(101);\n        var_dump('shake success at fd :' . $request-&gt;fd);\n        return true;\n    }\n}\n注册\nmainServerCreate\n&lt;?php\n$config = new \\EasySwoole\\Socket\\Config();\n$config-&gt;setType($config::WEB_SOCKET);\n$config-&gt;setParser(WebSocketParser::class);\n$dispatcher = new \\EasySwoole\\Socket\\Dispatcher($config);\n$config-&gt;setOnExceptionHandler(function (\\Swoole\\Server $server, \\Throwable $throwable, string $raw, \\EasySwoole\\Socket\\Client\\WebSocket $client, \\EasySwoole\\Socket\\Bean\\Response $response) {\n    $response-&gt;setMessage('system error!');\n    $response-&gt;setStatus($response::STATUS_RESPONSE_AND_CLOSE);\n});\n\n// 自定义握手\n/*$websocketEvent = new WebSocketEvent();\n$register-&gt;set(EventRegister::onHandShake, function (\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response) use ($websocketEvent) {\n    $websocketEvent-&gt;onHandShake($request, $response);\n});*/\n\n$register-&gt;set($register::onMessage, function (\\Swoole\\Websocket\\Server $server, \\Swoole\\Websocket\\Frame $frame) use ($dispatcher) {\n    $dispatcher-&gt;dispatch($server, $frame-&gt;data, $frame);\n});","link":"/Socket/install.html"},{"id":151,"title":"控制器对象","content":"Socket-Controller\n创建\n继承EasySwoole\\Socket\\AbstractInterface\\Controller\nclass Test extends \\EasySwoole\\Socket\\AbstractInterface\\Controller\n{\n\n}\n自定义解析器\nclass TestParser implements \\EasySwoole\\Socket\\AbstractInterface\\ParserInterface \n{\n    public function decode($raw,$client) : ?\\EasySwoole\\Socket\\Bean\\Caller\n    {\n\n    }\n\n    public function encode(\\EasySwoole\\Socket\\Bean\\Response $response,$client) : ?string\n    {\n\n    }\n}\n调度器注册\n子服务举例\nEasySwooleEvent中mainServerCreate事件进行回调注册：\npublic static function mainServerCreate(\\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register)\n{\n    $server = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer();\n\n    $subPort = $server-&gt;addlistener('0.0.0.0', 9502, SWOOLE_TCP);\n    $subPort-&gt;set(\n        // swoole 相关配置\n    );\n\n    $socketConfig = new \\EasySwoole\\Socket\\Config();\n    $socketConfig-&gt;setType($socketConfig::TCP);\n    $socketConfig-&gt;setParser(new TestParser());\n    //设置解析异常时的回调,默认将抛出异常到服务器\n    $socketConfig-&gt;setOnExceptionHandler(function ($server, $throwable, $raw, $client, \\EasySwoole\\Socket\\Bean\\Response $response) {\n        $response-&gt;setMessage(\"服务器异常（客户端fd:{$client-&gt;getFd()}）\");\n        $response-&gt;setStatus($response::STATUS_RESPONSE_AND_CLOSE); // 发送完主动关闭该连接\n    });\n    $dispatch = new \\EasySwoole\\Socket\\Dispatcher($socketConfig);\n\n    $subPort-&gt;on($register::onConnect, function (\\Swoole\\Server $server, int $fd, int $reactor_id) {\n            echo \"fd {$fd} connected\";\n    });\n\n    $subPort-&gt;on($register::onReceive, function (\\Swoole\\Server  $server, int $fd, int $reactor_id, string $data) use ($dispatch) {\n        $dispatch-&gt;dispatch($server, $data, $fd, $reactor_id);\n    });\n\n    $subPort-&gt;on($register::onClose, function (\\Swoole\\Server  $server, int $fd, int $reactor_id) {\n            echo \"fd {$fd} closed\";\n    });\n}","link":"/Socket/controller.html"},{"id":152,"title":"响应对象","content":"Socket-Response\n响应状态分析\nEasySwoole\\Socket\\Bean\\Response\n此响应类主要用于此调度结束或者调度出现异常，对连接后续的操作。\n正常响应(保持连接，服务端不主动关闭)(Response默认响应状态)\n\n\\EasySwoole\\Socket\\Bean\\Response::STATUS_OK;\n\n响应后服务端主动关闭连接\n\n\\EasySwoole\\Socket\\Bean\\Response::STATUS_RESPONSE_AND_CLOSE;\n\n服务端直接关闭连接\n\n\\EasySwoole\\Socket\\Bean\\Response::STATUS_CLOSE;\n\n设置响应信息\n响应信息会经过解析器的encode。\nclass Test extends \\EasySwoole\\Socket\\AbstractInterface\\Controller\n{\n    public function testMessage()\n    {   \n        $this-&gt;response()-&gt;setMessage('test message');\n    }\n}\n设置响应状态\n当响应信息为空的时候，并不会发送给客户端信息。\n异常\n自定义了异常处理器，可进行响应状态控制:\nclass TestParser implements \\EasySwoole\\Socket\\AbstractInterface\\ParserInterface \n{\n    public function decode($raw,$client) : ?\\EasySwoole\\Socket\\Bean\\Caller\n    {\n\n    }\n\n    public function encode(\\EasySwoole\\Socket\\Bean\\Response $response,$client) : ?string\n    {\n\n    }\n}\n// 伪代码 需要开发者在mainServerCreate中进行注册，或者脱离主框架使用\n$conf = new \\EasySwoole\\Socket\\Config();\n$conf-&gt;setType($conf::TCP);\n$conf-&gt;setParser(new TestParser());\n$conf-&gt;setMaxPoolNum(2);\n$conf-&gt;setOnExceptionHandler(function (\\swoole_server $server,\\Throwable $throwable,string $raw,$client,\\EasySwoole\\Socket\\Bean\\Response $response){\n    $response-&gt;setMessage('system error');\n    $response-&gt;setStatus($response::STATUS_RESPONSE_AND_CLOSE);\n});\n控制器内方法\nclass Test extends \\EasySwoole\\Socket\\AbstractInterface\\Controller\n{\n    public function testStatus()\n    {   \n        $this-&gt;response()-&gt;setMessage('test status');\n        $this-&gt;response()-&gt;setStatus($this-&gt;response()::STATUS_RESPONSE_OK);\n    }\n}","link":"/Socket/response.html"},{"id":153,"title":"安装","content":"redis协程客户端\n虽然swoole有着自带的协程客户端,但是在生产环境中我们发现了一些问题:\nswoole的redis客户端并没有完全支持redis的全部命令，比如geo搜索，还有事务，特别是集群模式的redis，swoole客户端并不支持。为此，我们决定用swoole的tcp客户端实现一个完整版的redis客户端。\n目前,该redis客户端组件,已经支持除去脚本外的所有方法(目前支持了178个方法):  \n\n连接方法(connection)\n集群方法(cluster)\ngeohash\n哈希(hash)\n键(keys)\n列表(lists)\n订阅/发布(pub/sub)\n服务器(server)\n字符串(string)\n有序集合(sorted sets)\n集合 (sets)\n事务 (transaction)\n管道实现 (pipe)  \n\n\n由于redis的命令较多,可能漏掉1,2个命令\n\n组件要求\n\nphp: &gt;=7.1.0\next-swoole: ^4.4.0\neasyswoole/spl: ^1.2\n\n安装方法\n\ncomposer require easyswoole/redis\n\n仓库地址\neasyswoole/redis\n基本使用\nredis 单机配置\nredis 在实例化时,需要传入\\EasySwoole\\Redis\\Config\\RedisConfig实例:\n\n\n\n配置名\n默认参数\n说明\n备注\n\n\n\n\nhost\n127.0.0.1\nredis ip\n\n\n\nport\n6379\nredis端口\n\n\n\nunixSocket\nnull\nunixSocket文件路径\n此参数配置后,将忽略host,port参数,直接通过UnixSocket连接.(&gt;=1.3.0才可使用)\n\n\nauth\n\nauth密码\n\n\n\ndb\nnull\nredis数据库\n当db配置不等于null时,在connect的时候会自动select该配置\n\n\ntimeout\n3.0\n超时时间\n\n\n\nreconnectTimes\n3\n客户端异常重连次数\n\n\n\nserialize\nSERIALIZE_NONE\n数据是否序列化\n序列化参数有:SERIALIZE_NONE,SERIALIZE_PHP,SERIALIZE_JSON\n\n\n\nredis 单机配置示例\n$config = new \\EasySwoole\\Redis\\Config\\RedisConfig([\n    'host'      =&gt; '127.0.0.1',\n    'port'      =&gt; '6379',\n    'auth'      =&gt; 'easyswoole',\n    'db'        =&gt; null,\n    'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n]);\nredis集群配置\nredis 集群在实例化时，需要传入\\EasySwoole\\Redis\\Config\\RedisConfig实例:\n$config = new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n    ['172.16.253.156', 9001],\n    ['172.16.253.156', 9002],\n    ['172.16.253.156', 9003],\n    ['172.16.253.156', 9004],\n], [\n    'auth' =&gt; '',\n    'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n]);\n集群配置先传入一个ip,port的多维数组,再传入其他配置项,其他配置项和redis单机配置一致  \n需要注意,auth密码需要集群所有节点相同,只支持一个密码\nredis单机使用示例\n使用redis客户端(需要协程环境)\n&lt;?php\ninclude \"../vendor/autoload.php\";\ngo(function (){\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host' =&gt; '127.0.0.1',\n        'port' =&gt; '6379',\n        'auth' =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    var_dump($redis-&gt;set('a',1));\n    var_dump($redis-&gt;get('a'));\n});\nredis集群使用示例\n&lt;?php\ninclude \"../vendor/autoload.php\";\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\RedisCluster(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ], [\n        'auth' =&gt; '',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n    ]));\n    var_dump($redis-&gt;set('a',1));\n    var_dump($redis-&gt;get('a'));\n    var_dump($redis-&gt;clusterKeySlot('a'));\n\n});\n回调事件\n在redis组件中,自定义了2个回调事件,用于代码跟踪调试,可在config中设置:\n&lt;?php\n$redisConfig = new RedisConfig([\n   'host' =&gt; REDIS_HOST,\n   'port' =&gt; REDIS_PORT,\n   'auth' =&gt; REDIS_AUTH,\n]);\n// 命令执行之前将调用\n$redisConfig-&gt;onBeforeEvent(function ($commandName,$commandData){\n   var_dump ($commandName,$commandData);\n});\n//命令获取到结果后将调用\n$redisConfig-&gt;onAfterEvent(function ($commandName,$commandData,$result){\n   var_dump ($commandName,$commandData,$result);\n});\n回调事件支持事务,pipe.\n在pipe模式中,只有最后excePipe时才会调用回调事件.\n异常处理\nredis组件根据错误的级别,区分了2种错误信息\n异常\n当redis连接失败,无法和redis服务通信时,将会抛出EasySwoole\\Redis\\Exception\\RedisException 异常,例如配置错误:\nPHP Fatal error:  Uncaught EasySwoole\\Redis\\Exception\\RedisException: connect to redis host 127.0.0.1:6379 fail after retry 4 times in /www/easyswoole/tioncico_redis/src/Redis.php:2866\nStack trace:\n#0 /www/easyswoole/tioncico_redis/src/Redis.php(579): EasySwoole\\Redis\\Redis-&gt;sendCommand(Array)\n#1 /www/easyswoole/tioncico_redis/tests/test.php(17): EasySwoole\\Redis\\Redis-&gt;get('a')\n#2 {main}\n  thrown in /www/easyswoole/tioncico_redis/src/Redis.php on line 2866\n\n接管异常\ngo(function () {\n\n    $redisConfig = new \\EasySwoole\\Redis\\Config\\RedisConfig();\n    $redisConfig-&gt;setAuth('easyswoole');\n    $redis = new \\EasySwoole\\Redis\\Redis($redisConfig);\n    try{\n\n        $data = $redis-&gt;rawCommand(['set','a','1','1']);//多了一个参数,redis将会报语法错误\n         var_dump($data);\n\n    }catch (\\EasySwoole\\Redis\\Exception\\RedisException $exception){\n\n        var_dump($exception-&gt;getMessage());\n        var_dump($exception-&gt;getRedisErrorCode());\n        var_dump($exception-&gt;getRedisErrorMsg());\n    }\n});","link":"/Components/Redis/introduction.html"},{"id":154,"title":"集群","content":"redis集群使用\n请查看安装章节的redis集群相关配置使用\n集群兼容方法\n在正常情况下,有些方法是不能直接被集群客户端调用成功的,比如mSet方法,它涉及了多个键名的操作,而多个键名是会分配给其他节点的\n目前redis集群客户端,实现了部分多键名操作方法的兼容,实现原理如下:\n对多键名操作方法,进行拆分成单键名,然后通过键名去获取槽节点,再通过槽节点分配的client去执行,每次只会执行一个键名\n已经实现了兼容的方法:\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nmSet\n$data\n设置多个键值对\n\n\n\nmGet\n$keys\n获取多个键名的值\n\n\n\nmSetNx\n$data\n设置多个键值对\n该方法将不能准确的判断&quot;当所有key不存在时,设置多个key值&quot;\n\n\n\n集群禁用方法\n由于集群的特性,不同的key分配到了不同的槽位,当你调用sUnion,sUnIonStore等涉及多个key操作的命令时,将会返回false,同时错误信息会在$redis->getErrorMsg()中显示:\n$redis = new \\EasySwoole\\Redis\\RedisCluster(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n    ['172.16.253.156', 9001],\n    ['172.16.253.156', 9002],\n    ['172.16.253.156', 9003],\n    ['172.16.253.156', 9004],\n], [\n    'auth'      =&gt; '',\n    'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n]));\n\n$data = $redis-&gt;sUnIonStore('a','v','c');\nvar_dump($data,$redis-&gt;getErrorMsg());\n将输出:\nbool(false)\nstring(53) \"CROSSSLOT Keys in request don't hash to the same slot\"\n集群客户端调度逻辑\n客户端默认调度\n集群客户端在调用redis方法的时候,自动默认一个客户端进行发送接收命令:\nfunction sendCommand(array $com, ?ClusterClient $client = null): bool\n{\n    $client = $client ?? $this-&gt;getDefaultClient();\n    $this-&gt;setDefaultClient($client);\n    return $this-&gt;sendCommandByClient($com, $client);\n}\n\nfunction recv($timeout = null, ?ClusterClient $client = null): ?Response\n{\n    $client = $client ?? $this-&gt;getDefaultClient();\n    $this-&gt;setDefaultClient($client);\n    return $this-&gt;recvByClient($client, $timeout);\n}\n当get,或者set的key值槽位不一致时,会自动切换客户端进行发送接收命令:\n //节点转移客户端处理\nif ($result-&gt;getErrorType() == 'MOVED') {\n    $nodeId = $this-&gt;getMoveNodeId($result);\n    $client = $this-&gt;getClient($nodeId);\n    $this-&gt;clientConnect($client);\n    //只处理一次moved,如果出错则不再处理\n    $client-&gt;sendCommand($command);\n    $result = $client-&gt;recv($timeout ?? $this-&gt;config-&gt;getTimeout());\n}\n切换完成之后,下一次命令,依旧是默认客户端.  \n获取集群的客户端\n集群操作方法列表:\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\ngetNodeClientList\n\n获取集群客户端列表\n\n\n\ngetNodeList\n\n获取集群节点信息数组\n\n\n\nclientAuth\nClusterClient $client, $password\n集群客户端auth验证\n\n\n\nsetDefaultClient\nClusterClient $defaultClient\n设置一个默认的客户端\n\n\n\ngetDefaultClient\n\n获取一个默认的客户端(初始化会自动默认一个)\n\n\n\ntryConnectServerList\n\n尝试重新获取客户端列表\n当调用命令返回false,可尝试重新获取\n\n\ngetClient\n$nodeKey = null\n根据nodeKey获取一个客户端\n\n\n\ngetMoveNodeId\nResponse $response\n根据recv返回的Move消息获取一个nodeKey\n\n\n\ngetSlotNodeId\n$slotId\n根据槽id获取 nodeKey\n\n\n\n\n这些方法用于用户自定义发送命令给redis服务端,或者是自己定义默认客户端进行发送\n集群兼容管道方法\n由于管道的特性,开启管道后,之后执行的命令将会保存不会直接发送,直到最后执行execPipe才会一次性发送\n在集群中,只能选择一个客户端,进行一次性发送命令:\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nexecPipe\n?ClusterClient $client = null\n一次性执行管道中保存的方法\n可通过获取客户端列表,自定义选择一个客户端进行发送\n\n\ndiscardPipe\n\n取消管道\n\n\n\nstartPipe\n\n管道开始记录\n\n\n\n","link":"/Components/Redis/cluster.html"},{"id":155,"title":"单机迁移集群","content":"场景\n在业务量小的情况下，我们使用Redis单机连接池就可以满足业务需求。因此，redis单机连接池就可以满足我们的业务。因此我们会这样写：\n示例\n注册连接池\nuse EasySwoole\\Redis\\Config\\RedisConfig;\nuse EasySwoole\\RedisPool\\Redis;\nRedis::getInstance()-&gt;register('redis',new RedisConfig());\n使用\nuse EasySwoole\\RedisPool\\Redis;\nuse EasySwoole\\Redis\\Redis as RedisClient\nRedis::invoke('redis', function (RedisClient $redis) {\n    var_dump($redis-&gt;set('a', 1));\n});\n当业务量上来后，我们需要切换成集群模式的时候怎么办。因此我们做的应该是：\n注册集群连接池\nuse EasySwoole\\RedisPool\\Redis;\nuse EasySwoole\\Redis\\Config\\RedisClusterConfig;\nRedis::getInstance()-&gt;register('redis',new RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ]\n));\n老业务代码\nuse EasySwoole\\RedisPool\\Redis;\nuse EasySwoole\\Redis\\Redis as RedisClient\nRedis::invoke('redis', function (RedisClient $redis) {\n    var_dump($redis-&gt;set('a', 1));\n});\n对于之前的老业务代码，就会出现、、、、此事，我的invoker回调参数是一个EasySwoole\\Redis\\RedisCluster实例，而非EasySwoole\\Redis\\Redis,\n因此就会导致业务代码报错。\n解决方案\nEasyswoole Redis Pool组件，在2.1.1版本开始，基于easyswoole的magic pool 引入一个cask机制。可以指定实例化的class。\n定义一个class\nnamespace App\\Utility;\n\nuse EasySwoole\\Redis\\Redis;\n\nclass RedisClient extends Redis\n{\n    function fuck()\n    {\n        var_dump('waf');\n    }\n}\n\n该class继承自EasySwoole\\Redis\\Redis\n\n注册redis\nuse EasySwoole\\Redis\\Config\\RedisConfig;\nuse EasySwoole\\RedisPool\\Redis;\nuse App\\Utility\\RedisClient\nRedis::getInstance()-&gt;register('redis',$config,RedisClient::class);\n使用redis\nuse EasySwoole\\RedisPool\\Redis;\nuse App\\Utility\\RedisClient\nRedis::invoke('redis', function (RedisClient $redis) {\n    var_dump($redis-&gt;set('a', 1));\n});\n迁移集群\n修改注册配置\nuse EasySwoole\\RedisPool\\Redis;\nuse EasySwoole\\Redis\\Config\\RedisClusterConfig;\nRedis::getInstance()-&gt;register('redis',new RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ]\n),RedisClient::class);\n继承修改\n修改App\\Utility\\RedisClient，让它继承EasySwoole\\Redis\\RedisCluster即可\n而由于redis单机客户端与集群客户端的方法几乎一致，因此可以不修改任何业务代码，就是实现单机到集群的迁移","link":"/Components/Redis/single2Cluster.html"},{"id":156,"title":"自定义命令","content":"自定义命令\nredis客户端提供了rawCommand方法以供使用自定义命令:  \n基本使用\n$data = $redis-&gt;rawCommand(['set','a','1']);\nvar_dump($data);\n$data = $redis-&gt;rawCommand(['get','a']);\nvar_dump($data);\n$redis-&gt;del('a');\nrawCommand将返回一个EasySwoole\\Redis\\Response对象\nobject(EasySwoole\\Redis\\Response)#8 (4) {\n  [\"status\":protected]=&gt;\n  int(0)\n  [\"data\":protected]=&gt;\n  string(2) \"OK\"\n  [\"msg\":protected]=&gt;\n  NULL\n  [\"errorType\":protected]=&gt;\n  NULL\n}\nobject(EasySwoole\\Redis\\Response)#9 (4) {\n  [\"status\":protected]=&gt;\n  int(0)\n  [\"data\":protected]=&gt;\n  string(1) \"1\"\n  [\"msg\":protected]=&gt;\n  NULL\n  [\"errorType\":protected]=&gt;\n  NULL\n}","link":"/Components/Redis/rawCommand.html"},{"id":157,"title":"连接池","content":"Redis-Pool\nRedis-Pool 基于 pool连接池管理,redis协程客户端 封装的组件\n安装\ncomposer require easyswoole/redis-pool\n连接池注册\n使用连接之前注册redis连接池:\n//redis连接池注册(config默认为127.0.0.1,端口6379)\n\\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;register(new \\EasySwoole\\Redis\\Config\\RedisConfig(),'redis');\n// config是空配置,用户需手动配置. \n\n//redis集群连接池注册\n\\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;register(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ]\n),'redisCluster');\n连接池配置\n当注册好时,将返回连接池的poolConf用于配置连接池:\n$redisPoolConfig = \\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;register(new \\EasySwoole\\Redis\\Config\\RedisConfig());\n//配置连接池连接数\n$redisPoolConfig-&gt;setMinObjectNum(5);\n$redisPoolConfig-&gt;setMaxObjectNum(20);\n\n$redisClusterPoolConfig = \\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;register(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ]\n));\n//配置连接池连接数\n$redisPoolConfig-&gt;setMinObjectNum(5);\n$redisPoolConfig-&gt;setMaxObjectNum(20);\n使用连接池\n//defer方式获取连接\n$redis = \\EasySwoole\\RedisPool\\RedisPool::defer();\n$redisCluster = \\EasySwoole\\RedisPool\\RedisPool::defer();\n$redis-&gt;set('a', 1);\n$redisCluster-&gt;set('a', 1);\n\n//invoke方式获取连接\n\\EasySwoole\\RedisPool\\RedisPool::invoke(function (\\EasySwoole\\Redis\\Redis $redis) {\n    var_dump($redis-&gt;set('a', 1));\n});\n\\EasySwoole\\RedisPool\\RedisPool::invoke(function (\\EasySwoole\\Redis\\Redis $redis) {\n    var_dump($redis-&gt;set('a', 1));\n});\n\n//获取连接池对象\n$redisPool = \\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;getPool();\n$redisClusterPool = \\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;getPool();\n\n$redis = $redisPool-&gt;getObj();\n$redisPool-&gt;recycleObj($redis);\n！！！注意，在未指定连接池名称是，注册的连接池名称为默认的default\n方法\nregister\n\\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;register();\n参数：\n\n$config new \\EasySwoole\\Redis\\Config\\RedisConfig() || new \\EasySwoole\\Redis\\Config\\RedisClusterConfig()\n\n$name 连接池名称 默认default\n\n$cask 用户自定义redis-client 可忽略\n\n返回：\n\n注册成功返回EasySwoole\\Pool\\Config,可设置连接池的配置.\n\ndefer\n\\EasySwoole\\RedisPool\\RedisPool::defer();\n参数：\n\n$name 连接池名称 默认default\n\n$timeout 取出连接超时时间\n\n返回：\n\n成功返回连接池内对象 失败为null \n\ninvoke\n\\EasySwoole\\RedisPool\\RedisPool::invoke(function (\\EasySwoole\\Redis\\Redis $redis) {\n    var_dump($redis-&gt;set('a', 1));\n});\n参数：\n\n$call 执行的闭包函数，闭包函数参数为连接池对象\n$name 连接池名称 默认default\n\n$timeout 取出连接超时时间\n\n返回：\n\n成功返回闭包函数内返回的结果，失败返回null\n\n\ngetPool\n\\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;getPool();\n参数：\n\n$name 连接池名称 默认default\n\n\n返回：\n\n成功返回EasySwoole\\RedisPool\\Pool,失败返回null.\n","link":"/Components/Redis/pool.html"},{"id":158,"title":"连接(connection)","content":"Redis 连接\nRedis 连接命令主要是用于连接 redis 服务\n操作方法\n连接方法包括一些auth,echo,ping,类似的方法,列表如下:    \n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nconnect\n$timeout\n连接\n\n\n\ndisconnect\n\n断开连接\n\n\n\nauth\n$password\nauth认证\n\n\n\necho\n$str\necho\n\n\n\nping\n\nping\n\n\n\nselect\n$db\n选择数据库\n\n\n\n\n基本使用\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $data = $redis-&gt;connect();\n    var_dump($data);\n    $data = $redis-&gt;auth('easyswoole');\n    var_dump($data);\n    $data = $redis-&gt;echo('test echo');\n    var_dump($data);\n    $data = $redis-&gt;ping();\n    var_dump($data);\n    $data = $redis-&gt;select(1);\n    var_dump($data);\n    $redis-&gt;disconnect();\n});","link":"/Components/Redis/connection.html"},{"id":159,"title":"键(keys)","content":"Redis 键(Keys)\nRedis 键命令用于管理 redis 的键。\n操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\ndel\n...$keys\n删除一个键\n$key可传一个array,也可以传多个可变参数\n\n\nunlink\n...$keys\n非阻塞删除一个键\n$key可传一个array,也可以传多个可变参数\n\n\ndump\n$key\n序列化\n\n\n\nexists\n$key\n查询是否存在\n\n\n\nexpire\n$key, $expireTime = 60\n给key设定过期时间(秒)\n\n\n\nexpireAt\n$key, $expireTime\n以UNIX时间戳格式设置key的过期时间\nexpireAt的作用和expire类似，都用于为key设置过期时间。 不同在于expireAt命令接受的时间参数是UNIX时间戳(unix timestamp)。At,顾名思义，在未来的某个时间点过期\n\n\npExpire\n$key, $expireTime = 60000\n给key设定过期时间(毫秒)\n\n\n\nkeys\n$pattern\n匹配key\n\n\n\nmove\n$key, $db\n移动key\n集群模式不能使用\n\n\npersist\n$key\n移除key的过期时间\n\n\n\npTTL\n$key\n返回毫秒过期时间\n\n\n\nttl\n$key\n返回过期时间\n\n\n\nrandomKey\n\n随机返回一个key\n\n\n\nrename\n$key, $new_key\n修改key的名字\n集群模式不能使用\n\n\nrenameNx\n$key, $new_key\nnewkey不存在时,修改key名字\n集群模式不能使用\n\n\ntype\n$key\n返回key储存的数据类型\n\n\n\n\ndel和unlink都可以传一个数组,或者传 ...数组(可变参数),如果第一个参数为数组,则后面的参数全部将忽略\n在集群中,del和unlink都是拆分key,判断key的solt进行一个个执行\n基本使用\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $key = 'test123213Key';\n    $redis-&gt;select(0);\n    $redis-&gt;set($key, 123);\n    $data = $redis-&gt;dump($key);\n    var_dump($data);\n    $data = $redis-&gt;dump($key . 'x');\n    var_dump($data);\n\n    $data = $redis-&gt;exists($key);\n    var_dump($data);\n\n    $data = $redis-&gt;expire($key, 1);\n    var_dump($data);\n    \\Swoole\\Coroutine::sleep(2);\n    var_dump($redis-&gt;exists($key));\n\n    $redis-&gt;expireAt($key, 1593570849);\n    \\Swoole\\Coroutine::sleep(1);\n    var_dump($redis-&gt;exists($key));\n\n    $redis-&gt;pExpire($key, 1 * 100);\n    \\Swoole\\Coroutine::sleep(0.1);\n    var_dump($redis-&gt;exists($key));\n\n    $redis-&gt;set($key, 123);\n    $data = $redis-&gt;keys(\"{$key}\");\n    var_dump($data);\n\n    $redis-&gt;select(1);\n    $redis-&gt;del($key);\n    $redis-&gt;select(0);\n    $data = $redis-&gt;move($key, 1);\n    var_dump($data);\n    $data = $redis-&gt;exists($key);\n    var_dump($data);\n    $redis-&gt;select(0);\n\n    $redis-&gt;set($key, 123);\n    $data = $redis-&gt;expire($key, 1);\n    var_dump($data);\n    $data = $redis-&gt;persist($key);\n    var_dump($data);\n\n    $redis-&gt;expire($key, 1);\n    $data = $redis-&gt;pTTL($key);\n    var_dump($data);\n\n    $data = $redis-&gt;ttl($key);\n    var_dump($data);\n\n    $data = $redis-&gt;randomKey();\n    var_dump($data);\n    $data = $redis-&gt;rename($key, $key . 'new');\n    var_dump($data);\n    var_dump($redis-&gt;expire($key . 'new'));\n    var_dump($redis-&gt;expire($key));\n\n    $data = $redis-&gt;renameNx($key, $key . 'new');\n    var_dump($data);\n    $redis-&gt;renameNx($key . 'new', $key);\n    $data = $redis-&gt;renameNx($key, $key . 'new');\n    var_dump($data);\n    $data = $redis-&gt;type($key);\n    var_dump($data);\n    $data = $redis-&gt;type($key . 'new');\n    var_dump($data);\n\n    $data = $redis-&gt;del($key);\n    var_dump($data);\n    $data = $redis-&gt;del('a','b','c');\n    var_dump($data);\n    $data = $redis-&gt;del(['a','b','c']);\n    var_dump($data);\n\n    $data = $redis-&gt;unlink($key);\n    var_dump($data);\n    $data = $redis-&gt;unlink('a','b','c');\n    var_dump($data);\n    $data = $redis-&gt;unlink(['a','b','c']);\n    var_dump($data);\n\n});","link":"/Components/Redis/keys.html"},{"id":160,"title":"字符串(string)","content":"Redis 字符串(String)\nRedis 字符串数据类型的相关命令用于管理 redis 字符串值\n操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nset\n$key, $val, $timeout = 0\n设置一个键,以及设置过期时间,单位秒\n$timeout值可为int(过期时间秒),可为string(&quot;NX&quot;,&quot;XX&quot;),也可为array['NX','EX'=&gt;10]\n\n\nget\n$key\n获取一个键\n\n\n\ngetRange\n$key, $start, $end\n返回子字符串\n\n\n\ngetSet\n$key, $value\n返回key旧值并设置新值\n\n\n\ngetBit\n$key, $offset\n获取指定偏移量上的bit值\n\n\n\nmGet\n$keys\n获取多个key的值(参数可为string或者数组)\n在集群中,将会分开处理\n\n\nsetBit\n$key, $offset, $value\n设置偏移量的bit值\n\n\n\nsetEx\n$key, $expireTime, $value\n设置值以及过期时间(秒)\n\n\n\nsetNx\n$key, $value\nkey不存在时设置 key 的值。\n\n\n\nsetRange\n$key, $offset, $value\n设置偏移量的值\n\n\n\nstrLen\n$key\n返回 key 所储存的字符串值的长度\n\n\n\nmSet\n$data\n设置多个key的值,参数为关联数组\n\n\n\nmSetNx\n$data\n当所有key不存在时,设置多个key值,参数和mSet一样\n在集群中,key将会分开处理\n\n\npSetEx\n$key, $expireTime, $value\n同setEx,过期时间为毫秒\n\n\n\nincr\n$key\n自增1\n\n\n\nincrBy\n$key, $value\n自增$value数值\n\n\n\nincrByFloat\n$key, $value\n自增$value浮点值\n\n\n\ndecr\n$key\n自减1\n\n\n\ndecrBy\n$key, $value\n自减$value数值\n\n\n\nappEnd\n$key, $value\n追加字符串\n\n\n\nscan\n&amp;$cursor, $pattern=null, $count=null\n迭代string键名\n集群模式不能使用\n\n\n\n如果开启序列化配置,getRange,setRange,getBit,setBit,strLen,自增自减命令,append等都会失效\n在集群中,批量设置,批量获取都是拆数组一个个处理的,所以mSetNx 的特性将失效\n基本使用\n\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $key = 'test';\n    $value = 1;\n    $data = $redis-&gt;del($key);\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value);\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value,'XX');\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value,'NX');\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value,['NX','EX'=&gt;20]);\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value,['NX','PX'=&gt;20000]);\n    var_dump($data);\n\n    $data = $redis-&gt;get($key);\n    var_dump($data);\n\n    $data = $redis-&gt;exists($key);\n    var_dump($data);\n\n    $data = $redis-&gt;set($key, $value);\n    var_dump($data);\n    $value += 1;\n    $data = $redis-&gt;incr($key);\n    var_dump($data);\n\n    $value += 10;\n    $data = $redis-&gt;incrBy($key, 10);\n    var_dump($data);\n\n    $value -= 1;\n    $data = $redis-&gt;decr($key);\n    var_dump($data);\n\n    $value -= 10;\n    $data = $redis-&gt;decrBy($key, 10);\n    var_dump($data);\n\n    $key = 'stringTest';\n    $value = 'tioncico';\n    $redis-&gt;set($key, $value);\n    $data = $redis-&gt;getRange($key, 1, 2);\n    var_dump($data);\n\n    $data = $redis-&gt;getSet($key, $value . 'a');\n    var_dump($data);\n    $redis-&gt;set($key, $value);\n\n    $bitKey = 'testBit';\n    $bitValue = 10000;\n    $redis-&gt;set($bitKey, $bitValue);\n    $data = $redis-&gt;setBit($bitKey, 1, 0);\n    var_dump($data);\n    $data = $redis-&gt;getBit($key, 1);\n    var_dump($data);\n\n    $field = [\n        'stringField1',\n        'stringField2',\n        'stringField3',\n        'stringField4',\n        'stringField5',\n    ];\n    $value = [\n        1,\n        2,\n        3,\n        4,\n        5,\n    ];\n    $data = $redis-&gt;mSet([\n        \"{$field[0]}\" =&gt; $value[0],\n        \"{$field[1]}\" =&gt; $value[1],\n        \"{$field[2]}\" =&gt; $value[2],\n        \"{$field[3]}\" =&gt; $value[3],\n        \"{$field[4]}\" =&gt; $value[4],\n    ]);\n    var_dump($data);\n    $data = $redis-&gt;mGet([$field[3], $field[2], $field[1]]);\n    var_dump($data);\n\n    $data = $redis-&gt;setEx($key, 1, $value[0] . $value[0]);\n    var_dump($data);\n    var_dump($redis-&gt;get($key));\n\n    $data = $redis-&gt;pSetEx($key, 1, $value[0]);\n    var_dump($data);\n    var_dump($redis-&gt;get($key));\n\n    $redis-&gt;del($key);\n    $data = $redis-&gt;setNx($key, 1);\n    var_dump($data);\n\n    $redis-&gt;del($field[0]);\n    $data = $redis-&gt;mSetNx([\n        \"{$field[0]}\" =&gt; $value[0],\n        \"{$field[1]}\" =&gt; $value[1],\n    ]);\n    var_dump($data);\n    var_dump( $redis-&gt;get($field[1]));\n    $redis-&gt;del($field[1]);\n    $data = $redis-&gt;mSetNx([\n        \"{$field[0]}\" =&gt; $value[0] + 1,\n        \"{$field[1]}\" =&gt; $value[1] + 1,\n    ]);\n    var_dump($data);\n    var_dump($redis-&gt;get($field[0]));\n\n    $data = $redis-&gt;setRange($field[0], 1, 1);\n    var_dump($data);\n    var_dump($redis-&gt;get($field[0]));\n\n    $data = $redis-&gt;strLen($field[0]);\n    var_dump($data);\n\n    $redis-&gt;set($key, 1);\n    $data = $redis-&gt;incrByFloat($key, 0.1);\n    var_dump($data);\n    $data = $redis-&gt;appEnd($field[0], '1');\n    var_dump($data);\n    var_dump($redis-&gt;get($field[0]));\n\n    //迭代测试\n    $cursor = 0;//迭代初始值0\n    $redis-&gt;flushAll();\n    $redis-&gt;set('xxxa', '仙士可');\n    $redis-&gt;set('xxxb', '仙士可');\n    $redis-&gt;set('xxxc', '仙士可');\n    $redis-&gt;set('xxxd', '仙士可');\n    $data = [];\n    do {\n        //每次迭代都会设置一次$cursor,为0代表迭代完成\n        $keys = $redis-&gt;scan($cursor, 'xxx*', 1);\n        $data = array_merge($data,$keys);\n    } while ($cursor);\n    var_dump($data);\n});","link":"/Components/Redis/string.html"},{"id":161,"title":"哈希(hash)","content":"Redis 哈希(Hash)\nRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\nRedis 中每个 hash 可以存储 232 - 1 键值对（40多亿)。\n操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nhDel\n$key, ...$field\n删除键,可多个\n\n\n\nhExists\n$key, $field\n查询字段是否存在\n\n\n\nhGet\n$key, $field\n获取一个字段值\n\n\n\nhGetAll\n$key\n获取这个key的全部字段值\n\n\n\nhSet\n$key, $field, $value\n设置key的字段值\n\n\n\nhValS\n$key\n获取哈希表中所有值\n\n\n\nhKeys\n$key\n获取所有哈希表中的字段\n\n\n\nhLen\n$key\n获取哈希表中字段的数量\n\n\n\nhMGet\n$key, $hashKeys\n获取所有给定字段$hashKeys数组的值\n\n\n\nhMSet\n$key, $data\n同时将多个$data键值对设置到$key中\n\n\n\nhIncrBy\n$key, $field, $increment\n给指定字段增加$increment\n\n\n\nhIncrByFloat\n$key, $field, $increment\n给指定字段增加浮点数$increment\n\n\n\nhSetNx\n$key, $field, $value\n只有在$filed不存在时,设置$field的值\n\n\n\nhScan\n$key,&amp;$cursor, $pattern=null, $count=null\n迭代哈希表中的键值对。\n\n\n\n\n基本使用\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n\n    $key = 'hKey';\n    $field = [\n        'hField1',\n        'hField2',\n        'hField3',\n        'hField4',\n        'hField5',\n    ];\n    $value = [\n        1,\n        2,\n        3,\n        4,\n        5,\n    ];\n\n    $redis-&gt;del($key);\n    $data = $redis-&gt;hSet($key, $field[0], $value[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hGet($key, $field[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hExists($key, $field[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hDel($key, $field[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hExists($key, $field[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hMSet($key, [\n        \"{$field[0]}\" =&gt; $value[0],\n        \"{$field[1]}\" =&gt; $value[1],\n        \"{$field[2]}\" =&gt; $value[2],\n        \"{$field[3]}\" =&gt; $value[3],\n        \"{$field[4]}\" =&gt; $value[4],\n    ]);\n    var_dump($data);\n    $data = $redis-&gt;hValS($key);\n    var_dump($data);\n\n    $data = $redis-&gt;hGetAll($key);\n    var_dump($data);\n\n    $data = $redis-&gt;hKeys($key);\n    var_dump($data);\n\n    $data = $redis-&gt;hLen($key);\n    var_dump($data);\n\n   $data = $redis-&gt;hMGet($key, [$field[0], $field[1], $field[2]]);\n    var_dump($data);\n\n    $data = $redis-&gt;hIncrBy($key, $field[4], 1);\n    var_dump($data);\n\n    $data = $redis-&gt;hIncrByFloat($key, $field[1], 1.1);\n    var_dump($data);\n\n    $data = $redis-&gt;hSetNx($key, $field[0], 1);\n    var_dump($data);\n\n    $data = $redis-&gt;hSetNx($key, $field[0] . 'a', 1);\n    var_dump($data);\n    var_dump($redis-&gt;hGet($key, $field[0] . 'a'));\n\n    $cursor = 0;\n    $redis-&gt;del('a');\n    $redis-&gt;hMSet('a',[\n        'a'=&gt;'tioncico',\n        'b'=&gt;'tioncico',\n        'c'=&gt;'tioncico',\n        'd'=&gt;'tioncico',\n        'e'=&gt;'tioncico',\n        'f'=&gt;'tioncico',\n        'g'=&gt;'tioncico',\n        'h'=&gt;'tioncico',\n    ]);\n\n    $data = [];\n    do {\n        $keys = $redis-&gt;hScan('a',$cursor);\n        $data = array_merge($data,$keys);\n        var_dump($keys);\n    } while ($cursor);\n\n});\n","link":"/Components/Redis/hash.html"},{"id":162,"title":"列表(lists)","content":"Redis 列表(List)\nRedis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）\n一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。\n操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nlPush\n$key, ...$data\n将一个或多个值插入到列表头部\n\n\n\nbLPop\n$keys,$timeout\n移出并获取$keys列表的第一个元素， 如果$keys列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\n$keys可为string,也可以为一个数组\n\n\nbRPop\n$keys,$timeout\n移出并获取$keys列表的最后一个元素， 如果$keys列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n$keys可为string,也可以为一个数组\n\n\nbRPopLPush\n$source, $destination, $timeout\n从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n\n\n\nrPopLPush\n$source, $destination\n移除列表的最后一个元素，并将该元素添加到另一个列表并返回\n\n\n\nlIndex\n$key,$index\n通过索引获取列表中的元素\n\n\n\nlLen\n$key\n获取列表长度\n\n\n\nlInsert\n$key,$bool,$pivot,$value\n在列表的元素前或者后插入元素\n\n\n\nrPush\n$key, ...$data\n在列表中添加一个或多个值\n\n\n\nlRange\n$key,$start,$stop\n获取列表指定范围内的元素\n\n\n\nlPop\n$key\n移出并获取列表的第一个元素\n\n\n\nrPop\n$key\n移出并获取列表的最后一个元素\n\n\n\nlPuShx\n$key,$value\n将一个值插入到已存在的列表头部\n\n\n\nrPuShx\n$key,$value\n为已存在的列表添加值\n\n\n\nlRem\n$key,$count,$value\n移除列表元素\n\n\n\nlSet\n$key,$index,$value\n通过索引设置列表元素的值\n\n\n\nlTrim\n$key,$start,$stop\n对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。\n\n\n\n\n基本使用\n\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    $key = [\n        'listKey1',\n        'listKey2',\n        'listKey3',\n    ];\n    $value = [\n        'a', 'b', 'c', 'd'\n    ];\n\n    $redis-&gt;flushAll();\n\n    //测试null的时候\n    $data = $redis-&gt;bLPop([$key[0],$key[1]], 1);\n    var_dump($data);\n    $data = $redis-&gt;lPush($key[0], $value[0], $value[1]);\n    var_dump($data);\n\n    //测试null的时候\n    $data = $redis-&gt;bLPop([$key[1]], 1);\n    var_dump($data);\n    $data = $redis-&gt;bRPop([$key[1]], 1);\n    var_dump($data);\n\n    $data = $redis-&gt;bLPop([$key[0],$key[1]], 1);\n    var_dump($data);\n\n    $data = $redis-&gt;bRPop([$key[0],$key[1]], 1);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;lPush($key[0], $value[0], $value[1]);\n    $data = $redis-&gt;bRPopLPush($key[0], $key[1], 1);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;lPush($key[0], $value[0], $value[1]);\n    $data = $redis-&gt;rPopLPush($key[0], $key[1]);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;lPush($key[0], $value[0], $value[1]);\n    $data = $redis-&gt;lIndex($key[0], 1);\n    var_dump($data);\n    $data = $redis-&gt;lLen($key[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;lInsert($key[0], true, 'b', 'c');\n    var_dump($data);\n    $data = $redis-&gt;lInsert($key[0], true, 'd', 'c');\n    var_dump($data);\n\n    $redis-&gt;del($key[1]);\n    $data = $redis-&gt;rPush($key[1], $value[0], $value[2], $value[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;lRange($key[1], 0, 3);\n    var_dump($data);\n\n    $data = $redis-&gt;lPop($key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;rPop($key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;lPuShx($key[1], 'x');\n    var_dump($data);\n\n    $data = $redis-&gt;rPuShx($key[1], 'z');\n    var_dump($data);\n\n    $redis-&gt;del($key[1]);\n    $redis-&gt;rPush($key[1], $value[0], $value[0], $value[0]);\n    $data = $redis-&gt;lRem($key[1], 1, $value[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;lSet($key[1], 0, 'xx');\n    var_dump($data);\n\n    $data = $redis-&gt;lTrim($key[1], 0, 2);\n    var_dump($data);\n});\n","link":"/Components/Redis/lists.html"},{"id":163,"title":"集合(sets)","content":"Redis 集合(Set)\nRedis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。\nRedis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。\n集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nsAdd\n$key, ...$data\n向集合添加一个或多个成员\n\n\n\nsCard\n$key\n获取集合的成员数\n\n\n\nsDiff\n$key1, ...$keys\n返回给定所有集合的差集\n\n\n\nsMembers\n$destination, ...$keys\n返回集合中的所有成员\n\n\n\nsDiffStore\n$key1, ...$keys\n返回给定所有集合的差集并存储在 destination 中\n\n\n\nsInter\n$destination, ...$keys\n返回给定所有集合的交集\n\n\n\nsInterStore\n$key, $member\n返回给定所有集合的交集并存储在 destination 中\n\n\n\nsIsMember\n$key\n判断 member 元素是否是集合 key 的成员\n\n\n\nsMove\n$source, $destination, $member\n将 member 元素从 source 集合移动到 destination 集合\n\n\n\nsPop\n$key\n移除并返回集合中的一个随机元素\n\n\n\nsRandMemBer\n$key, $count = null\n返回集合中一个或多个随机数\n\n\n\nsRem\n$key, $member1, ...$members\n移除集合中一个或多个成员\n\n\n\nsUnion\n$key1, ...$keys\n返回所有给定集合的并集\n\n\n\nsUnIonStore\n$destination, $key1, ...$keys\n所有给定集合的并集存储在 destination 集合中\n\n\n\nsScan\n$key,&amp;$cursor, $pattern=null, $count=null\n迭代集合中的元素\n\n\n\n\n在集群模式中,sDiff,sDiffStore,sInter,sMove,sUnion,sUnIonStore等方法不能使用\n基本使用\ngo(function () {\n     $redis =  new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $key = [\n            'muster1',\n            'muster2',\n            'muster3',\n            'muster4',\n            'muster5',\n        ];\n        $value = [\n            '1',\n            '2',\n            '3',\n            '4',\n        ];\n    $redis-&gt;del($key[0]);\n    $redis-&gt;del($key[1]);\n    $data = $redis-&gt;sAdd($key[0], $value[0], $value[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sCard($key[0]);\n    var_dump($data);\n\n    $redis-&gt;sAdd($key[1], $value[0], $value[2]);\n    $data = $redis-&gt;sDiff($key[0], $key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sDiff($key[1], $key[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;sMembers($key[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;sMembers($key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sDiffStore($key[2], $key[0], $key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sInter($key[0], $key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sInterStore($key[3], $key[0], $key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sIsMember($key[0], $value[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;sMove($key[0], $key[1], $value[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sPop($key[0]);\n    var_dump($data);\n\n    $redis-&gt;del($key[3]);\n    $redis-&gt;sAdd($key[3], $value[0], $value[1], $value[2], $value[3]);\n    $data = $redis-&gt;sRandMemBer($key[3], 4);\n    var_dump($data);\n\n    $data = $redis-&gt;sRem($key[3], $value[0], $value[1], $value[2], $value[3]);\n    var_dump($data);\n\n    $data = $redis-&gt;sUnion($key[0], $key[1]);\n    var_dump($data);\n\n    $redis-&gt;del($key[1]);\n    $redis-&gt;del($key[2]);\n    $redis-&gt;del($key[3]);\n    $redis-&gt;del($key[4]);\n    $redis-&gt;sAdd($key[1], 1, 2, 3, 4);\n    $redis-&gt;sAdd($key[2], 5);\n    $redis-&gt;sAdd($key[3], 6, 7);\n    $data = $redis-&gt;sUnIonStore($key[4], $key[1], $key[2], $key[3]);\n    var_dump($data);\n\n    $cursor = 0;\n    $redis-&gt;del('a');\n    $redis-&gt;sAdd('a','a1','a2','a3','a4','a5');\n    $data= [];\n    do {\n        $keys = $redis-&gt;sScan('a',$cursor,'*',1);\n        $data = array_merge($data,$keys);\n    } while ($cursor);\n    var_dump($data);\n});","link":"/Components/Redis/sets.html"},{"id":164,"title":"有序集合(sortedsets)","content":"Redis 有序集合(sorted set)\nRedis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。\n不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\n有序集合的成员是唯一的,但分数(score)却可以重复。\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nzAdd\n$key, $score1, $member1, ...$data\n向有序集合添加一个或多个成员，或者更新已存在成员的分数\n\n\n\nzCard\n$key\n获取有序集合的成员数\n\n\n\nzCount\n$key, $min, $max\n计算在有序集合中指定区间分数的成员数\n\n\n\nzInCrBy\n$key, $increment, $member\n有序集合中对指定成员的分数加上增量 increment\n\n\n\nzInTerStore\n$destination, array $keys, array $weights = [], $aggregate = 'SUM'\n计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中\n\n\n\nzLexCount\n$key, $min, $max\n在有序集合中计算指定字典区间内成员数量\n\n\n\nzRange\n$key, $start, $stop, $withScores = false\n通过索引区间返回有序集合指定区间内的成员\n\n\n\nzRangeByLex\n$key, $min, $max, ...$data\n通过字典区间返回有序集合的成员\n\n\n\nzRangeByScore\n$key, $min, $max, array $options\n通过分数返回有序集合指定区间内的成员\n\n\n\nzRank\n$key, $member\n返回有序集合中指定成员的索引\n\n\n\nzRem\n$key, $member, ...$members\n移除有序集合中的一个或多个成员\n\n\n\nzRemRangeByLex\n$key, $min, $max\n移除有序集合中给定的字典区间的所有成员\n\n\n\nzRemRangeByRank\n$key, $start, $stop\n移除有序集合中给定的排名区间的所有成员\n\n\n\nzRemRangeByScore\n$key, $min, $max\n移除有序集合中给定的分数区间的所有成员\n\n\n\nzRevRange\n$key, $start, $stop, $withScores = false\n返回有序集中指定区间内的成员，通过索引，分数从高到低\n\n\n\nzRevRangeByScore\n$key, $max, $min, array $options\n返回有序集中指定分数区间内的成员，分数从高到低排序\n\n\n\nzRevRank\n$key, $member\n返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序\n\n\n\nzScore\n$key, $member\n返回有序集中，成员的分数值\n\n\n\nzUnionStore\n$destination, array $keys, array $weights = [], $aggregate = 'SUM'\n计算给定的一个或多个有序集的并集，并存储在新的 key 中\n\n\n\nzScan\n$key,&amp;$cursor, $pattern=null, $count=null\n迭代有序集合中的元素（包括元素成员和元素分值）\n\n\n\n\n在集群模式中,zInTerStore,zUnionStore 等方法不能使用\n基本使用\ngo(function (){\n    $redis =  new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $key = [\n            'sortMuster1',\n            'sortMuster2',\n            'sortMuster3',\n            'sortMuster4',\n            'sortMuster5',\n        ];\n    $member = [\n        'member1',\n        'member2',\n        'member3',\n        'member4',\n        'member5',\n    ];\n    $score = [\n        1,\n        2,\n        3,\n        4,\n    ];\n    $redis-&gt;del($key[0]);\n    $data = $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;zCard($key[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;zCount($key[0], 0, 3);\n    var_dump($data);\n\n    $data = $redis-&gt;zInCrBy($key[0], 1, $member[1]);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;del($key[1]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1]);\n    $redis-&gt;zAdd($key[1], $score[0], $member[0], $score[3], $member[3]);\n    $data = $redis-&gt;zInTerStore($key[2], [$key[0], $key[1]], [1, 2]);\n    var_dump($data);\n\n    $data = $redis-&gt;zLexCount($key[0], '-', '+');\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRange($key[0], 0, -1, true);\n    var_dump($data);\n\n    $data = $redis-&gt;zRangeByLex($key[0], '-', '+');\n    var_dump($data);\n\n    $data = $redis-&gt;zRangeByScore($key[0], 2, 3, ['withScores' =&gt; true, 'limit' =&gt; array(0, 2)]);\n    var_dump($data);\n\n    $data = $redis-&gt;zRank($key[0], $member[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;zRem($key[0], $member[1], $member[2]);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRemRangeByLex($key[0], '-', '+');\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRemRangeByRank($key[0], 0, 2);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRemRangeByScore($key[0], 0, 3);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRevRange($key[0], 0, 3, true);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRevRangeByScore($key[0], 3, 0, ['withScores' =&gt; true, 'limit' =&gt; array(0, 3)]);\n    var_dump($data);\n\n    $data = $redis-&gt;zRevRank($key[0], $member[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;zScore($key[0], $member[0]);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;del($key[1]);\n    $redis-&gt;del($key[2]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1]);\n    $redis-&gt;zAdd($key[1], $score[0], $member[0], $score[3], $member[3]);\n    $data = $redis-&gt;zUnionStore($key[2], [$key[1], $key[0]]);\n    var_dump($data);\n\n    $cursor = 0;\n    $redis-&gt;del('a');\n    $redis-&gt;zAdd('a',1,'a1',2,'a2',3,'a3',4,'a4',5,'a5');\n    $data = [];\n    do {\n        $keys = $redis-&gt;zScan('a',$cursor,'*',1);\n        $data = array_merge($data,$keys);\n    } while ($cursor);\n    var_dump($data);\n\n})","link":"/Components/Redis/sortedSets.html"},{"id":165,"title":"hyperloglog","content":"Redis HyperLogLog\nRedis 在 2.8.9 版本添加了 HyperLogLog 结构。\nRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。\n在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\n操作方法\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\npfAdd\n$key, $elements\n添加指定元素到 HyperLogLog 中。\n传入一个索引数组\n\n\npfCount\n$key\n返回给定 HyperLogLog 的基数估算值。\n\n\n\npfMerge\n$deStKey, array $sourceKeys\n将多个 HyperLogLog 合并为一个 HyperLogLog\n传入一个索引数组\n\n\n\n基本使用\n\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    $key = [\n        'hp1',\n        'hp2',\n        'hp3',\n        'hp4',\n        'hp5',\n    ];\n    $redis-&gt;del($key[0]);\n    $redis-&gt;del($key[1]);\n    $data = $redis-&gt;pfAdd($key[0], [1, 2, 2, 3, 3]);\n    var_dump($data);\n\n    $redis-&gt;pfAdd($key[1], [1, 2, 2, 3, 3]);\n    $data = $redis-&gt;pfCount([$key[0], $key[1]]);\n    var_dump($data);\n\n    $data = $redis-&gt;pfMerge($key[2], [$key[0], $key[1]]);\n    var_dump($data);\n});\n","link":"/Components/Redis/hyperLogLog.html"},{"id":166,"title":"发布/订阅(pub/sub)","content":"Redis 发布订阅\nRedis发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。\n操作方法\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\n\npSubscribe\n$callback, $pattern, ...$patterns\n订阅一个或多个符合给定模式的频道。\n$callback是回调函数\n\n\n\npubSub\n$subCommand, ...$arguments\n查看订阅与发布系统状态。\n\n\n\n\npublish\n$channel, $message\n将信息发送到指定的频道。\n\n\n\n\npUnSubscribe\n$pattern, ...$patterns\n退订所有给定模式的频道。\n\n\n\n\n\n\n\n\n\n\n\nsubscribe\n$callback, $channel, ...$channels\n订阅给定的一个或多个频道的信息。\n\n\n\n\n\n\n\n\n\n\n\nunsubscribe\n$channel, ...$channels\n指退订给定的频道。\n\n\n\n\n\n\n\n\n\n\n\nsetSubscribeStop\nbool $subscribeStop\n设置是否退出订阅\n当你回调函数想退出时,调用这个命令\n\n\n\nisSubscribeStop\n\n查看当前订阅状态\n\n\n\n\n\n基本使用\n\ndefined(\"REDIS_HOST\") ?: define('REDIS_HOST', '127.0.0.1');\ndefined(\"REDIS_PORT\") ?: define('REDIS_PORT', 6379);\ndefined(\"REDIS_AUTH\") ?: define('REDIS_AUTH', 'easyswoole');\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    //新开协程进行订阅\n    go(function () {\n        $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n            'host' =&gt; REDIS_HOST,\n            'port' =&gt; REDIS_PORT,\n            'auth' =&gt; REDIS_AUTH\n        ]));\n        $redis-&gt;pSubscribe(function (\\EasySwoole\\Redis\\Redis $redis, $pattern, $str) {\n            var_dump($pattern,$str);\n            $data = $redis-&gt;unsubscribe('test');\n            var_dump($data);\n            $redis-&gt;setSubscribeStop(true);\n        }, 'test', 'test1', 'test2');\n    });\n\n    //新开协程进行订阅\n    go(function () {\n        $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n            'host' =&gt; REDIS_HOST,\n            'port' =&gt; REDIS_PORT,\n            'auth' =&gt; REDIS_AUTH\n        ]));\n        $redis-&gt;subscribe(function (\\EasySwoole\\Redis\\Redis $redis, $pattern, $str) {\n            var_dump($pattern,$str);\n            $data = $redis-&gt;unsubscribe('test');\n            var_dump($data);\n            $redis-&gt;setSubscribeStop(true);\n        }, 'test', 'test1', 'test2');\n    });\n\n    $data = $redis-&gt;pubSub('CHANNELS');\n    var_dump($data);\n    \\Swoole\\Coroutine::sleep(1);\n\n    $data = $redis-&gt;publish('test2', 'test');\n    var_dump($data);\n\n    $data = $redis-&gt;pUnSubscribe('test');\n    var_dump($data);\n\n});\n","link":"/Components/Redis/pubSub.html"},{"id":167,"title":"事物(transaction)","content":"Redis 事务\nRedis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：\n\n批量操作在发送 EXEC 命令前被放入队列缓存。\n收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。\n在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n\n一个事务从开始到执行会经历以下三个阶段：\n\n开始事务。\n命令入队。\n执行事务。\n操作方法\n\n\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\ndiscard\n\n取消事务(回滚)\n\n\n\nexec\n\n执行事务(获取事务结果)\n\n\n\nmulti\n\n开始事务\n\n\n\nunWatch\n\n取消 WATCH 命令对所有 key 的监视\n\n\n\nwatch\n$key, ...$keys\n监视key\n\n\n\n\n开始事务之后,操作命令都将返回\"QUEUED\",直到取消事务或者执行事务,执行exec之后,将返回所有命令结果\n在集群中并不支持事务.\n基本使用\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $data = $redis-&gt;multi();\n    var_dump($data);\n    $redis-&gt;del('ha');\n    $data = $redis-&gt;hset('ha', 'a', 1);\n    var_dump($data);\n    $data = $redis-&gt;hset('ha', 'b', '2');\n    var_dump($data);\n    $data = $redis-&gt;hset('ha', 'c', '3');\n    var_dump($data);\n    $data = $redis-&gt;hGetAll('ha');\n    var_dump($data);\n    $data = $redis-&gt;exec();\n    var_dump($data);\n\n    $redis-&gt;multi();\n    $data = $redis-&gt;discard();\n    var_dump($data);\n    $data = $redis-&gt;watch('a', 'b', 'c');\n    var_dump($data);\n    $data = $redis-&gt;unwatch();\n    var_dump($data);\n\n});","link":"/Components/Redis/transaction.html"},{"id":168,"title":"管道(pipe)","content":"Redis 管道技术\nRedis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。\n操作方法\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\ndiscardPipe\n\n取消管道\n\n\n\nexecPipe\n\n一次性发送命令\n\n\n\nstartPipe\n\n管道开始记录\n\n\n\n\n开始管道之后,操作命令都将返回\"PIPE\",直到取消管道或者执行,执行exec之后,将返回所有命令结果\n管道开始后,所有命令调用之后并不会执行,而是会记录起来,然后等待exec的时候一次性发送给redis服务端\n所以需要注意内存,一次管道不要执行过多的命令\n集群目前不支持管道模式,将会出现错误\n基本使用\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    $redis-&gt;get('a');\n    $data = $redis-&gt;startPipe();\n    var_dump($data);\n    $redis-&gt;del('ha');\n    $data = $redis-&gt;hset('ha', \"a\", \"a\\r\\nb\\r\\nc\");\n    var_dump($data);\n    $data = $redis-&gt;hset('ha', 'b', '2');\n    var_dump($data);\n    $data = $redis-&gt;hset('ha', 'c', '3');\n    var_dump($data);\n    $data = $redis-&gt;hGetAll('ha');\n    var_dump($data);\n    $data = $redis-&gt;execPipe();\n\n    var_dump($data);\n\n    $redis-&gt;startPipe();\n    $data = $redis-&gt;set(\"a\", '1');\n    var_dump($data);\n    $data = $redis-&gt;discardPipe();\n    var_dump($data);\n\n});","link":"/Components/Redis/pipe.html"},{"id":169,"title":"server命令","content":"Redis 服务器\nRedis 服务器命令主要是用于管理 redis 服务。\n操作方法\n\n\n\n方法列表\n方法名称\n参数\n说明\n备注\n\n\n\n\nbgRewriteAof\n\n手动触发重写操作。\n\n\n\nbgSave\n\n在后台异步保存当前数据库的数据到磁盘\n\n\n\nclientKill\n$data\n关闭客户端连接\n\n\n\nclientList\n\n获取连接到服务器的客户端连接列表\n\n\n\nclientGetName\n\n获取连接的名称\n\n\n\nclientPause\n$timeout\n在指定时间内终止运行来自客户端的命令\n\n\n\nclientSetName\n$connectionName\n设置当前连接的名称\n\n\n\ncommand\n\n获取 Redis 命令详情数组\n\n\n\ncommandCount\n\n获取 Redis 命令总数\n\n\n\ncommandGetKeys\n...$data\n获取给定命令的所有键\n\n\n\ntime\n\n返回当前redis服务器时间\n\n\n\ncommandInfo\n$commandName, ...$commandNames\n获取指定 Redis 命令描述的数组\n\n\n\nconfigGet\n$parameter\n获取指定配置参数的值\n\n\n\nconfigRewrite\n\n对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写\n\n\n\nconfigSet\n$parameter, $value\n修改 redis 配置参数,无需重启\n\n\n\nconfigResetStat\n\n重置 INFO 命令中的某些统计数据\n\n\n\ndBSize\n\n返回当前数据库的 key 的数量\n\n\n\ndebugObject\n$key\n获取 key 的调试信息\n\n\n\ndebugSegfault\n\n让 Redis 服务崩溃\n\n\n\nflushAll\n\n删除所有数据库的所有key\n\n\n\nflushDb\n\n删除当前数据库的所有key\n\n\n\ninfo\n$section = null\n获取 Redis 服务器的各种信息和统计数值\n\n\n\nlastSave\n\n返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示\n\n\n\nmonitor\ncallable $callback\nredis监视器,实时打印出 Redis 服务器接收到的命令\n\n\n\nisMonitorStop\n\n判断是否开启监视器\n\n\n\nsetMonitorStop\nbool $monitorStop\n设置停止监视器\n\n\n\nrole\n\n返回主从实例所属的角色\n\n\n\nsave\n\n同步保存数据到硬盘\n\n\n\nshutdown\n\n异步保存数据到硬盘，并关闭服务器\n\n\n\nslowLog\n$subCommand, ...$argument\n管理 redis 的慢日志\n\n\n\nSYNC\n\n用于复制功能(replication)的内部命令\n\n\n\n\n基本使用\n&lt;?php  \ngo(function () {\n    $redisConfig = new \\EasySwoole\\Redis\\Config\\RedisConfig();\n    $redisConfig-&gt;setAuth('easyswoole');\n    $redis = new \\EasySwoole\\Redis\\Redis($redisConfig);\n\n    $data = $redis-&gt;bgRewriteAof();\n    var_dump($data);\n    \\Swoole\\Coroutine::sleep(1);\n    $data = $redis-&gt;bgSave();\n    var_dump($data);\n    $data = $redis-&gt;clientList();\n    var_dump($data);\n    $data = $redis-&gt;clientSetName('test');\n    var_dump($data);\n    $data = $redis-&gt;clientGetName();\n    var_dump($data);\n    $data = $redis-&gt;clientPause(1);\n    var_dump($data);\n    $data = $redis-&gt;command();\n    var_dump($data);\n    $data = $redis-&gt;commandCount();\n    var_dump($data);\n    $data = $redis-&gt;commandGetKeys('MSET', 'a', 'b', 'c', 'd');\n    var_dump($data);\n    $data = $redis-&gt;time();\n    var_dump($data);\n    $data = $redis-&gt;commandInfo('get', 'set');\n    var_dump($data);\n    $data = $redis-&gt;configGet('*max-*-entries*');\n    var_dump($data);\n\n    $data = $redis-&gt;configSet('appendonly', 'yes');\n    var_dump($data);\n    $data = $redis-&gt;configRewrite();\n    var_dump($data);\n    $data = $redis-&gt;configResetStat();\n    var_dump($data);\n    $data = $redis-&gt;dBSize();\n    var_dump($data);\n    $redis-&gt;set('a', 1);\n    $data = $redis-&gt;debugObject('a');\n    var_dump($data);\n    $data = $redis-&gt;flushAll();\n    var_dump($data);\n    $data = $redis-&gt;flushDb();\n    var_dump($data);\n    $data = $redis-&gt;info();\n    var_dump($data);\n    $data = $redis-&gt;lastSave();\n    var_dump($data);\n    go(function () {\n        $redisConfig = new \\EasySwoole\\Redis\\Config\\RedisConfig();\n        $redisConfig-&gt;setAuth('easyswoole');\n        $redis = new \\EasySwoole\\Redis\\Redis($redisConfig);\n        $redis-&gt;monitor(function ( \\EasySwoole\\Redis\\Redis $redis, $data) {\n            $this-&gt;assertIsString($data);\n            $redis-&gt;set('a', 1);\n            $redis-&gt;setMonitorStop(true);\n        });\n    });\n\n    go(function () {\n        $redisConfig = new \\EasySwoole\\Redis\\Config\\RedisConfig();\n        $redisConfig-&gt;setAuth('easyswoole');\n        $redis = new \\EasySwoole\\Redis\\Redis($redisConfig);\n        \\Swoole\\Coroutine::sleep(1);\n        $redis-&gt;set('a', 1);\n    });\n\n    $data = $redis-&gt;save();\n    var_dump($data);\n    $data = $redis-&gt;clientKill($data[0]['addr']);\n    var_dump($data);\n    $data = $redis-&gt;slowLog('get', 'a');\n    var_dump($data, $redis-&gt;getErrorMsg());\n    var_dump($data);\n});","link":"/Components/Redis/server.html"},{"id":170,"title":"geohash","content":"操作方法\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\ngeoAdd\n$key, $locationData\n新增geohash数据\n$locationData为一个数组,写法为:[[longitude=&gt;'',latitude=&gt;'',name=&gt;'']] 或者 $locationData[[longitude,latitude,name]]\n\n\ngeoDist\n$key, $location1, $location2, $unit = 'm'\n返回排序集合表示的地理空间索引中两个成员之间的距离。\n\n\n\ngeoHash\n$key, $location, ...$locations\n返回表示地理空间索引的hash值\n\n\n\ngeoPos\n$key, $location1, ...$locations\n返回按键处有序集合表示的地理空间索引的所有指定成员的位置（经度，纬度）。\n\n\n\ngeoRadius\n$key, $longitude, $latitude, $radius, $unit = 'm', $withCoord = false, $withDist = false, $withHash = false, $count = null, $sort = null, $storeKey = null, $storeDistKey = null\n返回填充了地理空间信息的已排序集合的成员\n\n\n\ngeoRadiusByMember\n$key, $location, $radius, $unit = 'm', $withCoord = false, $withDist = false, $withHash = false, $count = null, $sort = null, $storeKey = null, $storeDistKey = null\n该命令与 GEORADIUS 完全相同，唯一的区别在于，它不是以查询区域的中心为经度和纬度值，而是采用已存在于有序集合所代表的地理空间索引内的成员的名称。\n\n\n\n\n基本使用\n\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    $key = 'testGeohash';\n\n    $redis-&gt;del($key);\n    $data = $redis-&gt;geoAdd($key, [\n        ['118.6197800000', '24.88849', 'user1',],\n        ['118.6197800000', '24.88859', 'user2',],\n        ['114.8197800000', '25.88849', 'user3'],\n        ['118.8197800000', '22.88849', 'user4'],\n    ]);\n    var_dump($data);\n\n    $data = $redis-&gt;geoDist($key, 'user1', 'user2');\n    var_dump($data);\n\n    $data = $redis-&gt;geoHash($key, 'user1', 'user2');\n    var_dump($data);\n\n    $data = $redis-&gt;geoPos($key, 'user1', 'user2');\n    var_dump($data);\n\n    $data = $redis-&gt;geoRadius($key, '118.6197800000', '24.88849', 100, 'm', false, false, false, null,'desc');\n    var_dump($data);\n\n    $data = $redis-&gt;geoRadiusByMember($key, 'user1', 100, 'm', false, false, false, 2,'DESC');\n    var_dump($data);\n});","link":"/Components/Redis/geoHash.html"},{"id":171,"title":"集群方法(cluster)","content":"操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nclusterNodes\n\n获取集群节点\n\n\n\nclusterAddSlots\n$slots\n集群槽位变更,$slots可以为字符串,可以为数组\n\n\n\nclusterCountFailureReports\n$nodeId\n集群计数失败报告\n\n\n\nclusterCountKeySinSlot\n$slot\n返回指定的 Redis Cluster 哈希槽中的键的数量。\n\n\n\nclusterDelSlots\n$slot\n删除一个哈希槽\n\n\n\nclusterFailOver\n$option = null\n手动故障转移\n\n\n\nclusterForget\n$nodeId\n删除指定的节点。\n\n\n\nclusterGetKeySinSlot\n$slot, $count\n返回存储节点中的密钥名称数组，并哈希到指定的哈希槽。\n\n\n\nclusterInfo\n\n集群信息\n\n\n\nclusterKeySlot\n$key\n返回key的集群槽\n\n\n\nclusterMeet\n$ip, $port\n节点连接到工作群集。\n\n\n\nclusterReplicate\n$nodeId\n集群复制\n\n\n\nclusterReset\n$option = null\n集群重置\n\n\n\nclusterSaveConfig\n\n强制节点将nodes.conf配置保存到磁盘上。\n\n\n\nclusterSetConfigEpoch\n$configEpoch\n在新节点中设置特定的配置时期\n\n\n\nclusterSetSlot\n$slot, $subCommand, $nodeId = null\n更改接收节点中散列槽的状态\n\n\n\nclusterSlaves\n$nodeId\n获取从指定主节点复制的从节点列表。\n\n\n\nclusterSlots\n\n返回有关哪些集群插槽映射到哪些 Redis 实例的详细信息。。\n\n\n\nreadonly\n\n启用读取查询以连接到 Redis 群集从属节点。\n\n\n\nreadwrite\n\n禁用与 Redis 集群从属节点的连接的读取查询。\n\n\n\n\n基本使用\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\RedisCluster(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ], [\n        'auth'      =&gt; '',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n    ]));\n\n    $data = $redis-&gt;clusterNodes();\n    var_dump($data);\n\n    $data = $redis-&gt;clusterKeySlot('key1');\n    var_dump($data);\n\n    $data = $redis-&gt;clusterCountFailureReports(current($redis-&gt;getNodeList())['name']);\n    var_dump($data);\n\n    $data = $redis-&gt;clusterCountKeySinSlot(1);\n    var_dump($data);\n\n    $data = $redis-&gt;clusterFailOver('FORCE');\n    var_dump($data);\n\n    $redis-&gt;tryConnectServerList();\n    $data = $redis-&gt;clusterForget(array_column(($redis-&gt;getNodeList()), 'name')[0]);\n    var_dump($data);\n\n    $redis-&gt;set('a', 1);\n    $data = $redis-&gt;clusterKeySlot('a');\n    var_dump($data);\n    $data = $redis-&gt;clusterGetKeySinSlot($data, 1);\n    var_dump($data);\n\n    $data = $redis-&gt;clusterInfo();\n    var_dump($data);\n\n    $data = $redis-&gt;clusterKeySlot('b');\n    var_dump($data);\n\n    $data = $redis-&gt;clusterMeet('172.16.253.156', '9005');\n    var_dump($data);\n});\n\n由于集群方法运行较为复杂,需要操作不同的客户端实现某种方法的实例,所以本示例只提供了部分代码,没有全部,可自行调用测试","link":"/Components/Redis/clusterMethod.html"},{"id":172,"title":"安装及使用","content":"memcache协程客户端\nmemcache协程客户端,由swoole 协程client实现   \n组件要求\n\neasyswoole/spl: ^1.1 \n\n安装方法\n\ncomposer require easyswoole/memcache\n\n仓库地址\neasyswoole/memcache\n客户端调用\n$config = new \\EasySwoole\\Memcache\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 11211\n]);\n$client = new EasySwoole\\Memcache\\Memcache($config);\n使用示例:\n$config = new \\EasySwoole\\Memcache\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 11211\n]);\n$client = new EasySwoole\\Memcache\\Memcache($config);\n$client-&gt;set('a',1);\n$client-&gt;get('a');\n使用方法:\ntouch摸一下(刷新有效期)\ntouch($key, $expiration, $timeout = null)\nincrement自增KEY\nincrement($key, $offset = 1, $initialValue = 0, $expiration = 0, $timeout = null)\ndecrement自减KEY\ndecrement($key, $offset = 1, $initialValue = 0, $expiration = 0, $timeout = null)\nset设置KEY(覆盖)\nset($key, $value, $expiration = 0, $timeout = null)\nadd增加KEY(非覆盖)\nadd($key, $value, $expiration = 0, $timeout = null)\nreplace替换一个KEY\nreplace($key, $value, $expiration = 0, $timeout = null)\nappend追加数据到末尾\nappend($key, $value, $timeout = null)\nprepend追加数据到开头\nprepend($key, $value, $timeout = null)\nget获取KEY\nget($key, $timeout = null)\ndelete删除一个key\ndelete($key, $timeout = null)\nstats获取服务器状态\nstats($type = null, $timeout = null)\nversion获取服务器版本\nversion(int $timeout = null)\nflush  清空缓存\nflush(int $expiration = null, int $timeout = null)\n进阶使用\nMemcache连接池示例\n安装 easyswoole/pool 组件\n\ncomposer require easyswoole/pool\n\n具体pool相关详细用法可查看 连接池\n新增MemcachePool管理器\n新增文件/App/Pool/MemcachePool.php\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/10/15 0015\n * Time: 14:46\n */\n\nnamespace App\\Pool;\n\nuse EasySwoole\\Memcache\\Memcache;\nuse EasySwoole\\Pool\\Config;\nuse EasySwoole\\Pool\\AbstractPool;\nuse EasySwoole\\Memcache\\Config as MemcacheConfig;\n\nclass MemcachePool extends AbstractPool\n{\n    protected $memcacheConfig;\n\n    /**\n     * 重写构造函数,为了传入memcache配置\n     * RedisPool constructor.\n     * @param Config      $conf\n     * @param MemcacheConfig $memcacheConfig\n     * @throws \\EasySwoole\\Pool\\Exception\\Exception\n     */\n    public function __construct(Config $conf,MemcacheConfig $memcacheConfig)\n    {\n        parent::__construct($conf);\n        $this-&gt;memcacheConfig = $memcacheConfig;\n    }\n\n    protected function createObject():Memcache\n    {\n        //根据传入的memcache配置进行new 一个memcache客户端\n        $memcache = new Memcache($this-&gt;memcacheConfig);\n        return $memcache;\n    }\n}\n注册到Manager中(在initialize事件中注册):\n\n$config = new \\EasySwoole\\Pool\\Config();\n\n$memcacheConfig1 = new \\EasySwoole\\Memcache\\Config(Config::getInstance()-&gt;getConf('MEMCACHE1'));\n\\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\MemcachePool($config,$memcacheConfig1),'memcache1');\n\n$memcacheConfig2 = new \\EasySwoole\\Memcache\\Config(Config::getInstance()-&gt;getConf('MEMCACHE2'));\n\\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\MemcachePool($config,$memcacheConfig2),'memcache2');\n\n调用(可在控制器中全局调用):\ngo(function (){\n    $memcachePool1 = Manager::getInstance()-&gt;get('memcache1');\n    $memcachePool2 = Manager::getInstance()-&gt;get('memcache2');\n    $memcache1 = $memcachePool1-&gt;getObj();\n    $memcache2 = $memcachePool2-&gt;getObj();\n\n    var_dump($memcache1-&gt;set('name', '仙士可1'));\n    $this-&gt;response()-&gt;write($memcache1-&gt;get('name'));\n    var_dump($memcache2-&gt;set('name', '仙士可2'));\n    $this-&gt;response()-&gt;write($memcache2-&gt;get('name'));\n\n    //回收对象\n    $memcachePool1-&gt;recycleObj($memcache1);\n    $memcachePool2-&gt;recycleObj($memcache2);\n});","link":"/Components/Memcache/memcache.html"},{"id":173,"title":"安装及使用","content":"FastCache\nEasySwoole 提供了一个快速缓存，是基础UnixSock通讯和自定义进程存储数据实现的，提供基本的缓存服务，本缓存为解决小型应用中，需要动不动就部署Redis服务而出现。\n组件要求\n\nphp: &gt;=7.1.0\neasyswoole/component: ^2.0\neasyswoole/spl: ^1.1\n\n安装方法\n\ncomposer require easyswoole/fast-cache\n\n仓库地址\neasyswoole/fast-cache\n基本使用\n服务注册\n我们在EasySwoole全局的事件中进行注册\nuse EasySwoole\\FastCache\\Cache;\nCache::getInstance()-&gt;setTempDir(EASYSWOOLE_TEMP_DIR)-&gt;attachToServer(ServerManager::getInstance()-&gt;getSwooleServer());\nFastCache只能在服务启动之后使用,需要有创建unix sock权限(建议使用vm,docker或者linux系统开发),虚拟机共享目录文件夹是无法创建unix sock监听的\n客户端调用\n服务启动后，可以在任意位置调用\nuse EasySwoole\\FastCache\\Cache;\nCache::getInstance()-&gt;set('get','a');\nvar_dump(Cache::getInstance()-&gt;get('get'));\n相关方法\n\n设置临时目录\n\npublic function setTempDir(string $tempDir): Cache\n\n设置缓存进程数  \n\npublic function setProcessNum(int $num): Cache\n\n设置缓存进程所在服务名   \n\npublic function setServerName(string $serverName): Cache\n\n设置定时回调，可用于数据定时落地   \n\npublic function setOnTick($onTick): Cache\n\n设置定时回调间隔  \n\npublic function setTickInterval($tickInterval): Cache \n\n设置进程启动回调，可以用于数据落地恢复   \n\npublic function setOnStart($onStart): Cache   \n\n设置进程关闭回调，可以用于数据落地   \n\npublic function setOnShutdown(callable $onShutdown): Cache  \n\n设置指定 key 的值    \n\npublic function set($key, $value, ?int $ttl = null, float $timeout = 1.0)\n\n获取指定 key 的值\n\npublic function get($key, float $timeout = 1.0)\n\n删除指定 key的值\n\npublic function unset($key, float $timeout = 1.0)\n\n获取所有key的值\n\npublic function keys($key = null, float $timeout = 1.0): ?array\n\n清空所有进程的数据\n\npublic function flush(float $timeout = 1.0)\n\n推入队列\n\npublic function enQueue($key, $value, $timeout = 1.0)\n\n从队列中取出\n\npublic function deQueue($key, $timeout = 1.0)\n\n获取队列当前长度\n\npublic function queueSize($key, $timeout = 1.0)\n\n释放队列\n\npublic function unsetQueue($key, $timeout = 1.0)\n\n返回当前队列的全部key名称\n\npublic function queueList($timeout = 1.0): ?array\n\n清空所有队列\n\npublic function flushQueue(float $timeout = 1.0): bool\n\n设置一个key的过期时间\n\npublic function expire($key, int $ttl, $timeout = 1.0)\n\n移除一个key的过期时间   \n\npublic function persist($key, $timeout = 1.0)\n\n查看某个key的ttl   \n\npublic function ttl($key, $timeout = 1.0)\n\n将哈希表 key 中的字段 field 的值设为 value\n\nfunction hSet($key, $field, $value, float $timeout = 1.0)\n\n获取存储在哈希表中指定字段的值\n\nfunction hGet($key, $field = null, float $timeout = 1.0)\n\n删除一个哈希表字段\n\nfunction hDel($key, $field = null, float $timeout = 1.0)\n\n清空所有\n\nfunction hFlush(float $timeout = 1.0)\n\n获取所有哈希表中的字段\n\nfunction hKeys($key, float $timeout = 1.0)\n\n迭代哈希表中的键值对\n\nfunction hScan($key, $cursor = 0, $limit = 10, float $timeout = 1.0)\n\n只有在字段 field 不存在时，设置哈希表字段的值\n\nfunction hSetnx($key, $field, $value, float $timeout = 1.0)\n\n查看哈希表 key 中，指定的字段是否存在\n\nfunction hExists($key, $field, float $timeout = 1.0)\n\n获取哈希表中字段的数量\n\nfunction hLen($key, float $timeout = 1.0)\n\n为哈希表 key 中的指定字段的整数值加上\n\nfunction hIncrby($key, $field, $value, float $timeout = 1.0)\n\n同时将多个 field-value对设置到哈希表 key 中\n\nfunction hMset($key, $fieldValues, float $timeout = 1.0)\n\n获取所有给定字段的值\n\nfunction hMget($key, $fields, float $timeout = 1.0)\n\n获取哈希表中所有值\n\nfunction hVals($key, float $timeout = 1.0)\n\n获取在哈希表中指定 key 的所有字段和值\n\nfunction hGetAll($key, float $timeout = 1.0)\n\n\n落地重启恢复数据方案\nFastCache提供了3个方法,用于数据落地以及重启恢复,在EasySwooleEvent.php中的mainServerCreate回调事件中设置以下方法:\n设置回调要在注册cache服务之前，注册服务之后不能更改回调事件。 \n&lt;?php\n\nuse EasySwoole\\FastCache\\Cache;\nuse EasySwoole\\FastCache\\CacheProcessConfig;\nuse EasySwoole\\FastCache\\SyncData;\nuse EasySwoole\\Utility\\File;\n\n// 每隔5秒将数据存回文件\nCache::getInstance()-&gt;setTickInterval(5 * 1000);//设置定时频率\nCache::getInstance()-&gt;setOnTick(function (SyncData $SyncData, CacheProcessConfig $cacheProcessConfig) {\n    $data = [\n        'data'  =&gt; $SyncData-&gt;getArray(),\n        'queue' =&gt; $SyncData-&gt;getQueueArray(),\n        'ttl'   =&gt; $SyncData-&gt;getTtlKeys(),\n     // queue支持\n        'jobIds'     =&gt; $SyncData-&gt;getJobIds(),\n        'readyJob'   =&gt; $SyncData-&gt;getReadyJob(),\n        'reserveJob' =&gt; $SyncData-&gt;getReserveJob(),\n        'delayJob'   =&gt; $SyncData-&gt;getDelayJob(),\n        'buryJob'    =&gt; $SyncData-&gt;getBuryJob(),\n    ];\n    $path = EASYSWOOLE_TEMP_DIR . '/FastCacheData/' . $cacheProcessConfig-&gt;getProcessName();\n    File::createFile($path,serialize($data));\n});\n\n// 启动时将存回的文件重新写入\nCache::getInstance()-&gt;setOnStart(function (CacheProcessConfig $cacheProcessConfig) {\n    $path = EASYSWOOLE_TEMP_DIR . '/FastCacheData/' . $cacheProcessConfig-&gt;getProcessName();\n    if(is_file($path)){\n        $data = unserialize(file_get_contents($path));\n        $syncData = new SyncData();\n        $syncData-&gt;setArray($data['data']);\n        $syncData-&gt;setQueueArray($data['queue']);\n        $syncData-&gt;setTtlKeys(($data['ttl']));\n        // queue支持\n        $syncData-&gt;setJobIds($data['jobIds']);\n        $syncData-&gt;setReadyJob($data['readyJob']);\n        $syncData-&gt;setReserveJob($data['reserveJob']);\n        $syncData-&gt;setDelayJob($data['delayJob']);\n        $syncData-&gt;setBuryJob($data['buryJob']);\n        return $syncData;\n    }\n});\n\n// 在守护进程时,php easyswoole stop 时会调用,落地数据\nCache::getInstance()-&gt;setOnShutdown(function (SyncData $SyncData, CacheProcessConfig $cacheProcessConfig) {\n    $data = [\n        'data'  =&gt; $SyncData-&gt;getArray(),\n        'queue' =&gt; $SyncData-&gt;getQueueArray(),\n        'ttl'   =&gt; $SyncData-&gt;getTtlKeys(),\n         // queue支持\n        'jobIds'     =&gt; $SyncData-&gt;getJobIds(),\n        'readyJob'   =&gt; $SyncData-&gt;getReadyJob(),\n        'reserveJob' =&gt; $SyncData-&gt;getReserveJob(),\n        'delayJob'   =&gt; $SyncData-&gt;getDelayJob(),\n        'buryJob'    =&gt; $SyncData-&gt;getBuryJob(),\n    ];\n    $path = EASYSWOOLE_TEMP_DIR . '/FastCacheData/' . $cacheProcessConfig-&gt;getProcessName();\n    File::createFile($path,serialize($data));\n});\n\nCache::getInstance()-&gt;setTempDir(EASYSWOOLE_TEMP_DIR)-&gt;attachToServer(ServerManager::getInstance()-&gt;getSwooleServer());\n\n消息队列支持\n如具体查看消息队列，请查看FastCacheQueue","link":"/Components/FashCache/fastCache.html"},{"id":174,"title":"安装","content":"Queue介绍\nEasyswoole封装实现了一个轻量级的队列，默认以Redis作为队列驱动器。\n可以自己实现一个队列驱动来实现用kafka或者启动方式的队列存储。\n从上可知，Queue并不是一个单独使用的组件，它更像一个对不同驱动的队列进行统一封装的门面组件。\n组件要求\n\next-swoole: &gt;=4.4.0\neasyswoole/component: ^2.0\neasyswoole/redis-pool: ~2.2.0\n\n安装方法\n\ncomposer require easyswoole/queue=2.1.x\n\n仓库地址\neasyswoole/queue\n基本使用\n\n注册队列驱动器\n设置消费进程\n生产者投递任务\n\n定义一个队列\nnamespace App\\Utility;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\Queue\\Queue;\n\nclass MyQueue extends Queue\n{\n    use Singleton;\n}\n定义消费进程\nnamespace App\\Utility;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Queue\\Job;\n\nclass QueueProcess extends AbstractProcess\n{\n\n    protected function run($arg)\n    {\n        go(function (){\n            MyQueue::getInstance()-&gt;consumer()-&gt;listen(function (Job $job){\n                var_dump($job-&gt;getJobData());\n            });\n        });\n    }\n}\n\n可以多进程，多协程消费\n\n驱动注册\n &lt;?php\n\n namespace EasySwoole\\EasySwoole;\n\n use App\\Utility\\MyQueue;\n use App\\Utility\\QueueProcess;\n use EasySwoole\\Component\\Timer;\n use EasySwoole\\EasySwoole\\AbstractInterface\\Event;\n use EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n use EasySwoole\\Queue\\Job;\n\n class EasySwooleEvent implements Event\n {\n     public static function initialize()\n     {\n         date_default_timezone_set('Asia/Shanghai');\n\n     }\n\n     public static function mainServerCreate(EventRegister $register)\n     {\n         //redis pool使用请看redis 章节文档\n         \\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;register(new \\EasySwoole\\Redis\\Config\\RedisConfig(\n             [\n                 'host' =&gt; '127.0.0.1',\n                 'port' =&gt; '6379'\n             ]\n         ), 'queue');\n         $redisPool = \\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;getPool('queue');\n         $driver = new \\EasySwoole\\Queue\\Driver\\Redis($redisPool, 'queue');\n         MyQueue::getInstance($driver);\n         //注册一个消费进程\n         \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new QueueProcess());\n         //模拟生产者，可以在任意位置投递\n         $register-&gt;add($register::onWorkerStart, function ($server, $id) {\n             if ($id == 0) {\n                 Timer::getInstance()-&gt;loop(3000, function () {\n                     $job = new Job();\n                     $job-&gt;setJobData(['time' =&gt; \\time()]);\n                     MyQueue::getInstance()-&gt;producer()-&gt;push($job);\n                 });\n             }\n         });\n     }\n }\n\n进程安全退出问题请看进程章节。\n\n进阶使用\n我们可以自定义驱动，实现RabbitMQ等消费队列软件的封装。\n定义类，并继承EasySwoole\\Queue\\QueueDriverInterface接口，实现几个方法即可。\nQueueDriverInterface 类实现\nnamespace EasySwoole\\Queue;\ninterface QueueDriverInterface\n{\n    public function push(Job $job):bool ;\n    public function pop(float $timeout = 3.0):?Job;\n    public function size():?int ;\n}\n组件自带的Redis驱动实现\n&lt;?php\n\nnamespace EasySwoole\\Queue\\Driver;\n\nuse EasySwoole\\Queue\\Job;\nuse EasySwoole\\Queue\\QueueDriverInterface;\nuse EasySwoole\\Redis\\Redis as Connection;\nuse EasySwoole\\RedisPool\\Pool;\n\nclass Redis implements QueueDriverInterface\n{\n\n    protected $pool;\n    protected $queueName;\n    public function __construct(Pool $pool,string $queueName = 'easy_queue')\n    {\n        $this-&gt;pool = $pool;\n        $this-&gt;queueName = $queueName;\n    }\n\n    public function push(Job $job): bool\n    {\n        $data = serialize($job);\n        return $this-&gt;pool-&gt;invoke(function (Connection $connection)use($data){\n            return $connection-&gt;lPush($this-&gt;queueName,$data);\n        });\n    }\n\n    public function pop(float $timeout = 3.0): ?Job\n    {\n        return $this-&gt;pool-&gt;invoke(function (Connection $connection){\n            $data =  $connection-&gt;rPop($this-&gt;queueName);\n            if($data){\n                return unserialize($data);\n            }\n            return null;\n        });\n    }\n\n    public function size(): ?int\n    {\n        return $this-&gt;pool-&gt;invoke(function (Connection $connection){\n            return $connection-&gt;lLen($this-&gt;queueName);\n        });\n    }\n}\n相关仓库\nEasySwoole中利用redis实现消息队列  \n如何利用EasySwoole多进程多协程redis队列实现爬虫","link":"/Components/Queue/install.html"},{"id":175,"title":"多节点","content":"Queue多节点使用\n定义第一个队列(自定义nodeId)\n&lt;?php\n\nnamespace App\\Utility;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\Queue\\Queue;\nuse EasySwoole\\Queue\\QueueDriverInterface;\n\nclass MyQueue1 extends Queue\n{\n    use Singleton;\n\n    public function __construct(QueueDriverInterface $driver)\n    {\n        parent::__construct($driver);\n        $this-&gt;setNodeId('xxxxx1');\n    }\n}\n定义第二个队列(自动生成nodeId)\nnamespace App\\Utility;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\Queue\\Queue;\n\nclass MyQueue2 extends Queue\n{\n    use Singleton;\n}\n获取节点id\n&lt;?php\n\nnamespace App\\Utility;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Queue\\Job;\n\nclass QueueProcess extends AbstractProcess\n{\n\n    protected function run($arg)\n    {\n        go(function () {\n            MyQueue1::getInstance()-&gt;consumer()-&gt;listen(function (Job $job) {\n                var_dump($job-&gt;getNodeId());\n                var_dump($job-&gt;getJobId());\n            });\n            MyQueue2::getInstance()-&gt;consumer()-&gt;listen(function (Job $job) {\n                var_dump($job-&gt;getNodeId());\n                var_dump($job-&gt;getJobId());\n            });\n        });\n    }\n}\n\n可以多进程，多协程消费\n\n驱动注册\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Utility\\MyQueue1;\nuse App\\Utility\\MyQueue2;\nuse App\\Utility\\QueueProcess;\nuse EasySwoole\\Component\\Timer;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\Queue\\Job;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        //redis pool使用请看redis 章节文档\n        \\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;register(new \\EasySwoole\\Redis\\Config\\RedisConfig(\n            [\n                'host' =&gt; '127.0.0.1',\n                'port' =&gt; '6379'\n            ]\n        ), 'queue');\n        $redisPool = \\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;getPool('queue');\n        $driver = new \\EasySwoole\\Queue\\Driver\\Redis($redisPool, 'queue');\n        // 这里是重点\n        MyQueue1::getInstance($driver);\n        MyQueue2::getInstance($driver);\n        //注册一个消费进程\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new QueueProcess());\n        //模拟生产者，可以在任意位置投递\n        $register-&gt;add($register::onWorkerStart, function ($ser, $id) {\n            if ($id == 0) {\n                Timer::getInstance()-&gt;loop(3000, function () {\n                    $job = new Job();\n                    $job-&gt;setJobData(['time' =&gt; \\time()]);\n                    // 这里是重点\n                    MyQueue1::getInstance()-&gt;producer()-&gt;push($job);\n                    MyQueue2::getInstance()-&gt;producer()-&gt;push($job);\n                });\n            }\n        });\n\n    }\n}","link":"/Components/Queue/nodes.html"},{"id":176,"title":"kafka","content":"kafka\nKafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性：\n通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。\n高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息。\n支持通过Kafka服务器和消费机集群来分区消息。\n支持Hadoop并行数据加载。\n\n本项目代码参考自 https://github.com/weiboad/kafka-php\n\n组件要求\n\nphp: &gt;=7.1.0\next-swoole: ^4.4.5\neasyswoole/component: ^2.0\n-easyswoole/spl: ^1.1\n\n安装方法\n\ncomposer require easyswoole/kafka\n\n仓库地址\neasyswoole/kafka\n基本使用\n注册kafka服务\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Producer\\Process as ProducerProcess;\nuse App\\Consumer\\Process as ConsumerProcess;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // TODO: Implement mainServerCreate() method.\n        // 生产者\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new ProducerProcess());\n        // 消费者\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new ConsumerProcess());\n    }\n}\n\n生产者\nnamespace App\\Producer;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Kafka\\Config\\ProducerConfig;\nuse EasySwoole\\Kafka\\Kafka;\n\nclass Process extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        go(function () {\n            $config = new ProducerConfig();\n            $config-&gt;setMetadataBrokerList('127.0.0.1:9092,127.0.0.1:9093');\n            $config-&gt;setBrokerVersion('0.9.0');\n            $config-&gt;setRequiredAck(1);\n\n            $kafka = new Kafka($config);\n            $result = $kafka-&gt;producer()-&gt;send([\n                [\n                    'topic' =&gt; 'test',\n                    'value' =&gt; 'message--',\n                    'key'   =&gt; 'key--',\n                ],\n            ]);\n\n            var_dump($result);\n            var_dump('ok');\n        });\n    }\n}\n消费者\nnamespace App\\Consumer;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Kafka\\Config\\ConsumerConfig;\nuse EasySwoole\\Kafka\\Kafka;\n\nclass Process extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        go(function () {\n            $config = new ConsumerConfig();\n            $config-&gt;setRefreshIntervalMs(1000);\n            $config-&gt;setMetadataBrokerList('127.0.0.1:9092,127.0.0.1:9093');\n            $config-&gt;setBrokerVersion('0.9.0');\n            $config-&gt;setGroupId('test');\n\n            $config-&gt;setTopics(['test']);\n            $config-&gt;setOffsetReset('earliest');\n\n            $kafka = new Kafka($config);\n            // 设置消费回调\n            $func = function ($topic, $partition, $message) {\n                var_dump($topic);\n                var_dump($partition);\n                var_dump($message);\n            };\n            $kafka-&gt;consumer()-&gt;subscribe($func);\n        });\n    }\n}\n\n附赠\n\nKafka 集群部署 docker-compose.yml 一份，使用方式如下\n\n保证2181,9092,9093,9000端口未被占用（占用后可以修改compose文件中的端口号）\n根目录下，docker-compose up -d\n访问localhost:9000，可以查看kafka集群状态。\n\n\n\n\nhttps://github.com/easy-swoole/kafka/blob/master/docker-compose.yml\n","link":"/Components/kafka.html"},{"id":177,"title":"nsq","content":"NSQ客户端\nNSQ 是实时的分布式消息处理平台，其设计的目的是用来大规模地处理每天数以十亿计级别的消息。\n它具有分布式和去中心化拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征。\n组件要求\n\nphp: &gt;=5.3.0\next-json: *\neasyswoole/easyswoole: 3.x\neasyswoole/http-client: ^1.2.5\neasyswoole/pool: ^1.0\neasyswoole/spl: ^1.1\nmonolog/monolog: ~1.0\nreact/react: &gt;=0.2.1\n\n安装方法\n\ncomposer require easyswoole/nsq\n\n仓库地址\neasyswoole/nsq\n基本使用\n注册Nsq服务\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Producer\\Process as ProducerProcess;\nuse App\\Consumer\\Process as ConsumerProcess;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // TODO: Implement mainServerCreate() method.\n        // 生产者\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new ProducerProcess());\n        // 消费者\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new ConsumerProcess());\n    }\n\n    ......\n\n}\n\n生产者\nnamespace App\\Producer;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\n\nclass Process extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        go(function () {\n            $config = new \\EasySwoole\\Nsq\\Config();\n            $topic  = \"topic.test\";\n            $nsqlookup = new \\EasySwoole\\Nsq\\Lookup\\Nsqlookupd($config-&gt;getNsqdUrl());\n            $hosts = $nsqlookup-&gt;lookupHosts($topic);\n\n            foreach ($hosts as $host) {\n                $nsq = new \\EasySwoole\\Nsq\\Nsq();\n                for ($i = 0; $i &lt; 10; $i++) {\n                    $msg = new \\EasySwoole\\Nsq\\Message\\Message();\n                    $msg-&gt;setPayload(\"test$i\");\n                    $nsq-&gt;push(\n                        new \\EasySwoole\\Nsq\\Connection\\Producer($host, $config),\n                        $topic,\n                        $msg\n                    );\n                }\n            }\n        });\n    }\n}\n消费者\nnamespace App\\Consumer;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\n\nclass Process extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        go(function () {\n            $topic      = \"topic.test\";\n            $config     = new \\EasySwoole\\Nsq\\Config();\n            $nsqlookup  = new \\EasySwoole\\Nsq\\Lookup\\Nsqlookupd($config-&gt;getNsqdUrl());\n            $hosts      = $nsqlookup-&gt;lookupHosts($topic);\n            foreach ($hosts as $host) {\n                $nsq = new \\EasySwoole\\Nsq\\Nsq();\n                $nsq-&gt;subscribe(\n                    new \\EasySwoole\\Nsq\\Connection\\Consumer($host, $config, $topic, 'test.consuming'),\n                    function ($item) {\n                        var_dump($item['message']);\n                    }\n                );\n            }\n        });\n    }\n}\n\n附赠\n\nNsq 集群部署 docker-compose.yml 一份，使用方式如下\n\n保证4150,4151,4160,4161,4171端口未被占用（占用后可以修改compose文件中的端口号）\n根目录下，docker-compose up -d\n访问localhost:4171，可以查看Web版 nsqadmin 状态。\n\n\n\n\nhttps://github.com/easy-swoole/nsq/blob/master/docker-compose.yml\n","link":"/Components/nsq.html"},{"id":178,"title":"安装及使用","content":"FastCacheQueue\nEasySwoole FastCache组件在&gt;= 1.2.1的时候新增类似· beanstalkd消息队列 ·特性。\n\n可以创建多个queue\n支持延迟投递\n任务超时恢复执行\n任务重发执行\n任务最大重发次数\n支持putJob、delayJob、releaseJob、reserveJob、buryJob、kickJob等命令\n\n基本使用\nFastCacheQueue依托于FastCache，具体安装请查看FastCache\n服务注册\n更新后，EasySwoole\\FastCache\\CacheProcessConfig类多出以下方法\n/** 设置进程最大内存 默认512M */\npublic function setMaxMem(string $maxMem): void\n/** 设置消息队列保留时间 默认60s （取出任务后没有及时确认会重新放回队列） */\npublic function setQueueReserveTime(int $queueReserveTime): void\n/** 设置消息队列最大重发次数 默认10 达到次数后重发将会被丢弃 */\npublic function setQueueMaxReleaseTimes(int $queueMaxReleaseTimes): void\n开始使用\n下文示例代码的Job和Cache都使用以下命名空间\nuse EasySwoole\\FastCache\\Cache;\nuse EasySwoole\\FastCache\\Job;\n投递任务\n投递成功之后 将会返回该任务的jobId。\n没有失败情况，除非fastCache注册注册失败。\n$job = new Job();\n$job-&gt;setData(\"siam\"); // 任意类型数据\n$job-&gt;setQueue(\"siam_queue\");\n$jobId = Cache::getInstance()-&gt;putJob($job);\nvar_dump($jobId);\n取出任务\n可以开启自定义进程当消费者，循环监听队列，执行任务处理。\n注意：任务执行完成一定要有一个结果。要么删除该任务，要么重发。否则当任务取出一定时间后（默认60s）会自动放回队列中。\n$job = Cache::getInstance()-&gt;getJob('siam_queue');// Job对象或者null\nif ($job === null){\n    echo \"没有任务\\n\";\n}else{\n    // 执行业务逻辑\n    var_dump($job);\n    // 执行完了要删除或者重发，否则超时会自动重发\n    Cache::getInstance()-&gt;deleteJob($job);\n}\n清空ready任务队列\n\n var_dump(Cache::getInstance()-&gt;flushReadyJobQueue('siam_queue'));\n\n var_dump(Cache::getInstance()-&gt;jobQueueSize('siam_queue'));\n延迟执行任务\n$job = new Job();\n$job-&gt;setData(\"siam\");\n$job-&gt;setQueue(\"siam_queue_delay\");\n$job-&gt;setDelay(5);// 延时5s\n$jobId = Cache::getInstance()-&gt;putJob($job);\nvar_dump($jobId);\n// 马上取会失败 隔5s取才成功\n$job = Cache::getInstance()-&gt;getJob('siam_queue_delay');\nvar_dump($job);\n删除任务\n可以是由getJob取出的对象，也可以自己声明Job对象，传入JobId来删除。\n$job = new Job();\n$job-&gt;setJobId(1);\n$job-&gt;setQueue('siam_queue_delay');\nCache::getInstance()-&gt;deleteJob($job);\n任务重发\n任务执行失败，或者某些场景需要重新执行，则可以重发。\n重发时，可以指定是否延迟执行。\n// get出来的任务执行失败可以重发\n$job = new Job();\n$job-&gt;setData(\"siam\");\n$job-&gt;setQueue(\"siam_queue\");\n$jobId = Cache::getInstance()-&gt;putJob($job);\n\n$job = Cache::getInstance()-&gt;getJob('siam_queue');\n\nif ($job === null){\n    echo \"没有任务\\n\";\n}else{\n    // 执行业务逻辑\n    $doRes = false;\n    if (!$doRes){\n        // 业务逻辑失败,需要重发  \n        // 如果延迟队列需要马上重发,在这里需要清空delay属性\n        // $job-&gt;setDelay(0);\n        // 如果普通队列需要延迟重发,则设置delay属性\n        // $job-&gt;setDelay(5);\n        $res = Cache::getInstance()-&gt;releaseJob($job);\n        var_dump($res);\n    }else{\n        // 执行完了要删除或者重发，否则超时会自动重发\n        Cache::getInstance()-&gt;deleteJob($job);\n    }\n}\n返回现在有什么队列\n$queues = Cache::getInstance()-&gt;jobQueues();\nvar_dump($queues);\n返回某个队列的长度\n$queueSize = Cache::getInstance()-&gt;jobQueueSize(\"siam_queue\");\n$queueSize2 = Cache::getInstance()-&gt;jobQueueSize(\"siam_queue_delay\");\nvar_dump($queueSize);\nvar_dump($queueSize2);\n清空队列 可指定名称\n// 清空全部\n$res = Cache::getInstance()-&gt;flushJobQueue();\nvar_dump($res);\n\n// 清空siam_queue队列\n$res = Cache::getInstance()-&gt;flushJobQueue('siam_queue');\nvar_dump($res);\n将任务改为延迟状态\n//添加任务\n$job = new Job();\n$job-&gt;setData(\"LuffyQAQ\");\n$job-&gt;setQueue(\"LuffyQAQ_queue_delay\");\n$jobId = Cache::getInstance()-&gt;putJob($job);\n\n//方法一 直接传入jobId\n$job-&gt;setJobId($jobId);\n$job-&gt;setDelay(30);\nvar_dump(Cache::getInstance()-&gt;delayJob($job));\n\n//方法二 取出任务\n$job = Cache::getInstance()-&gt;getJob('LuffyQAQ_queue_delay');\n$job-&gt;setDelay(30);\nvar_dump(Cache::getInstance()-&gt;delayJob($job));\n\n//使用jobQueueSize查看队列长度\n$queueSize = Cache::getInstance()-&gt;jobQueueSize(\"LuffyQAQ_queue_delay\");\nvar_dump($queueSize);\n\n从延迟执行队列中拿取\n//传入队列名\nvar_dump(Cache::getInstance()-&gt;getDelayJob('LuffyQAQ_queue_delay'));\n\n清空delay任务队列\n\n var_dump(Cache::getInstance()-&gt;flushDelayJobQueue('LuffyQAQ_queue_delay'));\n\n var_dump(Cache::getInstance()-&gt;jobQueueSize('LuffyQAQ_queue_delay'));\n将任务改为保留状态\n//添加任务\n$job = new Job();\n$job-&gt;setData(\"LuffyQAQ\");\n$job-&gt;setQueue(\"LuffyQAQ_queue_reserve\");\n$jobId = Cache::getInstance()-&gt;putJob($job);\n\n//方法一 直接传入jobId\n$job-&gt;setJobId($jobId);\nvar_dump(Cache::getInstance()-&gt;reserveJob($job));\n\n//方法二 取出任务\n$job = Cache::getInstance()-&gt;getJob('LuffyQAQ_queue_reserve');\nvar_dump(Cache::getInstance()-&gt;reserveJob($job));\n\n//使用jobQueueSize查看队列长度\n$queueSize = Cache::getInstance()-&gt;jobQueueSize(\"LuffyQAQ_queue_reserve\");\nvar_dump($queueSize);\n从保留队列中拿取\n//传入队列名\nvar_dump(Cache::getInstance()-&gt;getReserveJob('LuffyQAQ_queue_reserve'));\n\n清空reserve任务队列\n\n var_dump(Cache::getInstance()-&gt;flushReserveJobQueue('LuffyQAQ_queue_reserve'));\n\n var_dump(Cache::getInstance()-&gt;jobQueueSize('LuffyQAQ_queue_reserve'));\n将任务改为埋藏状态\n$job = new Job();\n$job-&gt;setQueue('LuffyQAQ_queue_bury');\n$job-&gt;setData('LuffyQAQ');\n$jobId = Cache::getInstance()-&gt;putJob($job);\n$job-&gt;setJobId($jobId);\n\nvar_dump(Cache::getInstance()-&gt;buryJob($job));\n\n//使用jobQueueSize查看队列长度\n$queueSize = Cache::getInstance()-&gt;jobQueueSize(\"LuffyQAQ_queue_bury\");\nvar_dump($queueSize);\n\n从埋藏队列中拿取\n//传入队列名\nvar_dump(Cache::getInstance()-&gt;getBuryJob('LuffyQAQ_queue_bury'));\n\n将埋藏队列任务恢复到ready中\n\nvar_dump(Cache::getInstance()-&gt;kickJob($job));\n\n清空bury任务队列\n\n var_dump(Cache::getInstance()-&gt;flushBuryJobQueue('LuffyQAQ_queue_bury'));\n\n var_dump(Cache::getInstance()-&gt;jobQueueSize('LuffyQAQ_queue_bury'));","link":"/Components/FashCache/fastCacheQueue.html"},{"id":179,"title":"微服务理念","content":"微服务\n微服务的意义\n&ensp;&ensp;例如我们在一个基础的商场系统当中，可能分为用户模块，商品模块，订单模块、活动模块等，系统建设初期，\n我们也许为了快速上线和节约成本，那么就是直接一整套的模块代码，全部写在一个项目代码中。\n而在后期流量上来后，我们会发现，经常因为某个模块的的模块失效，导致整个服务瘫痪。例如活动模块，和商品模块是最容易在高流量下瘫痪的。举个例子，在2018年的双十一活动中，\n某商场系统花了很多钱去做广告，导致很高流量直接进入到商场系统当中，而在此之前，也没做服务拆分，那么活动模块的高流量导致数据库和带宽完全无法支撑，整个商场全部进入黑洞状态，，用户即无法进入活动页面，连正常的商场首页也无法打开。\n后面，在Easyswoole项目组的建议下，将商场系统进行了模块化服务拆分，例如，活动系统就是一个独立的服务，用户参与活动的时候，直接从客户端调用活动服务接口，活动服务需要验证商品和用户数据的时候，又通过RPC调用进行服务间的数据交互。从而实现\n压力的分摊，不再让全部的服务压力都堆积到单台服务器或数据库上，且在最糟糕的情况下，即使活动模块瘫痪，也不会导致整个商场系统不可用。\n　\n因此微服务的主要意义在于，流量分压，模块高度自治，服务隔离保护。\n什么是微服务框架\n&ensp;&ensp;实际上，所谓的微服务框架，是一种错误的说法，微服务是一种架构性上的概念，与框架无关。例如，在以上的案例当中，我们服务间的互相调用，可以用HTTP,或者是原生TCP协议来实现，因此实际上，和框架没有半毛钱关系。而如果真的要牵强的说是微服务框架的话，那其实是无非类似某些框架做了一些组件的封装，让你更加方便的实现RPC调用。例如Easyswoole就提供了RCP封装和基础的服务发现与注册中心。但是实际上，这仅仅是工具，真正的微服务，最核心的其实是如何做好服务间的最小粒度切分，也就是其实这个属于架构规划上的范畴。\n服务限流\n再举一个我们生活中的例子：一些热门的旅游景点，往往会对每日的旅游参观人数有严格的限制，比如厦门的鼓浪屿、北京的故宫等，每天只会卖出固定数目的门票，如果你去的晚了，可能当天的票就已经卖完了，当天就无法进去游玩了。\n为什么旅游景点要做这样的限制呢？多卖一些门票多赚一些钱岂不是更好？\n其实对于旅游景点而言，她们也很无奈，因为景点的服务资源有限嘛，每日能服务的人数是有限的，一旦放开限制了，景点的工作人员就会不够用，卫生情况也得不到保障，安全也有隐患，超密集的人群也会严重的影响游客的体验。\n但由于景区名气大，来游玩的旅客络绎不绝，远超出了景区的承载能力，因此景区只好做出限制每日人员流量的举措。\n同理，在IT软件行业中，系统服务也是这样的。如果你的系统理论是时间单位内可服务100W用户，但是今天却突然来了300W用户，由于用户流量的随机性，如果不加以限流，很有可能这300W用户一下子就压垮了系统，导致所有人都得不到服务。\n因此为了保证系统至少还能为100W用户提供正常服务，我们需要对系统进行限流设计。\n有的人可能会想，既然会有300W用户来访问，那为啥系统不干脆设计成能足以支撑这么大量用户的集群呢？\n这是个好问题。如果系统是长期有300W的用户来访问，肯定是要做上述升级的，但是常常面临的情况是，系统的日常访问量就是100W，只不过偶尔有一些不可预知的特定原因导致的短时间的流量激增，这个时候，公司往往出于节约成本的考虑，不会为了一个不常见的尖峰来把我们的系统扩容到最大的尺寸。\n如何限流\n在实际的应用当中，流量入口应该是：\n防火墙 --&gt; Api网关  -&gt; 服务\n因此，实际上我们是有三个地方可以进行限流。那么，防火墙，和API网关我们则不再进行讲解，那是运维的事情。我们要说的是API网关的自我保护。在Easyswoole中，有提供了一个基础的AtomicLimit组件，原理与令牌桶差不多，有兴趣的同学可以去看下。当然Easyswoole也支持其他方式的限流，你可以在流量入口的onRequest方法中进行拦截。\n熔断保护\n这个模式是需要系统在设计之初，就要把熔断措施考虑进去。当系统出现问题时，如果短时间内无法修复，系统要自动做出判断，开启熔断开关，拒绝流量访问，避免大流量对后端的过载请求。系统也应该能够动态监测后端程序的修复情况，当程序已恢复稳定时，可以关闭熔断开关，恢复正常服务。\n服务降级\n将系统的所有功能服务进行一个分级，当系统出现问题，需要紧急限流时，可将不是那么重要的功能进行降级处理，停止服务，这样可以释放出更多的资源供给核心功能的去用。\n例如在电商平台中，如果突发流量激增，可临时将商品评论、积分等非核心功能进行降级，停止这些服务，释放出机器和CPU等资源来保障用户正常下单，而这些降级的功能服务可以等整个系统恢复正常后，再来启动，进行补单/补偿处理。\n除了功能降级以外，还可以采用不直接操作数据库，而全部读缓存、写缓存的方式作为临时降级方案。\n延迟处理\n这个模式需要在系统的前端设置一个流量缓冲池，将所有的请求全部缓冲进这个池子，不立即处理。然后后端真正的业务处理程序从这个池子中取出请求依次处理，常见的可以用队列模式来实现。这就相当于用异步的方式去减少了后端的处理压力，但是当流量较大时，后端的处理能力有限，缓冲池里的请求可能处理不及时，会有一定程度延迟。\n特权处理\n这个模式需要将用户进行分类，通过预设的分类，让系统优先处理需要高保障的用户群体，其它用户群的请求就会延迟处理或者直接不处理。\n当然，微服务还有很多东西，本文只是进行基础的概念科普，具体可以请教架构师","link":"/Microservices/introduction.html"},{"id":180,"title":"consul","content":"Consul\nEasySwoole提供了一个协程安全的consul协程版本客户端，方便用户做分布式的微服务开发。\n安装\n\ncomposer require easyswoole/consul\n\n使用方式\n\n使用下面的接口方式，都需要先给Consul注入Config配置。\n接口只展示用法，具体的命名空间需要开发者自己引入\n\n\nuse EasySwoole\\Consul\\Config;\nuse EasySwoole\\Consul\\Consul;\n\n// config默认  127.0.0.1:8500/v1\n$config = new Config([\n    'IP'       =&gt; '127.0.0.1',\n    'port'     =&gt; '8500',\n    'version'  =&gt; 'v1',\n]);\n$consul = new Consul($config);\n\n// 两种写法，结果相同\n$config = new Config();\n$config-&gt;setIP('127.0.0.1');\n$config-&gt;setPort('8500');\n$config-&gt;setVersion('v1');    \n\n$consul = new Consul($config);\n\nACLs\n// Bootstrap ACLs\n$bootstrap = new Bootstrap();\n$this-&gt;consul-&gt;acl()-&gt;bootstrap($bootstrap);\n\n// Check ACL Replication\n$replication = new Replication();\n$this-&gt;consul-&gt;acl()-&gt;replication($replication);\n\n// Translate Rules\n// Translate a Legacy Token's Rules\n$translate = new Translate([\n    'accessor_id' =&gt; $accessor_id\n]);\n$this-&gt;consul-&gt;acl()-&gt;translate($translate);\n\n// Login to Auth Method\n$login = new Login([\n    \"authMethod\" =&gt; $authMethod,\n    \"bearerToken\" =&gt; $bearerToken\n]);\n$this-&gt;consul-&gt;acl()-&gt;login($login);\n\n// Logout from Auth Method\n$logout = new Logout([\n    'token' =&gt; $header['token']\n]);\n$this-&gt;consul-&gt;acl()-&gt;logout($logout);\nTokens\n// Create a Token\n$token = new Token([\n    \"description\" =&gt; \"Agent token for 'node1'\",\n    \"Policies\" =&gt; [\n        [\"ID\" =&gt; \"165d4317-e379-f732-ce70-86278c4558f7\"],\n        [\"Name\" =&gt; \"node-read\"],\n    ],\n    \"Local\" =&gt; false,\n]);\n$this-&gt;consul-&gt;acl()-&gt;token($token);\n\n// Read a Token\n$token = new Token([\n    \"AccessorID\" =&gt; \"6a1253d2-1785-24fd-91c2-f8e78c745511\"\n]);\n$this-&gt;consul-&gt;acl()-&gt;readToken($token);\n\n// Read Self Token\n$self = new Token\\GetSelf([\n    'token' =&gt; \"6a1253d2-1785-24fd-91c2-f8e78c745511\"\n]);\n$this-&gt;consul-&gt;acl()-&gt;self($self);\n\n// Update a Token\n$update = new Token([\n    'accessorID' =&gt; '6a1253d2-1785-24fd-91c2-f8e78c745511',\n    \"Description\" =&gt; \"Agent token for 'node1'\",\n    \"Policies\" =&gt; [],\n    \"local\" =&gt; false\n]);\n$this-&gt;consul-&gt;acl()-&gt;updateToken($update);\n\n// Clone a Token\n$clone = new Token\\CloneToken([\n    'accessorID' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05',\n    \"description\" =&gt; \"Clone of Agent token for 'node1'\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;cloneToken($clone);\n\n// Delete a Token\n$delete = new Token([\n    'AccessorID' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05'\n]);\n$this-&gt;consul-&gt;acl()-&gt;delete($delete);\n\n// List Tokens\n$token = new Tokens();\n$this-&gt;consul-&gt;acl()-&gt;tokens($token);\nLegacy Tokens\n// Create ACL Token\n$create = new Create([\n    \"Name\" =&gt; \"my-app-token\",\n    \"Type\" =&gt; \"client\",\n    \"rules\" =&gt; \"a\"\n]);\n$this-&gt;consul-&gt;acl()-&gt;create($create);\n\n// Update ACL Token\n$update = new Update([\n    \"id\" =&gt; \"adf4238a-882b-9ddc-4a9d-5b6758e4159e\",\n    \"Name\" =&gt; \"my-app-token-updated\",\n    \"Type\" =&gt; \"client\",\n    \"Rules\" =&gt; \"# New Rules\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;update($update);\n\n// Delete ACL Token\n$delete = new Destroy([\n    'uuid' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05'\n]);\n$this-&gt;consul-&gt;acl()-&gt;destroy($delete);\n\n// Read ACL Token\n$info = new Info([\n    'uuid' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05'\n]);\n$this-&gt;consul-&gt;acl()-&gt;info($info);\n\n// Clone ACL Token\n$cloneAclToken = new CloneACLToken([\n    'uuid' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05'\n]);\n$this-&gt;consul-&gt;acl()-&gt;cloneAclToken($cloneAclToken);\n\n// List ACLs\n$getList = new Lists();\n$this-&gt;consul-&gt;acl()-&gt;getList($getList);\n$this-&gt;assertEquals('x','x');\nPolicies\n// Create a Policy\n$policy = new Policy([\n    \"Name\" =&gt; \"node-read\",\n    \"Description\" =&gt; \"Grants read access to all node information\",\n    \"Rules\" =&gt; \"node_prefix \\\"\\\" { policy = \\\"read\\\"}\",\n    \"datacenters\" =&gt; [\"dc1\"]\n]);\n$this-&gt;consul-&gt;acl()-&gt;policy($policy);\n\n// Read a Policy\n$policy = new Policy([\n    'id' =&gt; 'c01a1f82-44be-41b0-a686-685fb6e0f485',\n]);\n$this-&gt;consul-&gt;acl()-&gt;readPolicy($policy);\n\n// Update a Policy\n$policy = new Policy([\n    \"ID\" =&gt; \"c01a1f82-44be-41b0-a686-685fb6e0f485\",\n    \"Name\" =&gt; \"register-app-service\",\n    \"Description\" =&gt; \"Grants write permissions necessary to register the 'app' service\",\n    \"Rules\" =&gt; \"service \\\"app\\\" { policy = \\\"write\\\"}\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;updatePolicy($policy);\n\n// Delete a Policy\n$policy = new Policy([\n    'id' =&gt; 'c01a1f82-44be-41b0-a686-685fb6e0f485'\n]);\n$this-&gt;consul-&gt;acl()-&gt;deletePolicy($policy);\n\n// List Policies\n$policies = new Policies();\n$this-&gt;consul-&gt;acl()-&gt;policies($policies);\nRoles\n// Create a Role\n$role = new Role([\n    \"name\" =&gt; \"example-role\",\n    \"description\" =&gt; \"Showcases all input parameters\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;role($role);\n\n// Read a Role\n$role = new Role([\n    'id' =&gt; 'aa770e5b-8b0b-7fcf-e5a1-8535fcc388b4'\n]);\n$this-&gt;consul-&gt;acl()-&gt;readRole($role);\n\n// Read a Role by Name\n$name = new Role([\n    'name' =&gt; 'example-role'\n]);\n$this-&gt;consul-&gt;acl()-&gt;readRoleByName($name);\n\n// Update a Role\n$role = new Role([\n    'id' =&gt; 'aa770e5b-8b0b-7fcf-e5a1-8535fcc388b4',\n    \"name\" =&gt; \"example-two\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;updateRole($role);\n\n// Delete a Role\n$role = new Role([\n    'id' =&gt; 'aa770e5b-8b0b-7fcf-e5a1-8535fcc388b4'\n]);\n$this-&gt;consul-&gt;acl()-&gt;deleteRole($role);\n\n// List Roles\n$roles = new Roles();\n$this-&gt;consul-&gt;acl()-&gt;roles($roles);\nAuth Method\n// Create an Auth Method\n$method = new AuthMethod([\n    \"Name\" =&gt; \"minikube\",\n    \"Type\" =&gt; \"kubernetes\",\n    \"Description\" =&gt; \"dev minikube cluster\",\n    \"Config\" =&gt; [\n        \"Host\" =&gt; \"https://192.0.2.42:8443\",\n        \"CACert\" =&gt; \"-----BEGIN CERTIFICATE-----\\n...-----END CERTIFICATE-----\\n\",\n        \"ServiceAccountJWT\" =&gt; \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\"\n    ]\n]);\n$this-&gt;consul-&gt;acl()-&gt;authMethod($method);\n\n// Read an Auth Method\n$method = new AuthMethod([\n    'name' =&gt; 'minikube',\n]);\n$this-&gt;consul-&gt;acl()-&gt;readAuthMethod($method);\n\n// Update an Auth Method\n$method = new AuthMethod([\n    \"Name\" =&gt; \"minikube\",\n    \"Type\" =&gt; \"kubernetes\",\n    \"Description\" =&gt; \"dev minikube cluster\",\n    \"Config\" =&gt; [\n        \"Host\" =&gt; \"https://192.0.2.42:8443\",\n        \"CACert\" =&gt; \"-----BEGIN CERTIFICATE-----\\n...-----END CERTIFICATE-----\\n\",\n        \"ServiceAccountJWT\" =&gt; \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\"\n    ]\n]);\n$this-&gt;consul-&gt;acl()-&gt;updateAuthMethod($method);\n\n// Delete an Auth Method\n$method = new AuthMethod([\n    \"Name\" =&gt; \"minikube\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;deleteAuthMethod($method);\n\n// List Auth Methods\n$method = new AuthMethods();\n$this-&gt;consul-&gt;acl()-&gt;authMethods($method);\nBinding Rules\n// Create a Binding Rule\n$bindingRule = new BindingRule([\n    \"description\" =&gt; \"example rule\",\n    \"authMethod\" =&gt; \"minikube\",\n    \"Selector\" =&gt; \"serviceaccount.namespace==default\",\n    \"BindType\" =&gt; \"service\",\n    \"BindName\" =&gt; \"{{ serviceaccount.name }}\"\n]);\n$this-&gt;consul-&gt;acl()-&gt;bindingRule($bindingRule);\n\n// Read a Binding Rule\n$bindingRule = new BindingRule([\n    'id' =&gt; '000ed53c-e2d3-e7e6-31a5-c19bc3518a3d',\n]);\n$this-&gt;consul-&gt;acl()-&gt;readBindingRule($bindingRule);\n\n// Update a Binding Rule\n$bindingRule = new BindingRule([\n    'id' =&gt; '000ed53c-e2d3-e7e6-31a5-c19bc3518a3d',\n    \"Description\" =&gt; \"updated rule\",\n    \"authMethod\" =&gt; \"minikube\",\n    \"Selector\" =&gt; \"serviceaccount.namespace=dev\",\n    \"BindType\" =&gt; \"role\",\n    \"BindName\" =&gt; \"{{ serviceaccount.name }}\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;updateBindingRule($bindingRule);\n\n// Delete a Binding Rule\n$bindingRule = new BindingRule([\n    'id' =&gt; '000ed53c-e2d3-e7e6-31a5-c19bc3518a3d',\n]);\n$this-&gt;consul-&gt;acl()-&gt;deleteBindingRule($bindingRule);\n\n// List Binding Rules\n$bindingRules = new BindingRules();\n$this-&gt;consul-&gt;acl()-&gt;bindingRules($bindingRules);\nAgent\n// List Members\n$this-&gt;consul-&gt;agent()-&gt;members(new Members([\n    'wan' =&gt; 'a',\n    'segment' =&gt; 'b',\n]));\n\n// Read Configuration\n$self = new SelfParams();\n$this-&gt;consul-&gt;agent()-&gt;self($self);\n\n// Reload Agent\n$reload = new Reload();\n$this-&gt;consul-&gt;agent()-&gt;reload($reload);\n\n// Enable Maintenance Mode\n$maintenance = new Maintenance([\n    'enable' =&gt; true,\n    'reason' =&gt; 'whatever',\n]);\n$this-&gt;consul-&gt;agent()-&gt;maintenance($maintenance);\n\n// View Metrics\n$metrics = new Metrics([\n    'format' =&gt; 'prometheus',\n]);\n$this-&gt;consul-&gt;agent()-&gt;metrics($metrics);\n\n// Stream Logs\n$monitor = new Monitor([\n    'loglevel' =&gt; 'info',\n]);\n$this-&gt;consul-&gt;agent()-&gt;monitor($monitor);\n\n// Join Agent\n$join = new Join([\n    'address' =&gt; '1.2.3.4',\n    'wan' =&gt; false\n]);\n$this-&gt;consul-&gt;agent()-&gt;join($join);\n\n// Graceful Leave and Shutdown\n$leave = new Leave();\n$this-&gt;consul-&gt;agent()-&gt;leave($leave);\n\n// Force Leave and Shutdown\n$forceLeave = new ForceLeave([\n    'node' =&gt; 'consul'\n]);\n$this-&gt;consul-&gt;agent()-&gt;forceLeave($forceLeave);\n\n// Update ACL Tokens\n$token = new Token([\n    'action' =&gt; 'acl_agent_token',\n    'token' =&gt; 'token'\n]);\n$this-&gt;consul-&gt;agent()-&gt;token($token);\nChecks\n// List Checks\n$checks = new Checks([\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;agent()-&gt;checks($checks);\n\n// Register Check\n$register = new Register([\n    'name' =&gt; 'Memory_utilization', // 不可以出现空格或者其他url中不允许出现的特殊字符，否则取消注册的check_id会报400 error\n    \"notes\" =&gt; \"Ensure we don't oversubscribe memory\",\n    \"DeregisterCriticalServiceAfter\" =&gt; \"90m\",\n    \"Args\" =&gt; [\"/usr/local/bin/check_mem.py\"],\n    \"DockerContainerID\" =&gt; \"f972c95ebf0e\",\n    \"Shell\" =&gt; \"/bin/bash\",\n    \"HTTP\" =&gt; \"https://example.com\",\n    \"Method\" =&gt; \"POST\",\n    \"Header\" =&gt; [\"x-foo\" =&gt; [\"bar\", \"baz\"]],\n    \"TCP\" =&gt; \"example.com:22\",\n    \"Interval\" =&gt; \"10s\",\n    \"TTL\" =&gt; \"15s\",\n    \"TLSSkipVerify\" =&gt; true,\n]);\n$this-&gt;consul-&gt;agent()-&gt;register($register);\n\n// Deregister Check\n$deRegister = new DeRegister([\n    'check_id' =&gt; 'Memory_utilization'\n]);\n$this-&gt;consul-&gt;agent()-&gt;deRegister($deRegister);\n\n// TTL Check Pass\n$pass = new Pass([\n    'check_id' =&gt; 'Memory_utilization',\n    'note' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;agent()-&gt;pass($pass);\n\n// TTL Check Warn\n$warn = new Warn([\n    'check_id' =&gt; 'Memory_utilization',\n    'note' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;agent()-&gt;warn($warn);\n\n// TTL Check Fail\n$fail = new Fail([\n    'check_id' =&gt; 'Memory_utilization',\n    'note' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;agent()-&gt;fail($fail);\n\n// TTL Check Update\n$update = new Update([\n    'check_id' =&gt; 'Memory_utilization',\n    'Status' =&gt; 'passing',\n    'Output' =&gt; 'update success'\n]);\n$this-&gt;consul-&gt;agent()-&gt;update($update);\nServices\n// List Services\n$services = new Services([\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;agent()-&gt;services($services);\n\n// Get Service Configuration\n $service = new Service([\n    'service_id' =&gt; \"consul\"\n]);\n$this-&gt;consul-&gt;agent()-&gt;service($service);\n\n// Get local service health\n$name = new Name([\n    'service_name' =&gt; 'consul',\n    'format' =&gt; 'text',\n]);\n$this-&gt;consul-&gt;agent()-&gt;name($name);\n\n// Get local service health by its ID\n$id = new ID([\n    'service_id' =&gt; 'consul',\n    'format' =&gt; 'text',\n]);\n$this-&gt;consul-&gt;agent()-&gt;id($id);\n\n// Register Service\n $register = new Service\\Register([\n    \"ID\" =&gt; \"redis1\",\n    \"name\" =&gt; \"redis\",\n    \"Tags\" =&gt; [\n        \"primary\",\n        \"v1\"\n    ],\n    \"Address\" =&gt; \"127.0.0.1\",\n    \"Port\" =&gt; 8000,\n    \"meta\" =&gt; [\n        \"redis_version\" =&gt; \"4.0\",\n    ],\n    \"EnableTagOverride\" =&gt; false,\n    \"Check\" =&gt; [\n        \"DeregisterCriticalServiceAfter\" =&gt; \"90m\",\n    \"Args\" =&gt; [\"/usr/local/bin/check_redis.py\"],\n    \"HTTP\" =&gt; \"http://localhost:5000/health\",\n    \"Interval\" =&gt; \"10s\",\n    \"TTL\" =&gt; \"15s\"\n    ],\n    \"weights\" =&gt; [\n        \"Passing\" =&gt; 10,\n    \"Warning\" =&gt; 1\n    ]\n]);\n$this-&gt;consul-&gt;agent()-&gt;serviceRegister($register);\n\n// Deregister Service\n$deregister = new Service\\DeRegister([\n    'service_id' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;agent()-&gt;serviceDeregister($deregister);\n\n// Enable Maintenance Mode\n$maintenance= new Service\\Maintenance([\n    'service_id' =&gt; 'consul',\n    'enable' =&gt; true,\n    'reason' =&gt; ''\n]);\n$this-&gt;consul-&gt;agent()-&gt;serviceMaintenance($maintenance);\nConnect\n// Authorize\n$authorize = new Authorize([\n    \"target\" =&gt; \"db\",\n    \"clientCertURI\" =&gt; \"spiffe://dc1-7e567ac2-551d-463f-8497-f78972856fc1.consul/ns/default/dc/dc1/svc/web\",\n    \"clientCertSerial\" =&gt; \"04:00:00:00:00:01:15:4b:5a:c3:94\"\n]);\n$this-&gt;consul-&gt;agent()-&gt;authorize($authorize);\n\n// Certificate Authority (CA) Roots\n$roots = new Roots();\n$this-&gt;consul-&gt;agent()-&gt;roots($roots);\n\n// Service Leaf Certificate\n$leaf = new Leaf([\n    'service' =&gt; 'consul'\n]);\n$this-&gt;consul-&gt;agent()-&gt;leaf($leaf);\nCatalog\n// Register Entity\n$register = new Register([\n    \"datacenter\" =&gt; \"dc1\",\n    \"id\" =&gt; \"40e4a748-2192-161a-0510-9bf59fe950b5\",\n    \"node\" =&gt; \"foobar\",\n    \"Address\" =&gt; \"192.168.10.10\",\n    \"TaggedAddresses\" =&gt; [\n        \"lan\" =&gt; \"192.168.10.10\",\n    \"wan\" =&gt; \"10.0.10.10\"\n    ],\n    \"NodeMeta\" =&gt; [\n        \"somekey\" =&gt; \"somevalue\"\n    ],\n    \"Service\" =&gt; [\n        \"ID\" =&gt; \"redis1\",\n    \"Service\" =&gt; \"redis\",\n    \"Tags\" =&gt; [\n            \"primary\",\n            \"v1\"\n        ],\n    \"Address\" =&gt; \"127.0.0.1\",\n    \"TaggedAddresses\" =&gt; [\n            \"lan\" =&gt; [\n                \"address\" =&gt; \"127.0.0.1\",\n        \"port\" =&gt; 8000,\n      ],\n      \"wan\" =&gt; [\n                \"address\" =&gt; \"198.18.0.1\",\n        \"port\" =&gt; 80\n      ]\n    ],\n    \"Meta\" =&gt; [\n            \"redis_version\" =&gt; \"4.0\"\n    ],\n    \"Port\" =&gt; 8000\n    ],\n    \"Check\" =&gt; [\n        \"Node\" =&gt; \"foobar\",\n    \"CheckID\" =&gt; \"service:redis1\",\n    \"Name\" =&gt; \"Redis health check\",\n    \"Notes\" =&gt; \"Script based health check\",\n    \"Status\" =&gt; \"passing\",\n    \"ServiceID\" =&gt; \"redis1\",\n    \"Definition\" =&gt; [\n            \"TCP\" =&gt; \"localhost:8888\",\n      \"Interval\" =&gt; \"5s\",\n      \"Timeout\" =&gt; \"1s\",\n      \"DeregisterCriticalServiceAfter\" =&gt; \"30s\"\n    ]\n    ],\n    \"SkipNodeUpdate\" =&gt; false\n]);\n$this-&gt;consul-&gt;catalog()-&gt;register($register);\n\n// Deregister Entity\n$deregister = new Deregister([\n    \"datacenter\" =&gt; \"dc1\",\n    \"node\" =&gt; \"foobar\",\n    \"CheckID\" =&gt; \"service:redis1\",\n]);\n$this-&gt;consul-&gt;catalog()-&gt;deRegister($deregister);\n\n// List Datacenters\n$datacenters = new Datacenters();\n$this-&gt;consul-&gt;catalog()-&gt;dataCenters($datacenters);\n\n// List Nodes\n$nodes = new Nodes([\n    'dc' =&gt; 'dc1',\n    'node-meta' =&gt; '',\n    'near' =&gt; '',\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;nodes($nodes);\n\n// List Services\n$nodes = new Nodes([\n$services = new Services([\n    'dc' =&gt; 'dc1',\n    'node-meta' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;services($services);\n]);\n$this-&gt;consul-&gt;catalog()-&gt;nodes($nodes);\n\n// List Nodes for Service\n$services = new Services([\n    'dc' =&gt; 'a',\n    'node-meta' =&gt; 'b',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;services($services);\n\n// List Nodes for Connect-capable Service\n$service = new Service([\n    'service' =&gt; 'consul',\n    'dc' =&gt; 'dc1',\n    'tag' =&gt; '',\n    'near' =&gt; '',\n    'node-meta' =&gt; '',\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;service($service);\n\n// List Services for Node\n$connect = new Connect([\n    'service' =&gt; 'consul',\n    'dc' =&gt; 'dc1',\n    'tag' =&gt; '',\n    'near' =&gt; '',\n    'node-meta' =&gt; '',\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;connect($connect);\n\n// List Services for Node\n$node = new Node([\n    'node' =&gt; '2eb87046a6fe',\n    'dc' =&gt; 'dc1',\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;node($node);\nConfig\n// Apply Configuration\n$config = new \\EasySwoole\\Consul\\Request\\Config([\n    'Kind' =&gt; 'service-defaults',\n    'Name' =&gt; 'web',\n    'Protocol' =&gt; 'Http'\n]);\n$this-&gt;consul-&gt;config()-&gt;config($config);\n\n// Get Configuration\n$config = new \\EasySwoole\\Consul\\Request\\Config([\n    'Kind' =&gt; 'service-defaults',\n    'name' =&gt; 'web',\n]);\n$this-&gt;consul-&gt;config()-&gt;getConfig($config);\n\n// List Configurations\n$config = new \\EasySwoole\\Consul\\Request\\Config([\n    'Kind' =&gt; 'service-defaults'\n]);\n$this-&gt;consul-&gt;config()-&gt;listConfig($config);\n\n// Delete Configuration\n$config = new \\EasySwoole\\Consul\\Request\\Config([\n    'Kind' =&gt; 'service-defaults',\n    'name' =&gt; 'web',\n]);\n$this-&gt;consul-&gt;config()-&gt;deleteConfig($config);\nConnect\nCertificate Authority (CA)\n// List CA Root Certificates\n$roots = new Roots();\n$this-&gt;consul-&gt;connect()-&gt;roots($roots);\n\n// Get CA Configuration\n$configuration = new Configuration();\n$this-&gt;consul-&gt;connect()-&gt;configuration($configuration);\n\n// Update CA Configuration\n$configuration = new Configuration([\n    'Provider' =&gt; 'consul',\n    'Config' =&gt; [\n        'LeafCertTTL' =&gt; '72h'\n    ]\n]);\n$this-&gt;consul-&gt;connect()-&gt;updateConfiguration($configuration);\nIntentions\n// Create Intention\n$intentions = new Intentions([\n    'SourceName' =&gt; 'web',\n    'DestinationName' =&gt; 'db',\n    'SourceType' =&gt; 'consul',\n    'action' =&gt; 'allow'\n]);\n$this-&gt;consul-&gt;connect()-&gt;intentions($intentions);\n\n// Read Specific Intention\n$intentions = new Intentions([\n    'uuid' =&gt; 'e9ebc19f-d481-42b1-4871-4d298d3acd5c',\n]);\n$this-&gt;consul-&gt;connect()-&gt;readIntention($intentions);\n\n// List Intentions\n$intentions = new Intentions();\n$this-&gt;consul-&gt;connect()-&gt;listIntention($intentions);\n\n// Update Intention\n$intentions = new Intentions([\n    'uuid' =&gt; 'b40faaf3-34aa-349f-3cf2-f5d720240662',\n    'description' =&gt; 'just a test description',\n    'SourceName' =&gt; '',\n    'DestinationName' =&gt; '',\n    'Action' =&gt; 'allow'\n]);\n$this-&gt;consul-&gt;connect()-&gt;updateIntention($intentions);\n\n// Delete Intention\n$intentions = new Intentions([\n    'uuid' =&gt; 'b40faaf3-34aa-349f-3cf2-f5d720240662',\n]);\n$this-&gt;consul-&gt;connect()-&gt;deleteIntention($intentions);\n\n// Check Intention Result\n$intentions = new Intentions\\Check([\n    'source' =&gt; 'web',\n    'destination' =&gt; 'db',\n]);\n$this-&gt;consul-&gt;connect()-&gt;check($intentions);\n\n// List Matching Intentions\n$intentions = new Intentions\\Match([\n    'by' =&gt; 'source',\n    'name' =&gt; 'web',\n]);\n$this-&gt;consul-&gt;connect()-&gt;match($intentions);\nCoordinate\n// Read WAN Coordinates\n$datacenters = new Datacenters();\n$this-&gt;consul-&gt;coordinates()-&gt;datacenters($datacenters);\n\n// Read LAN Coordinates for all nodes\n$nodes = new Nodes([]);\n$this-&gt;consul-&gt;coordinates()-&gt;nodes($nodes);\n\n// Read LAN Coordinates for a node\n$node = new Node([\n    'node' =&gt; '2456c2850382',\n]);\n$this-&gt;consul-&gt;coordinates()-&gt;node($node);\n\n// Update LAN Coordinates for a node\n$update = new Update([\n    'dc' =&gt; 'dc1',\n    'node' =&gt; '2456c2850382',\n    'Segment' =&gt; 'update',\n    \"Coord\" =&gt; [\n        \"Adjustment\" =&gt; 0,\n        \"Error\" =&gt; 1.5,\n        \"Height\" =&gt; 0,\n        \"Vec\" =&gt; [0, 0, 0, 0, 0, 0, 0, 0]\n    ]\n]);\n$this-&gt;consul-&gt;coordinates()-&gt;update($update);\nEvents\n// Fire Event\n$fire = new Fire([\n    'name' =&gt; 'consul',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;event()-&gt;fire($fire);\n\n// List Events\n$listEvent = new ListEvent([\n    'name' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;event()-&gt;listEvent($listEvent);\nHealth\n// List Checks for Node\n$node = new Node([\n    'node' =&gt; '2456c2850382',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;health()-&gt;node($node);\n\n// List Checks for Service\n$checks = new Checks([\n   'service' =&gt; 'consul',\n   'node_meta' =&gt; 'node-meta',\n]);\n$this-&gt;consul-&gt;health()-&gt;checks($checks);\n\n// List Nodes for Service\n$service = new Service([\n    'service' =&gt; 'consul',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;health()-&gt;service($service);\n\n// List Nodes for Connect-capable Service\n$connect = new Connect([\n    'service' =&gt; 'consul'\n]);\n$this-&gt;consul-&gt;health()-&gt;connect($connect);\n\n// List Checks in State\n$state = new State([\n    'state' =&gt; 'passing'\n]);\n$this-&gt;consul-&gt;health()-&gt;state($state);\nKV Store\n// Read Key\n$kv = new Kv([\n    'key' =&gt; 'my-key',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;kvStore()-&gt;kv($kv);\n\n// Create Key\n$create = new kv([\n    'key' =&gt; 'my-key',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;kvStore()-&gt;create($create);\n\n// Update Key\n$update = new kv([\n    'key' =&gt; 'my-key',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;kvStore()-&gt;update($update);\n\n// Delete Key\n$delete = new Kv([\n    'key' =&gt; 'my-key',\n    'recurse' =&gt; false,\n]);\n$this-&gt;consul-&gt;kvStore()-&gt;delete($delete);\nOperator\nArea\n// Create Network Area\n$area = new Area([\n    'PeerDatacenter' =&gt; 'dc1',\n    \"RetryJoin\" =&gt; [ \"10.1.2.3\", \"10.1.2.4\", \"10.1.2.5\" ],\n    \"UseTLS\" =&gt; false\n]);\n$this-&gt;consul-&gt;operator()-&gt;area($area);\n\n// List Network Areas\n$area = new Area([\n    'dc' =&gt; 'dc1',\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n]);\n$this-&gt;consul-&gt;operator()-&gt;areaList($area);\n\n// List Specific Network Area\n$area = new Area([\n    'dc' =&gt; 'dc1',\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n]);\n$this-&gt;consul-&gt;operator()-&gt;areaList($area);\n\n// Update Network Area\n$area = new Area([\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n    'UseTLS' =&gt; true,\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;operator()-&gt;updateArea($area);\n\n// Delete Network Area\n$area = new Area([\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n]);\n$this-&gt;consul-&gt;operator()-&gt;deleteArea($area);\n\n// Join Network Area\n$area = new Area([\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n]);\n$this-&gt;consul-&gt;operator()-&gt;joinArea($area);\n\n// List Network Area Members\n$area = new Area([\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902'\n]);\n$this-&gt;consul-&gt;operator()-&gt;membersArea($area);\nAutopilot\n// Read Configuration\n$configuration = new Configuration([\n    'dc' =&gt; 'dc1',\n    'stale' =&gt; true,\n]);\n$this-&gt;consul-&gt;operator()-&gt;getConfiguration($configuration);\n\n// Update Configuration\n$configuration = new Configuration([\n    'dc' =&gt; 'dc1',\n    'stale' =&gt; true,\n    \"cleanupDeadServers\" =&gt; true,\n    \"lastContactThreshold\" =&gt; \"200ms\",\n    \"MaxTrailingLogs\" =&gt; 250,\n    \"ServerStabilizationTime\" =&gt; \"10s\",\n    \"RedundancyZoneTag\" =&gt; \"\",\n    \"DisableUpgradeMigration\" =&gt; false,\n    \"UpgradeVersionTag\" =&gt; \"\",\n\n]);\n$this-&gt;consul-&gt;operator()-&gt;updateConfiguration($configuration);\n\n// Read Health\n$health = new Health([\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;operator()-&gt;health($health);\nKeyring\n// List Gossip Encryption Keys\n$keyring = new Keyring();\n$keyring-&gt;setRelayFactor(0);\n$keyring-&gt;setLocalOnly(false);\n$this-&gt;consul-&gt;operator()-&gt;getKeyring($keyring);\n\n// Add New Gossip Encryption Key\n$keyring = new Keyring([\n    \"Key\" =&gt; \"3lg9DxVfKNzI8O+IQ5Ek+Q==\",\n    'relayFactor' =&gt; 1,\n]);\n$this-&gt;consul-&gt;operator()-&gt;addKeyring($keyring);\n\n// Change Primary Gossip Encryption Key\n$keyring = new Keyring([\n    \"Key\" =&gt; \"3lg9DxVfKNzI8O+IQ5Ek+Q==\",\n]);\n$this-&gt;consul-&gt;operator()-&gt;changeKeyring($keyring);\n\n// Delete Gossip Encryption Key\n$keyring = new Keyring([\n    \"Key\" =&gt; \"3lg9DxVfKNzI8O+IQ5Ek+Q==\",\n    \"relayFactor\" =&gt; 1\n]);\n$this-&gt;consul-&gt;operator()-&gt;deleteKeyring($keyring);\nLicense\n// Getting the Consul License\n$license = new License([\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;operator()-&gt;getLicense($license);\n\n// Updating the Consul License\n$license = new License([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;operator()-&gt;updateLicense($license);\n\n// Resetting the Consul License\n$license = new License([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;operator()-&gt;resetLicense($license);\nRaft\n// Read Configuration\n$raft = new \\EasySwoole\\Consul\\Request\\Operator\\Raft\\Configuration();\n$this-&gt;consul-&gt;operator()-&gt;getRaftConfiguration($raft);\n\n// Delete Raft Peer\n$peer = new Peer([\n    'address' =&gt; '172.17.0.18:8301',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;operator()-&gt;peer($peer);\nSegment\n// List Network Segments\n$segment = new Segment();\n$this-&gt;consul-&gt;operator()-&gt;segment($segment);\nPrepared Query\n// Create Prepared Query\n$query = new Query([\n    \"name\" =&gt; \"my-query\",\n    \"Session\" =&gt; \"adf4238a-882b-9ddc-4a9d-5b6758e4159e\",\n    \"Token\" =&gt; \"11\",\n    \"Service\" =&gt; [\n        \"Service\" =&gt; \"redis\",\n        \"Failover\" =&gt; [\n            \"NearestN\" =&gt; 3,\n            \"Datacenters\" =&gt; [\"dc1\", \"dc2\"]\n         ],\n        \"Near\" =&gt; \"node1\",\n        \"OnlyPassing\" =&gt; false,\n        \"Tags\" =&gt; [\"primary\", \"!experimental\"],\n        \"NodeMeta\" =&gt; [\"instance_type\" =&gt; \"m3.large\"],\n        \"ServiceMeta\" =&gt; [\"environment\" =&gt; \"production\"]\n    ],\n    \"DNS\" =&gt; [\n        \"TTL\" =&gt; \"10s\"\n    ],\n]);\n$this-&gt;consul-&gt;query()-&gt;query($query);\n\n// Read Prepared Query\n$query = new Query([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;query()-&gt;readQuery($query);\n\n// Update Prepared Query\n$query = new Query([\n    'uuid' =&gt; '90dce5ca-5697-ae2f-09ae-51e9542ea58c',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;query()-&gt;updateQuery($query);;\n\n// Read Prepared Query\n$query = new Query([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;query()-&gt;readQuery($query);\n\n// Delete Prepared Query\n$query = new Query([\n    'uuid' =&gt; '90dce5ca-5697-ae2f-09ae-51e9542ea58c'\n]);\n$this-&gt;consul-&gt;query()-&gt;deleteQuery($query);;\n\n// Execute Prepared Query\n$execute = new Query\\Execute([\n    'uuid' =&gt; '90dce5ca-5697-ae2f-09ae-51e9542ea58c',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;query()-&gt;execute($execute);\n\n// Explain Prepared Query\n$execute = new Query\\Explain([\n    'uuid' =&gt; '90dce5ca-5697-ae2f-09ae-51e9542ea58c',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;query()-&gt;explain($execute);\nSessions\n// Create Session\n$create = new Create([\n    'dc' =&gt; 'dc1',\n    \"LockDelay\" =&gt; \"15s\",\n    \"Name\" =&gt; \"my-service-lock\",\n    \"Node\" =&gt; \"foobar\",\n    \"Checks\" =&gt; [\"a\", \"b\", \"c\"],\n    \"Behavior\" =&gt; \"release\",\n    \"TTL\" =&gt; \"30s\",\n]);\n$this-&gt;consul-&gt;session()-&gt;create($create);\n\n// Delete Session\n$destroy = new Destroy([\n    'uuid' =&gt; 'f32a15b3-1baa-c047-bde9-bec3015ea013',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;session()-&gt;destroy($destroy);\n\n// Read Session\n$info = new Info([\n    'uuid' =&gt; 'f32a15b3-1baa-c047-bde9-bec3015ea013',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;session()-&gt;info($info);\n\n// List Sessions for Node\n$node = new Node([\n    'node' =&gt; '2456c2850382',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;session()-&gt;node($node);\n\n// List Sessions\n$sessionList = new SessionList([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;session()-&gt;sessionList($sessionList);\n\n// Renew Session\n$renew = new Renew([\n    'uuid' =&gt; '4f6d1cf6-b60a-c929-eeb8-12f4d7eaff62',\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;session()-&gt;renew($renew);\nSnapshots\n// Generate Snapshot\n$generate = new Snapshot([\n    'dc' =&gt; 'dc1',\n    'stale' =&gt; 'true',\n]);\n$this-&gt;consul-&gt;snapshot()-&gt;generate($generate);\n\n// Restore Snapshot\n$restore = new Snapshot();\n$this-&gt;consul-&gt;snapshot()-&gt;restore($restore);\nStatus\n// Get Raft Leader\n$leader = new Leader();\n$this-&gt;consul-&gt;status()-&gt;leader($leader);\n\n// List Raft Peers\n$peers = new Peers([\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;status()-&gt;peers($peers);\nTransactions\n// Create Transaction\n$transaction = new Txn([]);\n$this-&gt;consul-&gt;transaction()-&gt;create($transaction);\n$node = new Node([\n    'node' =&gt; '44e4656a94cd',\n    'dc' =&gt; 'dc1',\n    'filter' =&gt; '',\n]);\n$consul-&gt;catalog()-&gt;node($node);\n","link":"/Components/consul.html"},{"id":181,"title":"circuitbreaker注解","content":"CircuitBreaker\n熔断注解可为单个方法设定超时时间,以及超时之后的处理方法,例如:\n    /**\n     * 设定了超时时间和超时之后的方法,还传输了一个自定义的超时时间用于测试\n     * @CircuitBreaker(timeout=\"1.5\",failAction=\"circuitBreakerFail\")\n     * @Param(name=\"timeout\",required=\"\",between={1,5})\n     */\n    public function circuitBreaker($timeout)\n    {\n        \\co::sleep($timeout);\n        $this-&gt;writeJson(200,null,'success call');\n    }\n\n    public function circuitBreakerFail()\n    {\n        $this-&gt;writeJson(200,null,'this is fail call');\n    }","link":"/Microservices/circuitBreaker.html"},{"id":182,"title":"atomic-limit","content":"AtomicLimit\nEasyswoole提供了一个基于Atomic计数器的限流器。\n原理\n通过限制某一个时间周期内的总请求数，从而实现基础限流。举个例子，设置5秒内，允许的最大请求量为200，那么理论平均并发为40，峰值并发为200。\n安装\n\ncomposer require easyswoole/atomic-limit\n\n示例代码\n/*\n * egUrl http://127.0.0.1:9501/index.html?api=1\n */\n\nuse EasySwoole\\AtomicLimit\\AtomicLimit;\nAtomicLimit::getInstance()-&gt;addItem('default')-&gt;setMax(200);\nAtomicLimit::getInstance()-&gt;addItem('api')-&gt;setMax(2);\n\n$http = new swoole_http_server(\"127.0.0.1\", 9501);\n\nAtomicLimit::getInstance()-&gt;enableProcessAutoRestore($http,10*1000);\n\n$http-&gt;on(\"request\", function ($request, $response) {\n    if(isset($request-&gt;get['api'])){\n        if(AtomicLimit::isAllow('api')){\n            $response-&gt;write('api success');\n        }else{\n            $response-&gt;write('api refuse');\n        }\n    }else{\n        if(AtomicLimit::isAllow('default')){\n            $response-&gt;write('default success');\n        }else{\n            $response-&gt;write('default refuse');\n        }\n    }\n    $response-&gt;end();\n});\n\n$http-&gt;start();\n注意，本例子是用一个自定义进程内加定时器来实现计数定时重置，实际上用一个进程来做这件事情有点不值得，因此实际生产可以指定一个worker,设置定时器来实现\n使用\n我们可以在Easyswoole全局的mainServerCreate事件中，进行限流器注册\nuse EasySwoole\\AtomicLimit\\AtomicLimit;\nAtomicLimit::getInstance()-&gt;addItem('default')-&gt;setMax(200);\nAtomicLimit::getInstance()-&gt;addItem('api')-&gt;setMax(2);\nAtomicLimit::getInstance()-&gt;enableProcessAutoRestore(ServerManager::getInstance()-&gt;getSwooleServer(),10*1000)\n以上代码表示，default这个限流器在5秒内允许的最大流量为200，而api则个限流器的最大流量为2\n后续，我们可以在Easyswoole的base控制器中，进行请求拦截，例如在onRequest事件中，先进行流量检验，如果校验通过，则进行下一步操作。","link":"/Components/atomicLimit.html"},{"id":183,"title":"ip限流","content":"\nSwoole 如何对 IP 限制访问频率\n在我们开发 API 的过程中，有的时候我们还需要考虑单个用户(IP)访问频率控制，避免被恶意调用。\n归根到底也就只有两个步骤：\n\n用户访问要统计次数\n执行操作逻辑之前要判断次数频率是否过高，过高则不执行\n\n\nEasySwoole 中实现 IP 访问频率限制\n本文举例的是在 EasySwoole 框架中实现的代码，在Swoole 原生中实现方式是一样的。\n只要在对应的回调事件做判断拦截处理即可。\n\n使用 Swoole\\Table，存储用户访问情况（也可以使用其他组件、方式存储）\n使用定时器，将前一周期的访问情况清空，统计下一周期\n\n实现 IP 访问统计类\n\n如以下 IpList 类，实现了 初始化 Table、统计 IP访问次数、获取一个周期内次数超过一定值的记录\n&lt;?php\n/**\n * Ip访问次数统计\n * User: Siam\n * Date: 2019/7/8 0008\n * Time: 下午 9:53\n */\n\nnamespace App;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\Component\\TableManager;\nuse Swoole\\Table;\n\nclass IpList\n{\n    use Singleton;\n\n    /** @var Table */\n    protected $table;\n\n    public function __construct()\n    {\n        TableManager::getInstance()-&gt;add('ipList', [\n            'ip' =&gt; [\n                'type' =&gt; Table::TYPE_STRING,\n                'size' =&gt; 16\n            ],\n            'count' =&gt; [\n                'type' =&gt; Table::TYPE_INT,\n                'size' =&gt; 8\n            ],\n            'lastAccessTime' =&gt; [\n                'type' =&gt; Table::TYPE_INT,\n                'size' =&gt; 8\n            ]\n        ], 1024 * 128);\n        $this-&gt;table = TableManager::getInstance()-&gt;get('ipList');\n    }\n\n    public function access(string $ip): int\n    {\n        $key = substr(md5($ip), 8, 16);\n        $info = $this-&gt;table-&gt;get($key);\n\n        if ($info) {\n            $this-&gt;table-&gt;set($key, [\n                'lastAccessTime' =&gt; time(),\n                'count' =&gt; $info['count'] + 1,\n            ]);\n            return $info['count'] + 1;\n        } else {\n            $this-&gt;table-&gt;set($key, [\n                'ip' =&gt; $ip,\n                'lastAccessTime' =&gt; time(),\n                'count' =&gt; $info['count'] + 1,\n            ]);\n            return 1;\n        }\n    }\n\n    public function clear()\n    {\n        foreach ($this-&gt;table as $key =&gt; $item) {\n            $this-&gt;table-&gt;del($key);\n        }\n    }\n\n    public function accessList($count = 10): array\n    {\n        $ret = [];\n        foreach ($this-&gt;table as $key =&gt; $item) {\n            if ($item['count'] &gt;= $count) {\n                $ret[] = $item;\n            }\n        }\n        return $ret;\n    }\n}\n初始化 IP 统计类 和访问统计定时器\n封装完 IP统计 的操作之后，我们就可以在 EasySwooleEvent.php 中的 mainServerCreate 回调事件中初始化 IpList 类和定时器，注册 IP 统计自定义进程\n&lt;?php\nuse App\\IpList;\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Component\\Process\\Manager;\n\npublic static function mainServerCreate(EventRegister $register)\n{\n    // 开启 IP 限流\n    IpList::getInstance();\n    $class = new class('IpAccessCount') extends AbstractProcess\n    {\n        protected function run($arg)\n        {\n            $this-&gt;addTick(10 * 1000, function () {\n                /**\n                 * 正常用户不会有一秒超过 6 次的api请求\n                 * 做列表记录并清空\n                 */\n                $list = IpList::getInstance()-&gt;accessList(30);\n                // var_dump($list);\n                IpList::getInstance()-&gt;clear();\n            });\n        }\n    };\n\n    // 注册 IP 限流自定义进程\n    $processConfig = new \\EasySwoole\\Component\\Process\\Config();\n    $processConfig-&gt;setProcessName('IP_LIST');// 设置进程名称\n    $processConfig-&gt;setProcessGroup('IP_LIST');// 设置进程组名称\n    $processConfig-&gt;setArg([]);// 传参\n    $processConfig-&gt;setRedirectStdinStdout(false);// 是否重定向标准io\n    $processConfig-&gt;setPipeType(\\EasySwoole\\Component\\Process\\Config::PIPE_TYPE_SOCK_DGRAM);// 设置管道类型\n    $processConfig-&gt;setEnableCoroutine(true);// 是否自动开启协程\n    $processConfig-&gt;setMaxExitWaitTime(3);// 最大退出等待时间\n    Manager::getInstance()-&gt;addProcess(new $class($processConfig));\n}\n实现对 IP 访问的限制\n在 EasySwooleEvent.php 中的 mainServerCreate 回调事件中\n接着我们在 EasySwooleEvent.php 中的 initialize 回调事件中注入 HTTP_GLOBAL_ON_REQUEST 全局事件，判断和统计 IP 的访问\n&lt;?php\n\nuse EasySwoole\\Component\\Di;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse App\\IpList;\n\npublic static function initialize()\n{\n    // TODO: Implement initialize() method.\n    date_default_timezone_set('Asia/Shanghai');\n\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        Di::getInstance()-&gt;set('HTTP_GLOBAL_ON_REQUEST', function (Request $request, Response $response) {\n            $fd = $request-&gt;getSwooleRequest()-&gt;fd;\n            $ip = ServerManager::getInstance()-&gt;getSwooleServer()-&gt;getClientInfo($fd)['remote_ip'];\n\n            // 如果当前周期的访问频率已经超过设置的值，则拦截\n            // 测试的时候可以将 30 改小，比如 3\n            if (IpList::getInstance()-&gt;access($ip) &gt; 3) {\n                /**\n                 * 直接强制关闭连接\n                 */\n                ServerManager::getInstance()-&gt;getSwooleServer()-&gt;close($fd);\n                // 调试输出 可以做逻辑处理\n                echo '被拦截' . PHP_EOL;\n                return false;\n            }\n            // 调试输出 可以做逻辑处理\n            echo '正常访问' . PHP_EOL;\n            return true;\n        });\n    }\n}\n以上就实现了对同一 IP 访问频率的限制操作。具体还可以根据自身需求进行扩展，如对具体的某个接口再进行限流。\nEasySwoole 提供了一个基于 Atomic 计数器的限流器组件。可以直接使用，使用教程请移步查看限流器文档。","link":"/Components/ipLimit.html"},{"id":184,"title":"apollo","content":"apollo\nEasySwoole实现了对apollo数据中心的支持.可根据该组件,进行同步配置\n安装\n\ncomposer require easyswoole/apollo\n\n使用\ngo(function (){\n    //配置apollo服务器信息\n    $server = new \\EasySwoole\\Apollo\\Server([\n        'server'=&gt;'http://106.12.25.204:8080',\n        'appId'=&gt;'easyswoole'\n    ]);\n    //创建apollo客户端\n    $apollo = new \\EasySwoole\\Apollo\\Apollo($server);\n    //第一次同步\n    var_dump( $apollo-&gt;sync('mysql'));\n    //第二次同步，若服务端没有改变，那么返回的结果，isModify标记为fasle，并带有lastReleaseKey\n    var_dump( $apollo-&gt;sync('mysql'));\n});\n可以在进程中起一个定时器，实现自动定时更新","link":"/Components/apollo.html"},{"id":185,"title":"tracker","content":"Tracker\nEasyswoole提供了一个基础的追踪组件，方便用户实现基础的服务器状态监控，与调用链记录。\n组件要求\n\nphp: &gt;=7.1.0\next-swoole: ^4.4.0\neasyswoole/component: ^2.0\n\n安装方法\n\ncomposer require easyswoole/tracker\n\n仓库地址\neasyswoole/tracker\n调用链\nEasyswoole的调用链跟踪是一个以类似有序的树状链表的解构实现的，解构如下：\nstruct Point{\n    struct Point* nextPoint;\n    struct Point[] subPoints;\n    const END_SUCCESS = 'success';\n    const END_FAIL = 'fail';\n    const END_UNKNOWN = 'unknown';\n    int startTime;\n    mixed startArg;\n    int endTime;\n    string pointName;\n    string endStatus = self::END_UNKNOWN;\n    mixed endArg;\n    string pointId;\n    string parentId;\n    int depth = 0;\n    bool isNext\n}\n基本使用\n\nuse EasySwoole\\Tracker\\Point;\nuse EasySwoole\\Component\\WaitGroup;\nuse EasySwoole\\Tracker\\PointContext;\n/*\n * 假设我们的调用链是这样的\n * onRequest  -&gt;&gt; actionOne -&gt;&gt; actionOne call remote Api(1,2)  -&gt;&gt;  afterAction\n */\n\ngo(function (){\n    /*\n     * 创建入口\n     */\n    $onRequest = new Point('onRequest');\n    //记录请求参数，并模拟access log\n    \\co::sleep(0.01);\n    $onRequest-&gt;setStartArg([\n        'requestArg' =&gt; 'requestArgxxxxxxxx',\n        'accessLogId'=&gt;'logIdxxxxxxxxxx'\n    ]);\n    //onRequest完成\n    $onRequest-&gt;end();\n    //进入 next actionOne\n    $actionOne = $onRequest-&gt;next('actionOne');\n        //action one 进入子环节调用\n        $waitGroup = new WaitGroup();\n        //sub pointOne\n        $waitGroup-&gt;add();\n        $subOne = $actionOne-&gt;appendChild('subOne');\n        go(function ()use($subOne,$waitGroup){\n                \\co::sleep(0.1);\n                $subOne-&gt;end();\n                $waitGroup-&gt;done();\n        });\n        //sub pointTwo,并假设失败\n        $waitGroup-&gt;add();\n        $subTwo = $actionOne-&gt;appendChild('subTwo');\n            go(function ()use($subTwo,$waitGroup){\n                \\co::sleep(1);\n                $subTwo-&gt;end($subTwo::END_FAIL,['failMsg'=&gt;'timeout']);\n                $waitGroup-&gt;done();\n            });\n        $waitGroup-&gt;wait();\n    $actionOne-&gt;end();\n    //actionOne结束，进入afterAction\n    $afterAction = $actionOne-&gt;next('afterAction');\n    //模拟响应记录\n    \\co::sleep(0.01);\n    $afterAction-&gt;end($afterAction::END_SUCCESS,['log'=&gt;'success']);\n    /*\n     * 从入口开始打印调用链\n     */\n    echo Point::toString($onRequest);\n});\n//以上代码等价于如下\ngo(function (){\n    PointContext::getInstance()-&gt;createStart('onRequest')-&gt;next('actionOne')-&gt;next('afterAction');\n    //记录请求参数，并模拟access log\n    \\co::sleep(0.01);\n    PointContext::getInstance()-&gt;find('onRequest')-&gt;setStartArg([\n        'requestArg' =&gt; 'requestArgxxxxxxxx',\n        'accessLogId'=&gt;'logIdxxxxxxxxxx'\n    ])-&gt;end();\n    $subOne = PointContext::getInstance()-&gt;find('actionOne')-&gt;appendChild('subOne');\n    $subTwo = PointContext::getInstance()-&gt;find('actionOne')-&gt;appendChild('subTwo');\n    $waitGroup = new WaitGroup();\n    $waitGroup-&gt;add();\n    go(function ()use($subOne,$waitGroup){\n        \\co::sleep(0.1);\n        $subOne-&gt;end();\n        $waitGroup-&gt;done();\n    });\n    //sub pointTwo,并假设失败\n    $waitGroup-&gt;add();\n    go(function ()use($subTwo,$waitGroup){\n        \\co::sleep(1);\n        $subTwo-&gt;end($subTwo::END_FAIL,['failMsg'=&gt;'timeout']);\n        $waitGroup-&gt;done();\n    });\n    $waitGroup-&gt;wait();\n    PointContext::getInstance()-&gt;find('actionOne')-&gt;end();\n    //模拟响应记录\n    \\co::sleep(0.01);\n    PointContext::getInstance()-&gt;find('afterAction')-&gt;end(Point::END_SUCCESS,['log'=&gt;'success']);\n    /*\n    * 从入口开始打印调用链\n    */\n    echo Point::toString(PointContext::getInstance()-&gt;startPoint());\n});\n以上代码输出结果：\n#\nPointName:onRequest\nStatus:success\nPointId:AoRVFMgrsbNwukBZc7\nDepth:0\nIsNext:false\nStart:1561736477.2808\nStartArg:{\"requestArg\":\"requestArgxxxxxxxx\",\"accessLogId\":\"logIdxxxxxxxxxx\"}\nEnd:1561736477.2939\nEndArg:null\nChildCount:0\nChildren:None\nNextPoint:\n#\nPointName:actionOne\nStatus:success\nPointId:2zOWG1SvMbyBcnRmje\nDepth:0\nIsNext:true\nStart:1561736477.2809\nStartArg:null\nEnd:1561736478.2993\nEndArg:null\nChildCount:2\nChildren:\n        #\n        PointName:subOne\n        Status:success\n        PointId:0wU31l8brpfCnXdTxH\n        Depth:1\n        IsNext:false\n        Start:1561736477.2939\n        StartArg:null\n        End:1561736477.4006\n        EndArg:null\n        ChildCount:0\n        Children:None\n        NextPoint:None\n        #\n        PointName:subTwo\n        Status:fail\n        PointId:Jphr6RD8KSHmYbt70A\n        Depth:1\n        IsNext:false\n        Start:1561736477.2939\n        StartArg:null\n        End:1561736478.2993\n        EndArg:{\"failMsg\":\"timeout\"}\n        ChildCount:0\n        Children:None\n        NextPoint:None\nNextPoint:\n#\nPointName:afterAction\nStatus:success\nPointId:oPnGNrkj6qwb381BQl\nDepth:0\nIsNext:true\nStart:1561736477.2809\nStartArg:null\nEnd:1561736478.3119\nEndArg:{\"log\":\"success\"}\nChildCount:0\nChildren:None\nNextPoint:None\n如果想以自己的格式记录到数据库，可以具体查看Point实现的方法，每个Point都有自己的Id\n进阶使用\nHTTP API请求追踪\nEasySwooleEvent.php\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\Tracker\\Point;\nuse EasySwoole\\Tracker\\PointContext;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        $point = PointContext::getInstance()-&gt;createStart('onRequest');\n        $point-&gt;setStartArg([\n            'uri'=&gt;$request-&gt;getUri()-&gt;__toString(),\n            'get'=&gt;$request-&gt;getQueryParams()\n        ]);\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        $point = PointContext::getInstance()-&gt;startPoint();\n        $point-&gt;end();\n        echo Point::toString($point);\n        $array = Point::toArray($point);\n    }\n}\nIndex.php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Component\\WaitGroup;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Tracker\\PointContext;\n\nclass Index extends Controller\n{\n\n    protected function onRequest(?string $action): ?bool\n    {\n        /*\n         * 调用关系  HttpRequest-&gt;OnRequest\n         */\n        $point = PointContext::getInstance()-&gt;next('ControllerOnRequest');\n        //假设这里进行了权限验证，并模拟数据库耗时\n        \\co::sleep(0.01);\n        $point-&gt;setEndArg([\n            'userId'=&gt;'xxxxxxxxxxx'\n        ]);\n        $point-&gt;end();\n        return true;\n    }\n\n    function index()\n    {\n        //模拟调用第三方Api,调用关系  OnRequest-&gt;sub(subApi1,subApi2)\n        $actionPoint = PointContext::getInstance()-&gt;next('indexAction');\n        $wait = new WaitGroup();\n        $subApi = $actionPoint-&gt;appendChild('subOne');\n        $wait-&gt;add();\n        go(function ()use($wait,$subApi){\n            \\co::sleep(1);\n            $subApi-&gt;end();\n            $wait-&gt;done();\n        });\n\n        $subApi = $actionPoint-&gt;appendChild('subTwo');\n        $wait-&gt;add();\n        go(function ()use($wait,$subApi){\n            \\co::sleep(0.3);\n            $subApi-&gt;end($subApi::END_FAIL);\n            $wait-&gt;done();\n        });\n\n        $wait-&gt;wait();\n\n        $actionPoint-&gt;end();\n        $this-&gt;response()-&gt;write('hello world');\n    }\n}\n以上每次请求会输出如下格式：\n#\nPointName:onRequest\nStatus:success\nPointId:1561743038GyV4lnus\nParentId:\nDepth:0\nIsNext:false\nStart:1561743038.7011\nStartArg:{\"uri\":\"http://127.0.0.1:9501/\",\"get\":[]}\nEnd:1561743039.7152\nEndArg:null\nChildCount:0\nChildren:None\nNextPoint:\n#\nPointName:ControllerOnRequest\nStatus:success\nPointId:15617430386f0OQDsS\nParentId:1561743038GyV4lnus\nDepth:0\nIsNext:true\nStart:1561743038.7025\nStartArg:null\nEnd:1561743038.713\nEndArg:null\nChildCount:0\nChildren:None\nNextPoint:\n#\nPointName:indexAction\nStatus:success\nPointId:1561743038XEmF0M49\nParentId:15617430386f0OQDsS\nDepth:0\nIsNext:true\nStart:1561743038.7131\nStartArg:null\nEnd:1561743039.7151\nEndArg:null\nChildCount:2\nChildren:\n        #\n        PointName:subOne\n        Status:success\n        PointId:1561743038uIkzYgcS\n        ParentId:1561743038XEmF0M49\n        Depth:1\n        IsNext:false\n        Start:1561743038.7135\n        StartArg:null\n        End:1561743039.7151\n        EndArg:null\n        ChildCount:0\n        Children:None\n        NextPoint:None\n        #\n        PointName:subTwo\n        Status:fail\n        PointId:1561743038PslVSY4n\n        ParentId:1561743038XEmF0M49\n        Depth:1\n        IsNext:false\n        Start:1561743038.7136\n        StartArg:null\n        End:1561743039.0149\n        EndArg:null\n        ChildCount:0\n        Children:None\n        NextPoint:None\nNextPoint:None\nApi调用链记录\n$array = Point::toArray($point);\n可以把一个入口点转为一个数组。例如我们可以在MYSQL数据库中存储以下关键结构：\nCREATE TABLE `api_tracker_point_list` (\n  `pointd` varchar(18) NOT NULL,\n  `pointName` varchar(45) DEFAULT NULL,\n  `parentId` varchar(18) DEFAULT NULL,\n  `depth` int(11) NOT NULL DEFAULT '0',\n  `isNext` int(11) NOT NULL DEFAULT '0',\n  `startTime` varchar(14) NOT NULL,\n  `endTime` varchar(14) DEFAULT NULL,\n  `status` varchar(10) NOT NULL,\n  PRIMARY KEY (`pointd`),\n  UNIQUE KEY `trackerId_UNIQUE` (`pointd`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n其余请求参数可以自己记录。\n核心字段在pointId，parentId与isNext，status 这四个个字段,例如，我想得到哪次调用链超时，那么就是直接\nwhere status = fail\n如果想看哪次调用耗时多少，那么可以\nwhere spendTime &gt; 3\nspendTime 是用startTime和endTime计算\n相关仓库\nEasySwoole之链路追踪 简单demo","link":"/Components/tracker.html"},{"id":186,"title":"架构说明","content":"EasySwoole RPC\n很多传统的Phper并不懂RPC是什么，RPC全称Remote Procedure Call，中文译为远程过程调用,其实你可以把它理解为是一种架构性上的设计，或者是一种解决方案。\n例如在某庞大商场系统中，你可以把整个商场拆分为N个微服务（理解为N个独立的小模块也行），例如：\n\n订单系统\n用户管理系统\n商品管理系统\n等等 \n\n那么在这样的架构中，就会存在一个Api网关的概念，或者是叫服务集成者。我的Api网关的职责，就是把一个请求\n，拆分成N个小请求，分发到各个小服务里面，再整合各个小服务的结果，返回给用户。例如在某次下单请求中，那么大概\n发送的逻辑如下：\n\nApi网关接受请求\nApi网关提取用户参数，请求用户管理系统，获取用户余额等信息，等待结果\nApi网关提取商品参数，请求商品管理系统，获取商品剩余库存和价格等信息，等待结果。\nApi网关融合用户管理系统、商品管理系统的返回结果，进行下一步调用（假设满足购买条件）\nApi网关调用用户管理信息系统进行扣款，调用商品管理系统进行库存扣减，调用订单系统进行下单（事务逻辑和撤回可以用请求id保证，或者自己实现其他逻辑调度）\nAPi网关返回综合信息给用户\n\n而在以上发生的行为，就称为远程过程调用。而调用过程实现的通讯协议可以有很多，比如常见的HTTP协议。而EasySwoole RPC采用自定义短链接的TCP协议实现，每个请求包，都是一个JSON，从而方便实现跨平台调用。\n全新特性\n\n协程调度\n服务自动发现\n服务熔断\n服务降级\nOpenssl加密\n跨平台，跨语言支持\n支持接入第三方注册中心\n\n安装\n\ncomposer require easyswoole/rpc=4.x\n\n执行流程\n服务端：\n注册RPC服务，创建相应的服务swoole table表（ps:记录调用成功和失败的次数）\n注册worker,tick进程  \nwoker进程监听：\n客户端发送请求-&gt;解包成相对应的格式-&gt;执行对应的服务-&gt;返回结果-&gt;客户端  \ntick进程：\n注册定时器发送心跳包到本节点管理器\n启用广播：每隔几秒发送本节点各个服务信息到其他节点\n启用监听：监听其他节点发送的信息，发送相对应的命令（心跳|下线）到节点管理器处理\n进程关闭：主动删除本节点的信息，发送下线广播到其他节点  \n","link":"/Microservices/Rpc/introduction.html"},{"id":187,"title":"服务端","content":"Rpc-Server\n场景\n例如在一个商场系统中，我们将商品库和系统公告两个服务切分开到不同的服务器当中。当用户打开商场首页的时候，\n我们希望App向某个网关发起请求，该网关可以自动的帮我们请求商品列表和系统公共等数据，合并返回。\n服务定义\n每一个Rpc服务其实就一个EasySwoole\\Rpc\\AbstractService类。 如下：\n定义商品服务\nnamespace App\\RpcService;\n\nuse EasySwoole\\Rpc\\AbstractService;\n\nclass Goods extends AbstractService\n{\n\n    /**\n     *  重写onRequest(比如可以对方法做ip拦截或其它前置操作)\n     *\n     * @param string $action\n     * @return bool\n     * CreateTime: 2020/6/20 下午11:12\n     */\n    protected function onRequest(?string $action): ?bool\n    {\n        return true;\n    }\n\n    public function serviceName(): string\n    {\n        return 'goods';\n    }\n\n    public function list()\n    {\n        $this-&gt;response()-&gt;setResult([\n            [\n                'goodsId'=&gt;'100001',\n                'goodsName'=&gt;'商品1',\n                'prices'=&gt;1124\n            ],\n            [\n                'goodsId'=&gt;'100002',\n                'goodsName'=&gt;'商品2',\n                'prices'=&gt;599\n            ]\n        ]);\n        $this-&gt;response()-&gt;setMsg('get goods list success');\n    }\n}\n定义公共服务\nnamespace App\\RpcService;\n\nuse EasySwoole\\Rpc\\AbstractService;\n\nclass Common extends AbstractService\n{\n    public function serviceName(): string\n    {\n        return 'common';\n    }\n\n    public function mailBox()\n    {\n        $this-&gt;response()-&gt;setResult([\n            [\n                'mailId'=&gt;'100001',\n                'mailTitle'=&gt;'系统消息1',\n            ],\n            [\n                'mailId'=&gt;'100001',\n                'mailTitle'=&gt;'系统消息1',\n            ],\n        ]);\n        $this-&gt;response()-&gt;setMsg('get mail list success');\n    }\n\n    public function serverTime()\n    {\n        $this-&gt;response()-&gt;setResult(time());\n        $this-&gt;response()-&gt;setMsg('get server time success');\n    }\n}\n服务注册\n在Easyswoole全局的Event文件中，进行服务注册。至于节点管理、服务类定义等具体用法请看对应章节。\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\RpcService\\Common;\nuse App\\RpcService\\Goods;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\Redis\\Config\\RedisConfig;\nuse EasySwoole\\RedisPool\\RedisPool;\nuse EasySwoole\\Rpc\\NodeManager\\RedisManager;\nuse EasySwoole\\Rpc\\Config as RpcConfig;\nuse EasySwoole\\Rpc\\Rpc;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        /*\n         * 定义节点Redis管理器\n         */\n        $redisPool = new RedisPool(new RedisConfig([\n            'host'=&gt;'127.0.0.1'\n        ]));\n        $manager = new RedisManager($redisPool);\n        //配置Rpc实例\n        $config = new RpcConfig();\n        //这边用于指定当前服务节点ip，如果不指定，则默认用UDP广播得到的地址\n        $config-&gt;setServerIp('127.0.0.1');\n        $config-&gt;setNodeManager($manager);\n        /*\n         * 配置初始化\n         */\n        Rpc::getInstance($config);\n        //添加服务\n        Rpc::getInstance()-&gt;add(new Goods());\n        Rpc::getInstance()-&gt;add(new Common());\n        Rpc::getInstance()-&gt;attachToServer(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        // TODO: Implement onRequest() method.\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        // TODO: Implement afterAction() method.\n    }\n}\n\n为了方便测试，我把两个服务放在同一台机器中注册。实际生产场景应该是N台机注册商品服务，N台机器注册公告服务，把服务分开。\n","link":"/Microservices/Rpc/server.html"},{"id":188,"title":"客户端","content":"Rpc-Client\n控制器聚合调用\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Rpc\\Response;\nuse EasySwoole\\Rpc\\Rpc;\n\nclass Index extends Controller\n{\n\n    function index()\n    {\n        $ret = [];\n        $client = Rpc::getInstance()-&gt;client();\n        /*\n         * 调用商品列表\n         */\n        $client-&gt;addCall('goods','list',['page'=&gt;1])\n            -&gt;setOnSuccess(function (Response $response)use(&amp;$ret){\n                $ret['goods'] = $response-&gt;toArray();\n            })-&gt;setOnFail(function (Response $response)use(&amp;$ret){\n                $ret['goods'] = $response-&gt;toArray();\n            });\n        /*\n         * 调用信箱公共\n         */\n        $client-&gt;addCall('common','mailBox')\n            -&gt;setOnSuccess(function (Response $response)use(&amp;$ret){\n                $ret['mailBox'] = $response-&gt;toArray();\n            })-&gt;setOnFail(function (Response $response)use(&amp;$ret){\n                $ret['mailBox'] = $response-&gt;toArray();\n            });\n        /*\n        * 获取系统时间\n        */\n        $client-&gt;addCall('common','serverTime')\n            -&gt;setOnSuccess(function (Response $response)use(&amp;$ret){\n                $ret['serverTime'] = $response-&gt;toArray();\n            });\n\n        $client-&gt;exec(2.0);\n\n        $this-&gt;writeJson(200,$ret);\n    }\n}\n\n注意，控制器中可以这样调用，是因为服务端章节中，在EasySwoole的全局启动事件已经对当前的Rpc实例定义注册了节点管理器。因此在控制器中调用的时候\n该Rpc实例可以找到对应的节点。一般来说，在做聚合网关的节点，是不需要注册服务进去的，仅需注册节点管理器即可。\n\n客户端\n\n当rpc服务和客户端不在同一服务中时，并且服务端客户端使用的都是es\n\n&lt;?php\nrequire_once 'vendor/autoload.php';\n\nuse EasySwoole\\Rpc\\Config;\nuse EasySwoole\\Rpc\\Rpc;\nuse EasySwoole\\Rpc\\NodeManager\\RedisManager;\nuse EasySwoole\\Rpc\\Response;\n$redisConfig = new \\EasySwoole\\Redis\\Config\\RedisConfig();\n$redisConfig-&gt;setHost('127.0.0.1'); // 服务端使用的redis节点地址\n$redisConfig-&gt;setPort('6379'); // 服务端使用的redis节点端口\n$pool=new \\EasySwoole\\RedisPool\\RedisPool($redisConfig);\n$config = new Config();\n$config-&gt;setServerIp('127.0.0.1'); // 指定rpc服务地址\n$config-&gt;setListenPort(9502); // 指定rpc服务端口\n$config-&gt;setNodeManager(new RedisManager($pool));\n$rpc = new Rpc($config);\n\n\\Swoole\\Coroutine::create(function () use ($rpc) {\n    $client = $rpc-&gt;client();\n    $client-&gt;addCall('UserService', 'register', ['arg1', 'arg2'])\n        -&gt;setOnFail(function (Response $response) {\n            print_r($response-&gt;toArray());\n        })\n        -&gt;setOnSuccess(function (Response $response) {\n            print_r($response-&gt;toArray());\n        });\n\n    $client-&gt;exec();\n});\nswoole_timer_clear_all();","link":"/Microservices/Rpc/client.html"},{"id":189,"title":"跨语言","content":"跨平台\nRpc的请求响应通过tcp协议,服务广播使用udp协议,我们只需要实现网络协议即可。\nPHP示例代码\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: xcg\n * Date: 2019/6/17\n * Time: 14:30\n */\n$data = [\n    'command' =&gt; 1,//1:请求,2:状态rpc 各个服务的状态\n    'request' =&gt; [\n        'serviceName' =&gt; 'UserService',\n        'action' =&gt; 'register',//行为名称\n        'arg' =&gt; [\n            'args1' =&gt; 'args1',\n            'args2' =&gt; 'args2'\n        ]\n    ]\n];\n\n//$raw = serialize($data);//注意序列化类型,需要和RPC服务端约定好协议 $serializeType\n\n$raw = json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);\n\n$fp = stream_socket_client('tcp://127.0.0.1:9600');\nfwrite($fp, pack('N', strlen($raw)) . $raw);//pack数据校验\n\n$data = fread($fp, 65533);\n//做长度头部校验\n$len = unpack('N', $data);\n$data = substr($data, '4');\nif (strlen($data) != $len[1]) {\n    echo 'data error';\n} else {\n    $data = json_decode($data, true);\n//    //这就是服务端返回的结果，\n    var_dump($data);//默认将返回一个response对象 通过$serializeType修改\n}\nfclose($fp);\nGo示例代码\npackage main\n\nimport (\n    \"encoding/binary\"\n    \"net\"\n)\n\nfunc main() {\n    var tcpAddr *net.TCPAddr\n    tcpAddr,_ = net.ResolveTCPAddr(\"tcp\",\"127.0.0.1:9600\")\n    conn,_ := net.DialTCP(\"tcp\",nil,tcpAddr)\n    defer conn.Close()\n    sendEasyswooleMsg(conn)\n}\n\nfunc sendEasyswooleMsg(conn *net.TCPConn) {\n    var sendData []byte\n    data := `{\"command\":1,\"request\":{\"serviceName\":\"UserService\",\"action\":\"register\",\"arg\":{\"args1\":\"args1\",\"args2\":\"args2\"}}}`\n    b := []byte(data)\n    // 大端字节序(网络字节序)大端就是将高位字节放到内存的低地址端，低位字节放到高地址端。\n    // 网络传输中(比如TCP/IP)低地址端(高位字节)放在流的开始，对于2个字节的字符串(AB)，传输顺序为：A(0-7bit)、B(8-15bit)。\n    sendData = int32ToBytes8(int32(len(data)))\n    // 将数据byte拼装到sendData的后面\n    for _, value := range b {\n        sendData = append(sendData, value)\n    }\n    conn.Write(sendData)\n}\n\nfunc int32ToBytes8(n int32) []byte {\n    var buf = make([]byte, 4)\n    binary.BigEndian.PutUint32(buf, uint32(n))\n    return buf\n}\nJava\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        byte[] msg = \"{\\\"command\\\":1,\\\"request\\\":{\\\"serviceName\\\":\\\"UserService\\\",\\\"action\\\":\\\"register\\\",\\\"arg\\\":{\\\"args1\\\":\\\"args1\\\",\\\"args2\\\":\\\"args2\\\"}}}\".getBytes();\n        byte[] head = Main.toLH(msg.length);\n        byte[] data = Main.mergeByteArr(head, msg);\n\n        //创建Socket对象，连接服务器\n        Socket socket=new Socket(\"127.0.0.1\",9600);\n        //通过客户端的套接字对象Socket方法，获取字节输出流，将数据写向服务器\n        OutputStream out=socket.getOutputStream();\n        out.write(data);\n\n        //读取服务器发回的数据，使用socket套接字对象中的字节输入流\n        InputStream in=socket.getInputStream();\n        byte[] response=new byte[1024];\n        int len=in.read(response);\n        System.out.println(new String(response,4, len-4));\n        socket.close();\n    }\n\n    static byte[] toLH(int n) {\n        byte[] b = new byte[4];\n        b[3] = (byte) (n &amp; 0xff);\n        b[2] = (byte) (n &gt;&gt; 8 &amp; 0xff);\n        b[1] = (byte) (n &gt;&gt; 16 &amp; 0xff);\n        b[0] = (byte) (n &gt;&gt; 24 &amp; 0xff);\n        return b;\n    }\n\n    static byte[] mergeByteArr(byte[] a, byte[] b) {\n        byte[] c= new byte[a.length + b.length];\n        System.arraycopy(a, 0, c, 0, a.length);\n        System.arraycopy(b, 0, c, a.length, b.length);\n        return c;\n    }\n}\n其他语言只需要实现tcp协议即可","link":"/Microservices/Rpc/otherPlatform.html"},{"id":190,"title":"服务注册中心","content":"EasySwoole RPC 自定义注册中心\nEasySwoole默认为通过UDP广播+自定义进程定时刷新自身节点信息的方式来实现无主化/注册中心的服务发现。在服务正常关闭的时候，自定义定时进程的onShutdown方法会执行deleteServiceNode方法来实现节点下线。在非正常关闭的时候，心跳超时也会被节点管理器踢出。\n有些情况，不方便用UDP广播的情况下，那么EasySwoole支持你自定义一个节点管理器，来变更服务发现方式。\n例如用Redis来实现\nnamespace EasySwoole\\Rpc\\NodeManager;\n\nuse EasySwoole\\RedisPool\\RedisPool;\nuse EasySwoole\\Rpc\\ServiceNode;\nuse EasySwoole\\Utility\\Random;\n\nclass RedisManager implements NodeManagerInterface\n{\n    protected $redisKey;\n\n    protected $pool;\n\n    function __construct(RedisPool $pool, string $hashKey = 'rpc')\n    {\n        $this-&gt;redisKey = $hashKey;\n        $this-&gt;pool = $pool;\n    }\n\n    function getServiceNodes(string $serviceName, ?string $version = null): array\n    {\n        $redis = $this-&gt;pool-&gt;getObj(15);\n        try {\n            $nodes = $redis-&gt;hGetAll(\"{$this-&gt;redisKey}_{$serviceName}\");\n            $nodes = $nodes ?: [];\n            $ret = [];\n            foreach ($nodes as $nodeId =&gt; $node) {\n                $node = new ServiceNode(json_decode($node,true));\n                /**\n                 * @var  $nodeId\n                 * @var  ServiceNode $node\n                 */\n                if (time() - $node-&gt;getLastHeartBeat() &gt; 30) {\n                    $this-&gt;deleteServiceNode($node);\n                }\n                if ($version &amp;&amp; $version != $node-&gt;getServiceVersion()) {\n                    continue;\n                }\n                $ret[$nodeId] = $node;\n            }\n            return $ret;\n        } catch (\\Throwable $throwable) {\n            //如果该redis断线则销毁\n            $this-&gt;pool-&gt;unsetObj($redis);\n        } finally {\n            $this-&gt;pool-&gt;recycleObj($redis);\n        }\n        return [];\n    }\n\n    function getServiceNode(string $serviceName, ?string $version = null): ?ServiceNode\n    {\n        $list = $this-&gt;getServiceNodes($serviceName, $version);\n        if (empty($list)) {\n            return null;\n        }\n        return Random::arrayRandOne($list);\n    }\n\n    function deleteServiceNode(ServiceNode $serviceNode): bool\n    {\n        $redis = $this-&gt;pool-&gt;getObj(15);\n        try {\n            $redis-&gt;hDel($this-&gt;generateNodeKey($serviceNode), $serviceNode-&gt;getNodeId());\n            return true;\n        } catch (\\Throwable $throwable) {\n            $this-&gt;pool-&gt;unsetObj($redis);\n        } finally {\n            $this-&gt;pool-&gt;recycleObj($redis);\n        }\n        return false;\n    }\n\n    function serviceNodeHeartBeat(ServiceNode $serviceNode): bool\n    {\n        if (empty($serviceNode-&gt;getLastHeartBeat())) {\n            $serviceNode-&gt;setLastHeartBeat(time());\n        }\n        $redis = $this-&gt;pool-&gt;getObj(15);\n        try {\n            $redis-&gt;hSet($this-&gt;generateNodeKey($serviceNode), $serviceNode-&gt;getNodeId(), $serviceNode-&gt;__toString());\n            return true;\n        } catch (\\Throwable $throwable) {\n            $this-&gt;pool-&gt;unsetObj($redis);\n        } finally {\n            //这边需要测试一个对象被unset后是否还能被回收\n            $this-&gt;pool-&gt;recycleObj($redis);\n        }\n        return false;\n    }\n\n    protected function generateNodeKey(ServiceNode $node)\n    {\n        return \"{$this-&gt;redisKey}_{$node-&gt;getServiceName()}\";\n    }\n}\n即使关闭了UDP定时广,EasySwoole Rpc的tick进程依旧会每3秒执行一次serviceNodeHeartBeat用于更新自身的节点心跳信息。","link":"/Microservices/Rpc/registerCenter.html"},{"id":191,"title":"单例","content":"单例\n单例模式确保类在全局只能有一个实例，因为它的实例是由自己保存，在类的外部也无法对该类进行实例化。  \n作用\nPHP的单例模式是为了避免重复创建对象带来的资源消耗。\n用途\n实际项目中像数据库查询，日志输出，全局回调，统一校验等模块。这些模块功能单一，但需要多次访问，如果能够全局唯一，多次复用会大大提升性能。\n例子\n\nnamespace EasySwoole\\Component;\n\nclass MySingleton\n{\n    use Singleton;\n}\n\n$mySingleton = Mysingleton::getInstance();\n\n核心对象方法\n核心类：EasySwoole\\Component\\Singleton。\n获取对象\n\nmixed     $args     参数\n\nstatic function getInstance(...$args)","link":"/Components/Component/singleton.html"},{"id":192,"title":"协程单例","content":"协程单例\n为兼容协程环境下的单例模式安全 可以使用CoroutineSingleTon这个trait\n引用方法可以参考普通Singleton trait\nnamespace EasySwoole\\Component;\nuse Swoole\\Coroutine;\ntrait CoroutineSingleTon\n{\n    private static $instance = [];\n    static function getInstance(...$args)\n    {\n        $cid = Coroutine::getCid();\n        if(!isset(self::$instance[$cid])){\n            self::$instance[$cid] = new static(...$args);\n            /*\n             * 兼容非携程环境\n             */\n            if($cid &gt; 0){\n                Coroutine::defer(function ()use($cid){\n                    unset(self::$instance[$cid]);\n                });\n            }\n        }\n        return self::$instance[$cid];\n    }\n    function destroy(int $cid = null)\n    {\n        if($cid === null){\n            $cid = Coroutine::getCid();\n        }\n        unset(self::$instance[$cid]);\n    }\n} ","link":"/Components/Component/coroutineSingleton.html"},{"id":193,"title":"就绪等待","content":"ReadyScheduler\nEasyswoole 基础组件1.8.7版本起，提供了一个基于Swoole Table实现的就绪计划程序，用于解决主服务启动时，部分子服务未就绪问题。\n基础测试使用\nnamespace EasySwoole\\Component\\Tests;\n\nuse EasySwoole\\Component\\ReadyScheduler;\nuse PHPUnit\\Framework\\TestCase;\nuse Swoole\\Coroutine;\n\nclass ReadySchedulerTest extends TestCase\n{\n    function testNormal()\n    {\n        ReadyScheduler::getInstance()-&gt;addItem('worker');\n        ReadyScheduler::getInstance()-&gt;addItem('rpc');\n        ReadyScheduler::getInstance()-&gt;addItem('fastCache');\n\n        go(function (){\n            Coroutine::sleep(1);\n            ReadyScheduler::getInstance()-&gt;ready('worker');\n            ReadyScheduler::getInstance()-&gt;ready('rpc');\n        });\n        $this-&gt;assertEquals(false,ReadyScheduler::getInstance()-&gt;waitReady(['rpc','worker'],0.1));\n        $this-&gt;assertEquals(true,ReadyScheduler::getInstance()-&gt;waitReady('rpc'));\n        $this-&gt;assertEquals(true,ReadyScheduler::getInstance()-&gt;waitReady(['rpc','worker']));\n        $this-&gt;assertEquals(false,ReadyScheduler::getInstance()-&gt;waitReady(['rpc','worker','fastCache'],1.1));\n    }\n}\nEasySwoole服务中使用\n以Http服务作为基础例子\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\Component\\ReadyScheduler;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse Swoole\\Coroutine;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        /*\n         * 主进程初始化table\n         */\n        ReadyScheduler::getInstance();\n        /*\n         * 假设，服务启动的时候，依赖 serviceOne，serviceTwo 两个服务，例如链接第三方api等。\n         * 在服务未就绪的时候，我们不希望本机器开始对外服务\n         */\n        $register-&gt;add($register::onWorkerStart,function ($serv, $workerId){\n            if($workerId == 0){\n                /*\n                 * 若不是强制准备，请注意addItem,unready，ready实现方法\n                 */\n                Coroutine::sleep(3);\n                ReadyScheduler::getInstance()-&gt;ready('serviceOne',true);\n                var_dump('r1');\n            }else if($workerId == 1){\n                Coroutine::sleep(4);\n                ReadyScheduler::getInstance()-&gt;ready('serviceTwo',true);\n                var_dump('r2');\n            }\n        });\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        /*\n         * 链接进来的时候，判断依赖的服务是否就绪,等待时间为1s (tcp，ws服务也同理)\n         * 在服务未就绪的时候，我们先拒绝服务\n        */\n        if(!ReadyScheduler::getInstance()-&gt;waitReady(['serviceOne','serviceTwo'],1.0)){\n            $response-&gt;write('not ready,try again');\n            return false;\n        }\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n\n    }\n}","link":"/Components/Component/readyScheduler.html"},{"id":194,"title":"协程执行器","content":"CoroutineRunner\n协程执行器 CoroutineRunner类似于Csp组件，但更加灵活，可以投递协程任务并限制最大同时执行数、最长执行时间、成功或失败回调\n简单示例\nuse co;\nuse EasySwoole\\Component\\CoroutineRunner\\Runner;\nuse EasySwoole\\Component\\CoroutineRunner\\Task;\n\n$runner = new Runner(10);\n$runner-&gt;setOnException(function(\\Throwable  $e, $task){\n    echo $e-&gt;getMessage();\n    echo PHP_EOL;\n});\n\n$max = 30;\n$allTask = [];\nwhile($max&gt;0){\n    $task = new Task(function() use ($max) {\n        echo $max .PHP_EOL;\n        co::sleep(1);\n        // 将设这是一个curl爬取任务 return 爬取结果 可以在外部获取\n        return 'ok';\n    });\n    $runner-&gt;addTask($task);\n    $allTask[] = $task;\n    $max--;\n}\n\n$runner-&gt;start(1);// 最长执行1秒  总共投递了30个 最大并发10个 需要3秒执行完，所以会有一部分将被丢弃  看下方参数说明列表\n\nforeach($allTask as $key =&gt; $task){\n    var_dump($task-&gt;getResult());\n}\n\n参数说明\nRunner构造函数\n可接收两个参数 __construct($concurrency = 64,$taskChannelSize = 1024)\n\nconcurrency 最大同时执行的协程数量\ntaskChannelSize 可投递的task队列长度\n\nRunner-&gt;setOnException\n设置异常回调 有两个参数 (\\Throwable $e, Task $task) \nRunner-&gt;start\n开启已经投递的task协程的执行，有一个参数\n\nfloat $waitTime = 30 最长执行时间，如果超过这个时间，剩余的task协程将被丢弃，不再执行。\n\nTask构造函数\n需要一个callable参数，用于调用执行，可以在闭包内return数据，外部使用 $task-&gt;getResult()获取\n\nreturn 不等于 false的数据将会触发onSuccess\nreturn false 将会触发 onFail\n\nTask-&gt;setOnSuccess\n需要一个callable参数\n【非必选】 task执行完成回调\nTask-&gt;setOnFail\n需要一个callable参数\n【非必选】 task执行失败回调\nTask-&gt;getResult\n获取call函数执行后return的数据","link":"/Components/Component/coroutineRunner.html"},{"id":195,"title":"swoole table","content":"TableManager\nEasySwoole\\Component\\TableManager\nEasySwoole对Swoole table进行了基础的封装,用于共享内存\n方法列表\ngetInstance()\n该方法用于获取TableManager管理器实例\nadd($name,array $columns,$size = 1024)\n该方法用于创建一个table\nget($name):?Table\n该方法用于获取已经创建好的table\n示例代码\nTableManager::getInstance()-&gt;add(\n    self::TABLE_NAME,\n    [\n        'currentNum'=&gt;['type'=&gt;Table::TYPE_INT,'size'=&gt;2],\n    ],\n    1024\n);\n注意事项：请勿在onRequest、OnReceive等回调位置创建swoole table,swoole table应该在服务启动前创建，比如在mainServerCreate事件中创建。","link":"/Components/Component/tableManager.html"},{"id":196,"title":"atomic 计数器","content":"Atomic\nswoole_atomic是swoole扩展提供的原子计数操作类，可以方便整数的无锁原子增减。\n\n\nswoole_atomic使用共享内存，可以在不同的进程之间操作计数\n\nswoole_atomic基于gcc提供的CPU原子指令，无需加锁\n\nswoole_atomic在服务器程序中必须在swoole_server-&gt;start前创建才能在Worker进程中使用\n\nswoole_atomic默认使用32位无符号类型，如需要64有符号整型，可使用Swoole\\Atomic\\Long\n\n\n注意：请勿在onReceive等回调函数中创建原子数，否则底层的GlobalMemory内存会持续增长，造成内存泄漏。\n使用\n初始化计数：\n\nint init_value 初始值\n\npublic function __construct($init_value)\n增加计数：\n\nint add_value 增加的值\n\npublic function add($add_value)\n减少计数：\n\nint sub_value 减少的值\n\npublic function sub($sub_value)\n获取当前计数的值：\npublic function get()\n将当前值设置为指定的数字：\n\nint value 计数值\n\npublic function set($value)\n如果当前数值等于参数1，则将当前数值设置为参数2：\n\nint cmp_value  被做比较的值\nint set_value  当前数值等于被做比较的值后被设置为指定的计数值\n\npublic function cmpset($cmp_value, $set_value)\n例子\n在EasySwooleEvent初始化函数注册atomic对象。\n// 注册一个atomic对象\nAtomicManager::getInstance()-&gt;add('second');\n从AtomicManager获取atomic对象并使用。\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/3/18 0018\n * Time: 15:39\n */\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Component\\AtomicManager;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    function index()\n    {\n\n        AtomicManager::getInstance()-&gt;add('second',0);\n        $atomic = AtomicManager::getInstance()-&gt;get('second');\n        $atomic-&gt;add(1);\n        $this-&gt;response()-&gt;write($atomic-&gt;get());\n        // TODO: Implement index() method.\n    }\n}","link":"/Components/Component/atomic.html"},{"id":197,"title":"channel lock协程锁","content":"channel Lock\n命名空间:\\EasySwoole\\Component\\ChannelLock.\nChannelLock 通过协程channel特性实现了关于协程级的锁机制.  \ngo(function (){\n    //加锁\n    $result = \\EasySwoole\\Component\\ChannelLock::getInstance()-&gt;lock('a');\n    var_dump($result);\n    co::sleep(1);\n    //解锁\n    $result = \\EasySwoole\\Component\\ChannelLock::getInstance()-&gt;unlock('a');\n    var_dump($result);\n});\nlock\n尝试锁住$lockName.\n方法原型:  function lock(string $lockName,float $timeout = -1):bool\n参数介绍:  \n\n$lockName 锁名\n$timeout 超时时间,-1为永久不超时\n当调用此函数后,会尝试锁住$lockName,成功将返回true,如果之前已经有其他协程锁住了此$lockName,将会阻塞,直到超时返回false(-1用不超时,代表永远阻塞)  \n\nunlock\n解锁\n方法原型:  function unlock(string $lockName,float $timeout = -1):bool\n参数介绍:  \n\n$lockName 锁名\n$timeout 超时时间,-1为永久不超时\n解锁$lockName. 成功后将返回true.  \n\ndeferLock\n尝试锁住$lockName,并在协程结束后自动解锁.\n方法原型:  deferLock(string $lockName,float $timeout = -1):bool\n参数介绍:  \n\n$lockName 锁名\n$timeout 超时时间,-1为永久不超时\n","link":"/Components/Component/channelLock.html"},{"id":198,"title":"安装和使用","content":"ElasticSearch 协程客户端组件\n协程版 ElasticSearch Client，对官方客户端的协程化移植\n组件要求\n\neasyswoole/spl: ^1.3\neasyswoole/http-client: ^1.3\neasyswoole/swoole-ide-helper: ^1.3\n\n安装方法\n\ncomposer require easyswoole/elasticsearch\n\n仓库地址\neasyswoole/elasticsearch\nClient 用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Search();\n    $bean-&gt;setIndex('my_index');\n    $bean-&gt;setType('my_type');\n    $bean-&gt;setBody(['query' =&gt; ['matchAll' =&gt; []]]);\n    $response = $elasticsearch-&gt;client()-&gt;search($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\nx-pack 验证\n当 elasticsearch 开启 x-pack 登录验证时，只需在 config 中再传入用户名密码即可\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'     =&gt; '127.0.0.1',\n    'port'     =&gt; 9200,\n    'username' =&gt; 'elastic',\n    'password' =&gt; '123456'\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n修改 http 为 https\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'     =&gt; '127.0.0.1',\n    'port'     =&gt; 9200,\n    'username' =&gt; 'elastic',\n    'password' =&gt; '123456',\n    'scheme'   =&gt; 'https'\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);","link":"/Components/ElasticSearch/install.html"},{"id":199,"title":"插入","content":"ElasticSearch 协程客户端 - 插入文档\n单条插入文档用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Create();\n    $bean-&gt;setIndex('my_index');\n    $bean-&gt;setType('my_type');\n    $bean-&gt;setId('my_id');\n    $bean-&gt;setBody(['test_field' =&gt; 'test_data']);\n    $response = $elasticsearch-&gt;client()-&gt;create($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response['result']);\n});\n批量插入文档用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Bulk();\n    $bean-&gt;setIndex('my_index');\n    $bean-&gt;setType('my_type');\n\n    $body = [];\n    for ($i = 1; $i &lt;= 5; $i++) {\n        $body[] = [\n            'create' =&gt; [\n                '_index' =&gt; 'my-index',\n                '_type' =&gt; 'my-type',\n                '_id' =&gt; $i * 1000\n            ]\n        ];\n        $body[] = [\n            'test-field' =&gt; 'test-data',\n        ];\n    }\n\n    $bean-&gt;setBody($body);\n    $response = $elasticsearch-&gt;client()-&gt;bulk($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});","link":"/Components/ElasticSearch/create.html"},{"id":200,"title":"删除","content":"ElasticSearch 协程客户端 - 删除文档\n根据 id 删除文档用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Delete();\n    $time = time();\n    $bean-&gt;setIndex('my-index-' . $time);\n    $bean-&gt;setId('my-id-' . $time);\n    $response = $elasticsearch-&gt;client()-&gt;delete($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});\n根据 query 删除文档用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\DeleteByQuery();\n    $time = time();\n    $bean-&gt;setIndex('my-index-' . $time);\n    $bean-&gt;setBody([\n        'query' =&gt; [\n            'match' =&gt; ['name' =&gt; '测试删除']\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;deleteByQuery($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});","link":"/Components/ElasticSearch/delete.html"},{"id":201,"title":"修改","content":"ElasticSearch 协程客户端 - 修改文档\n根据 id 修改文档用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Update();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setId('my-id');\n    $bean-&gt;setBody([\n        'doc' =&gt; [\n            'test-field' =&gt; 'abd'\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;update($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});\n根据 query 修改文档用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\UpdateByQuery();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setBody([\n        'query' =&gt; [\n            'match' =&gt; ['test-field' =&gt; 'abd']\n        ],\n        'script' =&gt; [\n            'source' =&gt; 'ctx._source[\"test-field\"]=\"testing\"'\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;updateByQuery($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});\nReindex 用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Reindex();\n    $bean-&gt;setBody([\n        'source' =&gt; [\n            'index' =&gt; 'my-index'\n        ],\n        'dest' =&gt; [\n            'index' =&gt; 'my-index-new'\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;reindex($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});","link":"/Components/ElasticSearch/update.html"},{"id":202,"title":"查询","content":"ElasticSearch 协程客户端 - 查询文档\n查询\n根据 文档ID 查询 document 用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Get();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setId('my-id');\n    $response = $elasticsearch-&gt;client()-&gt;get($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\n根据 文档ID 批量查询 document 用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Mget();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setBody(['ids' =&gt; ['my-id', '1']]);\n    $response = $elasticsearch-&gt;client()-&gt;mget($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\n根据 文档ID 查询 source 用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Get();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setId('my-id');\n    $response = $response = $elasticsearch-&gt;client()-&gt;getSource($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\nquery 查询用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Search();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setBody(['query' =&gt; ['match' =&gt; ['test-field' =&gt; 'ab']]]);\n    $response = $elasticsearch-&gt;client()-&gt;search($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\n查询总数用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Count();\n    $response = $elasticsearch-&gt;client()-&gt;count($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response['count']);\n});\nscroll 分页查询用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $sBean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Search();\n    $sBean-&gt;setIndex('my-index');\n    $sBean-&gt;setScroll('1m');\n    $sBean-&gt;setBody([\n        'query' =&gt; [\n            'match' =&gt; [\n                'test-field' =&gt; 'abd'\n            ]\n        ],\n        'sort' =&gt; ['_doc'],\n        'size' =&gt; 1\n    ]);\n    $sResponse = $elasticsearch-&gt;client()-&gt;search($sBean)-&gt;getBody();\n    $sResponse = json_decode($sResponse, true);\n\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Scroll();\n    $bean-&gt;setScrollId($sResponse['_scroll_id']);\n    $bean-&gt;setScroll('1m');\n    $response = $elasticsearch-&gt;client()-&gt;scroll($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\ntemplate 查询用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\SearchTemplate();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setBody([\n        'inline' =&gt;\n            [\n                'query' =&gt;\n                    [\n                        'match' =&gt; [\"{{field}}\" =&gt; \"{{value}}\"]\n                    ]\n            ],\n        'params' =&gt;\n            [\n                'field' =&gt; 'test-field',\n                'value' =&gt; '博客'\n            ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;searchTemplate($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\ntermVectors 用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\TermVectors();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setId('my-id');\n    $bean-&gt;setPretty(true);\n    $bean-&gt;setBody([\n        'fields' =&gt; ['test-field'],\n        'offsets' =&gt; true,\n        'payloads' =&gt; true,\n        'positions' =&gt; true,\n        \"term_statistics\" =&gt; true,\n        \"field_statistics\" =&gt; true\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;termvectors($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\n分片信息查询用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\SearchShards();\n    $bean-&gt;setIndex('my-index');\n    $response = $elasticsearch-&gt;client()-&gt;searchShards($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});\n节点状态获取用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Info();\n    $response = $elasticsearch-&gt;client()-&gt;info($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});","link":"/Components/ElasticSearch/search.html"},{"id":203,"title":"分析","content":"ElasticSearch 协程客户端 - 分析文档\n分析\nfield 分析用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\FieldCaps();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setFields('test-field');\n\n    $response = $elasticsearch-&gt;client()-&gt;fieldCaps($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});\nquery 分析用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Explain();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setId('my-id');\n    $bean-&gt;setBody([\n        'query' =&gt; [\n            'bool' =&gt; [\n                'must' =&gt; [\n                    ['match' =&gt;\n                        [\n                            'test-field' =&gt; 'abd'\n                        ]\n                    ]\n                ]\n\n            ]\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;explain($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});","link":"/Components/ElasticSearch/analysis.html"},{"id":204,"title":"splarray","content":"SplArray\n用于处理数组封装的基础工具\n相关class位置\n\nSplArray\n\n\nnamespace: EasySwoole\\Spl\\SplArray\n\n\n\n\nSplArray相关方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nset\n$key,$value\n设置参数\n\n\n\nget\n$key\n获取参数\n\n\n\n__toString\n\n转字符\n\n\n\ngetArrayCopy\n\n数组赋值\n\n\n\nunset\n$key\n销毁数组元素\n\n\n\ndelete\n$key\n去除某个数据项\n\n\n\nunique\n\n数组值唯一\n\n\n\nmultiple\n\n获取数组中重复的值\n\n\n\nasort\n\n进行排序并保持索引关系\n\n\n\nksort\n\n按照键名排序\n\n\n\nsort\n$sort_flags = SORT_REGULAR\n自定义排序\n\n\n\ncolumn\n$key\n取得某一列\n\n\n\nflip\n\n交换数组中的键和值\n\n\n\nfilter\n$key,[$key2....],$bool\n过滤数组数据\n\n\n\nkeys\n$key\n获取数组索引\n\n\n\nvalues\n\n获取数组中所有的值\n\n\n\nflush\n\n清空数据\n\n\n\nloadArray\n$data\n重新加载数据\n\n\n\ntoXML\n\n转化成xml\n\n\n\n\n基本使用\n/**\n *\n * User: LuffyQAQ\n * Date: 2019/10/16 16:02\n * Email: &lt;1769360227@qq.com&gt;\n */\ninclude \"./vendor/autoload.php\";\n\n$data = [\n    'fruit' =&gt; [\n        'apple' =&gt; 2,\n        'orange' =&gt; 1,\n        'grape' =&gt; 4\n    ],\n    'color' =&gt; [\n        'red' =&gt; 12,\n        'blue' =&gt; 8,\n        'green' =&gt; 6\n    ],\n    'name' =&gt; [\n        'name1' =&gt; '北溟有鱼QAQ',\n        'name2' =&gt; '北溟有鱼QAQ'\n    ]\n];\n$splArray = new \\EasySwoole\\Spl\\SplArray($data);\n\n$splArray-&gt;set('fruit.apple', 3);\n\nvar_dump($splArray);\n\nvar_dump($splArray-&gt;get('fruit.apple'));\n\nvar_dump($splArray-&gt;__toString());\n\nvar_dump($splArray-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;unset('color'));\n\nvar_dump($splArray-&gt;delete('fruit.apple'));\n\nvar_dump($splArray-&gt;unique()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;multiple()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;asort()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;ksort()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;sort()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;column('name')-&gt;getArrayCopy());\n\n$splArrays = new \\EasySwoole\\Spl\\SplArray(['es' =&gt; 'easyswoole']);\n\nvar_dump($splArrays-&gt;flip()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;filter('green,grape', false)-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;filter('green,grape', true)-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;keys('name'));\n\nvar_dump($splArray-&gt;values()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;flush()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;loadArray(['name' =&gt; 'easyswoole'])-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;toXML());\n","link":"/Components/Spl/splArray.html"},{"id":205,"title":"splbean","content":"SplBean\n用于定义表结构，过滤掉无效字段数据。\n相关class位置\n\nSplBean\n\n\nnamespace: EasySwoole\\Spl\\SplBean\n\n\n\n\nSplBean相关方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\n__construct\narray $data = null,$autoCreateProperty = false\n构造函数，初始化bean数据\n\n\n\nallProperty\n\n过滤并转换成数组数据\n\n\n\ntoArray\narray $columns = null,$filter = null\n转字符\n\n\n\ntoArrayWithMapping\narray $columns = null,$filter = null\n获取过滤后带有字段别名的数组数据\n\n\n\narrayToBean\narray $data,$autoCreateProperty = false\n设置类属性\n\n\n\naddProperty\n$name,$value = null\n设置类成员变量\n\n\n\ngetProperty\n$name\n获取类成员变量值\n\n\n\njsonSerialize\n\n获取类成员变量集合\n\n\n\ninitialize\n\n初始化操作\n\n\n\nsetKeyMapping\n\n设置keyMapping关系，也就是字段别名\n\n\n\nsetClassMapping\n\n设置classMapping关系，也就是关联类\n\n\n\nrestore\narray $data = [], $autoCreateProperty = false\n重新初始化bean数据\n\n\n\nclassMap\n\n绑定关联类\n\n\n\n\n基本使用\n\n/**\n *\n * User: LuffyQAQ\n * Date: 2019/10/16 16:45\n * Email: &lt;1769360227@qq.com&gt;\n */\ninclude \"./vendor/autoload.php\";\nuse EasySwoole\\Spl\\SplBean;\n\nclass TestBean extends SplBean\n{\n    public $a = 2;\n    protected $b;\n    private $c;\n    protected $d_d;\n\n    protected function setKeyMapping(): array\n    {\n        return [\n            'd-d' =&gt; \"d_d\"\n        ];\n    }\n}\n\n$bean = new TestBean([\n    'a'=&gt;'a',\n    'b'=&gt;'b',\n    'c'=&gt;'c',\n    'd_d'=&gt;'d_d'\n]);\n\nvar_dump($bean-&gt;allProperty());\n\n$data = $bean-&gt;toArray(null, function ($a) {\n    if (in_array($a, ['d_d'])) {\n        return $a;\n    }\n});\n\n$bean = new TestBean([\n    'a'=&gt;1,\n    'b'=&gt;2,\n    'c'=&gt;3,\n    'd_d'=&gt;4\n]);\n$data = $bean-&gt;toArrayWithMapping(['a', 'b', 'd-d'], function ($val) {\n    return $val;\n});\n\nvar_dump($data);\n\nvar_dump($bean-&gt;toArrayWithMapping(['a','d-d']));\n\n$bean = new TestBean();\n$bean-&gt;addProperty('a', 'es');\n$bean-&gt;addProperty('b', 'es');\n$bean-&gt;addProperty('d_d', 'es');\n\nvar_dump($bean-&gt;toArray());\n\nvar_dump($bean-&gt;getProperty('a'));\n\nvar_dump( $bean-&gt;jsonSerialize());\n\nvar_dump($bean-&gt;restore()-&gt;toArray());\n","link":"/Components/Spl/splBean.html"},{"id":206,"title":"splenum","content":"SplEnum\n用于定义枚举一个集合，规范化枚举数据。\n相关class位置\n\nSplEnum\n\n\nnamespace: EasySwoole\\Spl\\SplEnum\n\n\n\n\nSplEnum相关方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\n__construct\n$val\n构造函数\n\n\n\ngetName\n\n获取定义常量的键\n\n\n\ngetValue\n\n获取定义常量\n\n\n\nisValidName\nstring $name\n查找常量的键值是否有效\n\n\n\nisValidValue\n$val\n查找常量的值是否有效\n\n\n\ngetEnumList\n\n获取枚举集合\n\n\n\ngetConstants\n\n获取枚举集合\n\n\n\n\n基本使用\n/**\n *\n * User: luffyQAQ\n * Date: 2019/10/16 17:08\n * Email: &lt;1769360227@qq.com&gt;\n */\n\ninclude \"./vendor/autoload.php\";\n\nclass Month extends \\EasySwoole\\Spl\\SplEnum {\n    const JANUARY = 1;\n    const FEBRUARY = 2;\n    const MARCH = 3;\n    const APRIL = 4;\n    const MAY = 5;\n    const JUNE = 6;\n    const JULY = 7;\n    const AUGUST = 8;\n    const SEPTEMBER = 9;\n    const OCTOBER = 10;\n    const NOVEMBER = 11;\n    const DECEMBER = 12;\n}\n$month = new Month(1);\n\nvar_dump($month-&gt;getName());\n\nvar_dump($month-&gt;getValue());\n\nvar_dump(Month::isValidName('JANUARY'));\n\nvar_dump(Month::isValidValue(1));\n\nvar_dump( Month::getEnumList());\n","link":"/Components/Spl/splEnum.html"},{"id":207,"title":"splstream","content":"SplStream\n资源流数据操作\n相关class位置\n\nSplStream\n\n\nnamespace: EasySwoole\\Spl\\SplStream\n\n\n\n\nSplStream相关方法\n\n\n\n方法名称\n参数\n说明\n\n\n\n\n__construct\n$resource = '',$mode = 'r+'\n初始化资源和读写操作\n\n\n__toString\n\n输出资源\n\n\nclose\n\n关闭一个打开的文件指针\n\n\ndetach\n\n获取资源并重置资源对象\n\n\ngetSize\n获取资源大小\n编码转换\n\n\ntell\n\n返回文件指针读/写的位置\n\n\neof\n\n文件指针是否到了文件结束的位置\n\n\nisSeekable\n\n获取是否可以在当前流中定位\n\n\nseek\n$offset, $whence = SEEK_SET\n在文件指针中定位\n\n\nrewind\n\n倒回文件指针的位置\n\n\nisWritable\n\n是否可写\n\n\nwrite\n$string\n写入内容\n\n\nisReadable\n\n是否可读\n\n\nread\n$length\n读取内容\n\n\nlength\n\n获取字符串长度\n\n\ngetContents\n\n读取资源流到一个字符串\n\n\ngetMetadata\n$key = null\n从封装协议文件指针中取得报头／元数据\n\n\ngetStreamResource\n\n获取资源\n\n\ntruncate\n$size = 0\n将文件截断到给定的长度\n\n\n\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 上午10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n//初始化资源和读写操作\n$resource = fopen('./test.txt', 'ab+');\n$stream = new \\EasySwoole\\Spl\\SplStream($resource);\nvar_dump($stream-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(10) \"Easyswoole\"\n */\n\n//输出资源\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\nvar_dump($stream-&gt;__toString());\n/**\n * 输出结果过：\n * string(10) \"Easyswoole\"\n */\n\n//关闭一个打开的文件指针\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;close();\nvar_dump($stream-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(0) \"\"\n */\n\n//获取资源并重置资源对象\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;detach();\nvar_dump($stream-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(0) \"\"\n */\n\n//获取资源大小\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$size = $stream-&gt;getSize();\nvar_dump($size);\n\n/**\n * 输出结果过：\n * int(10)\n */\n\n//返回文件指针读/写的位置\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$position = $stream-&gt;tell();\nvar_dump($position);\n\n/**\n * 输出结果过：\n * int(10)\n */\n\n//文件指针是否到了文件结束的位置\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$eof = $stream-&gt;eof();\nvar_dump($eof);\n$stream-&gt;detach();\n$eof = $stream-&gt;eof();\nvar_dump($eof);\n\n/**\n * 输出结果过：\n * bool(false)\n * bool(true)\n */\n\n//获取是否可以在当前流中定位\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$seekable = $stream-&gt;isSeekable();\nvar_dump($seekable);\n\n/**\n * 输出结果过：\n * bool(true)\n */\n\n//在文件指针中定位\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;seek(2);\n$position = $stream-&gt;tell();\nvar_dump($position);\n\n/**\n * 输出结果过：\n * int(2)\n */\n\n//倒回文件指针的位置\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;rewind();\n$position = $stream-&gt;tell();\nvar_dump($position);\n\n/**\n * 输出结果过：\n * int(0)\n */\n\n//是否可写\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$writeAble = $stream-&gt;isWritable();\nvar_dump($writeAble);\n\n/**\n * 输出结果过：\n * bool(true)\n */\n\n//写入内容\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;write(', 666');\nvar_dump($stream-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(15) \"Easyswoole, 666\"\n */\n\n//是否可读\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$readAble = $stream-&gt;isReadable();\nvar_dump($readAble);\n\n/**\n * 输出结果过：\n * bool(true)\n */\n\n//读取内容\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;rewind();\n$string = $stream-&gt;read(4);\nvar_dump($string);\n\n/**\n * 输出结果过：\n * string(4) \"Easy\"\n */\n\n//读取资源流到一个字符串\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;rewind();\n$string = $stream-&gt;getContents();\nvar_dump($string);\n\n/**\n * 输出结果过：\n * string(10) \"Easyswoole\"\n */\n\n//从封装协议文件指针中取得报头／元数据\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$meta = $stream-&gt;getMetadata();\nvar_dump($meta['stream_type']);\n\n/**\n * 输出结果过：\n * string(6) \"MEMORY\"\n */\n\n//获取资源\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$resource = $stream-&gt;getStreamResource();\nfseek($resource, 0, SEEK_SET);\nvar_dump(stream_get_contents($resource));\n\n/**\n * 输出结果过：\n * string(10) \"Easyswoole\"\n */\n\n//将文件截断到给定的长度\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;truncate(4);\nvar_dump($stream-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"Easy\"\n */\n\nps: 资源和资源流是有区别的,这里说的资源也就是数据或是变量,资源流是一种文件流。","link":"/Components/Spl/splStream.html"},{"id":208,"title":"splfilestream","content":"SplFileStream\n文件资源流数据操作\n相关class位置\n\nSplFileStream\n\n\nnamespace: EasySwoole\\Spl\\SplFileStream\n\n\n\n\nSplFileStream相关方法\n\n\n\n方法名称\n参数\n说明\n\n\n\n\n__construct\n$file,$mode = 'c+'\n初始化资源和读写操作\n\n\nlock\n$mode = LOCK_EX\n文件锁定\n\n\nunlock\n$mode = LOCK_UN\n释放锁定\n\n\n\nSplFileStream类继承SplStream，其他相关方法参考SplStream。\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 上午10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$fileStream = new \\EasySwoole\\Spl\\SplFileStream('./test.txt');\n$type = $fileStream-&gt;getMetadata('stream_type');\nvar_dump($type);\n\n/**\n * 输出结果过：\n * string(5) \"STDIO\"\n */\n\n$fileStream = new \\EasySwoole\\Spl\\SplFileStream('./test.txt');\n$lock = $fileStream-&gt;lock();\nvar_dump($lock);\n\n/**\n * 输出结果过：\n * bool(true)\n */\n\n$fileStream = new \\EasySwoole\\Spl\\SplFileStream('./test.txt');\n$unlock = $fileStream-&gt;unlock();\nvar_dump($unlock);\n\n/**\n * 输出结果过：\n * bool(true)\n */\n","link":"/Components/Spl/splFileStream.html"},{"id":209,"title":"splstring","content":"SplString\n用于处理字符串。\n相关class位置\n\nSplString\n\n\nnamespace: EasySwoole\\Spl\\SplString\n\n\n\n\nSplString相关方法\n\n\n\n方法名称\n参数\n说明\n\n\n\n\nsetString\nstring $string\n设置字符串\n\n\nsplit\nint $length = 1\n按长度分割字符串\n\n\nexplode\nstring $delimiter\n按分隔符分割字符串\n\n\nsubString\nint $start, int $length\n截取字符串\n\n\nencodingConvert\nstring $desEncoding, $detectList = ['UTF-8', 'ASCII', 'GBK',...]\n编码转换\n\n\nutf8\n\n转成utf\n\n\nunicodeToUtf8\n\n将unicode编码转成utf-8\n\n\ntoUnicode\n\n转成unicode编码(秒)\n\n\ncompare\nstring $str, int $ignoreCase = 0\n二进制字符串比较\n\n\nlTrim\nstring $charList = &quot; \\t\\n\\r\\0\\x0B&quot;\n删除字符串开头的空白字符（或其他字符）\n\n\nrTrim\nstring $charList = &quot; \\t\\n\\r\\0\\x0B&quot;\n删除字符串末端的空白字符（或者其他字符）\n\n\ntrim\nstring $charList = &quot; \\t\\n\\r\\0\\x0B&quot;\n去除字符串首尾处的空白字符（或者其他字符）\n\n\npad\nint $length, string $padString = null, int $pad_type = STR_PAD_RIGHT\n使用另一个字符串填充字符串为指定长度\n\n\nrepeat\nint $times\n重复一个字符串\n\n\nlength\n\n获取字符串长度\n\n\nupper\n\n将字符串转化为大写\n\n\nlower\n\n将字符串转化为小写\n\n\nstripTags\nstring $allowable_tags = null\n从字符串中去除 HTML 和 PHP 标记1\n\n\nreplace\nstring $find, string $replaceTo\n子字符串替换\n\n\nbetween\nstring $startStr, string $endStr\n获取指定目标的中间字符串\n\n\nregex\n$regex, bool $rawReturn = false\n按照正则规则查找字符串\n\n\nexist\nstring $find, bool $ignoreCase = true\n是否存在指定字符串\n\n\nkebab\n\n转换为烤串\n\n\nsnake\nstring $delimiter = '_'\n转为蛇的样子\n\n\nstudly\n\n驼峰\n\n\ncamel\n\n小驼峰\n\n\nreplaceArray\nstring $search, array $replace\n依次替换字符串\n\n\nreplaceFirst\nstring $search, string $replace\n替换字符串中给定值的第一次出现\n\n\nreplaceLast\nstring $search, string $replace\n替换字符串中给定值的最后一次出现\n\n\nstart\nstring $prefix\n以一个给定值的单一实例开始一个字符串\n\n\nafter\nstring $search\n在给定的值之后返回字符串的其余部分\n\n\nbefore\nstring $search\n在给定的值之前获取字符串的一部分\n\n\nendsWith\n$needles\n确定给定的字符串是否以给定的子字符串结束\n\n\nstartsWith\n$needles\n确定给定的字符串是否从给定的子字符串开始\n\n\n\n基础使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 上午10:10\n */\n\nrequire './vendor/autoload.php';\n\n//设置字符串\n$string = new \\EasySwoole\\Spl\\SplString();\nvar_dump($string-&gt;setString('Hello, EasySwoole')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(17) \"Hello, EasySwoole\"\n */\n\n//设置数组中某项的值\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;split(5)-&gt;getArrayCopy());\n\n/**\n * 输出结果过：\n * array(4) {\n *   [0]=&gt;\n *   string(5) \"Hello\"\n *   [1]=&gt;\n *   string(5) \", Eas\"\n *   [2]=&gt;\n *   string(5) \"ySwoo\"\n *   [3]=&gt;\n *   string(2) \"le\"\n * }\n */\n\n//分割字符串\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;explode(',')-&gt;getArrayCopy());\n\n/**\n * 输出结果过：\n * array(2) {\n *   [0]=&gt;\n *   string(5) \"Hello\"\n *   [1]=&gt;\n *   string(11) \" EasySwoole\"\n * }\n */\n\n//截取字符串\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;subString(0, 5)-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(5) \"Hello\"\n */\n\n//编码转换\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;encodingConvert('UTF-8')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(17) \"Hello, EasySwoole\"\n }\n\n */\n\n//转成utf-8\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;utf8()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(17) \"Hello, EasySwoole\"\n }\n\n */\n\n//将unicode编码转成utf-8\n$str = '\\u4e2d';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;unicodeToUtf8()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(3) \"中\"\n */\n\n//转成unicode编码\n$str = '中';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;toUnicode()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(6) \"\\U4E2D\"\n */\n\n//二进制字符串比较\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;compare('apple'));\n\n/**\n * 输出结果过：\n * int(19)\n */\n\n//删除字符串开头的空白字符（或其他字符）\n$str = '  test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;lTrim()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"test\"\n */\n\n//删除字符串末端的空白字符（或者其他字符）\n$str = 'test  ';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;rTrim()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"test\"\n */\n\n//去除字符串首尾处的空白字符（或者其他字符）\n$str = '  test  ';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;trim()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"test\"\n */\n\n//使用另一个字符串填充字符串为指定长度\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;pad(5, 'game')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(5) \"testg\"\n */\n\n//重复一个字符串\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;repeat(2)-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(8) \"testtest\"\n */\n\n//获取字符串长度\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;length());\n\n/**\n * 输出结果过：\n * int(4)\n */\n\n//将字符串转化为大写\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;upper()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"TEST\"\n */\n\n//将字符串转化为小写\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;lower()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"test\"\n */\n\n//从字符串中去除 HTML 和 PHP 标记\n$str = '&lt;a&gt;test&lt;/a&gt;';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;stripTags()-&gt;__toString());\n\n/**\n* 输出结果过：\n * string(4) \"test\"\n */\n\n//字符串替换\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;replace('t', 's')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"sess\"\n */\n\n//获取指定目标的中间字符串\n$str = 'easyswoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;between('easy', 'le')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"swoo\"\n */\n\n//按照正则规则查找字符串\n$str = 'easyswoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;regex('/swoole/'));\n\n/**\n * 输出结果过：\n * string(6) \"swoole\"\n */\n\n//是否存在指定字符串\n$str = 'easyswoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;exist('Swoole', true));\n\n/**\n * 输出结果过：\n * bool(true)\n */\n\n//转换为-连接的字符串\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;kebab()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(11) \"easy-swoole\"\n */\n\n//转为蛇的样子\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;snake()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(11) \"easy_swoole\"\n */\n\n//转换为驼峰\n$str = 'easy_swoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;studly()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(10) \"EasySwoole\"\n */\n\n//转换为小驼峰\n$str = 'easy_swoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;camel()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(10) \"easySwoole\"\n */\n\n//给数组每个元素替换字符串\n$str = 'easy_swoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;replaceArray('easy', ['as', 'bs', 'cs'])-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(9) \"as_swoole\"\n */\n\n//替换字符串中给定值的第一次出现\n$str = 'easy_swoole_easy';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;replaceFirst('easy', 'as')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(14) \"as_swoole_easy\"\n */\n\n//替换字符串中给定值的最后一次出现\n$str = 'easy_swoole_easy';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;replaceLast('easy', 'as')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(14) \"easy_swoole_as\"\n */\n\n//以一个给定值的单一实例开始一个字符串\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;start('Hello,')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(16) \"Hello,EasySwoole\"\n */\n\n//在给定的值之后返回字符串的其余部分\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;after('Easy')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(6) \"Swoole\"\n */\n\n//在给定的值之前获取字符串的一部分\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;before('Swoole')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"Easy\"\n */\n\n//确定给定的字符串是否以给定的子字符串结束\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;endsWith('Swoole'));\n\n/**\n * 输出结果过：\n * bool(true)\n */\n\n//确定给定的字符串是否从给定的子字符串开始\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;startsWith('Easy'));\n\n/**\n * 输出结果过：\n * bool(true)\n */\n","link":"/Components/Spl/splString.html"},{"id":210,"title":"连接池","content":"通用连接池\nEasySwoole通用的协程连接池管理。\n组件要求\n\nphp: &gt;=7.1.0\next-json: *\neasyswoole/component: ^2.2.1\neasyswoole/spl: ^1.3\neasyswoole/utility: ^1.1\n\n安装方法\n\ncomposer require easyswoole/pool\n\n仓库地址\neasyswoole/pool\n池配置\n在实例化一个连接池对象时,需要传入一个连接池配置对象EasySwoole\\Pool\\Config,该对象的属性如下:\n\n\n\n配置项\n默认值\n说明\n备注\n\n\n\n\n$intervalCheckTime\n30*1000\n定时器执行频率\n用于定时执行连接池对象回收,创建操作\n\n\n$maxIdleTime\n15\n连接池对象最大闲置时间(秒)\n超过这个时间未使用的对象将会被定时器回收\n\n\n$maxObjectNum\n20\n连接池最大数量\n每个进程最多会创建$maxObjectNum连接池对象,如果对象都在使用,则会返回空,或者等待连接空闲\n\n\n$minObjectNum\n5\n连接池最小数量(热启动)\n当连接池对象总数低于$minObjectNum时,会自动创建连接,保持连接的活跃性,让控制器能够尽快的获取连接\n\n\n$getObjectTimeout\n3.0\n获取连接池的超时时间\n当连接池为空时,会等待$getObjectTimeout秒,如果期间有连接空闲,则会返回连接对象,否则返回null\n\n\n$extraConf\n\n额外配置信息\n在实例化连接池前,可把一些额外配置放到这里,例如数据库配置信息,redis配置等等\n\n\n$loadAverageTime\n0.001\n负载阈值\n并发来临时，连接池内对象达到 maxObejctNum，此时并未达到 intervaklCheckTime 周期检测，因此设定一个 5s 负载检测，当 5s 内，取出总时间/取出连接总次数，会得到一个平均取出时间，如果小于此阈值，说明此次并发峰值非持续性，将回收 5% 的连接\n\n\n\n池管理器\n池管理器可以做全局的连接池管理,例如在EasySwooleEvent.php中的initialize中注册,然后可以在控制器中获取连接池进行获取连接:\npublic static function initialize()\n{\n    // TODO: Implement initialize() method.\n    date_default_timezone_set('Asia/Shanghai');\n\n    $config = new \\EasySwoole\\Pool\\Config();\n\n    $redisConfig1 = new \\EasySwoole\\Redis\\Config\\RedisConfig(Config::getInstance()-&gt;getConf('REDIS1'));\n    $redisConfig2 = new \\EasySwoole\\Redis\\Config\\RedisConfig(Config::getInstance()-&gt;getConf('REDIS2'));\n    //注册连接池管理对象\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\RedisPool($config,$redisConfig1),'redis1');\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\RedisPool($config,$redisConfig2),'redis2');\n\n}\n控制器获取连接池连接:\npublic function index()\n{\n    //取出连接池管理对象,并getObj\n\n    $redis1=\\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis1')-&gt;getObj();\n    $redis2=\\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis1')-&gt;getObj();\n\n    $redis1-&gt;set('name','仙士可');\n    var_dump($redis1-&gt;get('name'));\n\n    $redis2-&gt;set('name','仙士可2号');\n    var_dump($redis2-&gt;get('name'));\n\n    //回收对象\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis1')-&gt;recycleObj($redis1);\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis2')-&gt;recycleObj($redis2);\n}\n池对象方法\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\ncreateObject\n\n抽象方法,创建连接对象\n\n\n\nrecycleObj\n$obj\n回收一个连接\n\n\n\ngetObj\nfloat $timeout = null, int $tryTimes = 3\n获取一个连接,超时时间$timeout,尝试获取$tryTimes次\n\n\n\nunsetObj\n$obj\n直接释放一个连接\n\n\n\nidleCheck\nint $idleTime\n回收超过$idleTime未出队使用的连接\n\n\n\nitemIntervalCheck\nObjectInterface $item\n判断当前客户端是否还可用\n\n\n\nintervalCheck\n\n回收连接,以及热启动方法,允许外部调用热启动\n\n\n\nkeepMin\n?int $num = null\n保持最小连接(热启动)\n\n\n\ngetConfig\n\n获取连接池的配置信息\n\n\n\nstatus\n\n获取连接池状态信息\n获取当前连接池已创建,已使用,最大创建,最小创建数据\n\n\nisPoolObject\n$obj\n查看$obj对象是否由该连接池创建\n\n\n\nisInPool\n$obj\n获取当前连接是否在连接池内未使用\n\n\n\ndestroyPool\n\n销毁该连接池\n\n\n\nreset\n\n重置该连接池\n\n\n\ninvoke\ncallable $call,float $timeout = null\n获取一个连接,传入到$call回调函数中进行处理,回调结束后自动回收连接\n\n\n\ndefer\nfloat $timeout = null\n获取一个连接,协程结束后自动回收\n\n\n\n\ngetObj\n获取一个连接池的对象:\ngo(function (){\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    $redis = $redisPool-&gt;getObj();\n    var_dump($redis-&gt;echo('仙士可'));\n    $redisPool-&gt;recycleObj($redis);\n});\n通过getObj方法获取的对象,都必须调用unsetObj或者recycleObj进行回收,否则连接池对象会越来越少\nunsetObj\n直接释放一个连接池对象,其他协程不能再获取这个连接,而是会重新创建一个连接\n释放之后,并不会立即销毁该对象,而是会在作用域结束之后销毁\nrecycleObj\n回收一个连接对象,回收之后,其他协程可以正常获取这个连接.\n回收之后,其他协程可以正常获取这个连接,但在此时,该连接还处于当前协程中,如果再次调用该连接进行数据操作,将会协程混乱,所以需要开发人员自行约束,当recycleObj不能再操作这个对象\ninvoke\n获取一个连接,传入到$call回调函数中进行处理,回调结束后自动回收连接:\ngo(function (){\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    $redisPool-&gt;invoke(function (\\EasySwoole\\Redis\\Redis $redis){\n        var_dump($redis-&gt;echo('仙士可'));\n    });\n});\n\n通过该方法无需手动回收连接,在回调函数结束后,则自动回收\ndefer\n获取一个连接,协程结束后自动回收\ngo(function () {\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    $redis = $redisPool-&gt;defer();\n    var_dump($redis-&gt;echo('仙士可'));\n});\n通过该方法无需手动回收连接,在协程结束后,则自动回收\n需要注意的事,defer方法是协程结束后才回收,如果你当前协程运行时间过长,则会一直无法回收,直到协程结束\nkeepMin\n保持最小连接(热启动)\n由于easyswoole/pool的\n当一启动服务,出现过大的并发时,可能会突然需要几十上百个连接,这个时候为了使创建连接的时间分散,可以通过调用keepMin进行预热启动连接\n调用此方法后,将会预先创建n个连接,用于服务启动之后的控制器直接获取连接:\n在EasySwooleEvent.php中的mainServerCreate中,当worker进程启动后,热启动连接\n\npublic static function mainServerCreate(EventRegister $register)\n{\n    $register-&gt;add($register::onWorkerStart,function (\\swoole_server $server,int $workerId){\n        if ($server-&gt;taskworker == false) {\n            //每个worker进程都预创建连接\n            \\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis')-&gt;keepMin(10);\n            var_dump(\\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis')-&gt;status());\n        }\n    });\n\n    // TODO: Implement mainServerCreate() method.\n}\n将会输出:\narray(4) {\n  [\"created\"]=&gt;\n  int(10)\n  [\"inuse\"]=&gt;\n  int(0)\n  [\"max\"]=&gt;\n  int(20)\n  [\"min\"]=&gt;\n  int(5)\n}\nkeepMin是根据不同进程,创建不同的连接的,比如你有10个worker进程,将会输出10次,总共创建10*10=100个连接\ngetConfig\n获取连接池的配置:\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    var_dump($redisPool-&gt;getConfig());\n\ndestroyPool\n销毁连接池\n调用之后,连接池剩余的所有链接都会unsetObj,并且将关闭连接队列,调用之后getObj等方法都将失效:\ngo(function (){\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    var_dump($redisPool-&gt;getObj());\n    $redisPool-&gt;destroyPool();\n    var_dump($redisPool-&gt;getObj());\n});\nreset\n重置连接池,调用reset之后,会自动调用destroyPool销毁连接池,并在下一次getObj时重新初始化该连接池:\ngo(function (){\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    var_dump($redisPool-&gt;getObj());\n    $redisPool-&gt;reset();\n    var_dump($redisPool-&gt;getObj());\n});\nstatus\n获取连接池当前状态,调用之后将输出:\narray(4) {\n  [\"created\"]=&gt;\n  int(10)\n  [\"inuse\"]=&gt;\n  int(0)\n  [\"max\"]=&gt;\n  int(20)\n  [\"min\"]=&gt;\n  int(5)\n}\nidleCheck\n回收空闲超时的连接\nintervalCheck\n调用此方法后,将调用idleCheck和keepMin方法,用于手动回收空闲连接和手动热启动连接\npublic function intervalCheck()\n{\n    $this-&gt;idleCheck($this-&gt;getConfig()-&gt;getMaxIdleTime());\n    $this-&gt;keepMin($this-&gt;getConfig()-&gt;getMinObjectNum());\n}\nitemIntervalCheck\n在内部定时器丢弃超时客户端（闲置了超过指定时间，就先断开）时，会触发itemIntervalCheck函数，并将客户端传入，可以实现用户自己的判断客户端是否可用的逻辑。\n该函数如果返回true代表可用（默认情况） 返回false将会导致该客户端直接丢弃。\n可用于：维持客户端心跳等。如orm中对其使用场景如下：维持mysql连接，减少mysql掉线 gone away的几率\n    /**\n     * @param MysqliClient $item\n     * @return bool\n     */\n    public function itemIntervalCheck($item): bool\n    {\n        /*\n         * 如果最后一次使用时间超过autoPing间隔\n         */\n        /** @var Config $config */\n        $config = $this-&gt;getConfig();\n        if($config-&gt;getAutoPing() &gt; 0 &amp;&amp; (time() - $item-&gt;__lastUseTime &gt; $config-&gt;getAutoPing())){\n            try{\n                //执行一个sql触发活跃信息\n                $item-&gt;rawQuery('select 1');\n                //标记使用时间，避免被再次gc\n                $item-&gt;__lastUseTime = time();\n                return true;\n            }catch (\\Throwable $throwable){\n                //异常说明该链接出错了，return 进行回收\n                return false;\n            }\n        }else{\n            return true;\n        }\n    }\n基本使用\n定义池对象\nclass Std implements \\EasySwoole\\Pool\\ObjectInterface {\n    function gc()\n    {\n        /*\n         * 本对象被pool执行unset的时候\n         */\n    }\n\n    function objectRestore()\n    {\n        /*\n         * 回归到连接池的时候\n         */\n    }\n\n    function beforeUse(): ?bool\n    {\n        /*\n         * 取出连接池的时候，若返回false，则当前对象被弃用回收\n         */\n        return true;\n    }\n\n    public function who()\n    {\n        return spl_object_id($this);\n    }\n}\n定义池\n\nclass StdPool extends \\EasySwoole\\Pool\\AbstractPool{\n\n    protected function createObject()\n    {\n        return new Std();\n    }\n}\n\n\n不一定非要创建返回 EasySwoole\\Pool\\ObjectInterface 对象，任意类型对象均可\n\n在pool组件版本&gt;= 1.0.2后，提供了魔术池支持，可以快速进行定义池\nuse \\EasySwoole\\Pool\\MagicPool;\n$magic = new MagicPool(function (){\n    return new \\stdClass(); // 示例，可以返回实现了 ObjectInterface 的对象\n});\n\n// 注册后获取\n$test = $magic-&gt;getObj();\n// 归还\n$magic-&gt;recycleObj($test);\n魔术池构造方法的第二个参数，可以接收一个 config（EasySwoole\\Pool\\Config类），用于定义池数量等配置。\n简单示例\n\n$config = new \\EasySwoole\\Pool\\Config();\n$pool = new StdPool($config);\n\ngo(function ()use($pool){\n    $obj = $pool-&gt;getObj();\n    $obj2 = $pool-&gt;getObj();\n    var_dump($obj-&gt;who());\n    var_dump($obj2-&gt;who());\n});\n进阶使用\n基于pool实现的redis连接池\n[基于pool实现的mysql连接池]()\n相关仓库\neasyswoole/redis-pool","link":"/Components/Pool/introduction.html"},{"id":211,"title":"为什么使用连接池","content":"什么是连接池\n\n连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用。\n\n简单来说，就是创建一个容器，并且把资源提前准备好放在里面，比如我们常用的redis连接、mysql连接。\n连接池的优点\n计算机是由许多零件组装而成，比如CPU、内存、硬盘等等。\n当我们进行网络连接、请求的时候，就需要在不同组件中传递和返回各种信号、数据\n比如在CPU、内存、网卡中，数据的传递，请求，获取。\n如果在短时间内进行一万次mysql的连接，就需要在这个往返过程循环，在路上浪费了很多时间、性能消耗。\n如果我们先把连接连接好，并且放在连接池中，程序中需要使用就从池中获取，执行操作。\n就省去了反复创建连接、断开连接的操作。\n可以减少I/O操作，提高资源利用率。\n连接池数量如何设置\n那么一个池需要设置多少数量比较合适呢？是不是越多越好？\n连接数量需要根据并发数,以及数据库的处理情况来决定的,\n比如你的数据库最大只能处理500个连接,那你设置700个,数据库照样处理不过来,设置过多并没有什么用处,反而可能会让数据库宕机\n所以,一般情况下,连接池总数设置为100-200左右就够了(相当于200的并发)\n这里的连接池数量,说的是总数量,在easyswoole中,需要根据进程来看,每个进程*连接池配置数量=总数量,比如easyswoole中worker进程为8,那你设置20个,那就是20*8=160的总数\neasyswoole中为什么会pool empty\n这个问题有好几个可能性。\n\n连接信息错误，导致一个资源都没有\n程序有问题，把资源拿出去，没有归还到池内，后续就拿到空了\n并发高，池的数量少，需要检查资源占用率，如果占用率没问题，则提高池内的数量\n\n连接错误\n如果我们的mysql配置信息错误，在easyswoole框架启动之后，就会去初始化连接池。\n此时一直连接失败，也就没有产生资源，也没有将资源放在池内\n当你在后续程序获取池内资源的时候。自然就报了空池的错误提示。\n程序问题\n先来一个连接池的伪代码  \n&lt;?php\n\nclass Pool{\n    public static function getIn(){\n        // 单例模式\n    }\n    /**\n     * 初始化\n     */\n    public function init()\n    {\n        // pool准备好就填充指定的资源 比如10个连接\n        $this-&gt;pool = $array;\n    }\n\n    public function get(){\n        return array_pop($this-&gt;pool);\n    }   \n    public function push($obj)\n    {\n        $this-&gt;pool[] = $obj;\n    }\n}\n如果我们的程序有这样子的使用场景\n&lt;?php\n\n    $db = Pool::getIn()-&gt;get();\n    $res = $db-&gt;query('sql语句');\n然后没有进行push 归还操作，那么池内资源一旦拿完，就没有资源可用了。\n在easyswoole框架中，有提供以下方法获取资源（以mysql-pool为例）\n$db = MysqlPool::defer();\n$db-&gt;rawQuery('select version()');\n$data = MysqlPool::invoker(function (MysqlConnection $db){\n    return $db-&gt;rawQuery('select version()');\n});\n$db = PoolManager::getInstance()-&gt;getPool(MysqlPool::class)-&gt;getObj();\n$data = $db-&gt;get('test');\n//使用完毕需要回收\nPoolManager::getInstance()-&gt;getPool(MysqlPool::class)-&gt;recycleObj($db);\ndefer方法将会在本次请求协程退出的时候自动回收\ninvoker是闭包函数方式  一次运行完马上自动回收\nget方式 就是我们伪代码的方式 需要自己回收  使用这种方式就需要特别注意啦~！！！\n\n两种自动回收方式怎么选择  请接着往下看！\n\n并发高  资源占用率\n上面说到两种自动回收资源的方式，defer和invoker\n首先我们来看一个点，defer是在协程退出时自动回收，正常来说，在一个请求到达的时候，swoole会自动创建一个协程给他，比如我们一个http api的请求，就需要整个api跑完，这个协程才会退出\n（相当于我们传统fpm php中  一个脚本全部执行完）\n这个时候问题来了，如果我们的业务是这样子的\n&lt;?php\n\n    $db = MysqlPool::defer();\n    $db-&gt;rawQuery('select version()');\n\n    // 执行好mysql了  做其他任务\n\n    // 耗时1.5s 完成其他\n\n实际上使用到mysql资源的可能只有0.1s不到，但是其他运算占用了脚本大量执行时间，要等全部执行完，协程退出了，资源才会回收，这个时候就比较浪费资源的利用率了。占用率比较低。\n！\n如果可以的话 ，我们推荐使用invoker   执行一条 马上回收资源\n此时要注意一个点，如果程序有比较多执行语句，要么在一个invoker里执行，要么合理使用invoker\n不然就会把性能消耗转移到不断get  recycle上了\n如果以上排查都没问题，并且确认你的用户量比较多，并发高，就可以适当提高pool的number ","link":"/Components/Pool/whyUsePool.html"},{"id":212,"title":"httpclient","content":"HttpClient\n协程Http客户端，基于\\Swoole\\Http\\Client实现，在协程内快速发起http请求。\n安装\n\ncomposer require easyswoole/http-client\n\n请求\n需要在协程环境内发起请求。\n请求实例\n$client = new \\EasySwoole\\HttpClient\\HttpClient('http://easyswoole.com');\n设置Url\n可在实例化的时候，传入Url，或者如下：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setUrl('http://easyswoole.com');\n设置Ssl\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setEnableSSL(true);\n设置等待超时时间\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setTimeout(5);\n设置连接超时时间\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setConnectTimeout(10);\n设置Header\n设置单项：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setHeader('test','test');\n设置多项：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setHeaders(['test' =&gt; 'test']);\n参数：\n\n\n$isMerge 默认：true，false清空原有Header重新赋值。\n\n$strtolower 默认：true，false不进行小写转换。\n\n设置Cookie\n设置单项：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;addCookie('test','test');\n设置多项：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;addCookies(['test' =&gt; 'test']);\n参数：\n\n\n$isMerge 默认：true，false清空原有Cookie重新赋值。\n\n设置XMLHttpRequest\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setXMLHttpRequest();\n设置ContentType\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setContentType($client::CONTENT_TYPE_APPLICATION_XML);\njson：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setContentTypeJson();\nxml：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setContentTypeXml();\nfrom-data：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setContentTypeFormData();\nfrom-urlencode：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setContentTypeFormUrlencoded();\n设置BasicAuth\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setBasicAuth('admin','admin');\n设置KeepAlive\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setKeepAlive(true);\n设置客户端配置\n单个设置：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setClientSetting('bind_address','127.0.0.1');\n批量设置：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setClientSettings([\n    'bind_address'=&gt;'127.0.0.1',\n    'bind_port'=&gt;'8090'\n]);\n设置FollowLocation\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;enableFollowLocation(5);\n参数：\n\n\n$maxRedirect 默认5，表示最多根据30x状态码进行的重定向次数。0 为关闭。\n\n设置允许自签证书\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSslVerifyPeer(true,true);\n设置服务器主机名称\n与ssl_verify_peer配置配合使用\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSslHostName('');\n设置验证用的Ssl证书\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSslCafile('');\n设置Ssl证书目录\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSslCapath('');\n设置Ssl证书文件\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSslCertFile('');\n设置Ssl证书私钥文件\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSslKeyFile('');\n设置代理\nhttp代理：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setProxyHttp('127.0.0.1','1087','user','pass');\nsocks5代理：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setProxySocks5('127.0.0.1','1086','user','pass');\n设置端口绑定\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSocketBind('127.0.0.1','8090');\nGET\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;get();\n参数：\n\n\n$headers 设置Header\n\n\nHEAD\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;head();\nDELETE\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;delete();\n参数：\n\n\n$headers 设置Header\n\n\nPUT\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;put();\n参数：\n\n\n$data 请求的数据\n\n$headers 设置Header\n\n\nPOST\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;post();\npost-xml：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;postXml();\npost-json：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;postJson();\n参数：\n\n\n$data 请求的数据\n\n$headers 设置Header\n\n\nPATCH\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;patch();\n参数：\n\n\n$data 请求的数据\n\n$headers 设置Header\n\n\nOPTIONS\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;options();\n参数：\n\n\n$data 请求的数据\n\n$headers 设置Header\n\n\nDownload\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;download('./test.png');\n参数：\n\n\n$filename 保存路径\n\n$offset 写入偏移量\n\n$httpMethod 请求方法\n\n$rawData 请求数据\n\n$contentType 设置ContentType\n\n\n上传文件\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;post([\n    'file' =&gt; new \\CURLFile(__FILE__)\n]);\n分片上传：\n\n$file = new EasySwoole\\HttpClient\\Bean\\CURLFile('file',__FILE__);\n\n// 设置表单的名称\n$file-&gt;setName('file');\n\n// 设置要文件的路径\n\n$file-&gt;setPath(__FILE__);\n\n// 设置文件总大小\n$file-&gt;setLength(filesize(__FILE__));\n\n// 设置offset（分片上传的关键）\n$file-&gt;setOffset(0);\n\n// 设置文件类型\n$file-&gt;setType('image/png');\n\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;post([\n    'file' =&gt; $file\n]);\n响应\n以上快速发起http请求成功后，如（GET，POST），将会返回EasySwoole\\HttpClient\\Bean\\Response。\n获取响应体\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;getBody();\n当响应体为json，解析：\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;json();\n参数：\n\n\n$assoc 默认false，false为object，true为数组。\n\n当响应体为jsonp，解析：\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;jsonp();\n参数：\n\n\n$assoc 默认false，false为object，true为数组。\n\n当响应体为xml，解析：\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;xml();\n参数：\n\n\n$assoc 默认false，false为object，true为数组。\n\n获取错误码\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;getErrCode();\n获取错误信息\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;getErrMsg();\n获取响应状态码\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;getStatusCode();\n获取响应头及设置的Cookie\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;getSetCookieHeaders();\n获取请求的Cookie及响应头\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;getCookies();\nWebSocket-Client\n$client = new \\EasySwoole\\HttpClient\\HttpClient('127.0.0.1:9501');\n$upgradeResult = $client-&gt;upgrade(true);\n$frame = new \\Swoole\\WebSocket\\Frame();\n//设置发送的消息帧\n$frame-&gt;data = json_encode(['action' =&gt; 'hello','content'=&gt;['a'=&gt;1]]);\n$pushResult = $client-&gt;push($frame);\n$recvFrame = $client-&gt;recv();\n//将返回bool或一个消息帧，可自行判断\nvar_dump($recvFrame);\n\nrecv只会接收一次服务器的消息，如果需要一直接收，请增加while(1)死循环。\n","link":"/Components/httpClient.html"},{"id":213,"title":"smtp","content":"Smtp\n电子邮件是—种用电子手段提供信息交换的通信方式，是互联网应用最广的服务。电子邮件几乎是每个web应用程序不可或缺的，无论是时事通讯还是订单确认。本库采用swoole协程客户端实现了电子邮件的发送。\n组件要求\n\nphp: &gt;=7.1.0\next-swoole: ^4.2.6\neasyswoole/spl: ^1.1\neasyswoole/utility: ^1.0\n\n安装方法\n\ncomposer require easyswoole/smtp\n\n仓库地址\neasyswoole/smtp\n基本使用\n邮件配置\nset\n设置服务器地址\npublic function setServer(string $server): void\n设置服务器端口\npublic function setPort(int $port): void\n设置ssl\npublic function setSsl(bool $ssl): void\n设置用户名\npublic function setUsername(string $username): void\n设置密码\npublic function setPassword(string $password): void\n设置邮件发送方\npublic function setMailFrom(string $mailFrom): void\n设置超时时间\npublic function setTimeout(float $timeout): void\n设置邮件大小\npublic function setMaxPackage(int $maxPackage)\nget\n获取服务地址\npublic function getServer(): string\n获取服务端口\npublic function getPort(): int\n是否设置了ssl\npublic function isSsl(): bool\n获取用户名\npublic function getUsername(): string\n获取密码\npublic function getPassword(): string\n获取邮件发送方\npublic function getMailFrom(): string\n获取超时时间\npublic function getTimeout(): float\n获取邮件大小\npublic function getMaxPackage()\n内容配置\nset\n设置协议版本\npublic function setMimeVersion($mimeVersion): void\n设置contentType\npublic function setContentType($contentType): void\n设置字符\npublic function setCharset($charset): void\n设置编码\npublic function setContentTransferEncoding($contentTransferEncoding): void\n设置主题\npublic function setSubject($subject): void\n设置邮件内容\npublic function setBody($body): void\n添加附件\npublic function addAttachment($attachment)\nget\n获取协议版本\npublic function getMimeVersion()\n获取contenttype\npublic function getContentType()\n获取字符\npublic function getCharset()\n获取编码\npublic function getContentTransferEncoding()\n获取主题\npublic function getSubject()\n获取邮件内容\npublic function getBody()\n获取附件\npublic function getAttachments()\n使用示例\nuse EasySwoole\\Smtp\\Mailer;\nuse EasySwoole\\Smtp\\MailerConfig;\nuse EasySwoole\\Smtp\\Message\\Html;\nuse EasySwoole\\Smtp\\Message\\Attach;\n// 必须用go\ngo(function (){\n    $config = new MailerConfig();\n    $config-&gt;setServer('smtp.163.com');\n    $config-&gt;setSsl(false);\n    $config-&gt;setUsername('huizhang');\n    $config-&gt;setPassword('*******');\n    $config-&gt;setMailFrom('xx@163.com');\n    $config-&gt;setTimeout(10);//设置客户端连接超时时间\n    $config-&gt;setMaxPackage(1024*1024*5);//设置包发送的大小：5M\n\n    //设置文本或者html格式\n    $mimeBean = new Html();\n    $mimeBean-&gt;setSubject('Hello Word!');\n    $mimeBean-&gt;setBody('&lt;h1&gt;Hello Word&lt;/h1&gt;');\n\n    //添加附件\n    $mimeBean-&gt;addAttachment(Attach::create('./test.txt'));\n\n    $mailer = new Mailer($config);\n    $mailer-&gt;sendTo('xx@qq.com', $mimeBean);\n});\n\n进阶使用\n邮件内容支持文本和html两种类型\n文本\n示例\n$mimeBean = new \\EasySwoole\\Smtp\\Message\\Text();\n$mimeBean-&gt;setSubject('Hello Word!');\n$mimeBean-&gt;setBody('&lt;h1&gt;Hello Word&lt;/h1&gt;');\n效果\n \nHtml\n$mimeBean = new \\EasySwoole\\Smtp\\Message\\Html();\n$mimeBean-&gt;setSubject('Hello Word!');\n$mimeBean-&gt;setBody('&lt;h1&gt;Hello Word&lt;/h1&gt;');\n效果\n \n附件\n$mimeBean = new \\EasySwoole\\Smtp\\Message\\Text();\n//$mimeBean = new \\EasySwoole\\Smtp\\Message\\Html();\n\n...\n\n// 创建附件\n$createAttachment = Attach::create('./test.txt');\n\n// 添加附件\n$mimeBean-&gt;addAttachment($createAttachment);\n\n...","link":"/Components/Stmp/smtp.html"},{"id":214,"title":"actor组件","content":"Actor\n提供Actor模式支持，助力游戏行业开发。EasySwoole的Actor采用自定义Process作为存储载体，以协程作为最小调度单位，利用协程Channel做mail box，而客户端与Process之间的通讯，采用UnixSocket实现，并且借助TCP实现分布式的ActorClient，超高并发下也能轻松应对。\n工作流程\n一般来说有两种策略用来在并发线程中进行通信：共享数据和消息传递。使用共享数据方式的并发编程面临的最大的一个问题就是数据条件竞争，当两个实例需要访问同一个数据时，为了保证数据的一致性，通常需要为数据加锁，而Actor模型采用消息传递机制来避免数据竞争，无需复杂的加锁操作，各个实例只需要关注自身的状态以及处理收到的消息。\nActor是完全面向对象、无锁、异步、实例隔离、分布式的并发开发模式。Actor实例之间互相隔离，Actor实例拥有自己独立的状态，各个Actor之间不能直接访问对方的状态，需要通过消息投递机制来通知对方改变状态。由于每个实例的状态是独立的，没有数据被共享，所以不会发生数据竞争，从而避免了并发下的加锁问题。\n举一个游戏场景的例子，在一个游戏房间中，有5个玩家，每个玩家都是一个PlayerActor，拥有自己的属性，比如角色ID，昵称，当前血量，攻击力等。游戏房间本身也是一个RoomActor，房间也拥有属性，比如当前在线的玩家，当前场景的怪物数量，怪物血量等。此时玩家A攻击某个怪物，则PlayerActor-A向RoomActor发送一个攻击怪物的指令，RoomActor经过计算，得出玩家A对怪物的伤害值，并给房间内的所有PlayerActor发送一个消息（玩家A攻击怪物A，造成175点伤害，怪物A剩余血量1200点），类似此过程，每个PlayerActor都可以得知房间内发生了什么事情，但又不会造成同时访问怪物A的属性，导致的共享加锁问题。\n安装\nActor并没有作为内置组件，需要先引入包并进行基础配置才能够使用。\n\ncomposer require easyswoole/actor\n\n使用\n建立一个Actor\n每一种对象（玩家、房间、甚至是日志服务也可以作为一种Actor对象）都建立一个Actor来进行管理，一个对象可以拥有多个实例（Client）并且可以互相通过信箱发送消息来处理业务。\n&lt;?php\n\nnamespace App\\Player;\n\nuse EasySwoole\\Actor\\AbstractActor;\nuse EasySwoole\\Actor\\ActorConfig;\n\n/**\n * 玩家Actor\n * Class PlayerActor\n * @package App\\Player\n */\nclass PlayerActor extends AbstractActor\n{\n    /**\n     * 配置当前的Actor\n     * @param ActorConfig $actorConfig\n     */\n    public static function configure(ActorConfig $actorConfig)\n    {\n        $actorConfig-&gt;setActorName('PlayerActor');\n        $actorConfig-&gt;setWorkerNum(3);\n    }\n\n    /**\n     * Actor首次启动时\n     */\n    protected function onStart()\n    {\n        $actorId = $this-&gt;actorId();\n        echo \"Player Actor {$actorId} onStart\\n\";\n    }\n\n    /**\n     * Actor收到消息时\n     * @param $msg\n     */\n    protected function onMessage($msg)\n    {\n        $actorId = $this-&gt;actorId();\n        echo \"Player Actor {$actorId} onMessage\\n\";\n    }\n\n    /**\n     * Actor即将退出前\n     * @param $arg\n     */\n    protected function onExit($arg)\n    {\n        $actorId = $this-&gt;actorId();\n        echo \"Player Actor {$actorId} onExit\\n\";\n    }\n\n    /**\n     * Actor发生异常时\n     * @param \\Throwable $throwable\n     */\n    protected function onException(\\Throwable $throwable)\n    {\n        $actorId = $this-&gt;actorId();\n        echo \"Player Actor {$actorId} onException\\n\";\n    }\n\n}\n注册Actor服务\n可以使用setListenAddress和setListenPort指定本机对外监听的端口，其他机器可以通过该端口向本机的Actor发送消息。\n\npublic static function mainServerCreate(EventRegister $register) {\n\n    // 注册Actor管理器\n    $server = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer();\n    \\EasySwoole\\Actor\\Actor::getInstance()-&gt;register(PlayerActor::class);\n    \\EasySwoole\\Actor\\Actor::getInstance()-&gt;setTempDir(EASYSWOOLE_TEMP_DIR)\n        -&gt;setListenAddress('0.0.0.0')-&gt;setListenPort('9900')-&gt;attachServer($server);\n\n}\nActor实例管理\n服务启动后就可以进行Actor的操作，管理本机的Client实例，则不需要给client传入$node参数，默认的node为本机，管理其他机器时需要传入。\n\n    // 管理本机的Actor则不需要声明节点\n    $node = new \\EasySwoole\\Actor\\ActorNode();\n    $node-&gt;setIp('127.0.0.1');\n    $node-&gt;setListenPort(9900);\n\n    // 启动一个Actor并得到ActorId 后续操作需要依赖ActorId\n    $actorId = PlayerActor::client($node)-&gt;create(['time' =&gt; time()]);   // 00101000000000000000001\n    // 给某个Actor发消息\n    PlayerActor::client($node)-&gt;send($actorId, ['data' =&gt; 'data']);\n    // 给该类型的全部Actor发消息\n    PlayerActor::client($node)-&gt;sendAll(['data' =&gt; 'data']);\n    // 退出某个Actor\n    PlayerActor::client($node)-&gt;exit($actorId, ['arg' =&gt; 'arg']);\n    // 退出全部Actor\n    PlayerActor::client($node)-&gt;exitAll(['arg' =&gt; 'arg']);\n\n架构解读\nActor\n应该叫ActorManager更确切点，它用来注册Actor启动Proxy和ActorWorker进程。\n当你在业务逻辑里定义了几种Actor，比如RoomActor、PlayerActor，需要在SwooleServer启动时注册它们。\n具体就是在EasySwooleEvent.mainServerCreate方法中添加如下代码。\n$actor = Actor::getInstance();\n$actor-&gt;register(RoomActor::class);\n$actor-&gt;register(PlayerActor::class);\n$actorConf = Config::getInstance()-&gt;getConf('ACTOR_SERVER');\n$actor-&gt;setMachineId($actorConf['MACHINE_ID'])\n    -&gt;setListenAddress($actorConf['LISTEN_ADDRESS'])\n    -&gt;setListenPort($actorConf['PORT'])\n    -&gt;attachServer($server);\n其中ListenAddress、ListenPort为Proxy进程的监听地址端口，MachineId为ActorWorker进程的机器码。\nMachineId和IP:PORT对应。\nattachServer将开启相应数量的Proxy进程，以及前边register的ActorWorker进程。\n工作原理\nProxy进程做消息中转，Worker进程做消息分发推送。来看个具体的例子：\n游戏中玩家P请求进入房间R，抽象成Actor模型就是PlayerActor需要往RoomActor发送请求加入的命令。\n那么这时候需要这样写：\n\\EasySwoole\\Actor\\Test\\RoomActor::client($node)-&gt;send($roomActorId, [\n    'user_actor_id' =&gt; $userActorId,\n    'data'  =&gt; '其他进入房间的参数'\n])\n其中$roomActorId和$userActorId是事先xxActor::client()-&gt;create()出来的。\n上面那段代码的意思就是往$roomActorId的RoomActor实例推送了一条$userActorId玩家的UserActor实例要加入房间的消息。\n参数$node用来寻址Proxy，它由目标Actor实例的Worker.MachineId决定，在本例中就是$roomActorId被创建在了哪个MachineId的WorkerProcess。\n通过$roomActorId中的机器码找到IP:PORT，生成$node。\nsend时会创建一个协程TcpClient，将消息发送给Proxy，然后Proxy将消息转发（UnixClient）至本机WorkerProcess，WorkerProcess收到消息，推送到具体的Actor实例。\n这样就完成了从PlayerActor到RoomActor的请求通讯，RoomActor收到请求消息并处理完成后，向PlayerActor回发处理结果，用的是同样的通讯流程。\n如果是单机部署，可以忽略$node参数，因为所有通讯都是在本机进行。\n多机的话，需要自己根据业务来实现Actor如何分布和定位。\n主要属性\nmachineId 机器码\nproxyNum 启动几个ProxyProcess\nlistenPort 监听port\nlistenAddress 监听ip\nAbstractActor\nActor实例的基类，所有业务中用到的Actor都将继承于`AbstractActor。例如游戏场景中的房间，你可以：\nclass RoomActor extends AbstractActor\n工作原理\n每个Actor实例都维护一份独立的数据和状态，当一个Actor实例通过client()-&gt;create()后，会开启协程循环，接收mailbox pop的消息，进而处理业务逻辑，更新自己的数据及状态。具体实现就是__run()这个方法。\n静态方法 configure\n用来配置ActorConfig，只需要在具体的Actor（如RoomActor）去重写这个方法就行。\n关于ActorConfig具体属性可以看下边ActorConfig部分。\n几个虚拟方法\n以下几个虚拟方法需要在Actor子类中实现，这几个方法被用在__run()中来完成Actor的运行周期。\nonStart() 在协程开启前执行，你可以在此进行Actor初始化的一些操作，比如获取房间的基础属性等。\nonMessage() 当接收到消息时执行，一个Actor实例的生命周期基本上就是在收消息-处理-发消息，你需要在这里对消息进行解析处理。\nonExit() 当接收到退出命令时执行。比如你希望在一个Actor实例退出的时候，同时通知某些关联的其他Actor，可以在此处理。\n其它\nexit() 用于实例自己退出操作，会向自己发一条退出的命令。\ntick()、after() 两个定时器，用于Actor实例的定时任务，比如游戏房间的定时刷怪（tick）；掉线后多长时间自动踢出（after）。\nstatic client() 用于创建一个ActorClient来进行对应Actor（实例）的通讯。\nActorClient\nActor通讯客户端，调用xxActor::client()来创建一个ActorClient进行Actor通讯。\n上边已经大概讲过了Actor的通讯流程，本质就是TcpClient-&gt;ProxyProcess-&gt;UnixClient-&gt;ActorWorkerProcess-&gt;xxActor。\n看下它实现了哪些方法：\ncreate() 创建一个xxActor实例，返回actorId，在之后你可以使用这个actorId与此实例进行通讯。\nsend() 指定actorId，向其发送消息。\nexit() 通知xxActor退出指定actorId的实例。\nsendAll() 向所有的xxActor实例发送消息。\nexitAll() 退出所有xxActor实例。\nexist() 当前是否存在指定actorId的xxActor实例。\nstatus() 当前ActorWorker下xxActor的分布状态。\nActorConfig\n具体Actor的配置项，比如RoomActor、PlayerActor都有自己的配置。\nactorName 一般用类名就可以，注意在同一个服务中这个是不能重复的。\nactorClass 在Actor-&gt;register()会将对应的类名写入。\nworkerNum 为Actor开启几个进程，Actor-&gt;attachServer()时会根据这个参数为相应Actor启动WorkerNum个Worker进程。\nActorNode\n上边提到过，xxActor::client($node)，这个$node就是ActorNode对象，属性为Ip和Port，用于寻址Proxy。\nWorkerConfig\nWorkerProcess的配置项，WorkerProcess启动时用到。\nworkerId worker进程Id，create Actor的时候用于生成actorId\nmachineId worker进程机器码，create Actor的时候用于生成actorId\ntrigger 异常触发处理接口\nWorkerProcess\nActor的重点在这里，每个注册的Actor（类）会启动相应数量的WorkerProcess。\n比如你注册了RoomActor、PlayerActor，workerNum都配置的是3，那么系统将启动3个RoomActor的Worker进程和3个PlayerActor的Worker进程。\n每个WorkerProcess维护一个ActorList，你通过client()-&gt;create()的Actor将分布在不同Worker进程里，由它的ActorList进行管理。\nWorkerProcess通过协程接收client（这个client就是Proxy做转发时的UnixClient）消息，区分消息类型，然后分发给对应的Actor实例。\n请仔细阅读下WorkerProcess的源码，它继承于AbstractUnixProcess。\nUnixClient\nUnixStream Socket，自行了解。Proxy转发消息给本机Actor所使用的Client。\nProtocol\n数据封包协议。\nProxyCommand\n消息命令对象，Actor2将不同类型的消息封装成格式化的命令，最终传给WorkerProcess。\n你可以在ActorClient中了解一下方法和命令的对应关系，但这个不需要在业务层去更改。\nProxyConfig\n消息代理的配置项。\nactorList 注册的actor列表。\nmachineId 机器码\ntempDir 临时目录\ntrigger 错误触发处理接口 \nProxyProcess\nActor-&gt;attachServer()会启动proxyNum个ProxyProcess。\n用于在Actor实例和WorkerProcess做消息中转。","link":"/Components/actor.html"},{"id":215,"title":"whoops","content":"Whoops\nEasyswoole 提供了Whoops驱动，用于开发阶段，友好的排除HTTP业务的错误与异常。\n\n切勿用于生产阶段，否则造成代码泄露EasySwoole不负任何责任！！！\n组件要求\n\neasyswoole/component: ^2.0\neasyswoole/spl: ^1.1\neasyswoole/template: ^1.0\neasyswoole/utility: ^1.0\npsr/log: ^1.0.1\n\n安装方法\n\ncomposer require easyswoole/easy-whoops=3.x\n\n仓库地址\neasyswoole/easy-whoops=3.x\n基本使用\n直接在 EasySwoole 全局事件中进行注册\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response): bool {\n            // 拦截请求\n            if (\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;runMode() == 'dev') {\n                \\EasySwoole\\Whoops\\Run::attachRequest($request, $response);\n            }\n            return true;\n        });\n\n        if (\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;runMode() == 'dev') {\n            $whoops = new \\EasySwoole\\Whoops\\Run();\n            $whoops-&gt;pushHandler(new \\EasySwoole\\Whoops\\Handler\\PrettyPageHandler());  // 输出一个漂亮的页面\n            $whoops-&gt;pushHandler(new \\EasySwoole\\Whoops\\Handler\\CallbackHandler(function ($exception, $inspector, $run, $handle) {\n                // 可以推进多个Handle 支持回调做更多后续处理\n            }));\n            $whoops-&gt;register();\n        }\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        if (\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;runMode() == 'dev') {\n            \\EasySwoole\\Whoops\\Run::attachTemplateRender(ServerManager::getInstance()-&gt;getSwooleServer());\n        }\n    }\n}\n经过上面配置完成之后，就可以在框架抛出异常时，输出一个漂亮的异常页面。","link":"/Components/whoops.html"},{"id":216,"title":"安装","content":"SyncInvoker 组件\n使用场景\nSwoole4.x 后，提供了非常强大的协程能力，让我们可以更好地压榨服务器性能，提高并发。然而，目前 PHP 在 Swoole 协程生态上，并不是很完善，比如：没有协程版本的 MonogoDB 客户端，而为了避免在 Worker 进程中调用了同步阻塞的 Api，例如在 Http 回调中使用了同步的 MonogoDB 客户端，导致 Worker 进程退化为同步阻塞，导致无法完全地发挥协程的优势。所以 EasySwoole 提供了一个同步程序协程调用转化驱动。\n设计原理\n启动自定义进程监听 UnixSocket，然后在 Worker 进程中调用协程客户端发送命令到自定义进程并处理，然后把处理结果返回给 Worker进程中的协程客户端。\n组件要求\n\nphp: &gt;= 7.1.0\next-swoole: &gt;= 4.4.23\neasyswoole/component: ^2.0\nopis/closure: ^3.5\n\n安装方法\n\ncomposer require easyswoole/sync-invoker\n\n仓库地址\neasyswoole/sync-invoker\n基本使用\n首先定义一个驱动工作实例（可以定义多个），示例代码如下：\n&lt;?php\n\nnamespace App\\Utility;\n\nuse EasySwoole\\SyncInvoker\\AbstractDriver;\n\nclass MyInvokerDriver extends AbstractDriver\n{\n    private $stdclass;\n\n    function __construct()\n    {\n        $this-&gt;stdclass = new \\stdClass();\n        parent::__construct();\n    }\n\n    public function test($a, $b)\n    {\n        $this-&gt;response($a + $b);\n    }\n\n    public function a()\n    {\n        $this-&gt;response('this is a');\n    }\n\n    public function getStdClass()\n    {\n        return $this-&gt;stdclass;\n    }\n}\n然后注册一个对应的调用器，示例代码如下：\n&lt;?php\n\nnamespace App\\Utility;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\SyncInvoker\\SyncInvoker;\n\n// 注册一个对应的调用器\nclass MyInvoker extends SyncInvoker\n{\n    use Singleton;\n}\n最后在 EasySwoole全局事件 中 的 mainServerCreate 事件中进行注册\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        $invokerConfig = \\App\\Utility\\MyInvoker::getInstance()-&gt;getConfig();\n\n        // 以下这些配置都是可选的，可以使用组件默认的配置\n        /*\n        $invokerConfig-&gt;setServerName('EasySwoole'); // 设置服务名称，默认为 'EasySwoole'\n        $invokerConfig-&gt;setWorkerNum(3); // 设置 Worker 进程数，默认为 3\n        $invokerConfig-&gt;setTempDir(EASYSWOOLE_ROOT . '/Temp'); // 设置 unixSocket 存放目录，默认为 系统临时文件存放目录('/tmp')\n        $invokerConfig-&gt;setMaxPackageSize(2 * 1024 * 1024); // 设置最大允许发送数据大小，默认为 2M\n        $invokerConfig-&gt;setTimeout(3.0); // 设置服务调用超时时间，默认为 3.0 秒\n        $invokerConfig-&gt;setAsyncAccept(true); // 设置异步接收数据，默认为 异步接收(不建议修改)\n        $invokerConfig-&gt;setOnWorkerStart(function (\\EasySwoole\\SyncInvoker\\Worker $worker) {\n            var_dump('worker start at Id ' . $worker-&gt;getArg()['workerIndex']);\n        }); // 设置服务启动时执行的事件回调\n        */\n\n        $invokerConfig-&gt;setDriver(new \\App\\Utility\\MyInvokerDriver()); // 设置驱动工作实例【必须配置】\n\n        // 注册 Invoker\n        \\App\\Utility\\MyInvoker::getInstance()-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n}\n在框架服务启动后，即可在框架的任意位置调用 Invoker 服务了，使用示例如下：\n例如在控制器中进行调用：\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        $ret = \\App\\Utility\\MyInvoker::getInstance()-&gt;invoke()-&gt;test(1, 2);\n        var_dump($ret);\n        var_dump(\\App\\Utility\\MyInvoker::getInstance()-&gt;invoke()-&gt;a());\n        $ret = \\App\\Utility\\MyInvoker::getInstance()-&gt;invoke()-&gt;callback(function (\\App\\Utility\\MyInvokerDriver $driver) {\n            $std = $driver-&gt;getStdClass();\n            if (isset($std-&gt;time)) {\n                return $driver-&gt;response($std-&gt;time);\n            } else {\n                $std-&gt;time = time();\n                return $driver-&gt;response('new set time');\n            }\n        });\n        var_dump($ret);\n    }\n}\n\n/**\n * 输出结果：\n * int(3)\n * string(9) \"this is a\"\n * string(12) \"new set time\"\n * int(3)\n * string(9) \"this is a\"\n * int(1611071672)\n */\n注意事项\n\n尽量使用函数名调用方式，闭包方式调用会存在部分闭包函数序列化失败问题\n传递参数，返回结果尽量用数组或者字符串传递，资源对象无法序列化\n","link":"/Components/SyncInvoker/syncInvoker.html"},{"id":217,"title":"mongodb 客户端案例","content":"MongoDB\n目前，MongoDB 并没有提供协程版本的 php 客户端，只有同步阻塞版本。\nEasySwoole 的协程版客户端已经在排期内。\n在实际生产中，直接创建原生的 MongoDB客户端 来进行数据交互，也不是不可。\n若希望将同步调用转为协程调用，可以用 Easyswoole 提供的 sync-invoker 组件。\n将 MongoDB客户端 的同步调用转为协程调用具体使用如下：\n定义驱动\n&lt;?php\n\nnamespace App\\MongoDb;\n\nuse EasySwoole\\EasySwoole\\Trigger;\nuse EasySwoole\\SyncInvoker\\AbstractDriver;\nuse MongoDB\\Client;\n\nclass Driver extends AbstractDriver\n{\n    private $db;\n\n    // 【建议使用】\n    // 使用 mongodb/mongodb composer组件包封装的 MongoDB 客户端调用类，作为客户端调用驱动\n    // 【前提：需要先使用 `composer require mongodb/mongodb` 安装 mongodb/mongodb composer组件包】\n    function getDb(): Client\n    {\n        if ($this-&gt;db == null) {\n            // 这里为要连接的 mongodb 的服务端地址【前提是必须先有服务端，且安装 php-mongodb 扩展才可使用】\n            $mongoUrl = \"mongodb://127.0.0.1:27017\";\n            $this-&gt;db = new Client($mongoUrl);\n        }\n        return $this-&gt;db;\n    }\n\n    // 仅使用 php-mongodb 扩展内置类(不使用composer组件包的)，作为客户端调用驱动\n    /*\n    function getDb(): \\MongoDB\\Driver\\Manager\n    {\n        if ($this-&gt;db == null) {\n            // 这里为要连接的 mongodb 的服务端地址【前提是必须先有服务端，且安装 php-mongodb 扩展才可使用】\n            $mongoUrl = \"mongodb://127.0.0.1:27017\";\n            $this-&gt;db = new \\MongoDB\\Driver\\Manager($mongoUrl);\n\n        }\n        return $this-&gt;db;\n    }\n    */\n\n    protected function onException(\\Throwable $throwable)\n    {\n        Trigger::getInstance()-&gt;throwable($throwable);\n        return null;\n    }\n}\n客户端调用类定义\n&lt;?php\n\nnamespace App\\MongoDb;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\SyncInvoker\\SyncInvoker;\n\nclass MongoClient extends SyncInvoker\n{\n    use Singleton;\n}\n注册 Invoker 服务\n在 EasySwoole 全局事件 的 mainServerCreate 事件 中进行服务注册\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // 配置 Invoker\n        $invokerConfig = \\App\\MongoDb\\MongoClient::getInstance()-&gt;getConfig();\n        $invokerConfig-&gt;setDriver(new \\App\\MongoDb\\Driver()); // 配置 MongoDB 客户端协程调用驱动\n\n        // 以下这些配置都是可选的，可以使用组件默认的配置\n        /*\n        $invokerConfig-&gt;setMaxPackageSize(2 * 1024 * 1024); // 设置最大允许发送数据大小，默认为 2M【注意：当使用 MongoDB 客户端查询大于 2M 的数据时，可以修改此参数】\n        $invokerConfig-&gt;setTimeout(3.0); // 设置 MongoDB 客户端操作超时时间，默认为 3.0 秒;\n        */\n\n        // 注册 Invoker\n        \\App\\MongoDb\\MongoClient::getInstance()-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n}\n在框架中使用 MongoDB 客户端(协程调用)\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse App\\MongoDb\\Driver;\nuse App\\MongoDb\\MongoClient;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Utility\\Random;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        // 使用 mongodb/mongodb composer组件包【建议使用，需要先使用composer安装】\n        $ret = MongoClient::getInstance()-&gt;invoke()-&gt;callback(function (Driver $driver) {\n            $ret = $driver-&gt;getDb()-&gt;user-&gt;list-&gt;insertOne([\n                'name' =&gt; Random::character(8),\n                'sex' =&gt; 'man',\n            ]);\n            if (!$ret) {\n                $driver-&gt;response(false);\n            }\n            $driver-&gt;response($ret-&gt;getInsertedId());\n        });\n        var_dump($ret);\n\n        $ret = MongoClient::getInstance()-&gt;invoke()-&gt;callback(function (Driver $driver) {\n            $ret = [];\n            $collections = $driver-&gt;getDb()-&gt;user-&gt;listCollections();\n            foreach ($collections as $collection) {\n                $ret[] = (array)$collection;\n            }\n            $driver-&gt;response($ret);\n        });\n        var_dump($ret);\n        /**\n         * 输出结果：\n         * object(MongoDB\\BSON\\ObjectId)#109 (1) {\n             [\"oid\"]=&gt;\n             string(24) \"600da377004c82305a02fb52\"\n           }\n         * array(1) {\n             [0]=&gt;\n             array(1) {\n               [\"MongoDB\\Model\\CollectionInfoinfo\"]=&gt;\n               array(5) {\n                 [\"name\"]=&gt;\n                 string(4) \"list\"\n                 [\"type\"]=&gt;\n                 string(10) \"collection\"\n                 [\"options\"]=&gt;\n                 array(0) {\n                 }\n                 [\"info\"]=&gt;\n                 array(2) {\n                   [\"readOnly\"]=&gt;\n                   bool(false)\n                   [\"uuid\"]=&gt;\n                   object(MongoDB\\BSON\\Binary)#110 (2) {\n                     [\"data\"]=&gt;\n                     string(16) \"EasySwoole\"\n                     [\"type\"]=&gt;\n                     int(4)\n                   }\n                 }\n                 [\"idIndex\"]=&gt;\n                 array(4) {\n                   [\"v\"]=&gt;\n                   int(2)\n                   [\"key\"]=&gt;\n                   array(1) {\n                     [\"_id\"]=&gt;\n                     int(1)\n                   }\n                   [\"name\"]=&gt;\n                   string(4) \"_id_\"\n                   [\"ns\"]=&gt;\n                   string(9) \"user.list\"\n                 }\n               }\n             }\n           } \n        */\n\n        // 使用 php-mongodb 扩展时(不使用 mongodb/mongodb composer组件包)\n        /*\n        // 插入数据\n        $rets = MongoClient::getInstance()-&gt;invoke()-&gt;callback(function (Driver $driver) {\n            $bulk = new \\MongoDB\\Driver\\BulkWrite();\n\n            $bulk-&gt;insert([\n                'name' =&gt; Random::character(8),\n                'sex' =&gt; 'man',\n            ]);\n\n            $bulk-&gt;insert(['_id' =&gt; 1, 'x' =&gt; 1]);\n            $bulk-&gt;insert(['_id' =&gt; 2, 'x' =&gt; 2]);\n\n            $bulk-&gt;update(['x' =&gt; 2], ['$set' =&gt; ['x' =&gt; 1]], ['multi' =&gt; false, 'upsert' =&gt; false]);\n            $bulk-&gt;update(['x' =&gt; 3], ['$set' =&gt; ['x' =&gt; 3]], ['multi' =&gt; false, 'upsert' =&gt; true]);\n            $bulk-&gt;update(['_id' =&gt; 3], ['$set' =&gt; ['x' =&gt; 3]], ['multi' =&gt; false, 'upsert' =&gt; true]);\n\n            $bulk-&gt;insert(['_id' =&gt; 4, 'x' =&gt; 2]);\n\n            $bulk-&gt;delete(['x' =&gt; 1], ['limit' =&gt; 1]);\n\n            $manager = $driver-&gt;getDb();\n            $writeConcern = new \\MongoDB\\Driver\\WriteConcern(\\MongoDB\\Driver\\WriteConcern::MAJORITY, 100);\n            // 查到 user 库的 list 集合中\n            $ret = $manager-&gt;executeBulkWrite('user.list', $bulk, $writeConcern);\n\n            printf(\"Inserted %d document(s)\\n\", $ret-&gt;getInsertedCount()); // 插入条数\n            printf(\"Matched  %d document(s)\\n\", $ret-&gt;getMatchedCount()); // 匹配条数\n            printf(\"Updated  %d document(s)\\n\", $ret-&gt;getModifiedCount()); // 修改条数\n            printf(\"Upserted %d document(s)\\n\", $ret-&gt;getUpsertedCount()); // 修改插入条数\n            printf(\"Deleted  %d document(s)\\n\", $ret-&gt;getDeletedCount()); // 删除条数\n\n            foreach ($ret-&gt;getUpsertedIds() as $index =&gt; $id) {\n                printf('upsertedId[%d]: ', $index);\n                var_dump($id);\n            }\n\n            if (!$ret) {\n                return false;\n            }\n\n            return true;\n        });\n\n        // 查询数据\n        $rets = MongoClient::getInstance()-&gt;invoke()-&gt;callback(function (Driver $driver) {\n            $filter = ['x' =&gt; ['$gt' =&gt; 1]];\n            $options = [\n                'projection' =&gt; ['_id' =&gt; 0],\n                'sort' =&gt; ['x' =&gt; -1],\n            ];\n\n// 查询数据\n            $query = new \\MongoDB\\Driver\\Query($filter, $options);\n            $cursor = $driver-&gt;getDb()-&gt;executeQuery('user.list', $query);\n            foreach ($cursor as $document) {\n                print_r($document);\n            }\n        });\n        */\n\n    }\n}","link":"/Components/SyncInvoker/mongoDb.html"},{"id":218,"title":"热重载","content":"hot-reload\n用于开发过程中的代码热重载\n组件要求\n\neasyswoole/component: ^2.0\neasyswoole/spl: ^1.3\neasyswoole/utility: ^1.1\n\n安装方法\n\ncomposer require easyswoole/hot-reload\n\n仓库地址\neasyswoole/hot-reload\n基本使用\n单独使用\n// 创建一个服务\nrequire_once 'vendor/autoload.php';\n$server = new \\Swoole\\Server('0.0.0.0', '9801');\n$server-&gt;on('receive', function () {});\n\n// 设置监视器的选项\n$hotReloadOptions = new \\EasySwoole\\HotReload\\HotReloadOptions;\n// 虚拟机中可以关闭Inotify检测\n$hotReloadOptions-&gt;disableInotify(true);\n// 可以设置多个监控目录的绝对路径\n$hotReloadOptions-&gt;setMonitorFolder([dirname(__FILE__)]);\n// 忽略某些后缀名不去检测\n$hotReloadOptions-&gt;setIgnoreSuffix(['php', 'txt']);\n// 自定义检测到变更后的事件\n$hotReloadOptions-&gt;setReloadCallback(function (\\Swoole\\Server $server) {\n    echo \"File change event triggered\";  // 可以执行如清理临时目录等逻辑\n    $server-&gt;reload();  // 接管变更事件 需要自己执行重启\n});\n\n$hotReload = new \\EasySwoole\\HotReload\\HotReload($hotReloadOptions);\n$hotReload-&gt;attachToServer($server);\n$server-&gt;start();\nEasySwoole框架中使用\n请在全局事件(EasySwooleEvent)的mainServerCreate方法中进行注册\nclass EasySwooleEvent {\n\n    // 省略部分代码 ...\n\n    /**\n     * 服务启动时\n     * @param EventRegister $register\n     * @throws Exception\n     */\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // 配置同上别忘了添加要检视的目录\n        $hotReloadOptions = new \\EasySwoole\\HotReload\\HotReloadOptions;\n        $hotReload = new \\EasySwoole\\HotReload\\HotReload($hotReloadOptions);\n        $hotReloadOptions-&gt;setMonitorFolder([EASYSWOOLE_ROOT . '/App']);\n\n        $server = ServerManager::getInstance()-&gt;getSwooleServer();\n        $hotReload-&gt;attachToServer($server);\n    }\n\n    // 省略部分代码 ...\n\n}\n注意\n方便的热重载组件，在Linux环境下使用Inotify，其他环境或虚拟机内使用iNode脏检测扫描实现开发过程中的代码热重载，可自定义重载处理逻辑，由于可以自定义，也可以作为一个方便的文件变更事件触发器使用，在文件变更时执行一些逻辑\n!!!警告!!! 仅供开发使用，请勿在生产环境使用，以免意外重启造成逻辑异常","link":"/Components/hotReload.html"},{"id":219,"title":"linuxdash","content":"LinuxDash\nlinuxDash封装了很多直接获取linux信息的命令,可以查看相关信息\n组件要求\n\nphp: &gt;=7.1.0\next-swoole: ^4.4.0\neasyswoole/spl: ^1.3\n\n安装方法\n\ncomposer require easyswoole/linux-dash \n\n仓库地址\neasyswoole/linux-dash\n基本使用\n\n$run = new \\Swoole\\Coroutine\\Scheduler();\n$run-&gt;add(function () {\n    //获取ip地址网卡缓冲信息\n    $data = LinuxDash::arpCache();\n    var_dump($data);\n    //获取当前带宽数据\n    $data = LinuxDash::bandWidth();\n    var_dump($data);\n    //获取cpu进程占用排行信息\n    $data = LinuxDash::cpuIntensiveProcesses();\n    var_dump($data);\n    //获取磁盘分区信息\n    $data = LinuxDash::diskPartitions();\n    var_dump($data);\n    //获取当前内存使用信息\n    $data = LinuxDash::currentRam();\n    var_dump($data);\n    //获取cpu信息\n    $data = LinuxDash::cpuInfo();\n    var_dump($data);\n    //获取当前系统信息\n    $data = LinuxDash::generalInfo();\n    var_dump($data);\n    //获取当前磁盘io统计\n    $data = LinuxDash::ioStats();\n    var_dump($data);\n    //获取ip地址\n    $data = LinuxDash::ipAddresses();\n    var_dump($data);\n    //CPU负载信息\n    $data = LinuxDash::loadAvg();\n    var_dump($data);\n    //获取内存详细信息\n    $data = LinuxDash::memoryInfo();\n    var_dump($data);\n    //获取进程占用内存排行信息\n    $data = LinuxDash::ramIntensiveProcesses();\n    var_dump($data);\n    //获取swap交换空间信息\n    $data = LinuxDash::swap();\n    var_dump($data);\n    //获取当前用户名信息\n    $data = LinuxDash::userAccounts();\n    var_dump($data);\n\n});\n$run-&gt;start();\n注意，mac环境不兼容。但是可以用docker测试","link":"/Components/linuxDash.html"},{"id":220,"title":"filewatcher","content":"File-Watcher 组件\n用于在 EasySwoole 中实现热重启，让开发变得更简便。\n组件要求\n\neasyswoole/spl: ^1.3\neasyswoole/component: ^2.2\n\n安装方法\n\ncomposer require easyswoole/file-watcher\n\n仓库地址\neasyswoole/file-watcher\nWatchRule\n监控目录:\n$watchRule = new \\EasySwoole\\FileWatcher\\WatchRule(EASYSWOOLE_ROOT.\"/App\");\n指定忽略目录：\n/**@var \\EasySwoole\\FileWatcher\\WatchRule $watchRule **/\n$watchRule-&gt;setIgnorePaths([EASYSWOOLE_ROOT.\"/App/Api\", EASYSWOOLE_ROOT.\"/App/Admin\"]);\n指定忽略文件：\n/**@var \\EasySwoole\\FileWatcher\\WatchRule $watchRule **/\n$watchRule-&gt;setIgnoreFiles([EASYSWOOLE_ROOT.\"/App/Api/Teacher.php\", EASYSWOOLE_ROOT.\"/App/Admin/Teacher.php\"]);\n指定匹配后缀：\n/**@var \\EasySwoole\\FileWatcher\\WatchRule $watchRule **/\n$watchRule-&gt;setType($watchRule::SCAN_TYPE_SUFFIX_MATCH);\n//$watchRule-&gt;setType($watchRule::SCAN_TYPE_IGNORE_SUFFIX);\n$watchRule-&gt;setSuffix(['php']);\ntype为SCAN_TYPE_SUFFIX_MATCH时，只匹配后缀必须在suffix规则数组的文件。 type为SCAN_TYPE_IGNORE_SUFFIX时，会忽略掉后缀在suffix规则数组的文件。\nFileWatcher\n设置监控程序:\n$fileWatcher = new \\EasySwoole\\FileWatcher\\FileWatcher();\n$fileWatcher-&gt;setScannerDriver(\\EasySwoole\\FileWatcher\\Scanner\\Inotify::class);\n$fileWatcher-&gt;setScannerDriver(\\EasySwoole\\FileWatcher\\Scanner\\FileScanner::class);\n二选一 不调用此方法 存在inotify扩展默认为Inotify::class反之FileScanner::class\n增加监控规则：\n/**@var \\EasySwoole\\FileWatcher\\FileWatcher $fileWatcher **/\n$fileWatcher-&gt;addRule(new \\EasySwoole\\FileWatcher\\WatchRule(__DIR__));\n$fileWatcher-&gt;addRule(new \\EasySwoole\\FileWatcher\\WatchRule(EASYSWOOLE_ROOT. '/App'));\n可进行多次调用 对不同目录设置不同的规则\n设置异常回调：\n/**@var \\EasySwoole\\FileWatcher\\FileWatcher $fileWatcher **/\n$fileWatcher-&gt;setOnException(function (\\Throwable $throwable){\n\n});\n设置检测周期(默认1000ms)：\n/**@var \\EasySwoole\\FileWatcher\\FileWatcher $fileWatcher **/\n$fileWatcher-&gt;setCheckInterval(1000);\n设置触发回调(文件有变化)：\n/**@var \\EasySwoole\\FileWatcher\\FileWatcher $fileWatcher **/\n$fileWatcher-&gt;setOnChange(function (array $list, \\EasySwoole\\FileWatcher\\WatchRule $rule){\n    // list为变化的文件列表\n});\n启动(swoole服务中使用)：\n/**@var \\EasySwoole\\FileWatcher\\FileWatcher $fileWatcher **/\n/**@var \\Swoole\\Server $server **/\n$fileWatcher-&gt;attachServer($server);\nEasySwoole 中用于热重启\n例如在 EasySwoole 开发模式中，我们希望当有代码变动的时候，实现 Server 重启，只需要在 EasySwoole 的全局事件 EasySwooleEvent 中注册一下即可实现。 示例代码如下：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\FileWatcher\\FileWatcher;\nuse EasySwoole\\FileWatcher\\WatchRule;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        $watcher = new FileWatcher();\n        $rule = new WatchRule(EASYSWOOLE_ROOT . \"/App\"); // 设置监控规则和监控目录\n        $watcher-&gt;addRule($rule);\n        $watcher-&gt;setOnChange(function () {\n            Logger::getInstance()-&gt;info('file change ,reload!!!');\n            ServerManager::getInstance()-&gt;getSwooleServer()-&gt;reload();\n        });\n        $watcher-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n}\n注意，reload 仅仅针对 Worker进程 加载的代码有效。","link":"/Components/fileWatcher.html"},{"id":221,"title":"arraytotexttable","content":"ArrayToTextTable\n功能介绍\n用于把数组数据转为表格输出。\n相关Class位置\n\nArrayToTextTable\n\n\nnamespace: EasySwoole\\Utility\\ArrayToTextTable\n\n\n\n\n核心对象方法\ngetTable\n获取表格\n\nmixed $data 表格数据\n\npublic function getTable($data = null)\nsetIndentation\n设置表格缩进\n\nmixed $indentation 设置缩进\n\npublic function setIndentation($indentation)\nisDisplayHeader\n设置表格头部\n\nbool $displayHeader 是否需要表格头部\n\npublic function isDisplayHeader(bool $displayHeader)\nsetKeysAlignment\n设置表格头部对齐方式\n\nmixed $keysAlignment 表格头部对齐方式\n\npublic function setKeysAlignment($keysAlignment)\nsetValuesAlignment\n设置表格数据对齐方式\n\nmixed $keysAlignment 表格头部对齐方式\n\npublic function setValuesAlignment($valuesAlignment)\nsetFormatter\n处理表格数据格式\n\nmixed $formatter 数据方式\n\npublic function setFormatter($formatter)\n基本使用\n创建核心类的对象\n$data = [\n    [\n        'name' =&gt; 'James',\n        'age' =&gt; '20',\n        'sex'=&gt;'男'\n    ],\n    [\n        'name' =&gt; 'Tony',\n        'age' =&gt; 50,\n        'email' =&gt; '291323003@qq.com',\n    ],\n];\n//创建核心类的对象，并带入了数据参数  $data\n$renderer = new \\EasySwoole\\Utility\\ArrayToTextTable($data);\n//设置表格缩进\n$renderer-&gt;setIndentation(\"\\t\");\n//设置表格头部\n$renderer-&gt;isDisplayHeader(true);\n//设置表格头部对齐方式\n$renderer-&gt;setKeysAlignment(\\EasySwoole\\Utility\\ArrayToTextTable::AlignLeft);\n//设置表格数据对齐方式\n$renderer-&gt;setValuesAlignment(\\EasySwoole\\Utility\\ArrayToTextTable::AlignLeft);\n//处理表格数据格式\n$renderer-&gt;setFormatter(function (&amp;$value,$key){\n    if($key == 'sex'){\n        if(empty($value)){\n            $value = '未知性别';\n        }\n    }else if($key == 'email'){\n        if(empty($value)){\n            $value = '未知邮箱';\n        }\n    }\n});\n\n$table =  $renderer-&gt;getTable();\n\necho $renderer;\n​       ps: 执行的时候请用命令行的模式运行；如若遇到表格的外框线没有对齐，请检查中文字体和英文的字体所占用的空间比是否为2：1。","link":"/Components/Help/arrayToTextTable.html"},{"id":222,"title":"file","content":"File\n功能介绍\n用于操作文件或目录。\n相关class位置\n\nFile\n\n\nnamespace: EasySwoole\\Utility\\File\n\n\n\n\n核心对象方法\ncreateDirectory\n创建目录：\n\nstring $dirPath 目录路径\nstring $permissions 目录权限\n\nstatic function createDirectory($dirPath, $permissions = 0755):bool\ncleanDirectory\n清空目录：\n\nstring $dirPath 目录路径\nstring $keepStructure 是否保持目录结构\n\nstatic function cleanDirectory($dirPath, $keepStructure = false):bool\ndeleteDirectory\n删除目录：\n\nstring $dirPath 目录路径\n\nstatic function deleteDirectory($dirPath):bool\ncopyDirectory\n复制目录：\n\nstring $source 源位置\nstring $target 目标位置\nbool $overwrite 是否覆盖\n\nstatic function copyDirectory($source, $target, $overwrite = true):bool\nmoveDirectory\n移动目录：\n\nstring $source 源位置\nstring $target 目标位置\nbool $overwrite 是否覆盖\n\nstatic function moveDirectory($source, $target ,$overwrite = true):bool\ncopyFile\n复制文件：\n\nstring $source 源位置\nstring $target 目标位置\nbool $overwrite 是否覆盖\n\nstatic function copyFile($source, $target, $overwrite = true):bool\ntouchFile\n创建空文件：\n\nstring $filePath 文件名\nbool $overwrite 是否覆盖\n\nstatic function touchFile($filePath, $overwrite = true):bool\ncreateFile\n创建有内容文件：\n\nstring $filePath 文件名\nstring $content 内容\nbool $overwrite 是否覆盖\n\nstatic function createFile($filePath, $content, $overwrite = true):bool\nmoveFile\n移动文件：\n\nstring $source 源位置\nstring $target 目标位置\nbool $overwrite 是否覆盖\n\nstatic function moveFile($source, $target, $overwrite = true):bool\n\nscanDir\n获得文件目录或目录文件数组：\n\nstring $dirPath 目录路径\n\nstatic function scanDir($dirPath)","link":"/Components/Help/file.html"},{"id":223,"title":"hash","content":"Hash\n功能介绍\n用于快速处理哈希密码以及数据完整性校验等场景\n相关class位置\n\nHash\n\n\nnamespace: EasySwoole\\Utility\\Hash\n\n\n\n\n核心对象方法\nmakePasswordHash\n从一个明文值生产哈希\n\nmixed $value 需要生产哈希的原文\nmixed $cost 递归的层数\n\nstatic function makePasswordHash($value, $cost = 10)\nvalidatePasswordHash\n校验明文值与哈希是否匹配\n\nmixed $value 原文\nmixed $cost 哈希加密文\n\nstatic function validatePasswordHash($value, $hashValue)\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 上午10:10\n */\n\nrequire './vendor/autoload.php';\n\n$password = 123456;\n$hash = \\EasySwoole\\Utility\\Hash::makePasswordHash($password);\nvar_dump($hash);\nvar_dump(\\EasySwoole\\Utility\\Hash::validatePasswordHash($password, $hash));\n\n/**\n * 输出结果:\n * string(60) \"$2y$10$ESx0z8TGSJpMI3Hgr6nJJOdbretS2TBqv4d5L0XjlTkSjSiCiq/f6\"\n * bool(true) \n */","link":"/Components/Help/hash.html"},{"id":224,"title":"random","content":"Random\n功能介绍\n用于生成随机验证码,随机字符串等等\n相关class位置\n\nRandom\n\n\nnamespace: EasySwoole\\Utility\\Random\n\n\n\n\n核心对象方法\ncharacter\n字符串随机生成：\n\nint $length 生成长度\nstring $alphabet 自定义生成字符集\n\nstatic function character($length = 6, $alphabet = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789')\nnumber\n纯数字字符串随机生成：\n\nint $length 生成长度\n\nstatic function number(length = 6)\narrayRandOne\n从集合里面随机产生一个个体：\n\narray $length 数组集合\n\nstatic function arrayRandOne(array $data)\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 上午10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Random::character());\nvar_dump(\\EasySwoole\\Utility\\Random::number());\nvar_dump(\\EasySwoole\\Utility\\Random::arrayRandOne(['one', 'two', 'three']));\n\n/**\n * 输出结果:\n * string(6) \"W94ohx\"\n * string(6) \"986543\"\n * string(3) \"two\"\n */","link":"/Components/Help/random.html"},{"id":225,"title":"snowflake","content":"雪花算法\n功能介绍\n生成唯一编号\n相关class位置\n\nSnowFlake\n\n\nnamespace: EasySwoole\\Utility\\SnowFlake\n\n\n\n\n核心对象方法\nmake\n生成基于雪花算法的随机编号\n\nmixed $dataCenterID 数据中心\nmixed $workerID 任务进程\n\nstatic function make($dataCenterID = 0, $workerID = 0)\nunmake\n反向解析雪花算法生成的编号\n\nmixed $snowFlakeId 编号\n\nstatic function unmake($snowFlakeId)\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 上午10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = \\EasySwoole\\Utility\\SnowFlake::make(1,1);//传入数据中心id(0-31),任务进程id(0-31)\nvar_dump($str);\nvar_dump(\\EasySwoole\\Utility\\SnowFlake::unmake($str));\n\n/**\n * 输出结果:\n * int(194470364728922112)\n * object(stdClass)#3 (4) {\n *   [\"timestamp\"]=&gt;\n *   int(1532127766018)\n *   [\"dataCenterID\"]=&gt;\n *   int(1)\n *   [\"workerID\"]=&gt;\n *   int(1)\n *   [\"sequence\"]=&gt;\n *   int(0)\n * }\n */","link":"/Components/Help/snowFlake.html"},{"id":226,"title":"str","content":"Str\n功能介绍\nStr字符串助手\n相关class位置\n\nStr\n\n\nnamespace: EasySwoole\\Utility\\Str\n\n\n\n\n核心对象方法\ncontains\n检查字符串中是否包含另一字符串\n\nmixed $haystack 被检查的字符串\nmixed $needles 需要包含的字符串\nmixed $strict 是否区分大小写\n\nstatic function contains($haystack, $needles, $strict = true)\nstartsWith\n检查字符串是否以某个字符串开头\n\nmixed $haystack 被检查的字符串\nmixed $needles 需要包含的字符串\nmixed $strict 是否区分大小写\n\nstatic function startsWith($haystack, $needles, $strict = true)\nendsWith\n检查字符串是否以某个字符串结尾\n\nmixed $haystack 被检查的字符串\nmixed $needles 需要包含的字符串\nmixed $strict 是否区分大小写\n\nstatic function endsWith($haystack, $needles, $strict = true)\nsnake\n驼峰转下划线\n\nmixed $value 待处理字符串\nmixed $delimiter 分隔符\n\nstatic function snake($value, $delimiter = '_')\ncamel\n下划线转驼峰 (首字母小写)\n\nmixed $value 待处理字符串\n\nstatic function camel($value)\nstudly\n下划线转驼峰 (首字母大写)\n\nmixed $value 待处理字符串\n\nstatic function studly($value)\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 上午10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Str::contains('hello, easyswoole', 'Swoole', false));\n\n/**\n * 输出结果:\n * bool(true)\n */\n\nvar_dump(\\EasySwoole\\Utility\\Str::startsWith('hello, easyswoole', 'Hello', false));\n\n/**\n * 输出结果:\n * bool(true)\n */\n\nvar_dump(\\EasySwoole\\Utility\\Str::endsWith('hello, easyswoole', 'Swoole', false));\n\n/**\n * 输出结果:\n * bool(true)\n */\n\nvar_dump(\\EasySwoole\\Utility\\Str::snake('EasySwoole'));\n\n/**\n * 输出结果:\n * string(11) \"easy_swoole\"\n */\n\nvar_dump(\\EasySwoole\\Utility\\Str::camel('easy_swoole'));\n\n/**\n * 输出结果:\n * string(10) \"easySwoole\"\n */\n\nvar_dump(\\EasySwoole\\Utility\\Str::studly('easy_swoole'));\n\n/**\n * 输出结果:\n * string(10) \"EasySwoole\"\n */","link":"/Components/Help/str.html"},{"id":227,"title":"time","content":"Time\n功能介绍\n时间戳助手\n相关class位置\n\nTime\n\n\nnamespace: EasySwoole\\Utility\\Time\n\n\n\n\n核心对象方法\nstartTimestamp\n返回某一天开始的时间戳\n\nmixed $date 字符串日期或时间戳\n\nstatic function startTimestamp($date = '')\nendTimestamp\n返回某一天结束的时间戳\n\nmixed $date 字符串日期或时间戳\n\nstatic function endTimestamp($date = '')\nendTimestamp\n从字符串创建出 Datetime 对象\n\nmixed $datetime 传入文本日期或者时间戳\n\nstatic function createDateTimeClass($datetime = '')\nparserDateTime\n从DateTime对象中获取年月日时分秒\n\nmixed $datetime 传入文本日期或者时间戳\n\nstatic function parserDateTime($dateTime)\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 上午10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Time::startTimestamp('2019-4-15'));\n\n/**\n * 输出结果:\n * int(1555286400)\n */\n\nvar_dump(\\EasySwoole\\Utility\\Time::endTimestamp('2019-4-15'));\n\n/**\n * 输出结果:\n * int(1555372799)\n */\n\nvar_dump(\\EasySwoole\\Utility\\Time::createDateTimeClass('2019-4-15'));\n\n/**\n * 输出结果:\n * object(DateTime)#3 (3) {\n *   [\"date\"]=&gt;\n *   string(26) \"2019-04-15 00:00:00.000000\"\n *   [\"timezone_type\"]=&gt;\n *   int(1)\n *   [\"timezone\"]=&gt;\n *   string(6) \"+00:00\"\n * }\n */\n\nvar_dump(\\EasySwoole\\Utility\\Time::parserDateTime('2019-4-15'));\n\n/**\n * 输出结果:\n * array(6) {\n *   [0]=&gt;\n *   string(2) \"00\"\n *   [1]=&gt;\n *   string(2) \"00\"\n *   [2]=&gt;\n *   string(2) \"00\"\n *   [3]=&gt;\n *   string(1) \"4\"\n *   [4]=&gt;\n *   string(2) \"15\"\n *   [5]=&gt;\n *   string(4) \"2019\"\n * }\n */","link":"/Components/Help/time.html"},{"id":228,"title":"intstr","content":"IntStr\n功能介绍\n用于 整数(需要转换的整数必须在 0 ~ 9223372036854775668 范围之内) 和 字符串 的相互转换，即：可以把一个字符串转换成一个数字，反之，通过这个数字，我们可以得到之前的字符串。\n可用于生成 url 短链接。\n相关class位置\n\nIntStr\n\n\nnamespace: EasySwoole\\Utility\\IntStr \n\n\n\n核心对象方法\ntoAlpha\n生成基于 整数 对应的 字符串\n\nint $number 要生成字符串的数字\n\npublic static function toAlpha(int $number): string\ntoNum\n反向解析 字符串 对应的 数字\n\nstring $string 待解析的字符串\n\npublic static function toNum(string $string): int\n基本使用\n&lt;?php\nrequire __DIR__ . '/vendor/autoload.php';\n\n// 传入小于 9223372036854775668 的整数，得到一个字符串，通过此字符串可以反向解析成对应的数组\n$str = \\EasySwoole\\Utility\\IntStr::toAlpha(122407155078249761);\nvar_dump($str);\n\n// 传入字符串得到对应的数字\n$num = \\EasySwoole\\Utility\\IntStr::toNum('EasySwoole');\nvar_dump($num);\n\n// 用于生成短链接\n$domain_prefix = 'https://easyswoole.com';\n$path1 = \\EasySwoole\\Utility\\IntStr::toNum('Preface');\n$path2 = \\EasySwoole\\Utility\\IntStr::toNum('intro');\n$new_short_url = \"{$domain_prefix}/{$path1}/{$path2}\";\nvar_dump($new_short_url); // 生成的短链接\n\n$real_path1 = \\EasySwoole\\Utility\\IntStr::toAlpha($path1);\n$real_path2 = \\EasySwoole\\Utility\\IntStr::toAlpha($path2);\n$real_url = \"{$domain_prefix}/{$real_path1}/{$real_path2}\";\nvar_dump($real_url); // 真实的请求地址\n\n/**\n * 输出结果:\n * string(10) \"EasySwoole\"\n * int(122407155078249761) \n * string(46) \"https://easyswoole.com/1793938716421/272803253\"\n * string(36) \"https://easyswoole.com/Preface/intro\"\n */","link":"/Components/Help/intStr.html"},{"id":229,"title":"jwt令牌","content":"JWT\nJSON Web Token（JWT）是目前最流行的跨域身份验证解决方案。\n随着技术的发展，分布式web应用的普及，通过session管理用户登录状态成本越来越高，因此慢慢发展成为token的方式做登录身份校验，然后通过token去取redis中的缓存的用户信息，随着之后jwt的出现，校验方式更加简单便捷化，无需通过redis缓存，而是直接根据token取出保存的用户信息，以及对token可用性校验，单点登录更为简单。\n\n建议阅读一下\n组件要求\n\nphp: &gt;=7.1.0\next-openssl: &gt;=1.0.0\neasyswoole/spl: ^1.2\neasyswoole/utility: ^1.1\n\n安装方法\n\ncomposer require easyswoole/jwt \n\n仓库地址\neasyswoole/jwt\n核心类库方法\n编码相关\n设置加密方式，默认HMACSHA256\n    function algMethod(string $method):Jwt\n设置秘钥，默认Easyswoole\n    function setSecretKey(string $key):Jwt\n初始化一个没有附带信息的token的JwtObject\n    public function publish():JwtObject\n设置加密方式, 默认HMACSHA256\n    public function setAlg($alg): self\n设置用户\n    public function setAud($aud): self\n设置过期时间\n    public function setExp($exp): self\n设置发布时间\n    public function setIat($iat): self\n设置发行人\n    public function setIss(string $iss): self\n设置jwt-id，用于标识该jwt\n    public function setJti($jti): self\n在此之前不可用\n    public function setNbf($nbf): self\n设置主题\n    public function setSub($sub): self\n设置其他数据\n    public function setData($data): self\n获取token\n    function __toString()\n解码相关\n解码\n    public function decode(?string $raw):?JwtObject\n获取解码状态, 1:通过, -1:无效, -2:token过期\n    public function getStatus(): int\n获取加密方式\n    public function getAlg()\n获取用户\n    public function getAud()\n获取过期时间\n    public function getExp()\n获取发布时间\n    public function getIat()\n获取发行人\n    public function getIss(): string\n获取jwt-id\n    public function getJti()\n获取生效时间\n    public function setNbf($nbf): void\n获取主题\n    public function getSub()\n获取自定义数据\n    public function getData()\n获取签名\n    public function getSignature()\n通过key获取相关数据\n    final public function getProperty($name)\n基本使用\n生成token\nuse EasySwoole\\Jwt\\Jwt;\n\n$jwtObject = Jwt::getInstance()\n    -&gt;setSecretKey('easyswoole') // 秘钥\n    -&gt;publish();\n\n$jwtObject-&gt;setAlg('HMACSHA256'); // 加密方式\n$jwtObject-&gt;setAud('user'); // 用户\n$jwtObject-&gt;setExp(time()+3600); // 过期时间\n$jwtObject-&gt;setIat(time()); // 发布时间\n$jwtObject-&gt;setIss('easyswoole'); // 发行人\n$jwtObject-&gt;setJti(md5(time())); // jwt id 用于标识该jwt\n$jwtObject-&gt;setNbf(time()+60*5); // 在此之前不可用\n$jwtObject-&gt;setSub('主题'); // 主题\n\n// 自定义数据\n$jwtObject-&gt;setData([\n    'other_info'\n]);\n\n// 最终生成的token\n$token = $jwtObject-&gt;__toString();\n解析token\nuse EasySwoole\\Jwt\\Jwt;\n\n$token = \"eyJhbGciOiJITUFDU0hBMjU2IiwiaXNzIjoiZWFzeXN3b29sZSIsImV4cCI6MTU3MzgzNTIxMSwic3ViIjoi5Li76aKYIiwibmJmIjoxNTczODMxOTExLCJhdWQiOiJ1c2VyIiwiaWF0IjoxNTczODMxNjExLCJqdGkiOiJjYWJhZmNiMWIxZTkxNTU3YzIxMDUxYTZiYTQ0MTliMiIsInNpZ25hdHVyZSI6IjZlNTI1ZjJkOTFjZGYzMjBmODE1NmEwMzE1MDhiNmU0ZDQ0YzhkNGFhYzZjNmU1YzMzMTNjMDIyMGJjYjJhZjQiLCJzdGF0dXMiOjEsImRhdGEiOlsib3RoZXJfaW5mbyJdfQ%3D%3D\";\n\ntry {\n    $jwtObject = Jwt::getInstance()-&gt;decode($token);\n\n    $status = $jwtObject-&gt;getStatus();\n\n    // 如果encode设置了秘钥,decode 的时候要指定\n    // $status = $jwt-&gt;setSecretKey('easyswoole')-&gt;decode($token)\n\n    switch ($status)\n    {\n        case  1:\n            echo '验证通过';\n            $jwtObject-&gt;getAlg();\n            $jwtObject-&gt;getAud();\n            $jwtObject-&gt;getData();\n            $jwtObject-&gt;getExp();\n            $jwtObject-&gt;getIat();\n            $jwtObject-&gt;getIss();\n            $jwtObject-&gt;getNbf();\n            $jwtObject-&gt;getJti();\n            $jwtObject-&gt;getSub();\n            $jwtObject-&gt;getSignature();\n            $jwtObject-&gt;getProperty('alg');\n            break;\n        case  -1:\n            echo '无效';\n            break;\n        case  -2:\n            echo 'token过期';\n        break;\n    }\n} catch (\\EasySwoole\\Jwt\\Exception $e) {\n\n}","link":"/Components/jwt.html"},{"id":230,"title":"policy","content":"Policy\nPolicy（即策略）是在特定模型或者资源中组织授权逻辑的类，用来处理用户授权动作。\n组件要求\n\nphp: ^7.1\next-json: &gt;=1.0\neasyswoole/spl: ^1.1\n\n安装\n\ncomposer require easyswoole/policy\n\n仓库地址\neasyswlle/policy\n使用方法\n\nuse EasySwoole\\Policy\\PolicyNode;\nuse EasySwoole\\Policy\\Policy;\n\n//授权动作\n//PolicyNode::EFFECT_ALLOW   允许\n//PolicyNode::EFFECT_DENY    拒绝\n//PolicyNode::EFFECT_UNKNOWN 未知\n\n$policy = new Policy();\n//添加节点授权   \n$policy-&gt;addPath('/user/add',PolicyNode::EFFECT_ALLOW);\n$policy-&gt;addPath('/user/update',PolicyNode::EFFECT_ALLOW);\n$policy-&gt;addPath('/user/delete',PolicyNode::EFFECT_DENY);\n$policy-&gt;addPath('/user/*',PolicyNode::EFFECT_DENY);\n\n//验证节点权限\nvar_dump($policy-&gt;check('user/asdasd'));//deny\nvar_dump($policy-&gt;check('user/add'));   //allow\nvar_dump($policy-&gt;check('user/update'));//allow\n\n/*\n * 允许/api/*,但是唯独拒绝/api/order/charge,/api/order/info,/api/sys/*\n */\n\n$policy-&gt;addPath('/api/*',PolicyNode::EFFECT_ALLOW);\n$policy-&gt;addPath('/api/order/charge',PolicyNode::EFFECT_DENY);\n$policy-&gt;addPath('/api/order/info',PolicyNode::EFFECT_DENY);\n$policy-&gt;addPath('/api/sys/*',PolicyNode::EFFECT_DENY);\n\nvar_dump($policy-&gt;check('/api/whatever'));\nvar_dump($policy-&gt;check('/api/order/charge'));\nvar_dump($policy-&gt;check('/api/order/info'));\nvar_dump($policy-&gt;check('/api/sys/whatever'));\n\n//对象添加\n$root = new PolicyNode('*');\n$userChild = $root-&gt;addChild('user');\n$userAddChild = $userChild-&gt;addChild('add');\n$userAddChild-&gt;addChild('aaaaaa')-&gt;setAllow(PolicyNode::EFFECT_ALLOW);\n$userChild-&gt;addChild('update')-&gt;setAllow(PolicyNode::EFFECT_DENY);\n$userChild-&gt;addChild('*')-&gt;setAllow(PolicyNode::EFFECT_ALLOW);\n\n$apiChild = $root-&gt;addChild('charge');\n$apiChild-&gt;addChild('*');\n\n$node = $root-&gt;search('/user/add/aaaa');\nif ($node) {\n    var_dump($node-&gt;isAllow());\n}\n\n相关仓库\n基于Policy组件的后台权限管理demo easyswoole_admin","link":"/Components/policy.html"},{"id":231,"title":"安装","content":"words-match\nwords-match组件是基于字典树(DFA)并利用UnixSock通讯和自定义进程实现，开发本组件的目的是帮小伙伴们快速部署内容检测服务。\n使用场景\n\n\n跟文字内容相关的产品都有应用场景。\n\n\n博客类的文章，评论的检测\n\n\n聊天内容的检测\n\n\n对垃圾内容的屏蔽\n\n\n组件要求\nNone\n安装方法\n\ncomposer require easyswoole/words-match\n\n仓库地址\neasyswoole/words-match\n基本使用\n准备词库\n服务启动的时候会一行一行将数据读出来，每一行的第一列为敏感词，其它列为附属信息\nphp,是世界上,最好的语言\njava\ngolang\n程序员\n代码\n逻辑\n服务注册\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\Component\\Di;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\WordsMatch\\WMServer;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        Di::getInstance()-&gt;set(SysConst::HTTP_GLOBAL_ON_REQUEST, function (Request $request, Response $response): bool {\n            // TODO: Implement onRequest() method.\n            return true;\n        });\n\n        Di::getInstance()-&gt;set(SysConst::HTTP_GLOBAL_AFTER_REQUEST, function (Request $request, Response $response): void {\n            // TODO: Implement onRequest() method.\n        });\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // 配置 words-match\n        $wdConfig = new \\EasySwoole\\WordsMatch\\Config();\n        $wdConfig-&gt;setDict(__DIR__ . '/dictionary.txt'); // 配置 词库地址\n        $wdConfig-&gt;setMaxMEM(1024); // 配置 每个进程最大占用内存(M)，默认为 512 M\n        $wdConfig-&gt;setTimeout(3.0); // 配置 内容检测超时时间。默认为 3.0 s\n        $wdConfig-&gt;setWorkerNum(3); // 配置 进程数\n        // $wdConfig-&gt;setSockDIR(sys_get_temp_dir()); // (不建议修改)配置 socket 存放地址，默认为 sys_get_temp_dir()，即 '/tmp'\n\n        // 注册服务\n        WMServer::getInstance($wdConfig)-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n}\n客户端使用\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\WordsMatch\\WMServer;\n\nclass Index extends Controller\n{\n    function detect()\n    {\n        // 需要检测的内容敏感词\n        $content = 'php是世界上最好的语言';\n        // 检测结果（返回 -1 表示检测超时，匹配检测到时返回检测到的敏感词内容）\n        $result = WMServer::getInstance()-&gt;detect($content, 3);\n        var_dump($result);\n        /**\n         * 输出结果：\n         * array(1) {\n            [0]=&gt;\n            object(EasySwoole\\WordsMatch\\Dictionary\\DetectResult)#96 (5) {\n            [\"word\"]=&gt;\n            string(30) \"php是世界上最好的语言\"\n            [\"location\"]=&gt;\n            array(1) {\n              [0]=&gt;\n              array(3) {\n                [\"word\"]=&gt;\n                string(30) \"php是世界上最好的语言\"\n                [\"length\"]=&gt;\n                int(12)\n                [\"location\"]=&gt;\n                array(1) {\n                  [0]=&gt;\n                  int(0)\n                }\n              }\n            }\n            [\"count\"]=&gt;\n            int(1)\n            [\"remark\"]=&gt;\n            string(0) \"\"\n            [\"type\"]=&gt;\n            int(1)\n            }\n         * }\n         */\n    }\n}\n压测结果\n对此组件分别进行1.5万、13万等级的词库测试，服务默认开启3个进程。\n仅做参考，具体还以线上验证\n电脑配置\nMacBook Air (13-inch, 2017)\n处理器 1.8 GHz Intel Core i5\n内存 8 GB 1600 MHz DDR3\n1.5万词\n并发10总请求数100\n10 100\nConcurrency Level:      10\nTime taken for tests:   0.067 seconds\nComplete requests:      100\nFailed requests:        0\nNon-2xx responses:      100\nTotal transferred:      17300 bytes\nHTML transferred:       2600 bytes\nRequests per second:    1492.49 [#/sec] (mean)\nTime per request:       6.700 [ms] (mean)\nTime per request:       0.670 [ms] (mean, across all concurrent requests)\nTransfer rate:          252.15 [Kbytes/sec] received\n并发100总请求数1000\nConcurrency Level:      100\nTime taken for tests:   0.239 seconds\nComplete requests:      1000\nFailed requests:        0\nNon-2xx responses:      1000\nTotal transferred:      173000 bytes\nHTML transferred:       26000 bytes\nRequests per second:    4189.17 [#/sec] (mean)\nTime per request:       23.871 [ms] (mean)\nTime per request:       0.239 [ms] (mean, across all concurrent requests)\nTransfer rate:          707.74 [Kbytes/sec] received\n13万词\n并发10总请求数100\nConcurrency Level:      10\nTime taken for tests:   0.057 seconds\nComplete requests:      100\nFailed requests:        0\nNon-2xx responses:      100\nTotal transferred:      17300 bytes\nHTML transferred:       2600 bytes\nRequests per second:    1751.71 [#/sec] (mean)\nTime per request:       5.709 [ms] (mean)\nTime per request:       0.571 [ms] (mean, across all concurrent requests)\nTransfer rate:          295.94 [Kbytes/sec] received\n并发100总请求数1000\nConcurrency Level:      100\nTime taken for tests:   0.225 seconds\nComplete requests:      1000\nFailed requests:        0\nNon-2xx responses:      1000\nTotal transferred:      173000 bytes\nHTML transferred:       26000 bytes\nRequests per second:    4444.84 [#/sec] (mean)\nTime per request:       22.498 [ms] (mean)\nTime per request:       0.225 [ms] (mean, across all concurrent requests)\nTransfer rate:          750.93 [Kbytes/sec] received","link":"/Components/WordsMatch/introduction.html"},{"id":232,"title":"常见问题","content":"实时添加、移除的词，服务停止后怎么办？\n\n1.x 版本服务停止时会将正在运行中的所有词落地到文件，2.x移除了这一特性\n我们更倾向于用户自己处理这些词。举个例子：比如你所有的词都存在db中，在线添加移除词时可相应更新db，\n然后定时去刷新词库文件。\n\n如何做到游戏中&quot;香词&quot;变*？\n\n检测结果中会有命中词在文章的具体位置，然后你再根据词的长度做相应的替换，或者你干脆直接替换命中的词，根据这个思路\n可以实现更多好玩的事情。\n\nQQ会根据聊天内容下表情雨，这是怎么做到的？\n\n检测聊天内容，命中相应关键词，拉取对应的表情扔到你屏幕上。\n\n","link":"/Components/WordsMatch/problem.html"},{"id":233,"title":"使用","content":"Spider\nSpider组件可以方便用户快速搭建分布式多协程爬虫，用户只需关心product和consume，product对dom的解析推荐使用Querylist\n安装\ncomposer require easyswoole/spider\n快速使用\n以百度搜索为例，根据搜索关键词爬出每次检索结果前几页的特定数据\n纯属教学目的，如有冒犯贵公司还请及时通知，会及时调整\nProduct\n&lt;?php\nnamespace App\\Spider;\n\nuse EasySwoole\\HttpClient\\HttpClient;\nuse EasySwoole\\Spider\\Config\\ProductConfig;\nuse EasySwoole\\Spider\\Hole\\ProductAbstract;\nuse EasySwoole\\Spider\\ProductResult;\nuse QL\\QueryList;\nuse EasySwoole\\FastCache\\Cache;\n\nclass ProductTest extends ProductAbstract\n{\n\n    public function product():ProductResult\n    {\n        // TODO: Implement product() method.\n        // 请求地址数据\n        $httpClient = new HttpClient($this-&gt;productConfig-&gt;getUrl());\n        $httpClient-&gt;setHeader('User-Agent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36');\n        $body = $httpClient-&gt;get()-&gt;getBody();\n\n        // 先将每个搜索结果的a标签内容拿到\n        $rules = [\n            'search_result' =&gt; ['.c-container .t', 'text', 'a']\n        ];\n        $searchResult = QueryList::rules($rules)-&gt;html($body)-&gt;query()-&gt;getData();\n\n        $data = [];\n        foreach ($searchResult as $result) {\n            $item = [\n                'href' =&gt; QueryList::html($result['search_result'])-&gt;find('a')-&gt;attr('href'),\n                'text' =&gt; QueryList::html($result['search_result'])-&gt;find('a')-&gt;text()\n            ];\n            $data[] = $item;\n        }\n\n        $productJobOtherInfo = $this-&gt;productConfig-&gt;getOtherInfo();\n\n        // 下一批任务\n        $productJobConfigs = [];\n        if ($productJobOtherInfo['page'] === 1) {\n            for($i=1;$i&lt;5;$i++) {\n                $pn = $i*10;\n                $productJobConfig = [\n                    'url' =&gt; \"https://www.baidu.com/s?wd={$productJobOtherInfo['word']}&amp;pn={$pn}\",\n                    'otherInfo' =&gt; [\n                        'word' =&gt; $productJobOtherInfo['word'],\n                        'page' =&gt; $i+1\n                    ]\n                ];\n                $productJobConfigs[] = $productJobConfig;\n            }\n\n            $word = Cache::getInstance()-&gt;deQueue(self::SEARCH_WORDS);\n            if (!empty($word)) {\n                $productJobConfigs[] = [\n                    'url' =&gt; \"https://www.baidu.com/s?wd={$word}&amp;pn=0\",\n                    'otherInfo' =&gt; [\n                        'word' =&gt; $word,\n                        'page' =&gt; 1\n                    ]\n                ];\n            }\n\n        }\n\n        $result = new ProductResult();\n        $result-&gt;setProductJobConfigs($productJobConfigs)-&gt;setConsumeData($data);\n        return $result;\n    }\n\n}\nConsume\n我这里直接存文件了，可按照需求自己定制\n&lt;?php\nnamespace App\\Spider;\n\nuse EasySwoole\\Spider\\ConsumeJob;\nuse EasySwoole\\Spider\\Hole\\ConsumeAbstract;\n\nclass ConsumeTest extends ConsumeAbstract\n{\n\n    public function consume()\n    {\n        // TODO: Implement consume() method.\n        $data = $this-&gt;getJobData();\n\n        $items = '';\n        foreach ($data as $item) {\n            $items .= implode(\"\\t\", $item).\"\\n\";\n        }\n\n        file_put_contents('baidu.txt', $items, FILE_APPEND);\n    }\n}\n注册爬虫组件\npublic static function mainServerCreate(EventRegister $register)\n{\n        $spiderConfig = [\n            'product' =&gt; ProductTest::class, // 必须\n            'consume' =&gt; ConsumeTest::class, // 必须\n            'queueType' =&gt; SpiderConfig::QUEUE_TYPE_FAST_CACHE, // 通信类型默认是fast-cache不支持分布式，如需分布式可使用SpiderConfig::QUEUE_TYPE_REDIS，或者自行实现通信队列\n            'queue' =&gt; '自定义队列，如使用组件自带则不需要', // 自定义通信队列\n            'queueConfig' =&gt; '自定义队列配置，目前只有SpiderConfig::QUEUE_TYPE_REDIS需要',\n            'maxCurrency' =&gt; 128 // 最大协程并发数(单台机器)\n        ];\n        SpiderServer::getInstance()\n            -&gt;setSpiderConfig($spiderConfig)\n            -&gt;attachProcess(ServerManager::getInstance()-&gt;getSwooleServer());\n}\n投递任务\n$words = [\n    'php',\n    'java',\n    'go'\n];\n\nforeach ($words as $word) {\n    Cache::getInstance()-&gt;enQueue('SEARCH_WORDS', $word);\n}\n\n$wd = Cache::getInstance()-&gt;deQueue('SEARCH_WORDS');\n\nSpiderClient::getInstance()-&gt;addJob(\n                'https://www.baidu.com/s?wd=php&amp;pn=0',\n                [\n                    'page' =&gt; 1,\n                    'word' =&gt; $wd\n                ]\n);","link":"/Components/Spider/use.html"},{"id":234,"title":"product","content":"Product\n注意事项\n\nproduct方法返回必须返回ProductResult对象，因为ProductResult包含此次任务新产生的一批任务配置和一个消费任务数据\n\n回调方法\npublic function product():ProductResult\n{\n    // TODO: Implement product() method.\n\n    // productConfig存的就是当前任务的配置信息[\n             'url' =&gt; '',\n             'otherInfo' =&gt; '其它信息'\n         ]\n\n    $this-&gt;productConfig;\n\n    $data = '爬出来的数据';\n\n    // 下一批任务配置\n    $productJobConfigs = [\n        [\n            'url' =&gt; '',\n            'otherInfo' =&gt; '其它信息'\n        ],\n        [\n            'url' =&gt; '',\n            'otherInfo' =&gt; '其它信息'\n        ],\n    ];\n\n    $result = new ProductResult();\n    $result-&gt;setProductJobConfigs($productJobConfigs)-&gt;setConsumeData($data);\n    return $result;\n}","link":"/Components/Spider/product.html"},{"id":235,"title":"consume","content":"Consume\nproduct 生产出来的数据，会投递consume任务数据在jobData中\n&lt;?php\nnamespace App\\Spider;\n\nuse EasySwoole\\Spider\\ConsumeJob;\nuse EasySwoole\\Spider\\Hole\\ConsumeAbstract;\n\nclass ConsumeTest extends ConsumeAbstract\n{\n\n    public function consume()\n    {\n        // TODO: Implement consume() method.\n        $data = $this-&gt;getJobData();\n\n        $items = '';\n        foreach ($data as $item) {\n            $items .= implode(\"\\t\", $item).\"\\n\";\n        }\n\n        file_put_contents('baidu.txt', $items, FILE_APPEND);\n    }\n}","link":"/Components/Spider/consume.html"},{"id":236,"title":"客户端","content":"Spider客户端\n通过客户端可以向Spider服务添加要爬取的任务信息\nSpiderClient::getInstance()-&gt;addJob('https://xxxxx','其它信息’);\n支持的方法\n添加job\n    public function addJob($url, $otherInfo)\n批量添加job\n    public function addJobs(array $jobsConfig)\n    $jobsConfig = [\n      [\n        'url' =&gt; xxx,\n        'otherInfo =&gt; xxx\n      ],\n      [\n        'url' =&gt; xxx,\n        'otherInfo =&gt; xxx\n      ],\n      [\n        'url' =&gt; xxx,\n        'otherInfo =&gt; xxx\n      ]\n    ];","link":"/Components/Spider/client.html"},{"id":237,"title":"自定义通信队列","content":"自定义队列\n实现EasySwoole\\Queue\\QueueDriverInterface;接口，以组件默认的fast-cache queue为例\nnamespace EasySwoole\\Spider\\Queue;\n\nuse EasySwoole\\FastCache\\Cache;\nuse EasySwoole\\Queue\\QueueDriverInterface;\nuse EasySwoole\\Queue\\Job;\n\nclass FastCacheQueue implements QueueDriverInterface\n{\n\n    private const FASTCACHE_JOB_QUEUE_KEY='FASTCACHE_JOB_QUEUE_KEY';\n\n    function pop(float $timeout = 3):?Job\n    {\n        // TODO: Implement pop() method.\n        $job =  Cache::getInstance()-&gt;deQueue(self::FASTCACHE_JOB_QUEUE_KEY);\n        if (empty($job)) {\n            return null;\n        }\n        $job = unserialize($job);\n        if (empty($job)) {\n            return null;\n        }\n        return $job;\n    }\n\n    function push(Job $job):bool\n    {\n        // TODO: Implement push() method.\n        $res = Cache::getInstance()-&gt;enQueue(self::FASTCACHE_JOB_QUEUE_KEY, serialize($job));\n        if (empty($res)) {\n            return false;\n        }\n        return true;\n    }\n\n    public function size(): ?int\n    {\n        // TODO: Implement size() method.\n    }\n}\n\n分布式\n使用组件自带的redis通信或自定义通信方式，即可实现","link":"/Components/Spider/consumequeue.html"},{"id":238,"title":"使用","content":"u-editor(百度编辑器)组件\n一个用 EasySwoole 实现的百度富文本编辑器组件，开箱即用，用户使用几行简单的代码就可以轻松使用富文本编辑器。 \n组件要求\n\nphp: &gt;= 7.1\neasyswoole/http-client: ^1.3\n\n安装\n\ncomposer require easyswoole/u-editor\n\n仓库地址\neasyswoole/u-editor\n基本使用方法\n新增一个控制器，继承 EasySwoole\\UEditor\\UEditorController。\n&lt;?php\nnamespace App\\HttpController;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\UEditor\\UEditorController;\n\nclass UEditor extends UEditorController\n{\n\n}\n\n该控制器请求地址为:/UEditor  \n\n修改百度编辑器 ueditor.config.js =&gt; window.UEDITOR_CONFIG =&gt; serverUrl = URL + \"/UEditor\"\n如图\n即可直接使用。\n补充说明\n百度编辑器前端初始化后，会通过 ueditor.config.js 获取配置，通过获取到的服务器路径，前端就可以去请求，请求格式为：服务器路径 + &quot;?action=操作方法&quot;。\n前端请求路径示例：http://127.0.0.1:9501/UEditor?action=config&amp;&amp;noCache=1587973402520   \n前端请求之后，将通过 UEditorController 的 index 方法进行识别 action，转发到不同的请求逻辑上，实现百度编辑器的后端接口。\n自定义使用方法\n在 EasySwoole\\UEditor\\UEditorController 控制器中，有默认的实现方法，如果你需要修改配置，可以通过重写控制器方法进行修改，实现自定义配置。\n保存路径\n默认保存路径为 EASYSWOOLE_ROOT . '/Static'。可通过属性继承 $rootPath 来修改默认的保存路径。\n权限控制实现\n本组件默认控制器的实现是继承 EasySwoole\\Http\\AbstractInterface\\Controller，如果你有需要登录用户上传等权限验证的需求，可以直接复制 EasySwoole\\UEditor\\UEditorController 里面的代码，然后重新实现自定义控制器并继承 EasySwoole\\Http\\AbstractInterface\\Controller，然后重写控制器的方法，即可实现权限控制。","link":"/Components/uEditor.html"},{"id":239,"title":"使用","content":"code-generation 2.x (代码生成组件)\nEasySwoole 代码生成组件，使用命令行就可以一键生成业务通用代码，支持生成的代码如下：\n\n一键生成 项目初始化 baseController、baseModel、baseUnitTest；\n一键生成 表 Model，自带属性注释；\n一键生成 表 curd 控制器，自带 5 个 curd 方法；\n一键生成 控制器单元测试用例，测试 5 个 curd 方法。\n\n组件版本说明\ncode-generation 组件当前最新稳定版本为 2.x，code-generation 2.x 相对于 1.x 版本，兼容了 EasySwoole 的最新注解组件，支持了新的 EasySwoole 文档自动生成，以及最新的 phpunit 版本，同时完善了 Model-&gt;getList 返回参数，以及控制器 getOne、getList 的 response 参数注解。\n\n注：code-generation 1.x 版本组件文档详见 code-generation 1.x\n\n组件要求\n\neasyswoole/trigger: ^1.0\neasyswoole/socket: ^1.0\neasyswoole/orm: ^1.4\nnette/php-generator: ^3.2\neasyswoole/http-annotation: ^1.4\nphp-curl-class/php-curl-class: ^8.5\neasyswoole/command: ^1.1\n\n安装方法\n\ncomposer require easyswoole/code-generation=2.x\n\n仓库地址\neasyswoole/code-generation 2.x\n基本使用\n配置文件 dev.php 配置如下：\n&lt;?php\nreturn [\n    'SERVER_NAME' =&gt; \"EasySwoole\",\n    'MAIN_SERVER' =&gt; [\n        'LISTEN_ADDRESS' =&gt; '0.0.0.0',\n        'PORT' =&gt; 9501,\n        'SERVER_TYPE' =&gt; EASYSWOOLE_WEB_SERVER, //可选为 EASYSWOOLE_SERVER  EASYSWOOLE_WEB_SERVER EASYSWOOLE_WEB_SOCKET_SERVER\n        'SOCK_TYPE' =&gt; SWOOLE_TCP,\n        'RUN_MODEL' =&gt; SWOOLE_PROCESS,\n        'SETTING' =&gt; [\n            'worker_num' =&gt; 8,\n            'reload_async' =&gt; true,\n            'max_wait_time' =&gt; 3\n        ],\n        'TASK' =&gt; [\n            'workerNum' =&gt; 4,\n            'maxRunningNum' =&gt; 128,\n            'timeout' =&gt; 15\n        ]\n    ],\n    'TEMP_DIR' =&gt; null,\n    'LOG_DIR' =&gt; null,\n    'MYSQL' =&gt; [\n        'host'          =&gt; '127.0.0.1',\n        'port'          =&gt; 3306,\n        'user'          =&gt; 'easyswoole',\n        'timeout'       =&gt; 5,\n        'charset'       =&gt; 'utf8mb4',\n        'password'      =&gt; 'easyswoole100%',\n        'database'      =&gt; 'easyswoole',\n        'maxObjectNum'  =&gt; 20,\n        'minObjectNum'  =&gt; 5,\n        'getObjectTimeout'  =&gt; 3.0,\n    ]\n];\n在项目根目录新建一个 TestCodeGeneration.php，代码内容如下：\n&lt;?php\n\ninclude __DIR__ . \"/vendor/autoload.php\";\n\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n\ngo(function () {\n    // 生成基础类\n    $generation = new \\EasySwoole\\CodeGeneration\\InitBaseClass\\Controller\\ControllerGeneration();\n    $generation-&gt;generate();\n    $generation = new \\EasySwoole\\CodeGeneration\\InitBaseClass\\UnitTest\\UnitTestGeneration();\n    $generation-&gt;generate();\n    $generation = new \\EasySwoole\\CodeGeneration\\InitBaseClass\\Model\\ModelGeneration();\n    $generation-&gt;generate();\n\n    // 获取 dev.php 中的 MYSQL 配置文件，配置文件具体说明请看：https://www.easyswoole.com/QuickStart/config.html\n    $mysqlConfig = new \\EasySwoole\\ORM\\Db\\Config(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n\n    // 获取数据库连接\n    $connection = new \\EasySwoole\\ORM\\Db\\Connection($mysqlConfig);\n\n    // 指定表名(这里以 user_list 表作为示例表，表结构请看下文)\n    $tableName = 'user_list';\n    $codeGeneration = new EasySwoole\\CodeGeneration\\CodeGeneration($tableName, $connection);\n\n    // 生成 model (默认生成模型的路径前缀为 App\\Model 目录，例如：如下生成的模型文件为 User模型【\\App\\Model\\User\\UserModel.php】 和 基础模型【\\App\\Model\\User\\BaseModel.php】)\n    $codeGeneration-&gt;generationModel(\"\\\\User\");\n\n    // 生成 controller (默认生成控制器的路径前缀为 App\\HttpController 目录，例如：如下生成的控制器文件为 User控制器【\\App\\Model\\Api\\User\\User.php】 和 基础控制器【\\App\\HttpController\\Api\\Base.php】)\n    $codeGeneration-&gt;generationController(\"\\\\Api\\\\User\", null);\n\n    // 生成 unitTest (默认生成 unitTest 的路径前缀为项目根目录的 UnitTest 目录，例如：如下生成的单元测试用例为 UserTest【UnitTest\\Api\\User\\UserTest.php】 和 基础单元测试用例【UnitTest\\BaseTest.php】)\n    $codeGeneration-&gt;generationUnitTest(\"\\\\Api\\\\User\", null);\n});\n在配置好数据库和数据库配置文件之后，然后在项目根目录运行 TestCodeGeneration.php(php TestCodeGeneration.php)，即可看到自动生成的模型、控制器和单元测试用例。\nEasySwoole\\CodeGeneration\\CodeGeneration 方法可自行查看，代码很简单。\n示例表结构(user_list)\nCREATE TABLE `user_list` (\n  `id` int(11) NOT NULL,\n  `name` varchar(50) DEFAULT NULL,\n  `age` int(11) DEFAULT NULL,\n  `email` varchar(100) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n命令行使用\n由于命令行特殊的特性，命令行功能支持并不完善，如果想要体验全部功能，请使用 \\EasySwoole\\CodeGeneration\\CodeGeneration 生成，或参考 \\EasySwoole\\CodeGeneration\\CodeGeneration 代码生成。\n注册命令\n配置数据库配置文件 dev.php，配置文件内容详见上文。\n在 EasySwoole 项目根目录中的 bootstrap.php(即 bootstrap事件) 中使用 Di 注入配置项:\n&lt;?php\n// 全局bootstrap事件\ndate_default_timezone_set('Asia/Shanghai');\n\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n\n## 1 直接注入 mysql 连接\n// 获取 dev.php 中的 MYSQL 配置文件，配置文件具体说明请看：https://www.easyswoole.com/QuickStart/config.html\n$mysqlConfig = new \\EasySwoole\\ORM\\Db\\Config(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n// 获取连接\n$connection = new \\EasySwoole\\ORM\\Db\\Connection($mysqlConfig);\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.connection', $connection);\n\n## 2 直接注入 mysql 配置对象\n//   $mysqlConfig = new \\EasySwoole\\ORM\\Db\\Config(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n//   \\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.connection', $mysqlConfig);\n\n## 3 直接注入 mysql 配置项\n//   \\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.connection',\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n\n// 以上 3 种注入 mysql 连接的方式均可，用户可以任选 1 种进行注入 mysql\n\n// 注入执行目录项，后面的为默认值，initClass 不能通过注入改变目录\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.modelBaseNameSpace', \"App\\\\Model\");\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.controllerBaseNameSpace', \"App\\\\HttpController\");\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.unitTestBaseNameSpace', \"UnitTest\");\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.rootPath', getcwd());\n然后即可使用命令实现自动生成代码，具体使用命令如下（使用如下命令前提：必须先在 bootstrap事件 中使用 Di 注册上述说明的配置项）：\nphp ./vendor/bin/code-generator\n ______                          _____                              _\n|  ____|                        / ____|                            | |\n| |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___\n|  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n| |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n|______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                         __/ |\n                        |___/\n\nCode auto generation tool\nUsage:\n  ./vendor/bin/code-generator ACTION [--opts ...]\nActions:\n  init  initialization\n  all   specify build\nOptions:\n  --tableName       specify table name\n  --modelPath       specify model path\n  --controllerPath  specify controller path\n  --unitTestPath    specify unit-test path\n\nphp ./vendor/bin/code-generator all --tableName=\"tableName\" --modelPath=\"生成的模型所在目录\" [--controllerPath=\"生成的控制器所在目录\"] [--unitTestPath=\"生成的单元测试用例所在目录\"]\n\n// 生成基础模型(BaseModel)、基础控制器(BaseController)、基础单元测试用例(BaseUnitTest)\nphp ./vendor/bin/code-generator init\n\n// 自动生成指定的模型、控制器、单元测试用例和 基础模型、基础控制器、基础单元测试用例\nphp vendor/bin/code-generator all --tableName=\"user_list\" --modelPath=\"\\\\User\" --controllerPath=\"\\\\Api\\\\User\" --unitTestPath=\"\\\\User\"\n执行结果示例如下：\n[root@localhost es-code-generation]# php ./vendor/bin/code-generator init\n┌────────────┬─────────────────────────────────────────────────────────────────────┐\n│ className  │                              filePath                               │\n├────────────┼─────────────────────────────────────────────────────────────────────┤\n│ Model      │ /www/wwwroot/easyswoole-code-generation/App/Model/BaseModel.php     │\n├────────────┼─────────────────────────────────────────────────────────────────────┤\n│ Controller │ /www/wwwroot/easyswoole-code-generation/App/HttpController/Base.php │\n├────────────┼─────────────────────────────────────────────────────────────────────┤\n│ UnitTest   │ /www/wwwroot/easyswoole-code-generation/UnitTest/BaseTest.php       │\n└────────────┴─────────────────────────────────────────────────────────────────────┘\n\n[root@localhost es-code-generation]# php ./vendor/bin/code-generator all --tableName=\"user_list\" --modelPath=\"\\\\User\" --controllerPath=\"\\\\Api\\\\User\" --unitTestPath=\"\\\\User\"\n┌────────────┬──────────────────────────────────────────────────────────────────────────────┐\n│ className  │                                   filePath                                   │\n├────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ Model      │ /www/wwwroot/easyswoole-code-generation/App/Model/User/UserModel.php         │\n├────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ Controller │ /www/wwwroot/easyswoole-code-generation/App/HttpController/Api/User/User.php │\n├────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ UnitTest   │ /www/wwwroot/easyswoole-code-generation/UnitTest/User/UserTest.php           │\n└────────────┴──────────────────────────────────────────────────────────────────────────────┘\n\n独立使用\n生成器流程说明\n\n通过 \\EasySwoole\\ORM\\Utility\\TableObjectGeneration，传入 \\EasySwoole\\ORM\\Db\\Connection 连接对象，通过 generationTable 方法获取表结构对象；\n实例化类生成器配置，配置命名空间、生成文件路径、类名等(详情看下面)；\n实例化生成器对象，调用 generate方法生成。\n\n生成器基础配置项\n\n\nextendClass 继承类，默认为\\EasySwoole\\ORM\\AbstractModel::class\n\ndirectory 生成路径,生成路径默认为 rootPath+namespace对应路径,namespace路径将自动通过composer.json-&gt;(autoload/autoload-dev)['psr-4'] 配置目录生成,如果没有则默认为根目录\nnamespace 命名空间配置.\nclassName 类名\nrootPath 项目根目录,默认为执行目录.\n\n获取数据表结构\n所有生成器都依赖于数据表结构对象EasySwoole\\ORM\\Utility\\Schema\\Table\n&lt;?php\n$mysqlConfig = new \\EasySwoole\\ORM\\Db\\Config(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n//获取连接\n$connection = new \\EasySwoole\\ORM\\Db\\Connection($mysqlConfig);\n$tableName = 'user_list';\n//获取数据表结构对象\n$tableObjectGeneration = new \\EasySwoole\\ORM\\Utility\\TableObjectGeneration($connection, $tableName);\n$schemaInfo = $tableObjectGeneration-&gt;generationTable();\n\nModel生成\nModel配置项说明\n\nextendClass 继承类,默认为\\EasySwoole\\ORM\\AbstractModel::class\n\ndirectory 生成路径,生成路径默认为 rootPath+namespace对应路径,namespace路径将自动通过composer.json-&gt;(autoload/autoload-dev)['psr-4'] 配置目录生成,如果没有则默认为根目录\nnamespace 命名空间配置.默认为 App\\Model\n\nclassName 类名,Model配置无效,强制为realTableName+fileSuffix\n\nrootPath 项目根目录,默认为执行目录.\ntablePre 表前缀,如果有配置,es_user 表=&gt; UserModel\ntable 表结构对象\nrealTableName 真实表名,通过下划线形式转为大驼峰,自动转化.用于生成最后的类名和文件名.\nfileSuffix 文件后缀,默认为Model,用于生成最后的类名和文件名.\nignoreString 默认为['list', 'log'], //生成时忽略表名存在的字符,例如user_list将生成=&gt;UserModel\n\nModel生成示例:\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: tioncico\n * Date: 2020-05-20\n * Time: 10:26\n */\ninclude \"./vendor/autoload.php\";\n\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n\ngo(function () {\n    $mysqlConfig = new \\EasySwoole\\ORM\\Db\\Config(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n    //获取连接\n    $connection = new \\EasySwoole\\ORM\\Db\\Connection($mysqlConfig);\n    $tableName = 'user_list';\n    //获取数据表结构对象\n    $tableObjectGeneration = new \\EasySwoole\\ORM\\Utility\\TableObjectGeneration($connection, $tableName);\n    $schemaInfo = $tableObjectGeneration-&gt;generationTable();\n\n    $tablePre = '';//表前缀\n    $path = \"App\\\\Model\";\n    $extendClass = \\EasySwoole\\ORM\\AbstractModel::class;\n    $modelConfig = new \\EasySwoole\\CodeGeneration\\ModelGeneration\\ModelConfig($schemaInfo, $tablePre, \"{$path}\", $extendClass);\n    $modelConfig-&gt;setRootPath(EASYSWOOLE_ROOT);//设置项目运行目录,默认为当前执行脚本目录.\n    $modelConfig-&gt;setIgnoreString(['list', 'log']);//生成时忽略表名存在的字符,例如user_list将生成=&gt;UserModel\n\n    $modelGeneration = new \\EasySwoole\\CodeGeneration\\ModelGeneration\\ModelGeneration($modelConfig);\n    $result = $modelGeneration-&gt;generate();\n    var_dump($result);//生成成功返回生成文件路径,否则返回false\n});\nModel方法\nModel方法默认生成一个GetList方法,用于获取列表.\n&lt;?php\npublic function getList(int $page = 1, int $pageSize = 10, string $field = '*'): array\n{\n    $list = $this\n        -&gt;withTotalCount()\n        -&gt;order($this-&gt;schemaInfo()-&gt;getPkFiledName(), 'DESC')\n        -&gt;field($field)\n        -&gt;page($page, $pageSize)\n        -&gt;all();\n    $total = $this-&gt;lastQueryResult()-&gt;getTotalCount();;\n    return ['total' =&gt; $total, 'list' =&gt; $list];\n}\n\n可参考EasySwoole\\CodeGeneration\\ModelGeneration\\Method\\GetList自定义其他方法.再进行注入即可.\n","link":"/Components/codeGeneration_2.x.html"},{"id":240,"title":"使用","content":"Oauth\nOAuth在&quot;客户端&quot;与&quot;服务提供商&quot;之间，设置了一个授权层（authorization layer）。&quot;客户端&quot;不能直接登录&quot;服务提供商&quot;，只能登录授权层，以此将用户与客户端区分开来。&quot;客户端&quot;登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。\n需要用户自行补充oauth的认证流程，方便自己更加快速的接入。\n安装\n请在EasySwoole根目录下执行以下命令\n\ncomposer require easyswoole/o-auth\n\n详情\n根据Oauth协议，分别有如下调用方法。\n\n\ngetAuthUrl() 获取授权地址\n\ngetAccessToken($storeState = null, $state = null, $code = null) 获取AccessToken（只返回access_token）\n\ngetAccessTokenResult() 执行getAccessToken方法后，此方法获取原结果\n\ngetUserInfo(string $accessToken) 获取用户信息\n\nvalidateAccessToken(string $accessToken) 验证token是否有效\n\nrefreshToken(string $refreshToken = null) 刷新token 返回bool\n\n\ngetRefreshTokenResult() 执行refreshToken方法后，此方法获取原结果\n\n示例代码\n微信\nclass WeiXin extends \\EasySwoole\\Http\\AbstractInterface\\Controller\n{\n    public function index()\n    {\n        $config = new \\EasySwoole\\OAuth\\WeiXin\\Config();\n        $config-&gt;setAppId('appid');\n        $config-&gt;setState('easyswoole');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        $oauth = new \\EasySwoole\\OAuth\\WeiXin\\OAuth($config);\n        $url = $oauth-&gt;getAuthUrl();\n\n        return $this-&gt;response()-&gt;redirect($url);\n    }\n\n    public function callback()\n    {\n        $params = $this-&gt;request()-&gt;getQueryParams();\n\n        $config = new \\EasySwoole\\OAuth\\WeiXin\\Config();\n        $config-&gt;setAppId('appid');\n        $config-&gt;setSecret('secret');\n        $config-&gt;setOpenIdMode(\\EasySwoole\\OAuth\\WeiXin\\Config::OPEN_ID); // 可设置UNION_ID 默认为OPEN_ID\n\n        $oauth = new \\EasySwoole\\OAuth\\WeiXin\\OAuth($config);\n        $accessToken = $oauth-&gt;getAccessToken('easyswoole', $params['state'], $params['code']);\n        $refreshToken = $oauth-&gt;getAccessTokenResult()['refresh_token'];\n\n        $userInfo = $oauth-&gt;getUserInfo($accessToken);\n        var_dump($userInfo);\n\n        if (!$oauth-&gt;validateAccessToken($accessToken)) echo 'access_token 验证失败！' . PHP_EOL;\n\n        if (!$oauth-&gt;refreshToken($refreshToken)) echo 'access_token 续期失败！' . PHP_EOL;\n\n    }\n}\nQQ\nclass QQ extends \\EasySwoole\\Http\\AbstractInterface\\Controller\n{\n    public function index()\n    {\n        $config = new \\EasySwoole\\OAuth\\QQ\\Config();\n        $config-&gt;setAppId('appid');\n        $config-&gt;setState('easyswoole');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        $oauth = new \\EasySwoole\\OAuth\\QQ\\OAuth($config);\n        $url = $oauth-&gt;getAuthUrl();\n\n        return $this-&gt;response()-&gt;redirect($url);\n    }\n\n    public function callback()\n    {\n        $params = $this-&gt;request()-&gt;getQueryParams();\n\n        $config = new \\EasySwoole\\OAuth\\QQ\\Config();\n        $config-&gt;setAppId('appid');\n        $config-&gt;setAppKey('appkey');\n        $config-&gt;setRedirectUri('redirect_uri');\n        $config-&gt;setOpenIdMode(\\EasySwoole\\OAuth\\QQ\\Config::OPEN_ID); // 可设置UNION_ID 默认为OPEN_ID\n\n        $oauth = new \\EasySwoole\\OAuth\\QQ\\OAuth($config);\n        $accessToken = $oauth-&gt;getAccessToken('easyswoole', $params['state'], $params['code']);\n        $refreshToken = $oauth-&gt;getAccessTokenResult()['refresh_token'];\n\n        $userInfo = $oauth-&gt;getUserInfo($accessToken);\n        var_dump($userInfo);\n\n        if (!$oauth-&gt;validateAccessToken($accessToken)) echo 'access_token 验证失败！' . PHP_EOL;\n\n        if (!$oauth-&gt;refreshToken($refreshToken)) echo 'access_token 续期失败！' . PHP_EOL;\n\n    }\n}\n微博\nclass Weibo extends \\EasySwoole\\Http\\AbstractInterface\\Controller\n{\n    public function index()\n    {\n        $config = new \\EasySwoole\\OAuth\\Weibo\\Config();\n        $config-&gt;setClientId('clientid');\n        $config-&gt;setState('easyswoole');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        $oauth = new \\EasySwoole\\OAuth\\Weibo\\OAuth($config);\n        $url = $oauth-&gt;getAuthUrl();\n\n        return $this-&gt;response()-&gt;redirect($url);\n    }\n\n    public function callback()\n    {\n        $params = $this-&gt;request()-&gt;getQueryParams();\n\n        $config = new \\EasySwoole\\OAuth\\Weibo\\Config();\n        $config-&gt;setClientId('clientid');\n        $config-&gt;setClientSecret('secret');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        $oauth = new \\EasySwoole\\OAuth\\Weibo\\OAuth($config);\n        $accessToken = $oauth-&gt;getAccessToken('easyswoole', $params['state'], $params['code']);\n\n        $userInfo = $oauth-&gt;getUserInfo($accessToken);\n        var_dump($userInfo);\n\n        if (!$oauth-&gt;validateAccessToken($accessToken)) echo 'access_token 验证失败！' . PHP_EOL;\n    }\n}\n支付宝\nclass AliPay extends \\EasySwoole\\Http\\AbstractInterface\\Controller\n{\n    public function index()\n    {\n        $config = new \\EasySwoole\\OAuth\\AliPay\\Config();\n        $config-&gt;setState('easyswoole');\n        $config-&gt;setAppId('appid');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        // 使用沙箱环境测试开发的时候 把OAuth的源码文件里面的 API_DOMAIN 和 AUTH_DOMAIN 进行修改\n        $oauth = new \\EasySwoole\\OAuth\\AliPay\\OAuth($config);\n        $url = $oauth-&gt;getAuthUrl();\n        return $this-&gt;response()-&gt;redirect($url);\n    }\n\n    public function callback()\n    {\n        $params = $this-&gt;request()-&gt;getQueryParams();\n\n        $config = new \\EasySwoole\\OAuth\\AliPay\\Config();\n        $config-&gt;setAppId('appid');\n//        $config-&gt;setAppPrivateKey('私钥');\n        $config-&gt;setAppPrivateKeyFile('私钥文件'); // 私钥文件(非远程) 此方法与上个方法二选一\n\n        $oauth = new \\EasySwoole\\OAuth\\AliPay\\OAuth($config);\n        $accessToken = $oauth-&gt;getAccessToken('easyswoole', $params['state'], $params['auth_code']);\n        $refreshToken = $oauth-&gt;getAccessTokenResult()['alipay_system_oauth_token_response']['refresh_token'];\n\n        $userInfo = $oauth-&gt;getUserInfo($accessToken);\n        var_dump($userInfo);\n\n        if (!$oauth-&gt;validateAccessToken($accessToken)) echo 'access_token 验证失败！' . PHP_EOL;\n        var_dump($oauth-&gt;getAccessTokenResult());\n\n        if (!$oauth-&gt;refreshToken($refreshToken)) echo 'access_token 续期失败！' . PHP_EOL;\n        var_dump($oauth-&gt;getRefreshTokenResult());\n    }\n}\nGithub\nclass Github extends \\EasySwoole\\Http\\AbstractInterface\\Controller\n{\n    public function index()\n    {\n        $config = new \\EasySwoole\\OAuth\\Github\\Config();\n        $config-&gt;setClientId('clientid');\n        $config-&gt;setRedirectUri('redirect_uri');\n        $config-&gt;setState('easyswoole');\n        $oauth = new \\EasySwoole\\OAuth\\Github\\OAuth($config);\n        $this-&gt;response()-&gt;redirect($oauth-&gt;getAuthUrl());\n    }\n\n    public function callback()\n    {\n        $params = $this-&gt;request()-&gt;getQueryParams();\n        $config = new \\EasySwoole\\OAuth\\Github\\Config();\n        $config-&gt;setClientId('clientid');\n        $config-&gt;setClientSecret('secret');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        $oauth = new \\EasySwoole\\OAuth\\Github\\OAuth($config);\n        $accessToken = $oauth-&gt;getAccessToken('easyswoole', $params['state'], $params['code']);\n        $userInfo = $oauth-&gt;getUserInfo($accessToken);\n        var_dump($userInfo);\n\n        if (!$oauth-&gt;validateAccessToken($accessToken)) echo 'access_token 验证失败！' . PHP_EOL;\n    }\n}\nGitee\nclass Gitee extends \\EasySwoole\\Http\\AbstractInterface\\Controller\n{\n    public function index()\n    {\n        $config = new \\EasySwoole\\OAuth\\Gitee\\Config();\n        $config-&gt;setState('easyswoole');\n        $config-&gt;setClientId('clientid');\n        $config-&gt;setRedirectUri('redirect_uri');\n        $oauth = new \\EasySwoole\\OAuth\\Gitee\\OAuth($config);\n        $this-&gt;response()-&gt;redirect($oauth-&gt;getAuthUrl());\n    }\n\n    public function callback()\n    {\n        $params = $this-&gt;request()-&gt;getQueryParams();\n\n        $config = new \\EasySwoole\\OAuth\\Gitee\\Config();\n        $config-&gt;setClientId('client_id');\n        $config-&gt;setClientSecret('secret');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        $oauth = new \\EasySwoole\\OAuth\\Gitee\\OAuth($config);\n        $accessToken = $oauth-&gt;getAccessToken('easyswoole', $params['state'], $params['code']);\n        $userInfo = $oauth-&gt;getUserInfo($accessToken);\n        var_dump($userInfo);\n\n        if (!$oauth-&gt;validateAccessToken($accessToken)) echo 'access_token 验证失败！' . PHP_EOL;\n        var_dump($oauth-&gt;getAccessTokenResult());\n    }\n}","link":"/Components/oauth.html"},{"id":241,"title":"使用","content":"OSS云存储\n安装\n\ncomposer require easyswoole/oss\n\n阿里云调用\n根据阿里云官方sdk修改,全部方法都一致,走通了所有官方的client请求类单元测试,全部调用方法都和阿里云一致\n文档可查看阿里云官方文档:https://help.aliyun.com/document_detail/32099.html?spm=a2c4g.11186623.2.17.de715d26YNLCah#concept-32099-zh\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/11/20 0020\n * Time: 15:28\n */\ninclude \"./vendor/autoload.php\";\ninclude \"./phpunit.php\";\n\ngo(function (){\n\n    $config = new \\EasySwoole\\Oss\\AliYun\\Config([\n        'accessKeyId'     =&gt; ACCESS_KEY_ID,\n        'accessKeySecret' =&gt; ACCESS_KEY_SECRET,\n        'endpoint'        =&gt; END_POINT,\n    ]);\n    $client = new \\EasySwoole\\Oss\\AliYun\\OssClient($config);\n    $data = $client-&gt;putObject('tioncicoxyz','test',__FILE__);\n    var_dump($data);\n});\n部分方法没走通单元测试\n由于有些方法可能是测试环境问题,未走通,可能出现问题(一般不会有问题),需要大家注意\n列出走不通单元测试的方法,以供大家参考:\n\naddBucketCname 提示: NoSuchCnameInRecord: No such cname be found in record\ntestDeleteCname 提示: CnameDenied: The cname belongs to another user.\n\n以下2个方法为callback走不通,应该不影响\n\n\\EasySwoole\\Oss\\Tests\\AliYun\\CallbackTest::testMultipartUploadCallbackNormal 提示: CallbackFailed: Response body is not valid json format.\n\\EasySwoole\\Oss\\Tests\\AliYun\\CallbackTest::testPutObjectCallbackNormal 走不通 \n\nSymlink 类方法全走不通,应该不影响,提示: bucket is not allowed empty或者The specified key does not exist.\n七牛云调用\n根据七牛云官方sdk修改,走通了oss的大部分单元测试,用法和七牛云oss完全一致\n操作文档可直接查看七牛云官方文档 https://developer.qiniu.com/kodo/sdk/1241/php\ninclude \"../../vendor/autoload.php\";\ninclude \"../../phpunit.php\";\ngo(function (){\n\n    $auth = new \\EasySwoole\\Oss\\QiNiu\\Auth(QINIU_ACCESS_KEY,QINIU_SECRET_KEY);\n\n    $key = 'formPutFileTest';\n    $token = $auth-&gt;uploadToken('tioncico', $key);\n    $upManager = new \\EasySwoole\\Oss\\QiNiu\\Storage\\UploadManager();\n    list($ret, $error) = $upManager-&gt;putFile($token, $key, __file__, null, 'text/plain', null);\n    var_dump($ret,$error);\n});\n部分方法没走通单元测试\n由于某些可能是测试环境问题,有部分方法未走通单元测试,需要大家注意,列出走不通的单元测试的方法,以供大家参考\n\n\\EasySwoole\\Oss\\Tests\\QiNiu\\BucketTest::testPrefetch 未走通,提示:{&quot;error&quot;:&quot;bucket source not set&quot;}\nPfopTest 类方法未走通,提示{&quot;error&quot;:&quot;no such bucket&quot;} \n\\EasySwoole\\Oss\\Tests\\QiNiu\\ResumeUpTest::test4ML2 方法未走通,一直卡住,不建议使用该方法上传文件,请使用 \\EasySwoole\\Oss\\Tests\\QiNiu\\ResumeUpTest::test4ML  方法上传\n\n七牛云设置超时\n官方sdk没有设置超时的逻辑,在本组件中新增加了,设置方法如下:\n\\EasySwoole\\Oss\\QiNiu\\Config::setTimeout(3);\n\\EasySwoole\\Oss\\QiNiu\\Config::setConnectTimeout(5);\n腾讯云调用\n腾讯云调用和原来的方法基本一致,操作文档可直接查看腾讯云官方文档:https://cloud.tencent.com/document/product/436/12266\n&lt;?php\ninclude \"../../vendor/autoload.php\";\ninclude \"../../phpunit2.php\";\ngo(function (){\n//config配置\n    $config = new \\EasySwoole\\Oss\\Tencent\\Config([\n        'appId'     =&gt; TX_APP_ID,\n        'secretId'  =&gt; TX_SECRETID,\n        'secretKey' =&gt; TX_SECRETKEY,\n        'region'    =&gt; TX_REGION,\n        'bucket'    =&gt; TX_BUCKET,\n    ]);\n    //new客户端\n    $cosClient = new \\EasySwoole\\Oss\\Tencent\\OssClient($config);\n\n    $key = '你好111.txt';\n    //生成一个文件数据\n    $body = generateRandomString(2 * 1024  + 1023);\n    //上传\n    $cosClient-&gt;upload($bucket = TX_BUCKET,\n        $key = $key,\n        $body = $body,\n        $options = ['PartSize' =&gt; 1024 + 1]\n    );\n    //获取文件内容\n    $rt = $cosClient-&gt;getObject(['Bucket' =&gt; TX_BUCKET, 'Key' =&gt; $key]);\n    var_dump($rt['Body']-&gt;__toString());\n});\n\nfunction generateRandomString($length = 10)\n{\n    $characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    $randomString = '';\n    for ($i = 0; $i &lt; $length; $i++) {\n        $randomString .= $characters[rand(0, strlen($characters) - 1)];\n    }\n    return $randomString;\n}\n补充\n大部分方法已经兼容,使用方法和腾讯云官方完全一致,但还有些注意事项:\n\n上传文件使用了SplStream 作为流文件管理\n下载文件使用了SplStream 作为流文件管理(上面的$rt['Body']就是SplStream对象)\n\n部分方法没走通单元测试\n由于腾讯云sdk使用了guzzle 库,改动非常麻烦,所以有部分单元测试没通过,具体方法如下,希望大家注意:\n\nPutBucketAcl 方法,相关的单元测试全部提示Access Denied.(官方sdk也这个提示)\ncopy 方法,小文件提示You have no authority to read the source file  大文件直接无法走通无法使用(官方sdk也走不通)\n","link":"/Components/oss.html"},{"id":242,"title":"安装","content":"微信SDK EasySwoole WeChat\nEasySwoole WeChat 是一个基于 Swoole 4.x 全协程支持的微信SDK库，告别同步阻塞，轻松编写高性能的微信公众号/小程序/开放平台业务接口。\n组件要求\n\nphp &gt;= 7.1.0\neasyswoole/component &gt;= 1.0\neasyswoole/spl &gt;= 1.3.7\neasyswoole/http-client ^1.0\neasyswoole/utility&quot; ^1.0\n\n安装方法\n\ncomposer require easyswoole/wechat\n\n仓库地址\neasyswoole/wechat","link":"/Components/WeChat/install.html"},{"id":243,"title":"公众号","content":"公众号\n\n相关连接地址：\n\n\n腾讯公众号文档\n\n\n微信公众号沙箱\n\n\n组件Demo(建议查看一遍)\n\n\n注：微信SDK文档右侧类目表与腾讯微信公众号文档基本对应\n\n基本使用\n异常捕获\n在调用方法时，如果传递了无效的参数或者发生网络异常，将会抛出EasySwoole\\WeChat\\Exception\\RequestError 或者 EasySwoole\\WeChat\\Exception\\OfficialAccountError 类型的异常，开发者需要手工捕获该类异常进行处理，类似这样：\nuse EasySwoole\\WeChat\\Exception\\RequestError;\nuse EasySwoole\\WeChat\\Exception\\OfficialAccountError;\n\ntry {\n  $wechat-&gt;officialAccount()-&gt;ipList();\n} catch (RequestError $requestError){\n\n} catch (OfficialAccountError $error){\n\n}\n配置公众号\n在EasySwooleEvent.php文件的mainServerCreate方法内设置相关微信公众号或微信开放平台的AppId、AppSecret、Token、AesKey和缓存目录。\n\n对象方式配置\n\nuse EasySwoole\\WeChat\\WeChat;\n\n// 获取WeChat配置实例\n$weChatConfig = new \\EasySwoole\\WeChat\\Config();\n// 设置全局缓存目录\n$weChatConfig-&gt;setTempDir(Config::getInstance()-&gt;getConf('TEMP_DIR'));\n\n// 方式一\n$weChatConfig-&gt;officialAccount()-&gt;setAppId('you appId');\n$weChatConfig-&gt;officialAccount()-&gt;setAppSecret('you appSecret');\n$weChatConfig-&gt;officialAccount()-&gt;setToken('you token');\n$weChatConfig-&gt;officialAccount()-&gt;setAesKey('you AesKey');    \n\n// 获取WeChat实例，后续相关操作需要依靠该实例\n$weChat = new WeChat($weChatConfig);\n\n数组方式配置\n\nuse EasySwoole\\WeChat\\WeChat;\n\n// 获取WeChat配置实例\n$weChatConfig = new \\EasySwoole\\WeChat\\Config();\n// 设置全局缓存目录\n$weChatConfig-&gt;setTempDir(Config::getInstance()-&gt;getConf('TEMP_DIR'));\n\n// 方式二\n$configArray = [\n  'appId'     =&gt; 'you appId',\n  'appSecret' =&gt; 'you appSecret',\n  'token'     =&gt; 'you token',\n  'AesKey'    =&gt; 'you AesKey',\n];\n$weChatConfig-&gt;officialAccount($configArray);\n\n// 获取WeChat实例，后续相关操作需要依靠该实例\n$weChat = new WeChat($weChatConfig);\n\n开放平台配置\n\nuse EasySwoole\\WeChat\\WeChat;\n\n// 获取WeChat配置实例\n$weChatConfig = new \\EasySwoole\\WeChat\\Config();\n// 设置全局缓存目录\n$weChatConfig-&gt;setTempDir(Config::getInstance()-&gt;getConf('TEMP_DIR'));\n\n// 开放平台注册\n$configArray = [\n  'componentAppId'     =&gt; 'you componentAppId',\n  'componentAppSecret' =&gt; 'you componentAppSecret',\n  'token'                    =&gt; 'you token',\n  'aesKey'                   =&gt; 'you aesKey',\n];\n$weChatConfig-&gt;openPlatform($configArray);\n\n// 获取WeChat实例，后续相关操作需要依靠该实例\n$weChat = new WeChat($weChatConfig);\n注册及使用\n微信SDK在EasySwoole中使用需要将WeChat实例注册到全局List中，这样后续的编程只需要在任意地方去获取WeChat实例即可。\n\n\n创建管理类WeChatManager\n根据需求自行选择文件存放位置（示例是存放在/App/WeChat目录中）\n&lt;?php\n\nnamespace App\\WeChat;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\WeChat\\WeChat;\nuse RuntimeException;\n\n/**\n * Class WeChatManager\n * @package App\\WeChat\n */\nclass WeChatManager\n{\n// 单例化 进程内共享\nuse Singleton;\n\n/**\n * @var array 存储全部WeChat对象\n */\n    private $weChatList = [];\n\n/**\n * 注册WeChat实例\n * @param string $name  实例名称\n * @param WeChat $weChat WeChat实例对象\n */\n    public function register(string $name, WeChat $weChat): void\n    {\n        if (!isset($this-&gt;weChatList[$name])) {\n        $this-&gt;weChatList[$name] = $weChat;\n        } else {\n            throw new RuntimeException('重复注册weChat.');\n        }\n    }\n\n/**\n * 获取WeChat实例\n * @param string $name 实例名称-传入该参数获取对应实例\n *\n * @return WeChat 返回WeChat实例对象\n */\n    public function weChat(string $name): WeChat\n    {\n        if (isset($this-&gt;weChatList[$name])) {\n            return $this-&gt;weChatList[$name];\n        }\n\n        throw new RuntimeException('not found weChat name');\n    }\n}\n\n\n注册WeChat对象到WeChatManager\n在EasySwooleEvent.php文件的mainServerCreate方法内，这里需要用到上面配置公众号信息已经设置好的weChatConfig变量。\nuse App\\WeChat\\WeChatManager;\nuse EasySwoole\\WeChat\\WeChat;\n\n/**\n* 实例化WeChat\n* $weChatConfig 为配置好的公众号信息，详见，配置公众号信息章节\n*/\n$weChat = new WeChat($weChatConfig);\n/**\n* 将WeChat对象注册到管理类当中\n* default 为自定义的实例名称\n* $weChat 为实例化后的WeChat对象\n*/\nWeChatManager::getInstance()-&gt;register('default', $weChat);\n\n\n\n使用WeChat实例\n注册好WeChat对象后在全局获取且使用它的方式。\nuse App\\WeChat\\WeChatManager;\n\n/**\n* 调用WeChatManager的weChat方法传入注册时的“实例名称”\n* 返回WeChat对象\n*/\n$weChat = WeChatManager::getInstance()-&gt;weChat('default');\n\n\nWeChat对象相关类方法说明\nuse App\\WeChat\\WeChatManager;\n\n/**\n* officialAccount方法为获取公众号实例\n*/\n$weChat = WeChatManager::getInstance()-&gt;weChat('default')-&gt;officialAccount();\n\n/**\n* miniProgram方法为获取小程序实例\n*/\n$weChat = WeChatManager::getInstance()-&gt;weChat('default')-&gt;miniProgram();\n\n/**\n* openPlatform方法为获取开放平台实例\n*/\n$weChat = WeChatManager::getInstance()-&gt;weChat('default')-&gt;openPlatform();\n\n\n\n\n基础支持\n微信公众号使用中的一些必须和非必须性的使用方法\n\n注意：从基础支持开始\n所有示例代码中的$weChat如果无特殊说明那么该变量均为WeChatManager::getInstance()->weChat('default');返回的值。\n\n\n获取AccessToken\naccess_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。\n/**\n*  调用accessToken()方法返回AccessToken对象\n*  再调用getToken()方法获取access_token\n*/\n$weChat-&gt;officialAccount()-&gt;accessToken()-&gt;getToken();\n\n刷新AccessToken\naccess_token的有效期目前为2个小时，需定时刷新，重复获取或超时将导致上次获取的access_token失效，因此需要刷新AccessToken。\n\n注意：\n1.2.0版本以前：wechat sdk自带的access token管理机制会自动刷新access_token。\n1.2.0版本及以后：出于分布式的考虑，wechat sdk自带的access token管理机制不再实行access_token自动刷新。用户可以起一个自定义进程，或者是worker进程实现定时更新。\n示例代码如下：\n\nuse App\\WeChat\\WeChatManager;\n\nCoroutine::create(function (){\n    while (1){\n    //定时刷新\n        WeChatManager::getInstance()-&gt;officialAccount()-&gt;accessToken()-&gt;refresh();\n        Coroutine::sleep(7100);\n    }\n});\n\n自定义AccessToken管理\n替换组件自带的access_token管理机制，实现自定义access_token的管理。\n1.2.0版本新增\n注意：自定义的access_token管理类必须实现AccessTokenInterface接口\nuse EasySwoole\\WeChat\\WeChat;\n\n/**\n* 调用公众号实例的setAccessTokenManager()方法传入\n* $accessTokenManager参数，该参数为实现了AccessTokenInterface接口的自定义access_token对象\n*/\n$weChat-&gt;officialAccount()-&gt;setAccessTokenManager($accessTokenManager);\n\n验证消息真实性(AccessCheck)\n验证请求消息来源是否真实而不是非法的请求\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\AccessCheck;\n\n// 实例化AccessCheck对象，并传入request的请求参数获取accessCheck实例\n$accessCheckBean = new AccessCheck($this-&gt;request()-&gt;getRequestParam());\n\n/**\n* 链式调用公众号实例的server()方法获取公众号实例服务对象\n* 然后再调用实例服务对象的accessCheck()方法，并传入上面的accessCheck实例，返回bool值\n*/\n$verify = $weChat-&gt;officialAccount()-&gt;server()-&gt;accessCheck($accessCheckBean);\n\n获取微信服务器IP地址\n如果公众号基于安全等考虑，需要获知微信服务器的IP地址列表，以便进行相关限制，可以通过该接口获得微信服务器IP地址列表或者IP网段信息。\nuse EasySwoole\\WeChat\\WeChat;\n\n// 微信公众号实例调用ipList()方法即可\n$weChat-&gt;officialAccount()-&gt;ipList()\n\n微信网络检测\n帮助开发者排查回调连接失败的问题，提供这个网络检测的API。\n它可以对开发者URL做域名解析，然后对所有IP进行一次ping操作，得到丢包率和耗时。\nuse EasySwoole\\WeChat\\WeChat;   \nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\NetCheckRequest;\n\n// 实例化NetCheckRequest对象获取实例\n$req = new NetCheckRequest();\n// 调用公众号实例的netCheck()方法传并入上面的NetCheckRequest对象即可实现检测\n$wechat-&gt;officialAccount()-&gt;netCheck($req);\n\n进阶使用\n\n自定义菜单\n自定义菜单能够帮助公众号丰富界面，让用户更好更快地理解公众号的功能。\n开启自定义菜单后，公众号界面如图所示：\n\n注意：\n\n自定义菜单最多包括3个一级菜单，每个一级菜单最多包含5个二级菜单。\n一级菜单最多4个汉字，二级菜单最多7个汉字，多出来的部分将会以“...”代替。\n创建自定义菜单后，菜单的刷新策略是，在用户进入公众号会话页或公众号profile页时，如果发现上一次拉取菜单的请求在5分钟以前，就会拉取一下菜单，如果菜单有更新，就会刷新客户端的菜单。测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果。\n\n\n创建接口\n通过数组方式定义并实现公众号的菜单及层级。\nuse EasySwoole\\WeChat\\WeChat;  \n\n// 构建菜单数据结构(更多结构请查看微信官方文档)\n$buttons = [\n  [\n    \"type\" =&gt; \"click\",\n    \"name\" =&gt; \"今日歌曲\",\n    \"key\"  =&gt; \"V1001_TODAY_MUSIC\"\n  ],\n  [\n    \"name\"       =&gt; \"菜单\",\n    \"sub_button\" =&gt; [\n      [\n        \"type\" =&gt; \"view\",\n        \"name\" =&gt; \"搜索\",\n        \"url\"  =&gt; \"http://www.soso.com/\"\n      ],\n      [\n        \"type\" =&gt; \"view\",\n        \"name\" =&gt; \"视频\",\n        \"url\"  =&gt; \"http://v.qq.com/\"\n      ],\n      [\n        \"type\" =&gt; \"click\",\n        \"name\" =&gt; \"赞一下我们\",\n        \"key\"  =&gt; \"V1001_GOOD\"\n      ],\n    ],\n  ],\n];\n\n/**\n* 链式调用公众号实例的menu()方法获取菜单实例对象\n* 然后再调用菜单实例对象的create()方法，并传入上面的菜单数据结构$buttons即可\n*/\n$weChat-&gt;officialAccount()-&gt;menu()-&gt;create($buttons);\n\n查询接口\n本接口将会提供公众号当前使用的自定义菜单的配置，如果公众号是通过API调用设置的菜单，则返回菜单的开发配置，而如果公众号是在公众平台官网通过网站功能发布菜单，则本接口返回运营者设置的菜单配置。\nuse EasySwoole\\WeChat\\WeChat;  \n\n/**\n* 链式调用公众号实例的menu()方法获取菜单实例对象\n* 然后再调用菜单实例对象的queryConfig()方法\n*/\n$weChat-&gt;officialAccount()-&gt;menu()-&gt;queryConfig();\n\n删除接口\n使用接口创建自定义菜单后，开发者还可使用接口删除当前使用的自定义菜单。\n\n注意:\n在个性化菜单时，调用此接口会删除默认菜单及全部个性化菜单。\n\nuse EasySwoole\\WeChat\\WeChat;  \n\n/**\n* 链式调用公众号实例的menu()方法获取菜单实例对象\n* 然后再调用菜单实例对象的delete()方法即可\n*/\n$weChat-&gt;officialAccount()-&gt;menu()-&gt;delete();\n\n个性化菜单接口\n为了帮助公众号实现灵活的业务运营，微信公众平台新增了个性化菜单接口，开发者可以通过该接口，让公众号的不同用户群体看到不一样的自定义菜单。\n该接口开放给已认证订阅号和已认证服务号。\n创建个性化菜单\nuse EasySwoole\\WeChat\\WeChat;  \n\n// 构建菜单数据结构\n$buttons = [\n  [\n    \"type\" =&gt; \"click\",\n    \"name\" =&gt; \"今日歌曲\",\n    \"key\"  =&gt; \"V1001_TODAY_MUSIC\"\n  ],\n  [\n    \"name\"       =&gt; \"菜单\",\n    \"sub_button\" =&gt; [\n      [\n        \"type\" =&gt; \"view\",\n        \"name\" =&gt; \"搜索\",\n        \"url\"  =&gt; \"http://www.soso.com/\"\n      ],\n      [\n        \"type\" =&gt; \"view\",\n        \"name\" =&gt; \"视频\",\n        \"url\"  =&gt; \"http://v.qq.com/\"\n      ],\n      [\n        \"type\" =&gt; \"click\",\n        \"name\" =&gt; \"赞一下我们\",\n        \"key\"  =&gt; \"V1001_GOOD\"\n      ],\n    ],\n  ],\n];\n// 构建菜单匹配规则\n$matchRule = [\n  \"tag_id\"               =&gt; \"2\",\n  \"sex\"                  =&gt; \"1\",\n  \"country\"              =&gt; \"中国\",\n  \"province\"             =&gt; \"广东\",\n  \"city\"                 =&gt; \"广州\",\n  \"client_platform_type\" =&gt; \"2\",\n  \"language\"             =&gt; \"zh_CN\"\n];\n\n/**\n* 链式调用公众号实例的menu()方法获取菜单实例对象\n* 然后再调用菜单实例对象的create()方法\n* 并传入上面的菜单数据结构$buttons和菜单匹配规则$matchRule即可\n*/\n$weChat-&gt;officialAccount()-&gt;menu()-&gt;create($buttons, $matchRule);\n\n删除个性化菜单\n\n注意：\nmenuid为菜单id，可以通过自定义菜单查询接口获取，如果不传入menuid则为删除全部\n\nuse EasySwoole\\WeChat\\WeChat;  \n\n/**\n* 链式调用公众号实例的menu()方法获取菜单实例对象\n* 然后再调用菜单实例对象的delete()方法，并传入menuid即可\n*/\n$weChat-&gt;officialAccount()-&gt;menu()-&gt;delete(208379533);\n\n测试个性化菜单\nuse EasySwoole\\WeChat\\WeChat;  \n\n/**\n* 链式调用公众号实例的menu()方法获取菜单实例对象\n* 然后再调用菜单实例对象的match()方法，并传入粉丝的OpenID或微信号即可\n*/\n$weChat-&gt;officialAccount()-&gt;menu()-&gt;match('openid OR wechat ID');\n\n获取自定义菜单配置\n使用接口创建自定义菜单后，开发者还可使用接口查询自定义菜单的结构。另外请注意，在设置了个性化菜单后，使用本自定义菜单查询接口可以获取默认菜单和全部个性化菜单信息。\n\n注意：\n返回值中键名等于menu的为默认菜单，键名等于conditionalmenu为个性化菜单列表。\n字段说明请见微信官方公众号文档的个性化菜单接口页的说明。\n\nuse EasySwoole\\WeChat\\WeChat;    \n\n/**\n* 链式调用公众号实例的menu()方法获取菜单实例对象\n* 然后再调用菜单实例对象的query()方法即可\n*/\n$weChat-&gt;officialAccount()-&gt;menu()-&gt;query();\n\n消息管理\n\n当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包到开发者填写的URL上。\n请注意：\n\n关于重试的消息排重，推荐使用msgid排重。\n微信服务器在五秒内收不到响应会断掉连接，并且重新发起请求，总共重试三次。假如服务器无法保证在五秒内处理并回复，可以直接回复空串，微信服务器不会对此作任何处理，并且不会发起重试。详情请见“发送消息-被动回复消息”。\n如果开发者需要对用户消息在5秒内立即做出回应，即使用“发送消息-被动回复消息”接口向用户被动回复消息时，可以在\n\n\n\n\n前置操作\n\n每个微信请求开发者填写的URL上到达时将会调用 preCall 方法，这是一个前置操作方法，类似 onRequest 。\n如果你返回false，则表示中断后续流程。\n如果你返回一个 RequestedReplyMsg 对象，则会响应微信对象中的消息并中断后续流程\n如果你什么都不返回，则会继续执行后续流程。\n在EasySwooleEvent.php的mainServerCreate方法里注册\n\nuse EasySwoole\\WeChat\\WeChat;    \n\n/**\n* 链式调用公众号实例的server()方法获取公众号实例服务对象\n* 然后再调用公众号实例服务对象的preCall()方法，并传入回调。\n*/\n$wechat-&gt;officialAccount()-&gt;server()-&gt;preCall(function (RequestMsg $msg){\n//    var_dump($msg-&gt;__toString());\n});\n\n\n接收普通消息\n\n在EasySwooleEvent.php的mainServerCreate方法里注册\n查看所支持的RequestConst预定义常量查看请点我\n\nuse EasySwoole\\WeChat\\WeChat;  \n\n/**\n* 链式调用公众号实例的server()方法获取公众号实例服务对象\n* 再调用公众号实例服务对象的onMessage()方法获取消息事件注册对象，该对象是注册普通消息到达时的事件处理。\n* 然后调用消息事件注册对象的set()方法，传入微信公众号的消息类型和回调。\n*/\n$wechat-&gt;officialAccount()-&gt;server()-&gt;onMessage()-&gt;set('text',function (RequestMsg $msg){\n$reply = new Text();\n$reply-&gt;setMsgType(RequestConst::MSG_TYPE_TEXT);\n$reply-&gt;setContent('hello from server');\n    return $reply;\n});\n\n/*\n * 更为精确和规范的方式则是在调用set()方法时使用 RequestConst 类中提供的类常量来进行注册\n */\n$wechat-&gt;officialAccount()-&gt;server()-&gt;onMessage()-&gt;set(\n  RequestConst::DEFAULT_ON_MESSAGE, \n  function (RequestMsg $msg){\n$reply = new RequestedReplyMsg();\n$reply-&gt;setMsgType(RequestConst::MSG_TYPE_TEXT);\n$reply-&gt;setContent('you say :'.$msg-&gt;getContent());\n    return $reply;\n});\n\n接收事件推送\n\n在EasySwooleEvent.php的mainServerCreate方法里注册\n查看所支持的RequestConst预定义常量查看请点我\n\n\n注册事件推送相应方法的命名规则采用小驼峰命名，为on+事件类型\n例如：\n​   关注事件subscribe，事件推送方法命名为onSubscribe()\n​   群发结果事件MASSSENDJOBFINISH，事件推送方法命名为onMassSendJobFinish()\n​   弹出微信相册发图器的事件pic_weixin，事件推送方法命名为onPicWeixin()\n\nuse EasySwoole\\WeChat\\WeChat;  \n\n/**\n* 链式调用公众号实例的server()方法获取公众号实例服务对象\n* 再调用公众号实例服务对象的onEvent()方法获取事件推送注册对象，该对象是注册事件推送到达时的事件处理。\n* 然后调用事件推送注册对象的onSubscribe()方法(用户取消关注事件)，传入回调。\n*/\n$wechat-&gt;officialAccount()-&gt;server()-&gt;onEvent()-&gt;onSubscribe(function (RequestMsg $msg){\n    var_dump(\"{$msg-&gt;getFromUserName()} has SUBSCRIBE\");\n$reply = new RequestedReplyMsg();\n$reply-&gt;setMsgType(RequestConst::MSG_TYPE_TEXT);\n$reply-&gt;setContent('Welcome to EasySwoole');\n    return $reply;\n});\n\n/*\n * 用户取消关注事件\n */\n$wechat-&gt;officialAccount()-&gt;server()-&gt;onEvent()-&gt;onUnSubscribe(function (RequestMsg $msg){\n    var_dump(\"{$msg-&gt;getFromUserName()} has UBSCRIBE\");\n});\n\n\n自定义和默认事件处理\n\n未支持的事件推送注册方法，可以采用自定义的形式去注册。\n默认事件处理在未注册相对应的事件推送时调用\n\nuse EasySwoole\\WeChat\\WeChat;  \n\n/**\n* 链式调用公众号实例的server()方法获取公众号实例服务对象\n* 再调用公众号实例服务对象的onEvent()方法获取事件推送注册对象，该对象是注册事件推送到达时的事件处理。\n* 然后调用事件推送注册对象的set()方法，传入事件类型和回调。\n*/\n$wechat-&gt;officialAccount()-&gt;server()-&gt;onEvent()-&gt;set(RequestConst::DEFAULT_ON_EVENT, function (){\n$reply = new RequestedReplyMsg();\n$reply-&gt;setMsgType(RequestConst::MSG_TYPE_TEXT);\n$reply-&gt;setContent('this is event default reply');\n    return $reply;\n});\n\n/**\n* 常量方式自定义注册\n*/\n$wechat-&gt;officialAccount()-&gt;server()-&gt;onEvent()-&gt;set(RequestConst::EVENT_SCANCODE_PUSH, function (){   });\n\n/**\n* 字符串方式自定义注册\n*/\n$wechat-&gt;officialAccount()-&gt;server()-&gt;onEvent()-&gt;set('view_miniprogram', function (){   });\n\n获取微信事件推送的内容\n\n在注册的事件推送中获取微信事件推送的内容依靠类RequestMsg来实现\n该类实现了对微信服务器POST过来的XML消息数据包解析后的设置和获取\n获取和设置的方法命名采用小驼峰命名的规则，例：\n获取方式：get+xml的标签\n设置方式：set+xml的标签\n\n假设微信POST过来的XML消息数据包为如下内容：\n&lt;xml&gt;\n  &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;\n  &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;\n  &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;\n  &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;\n  &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;\n  &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;\n&lt;/xml&gt;\n则在事件使用方式\nuse EasySwoole\\WeChat\\WeChat;  \n\n/**\n* 因微信POST过来的XML消息数据包是一个普通消息的文本消息\n* 所以在注册的普通消息文本消息回调中注入RequestMsg对象\n*/\n$wechat-&gt;officialAccount()-&gt;server()-&gt;onMessage()-&gt;set('text',function (RequestMsg $msg){\n// 获取微信服务器POST过来的XML消息\n    $msg-&gt;getToUserName();\n$msg-&gt;getFromUserName();\n$msg-&gt;getCreateTime();\n$msg-&gt;getMsgType();\n$msg-&gt;getContent();\n$msg-&gt;getMsgId();\n\n    // 设置改变微信服务器POST过来的XML消息\n    $msg-&gt;setToUserName('开发者微信号');\n$msg-&gt;setFromUserName('OpenID');\n$msg-&gt;setCreateTime('时间');\n$msg-&gt;setMsgType('消息类型');\n$msg-&gt;setContent('文本消息内容');\n$msg-&gt;setMsgId('消息ID');\n});\n\n被动回复消息\n当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。\n严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。\n\n自动回复\n\n在注册的对应事件中编写程序\n回复何种消息取决于程序的自身业务逻辑和判断\n\n/** @var string 微信发送的Body体 $rawContent */\n$rawContent = $this-&gt;request()-&gt;getBody();\n\n// 将请求转发给名为 'default' WeChat接管 会返回 XML string 或者 null\ntry {\n  // 这里会根据微信的事件推送类型自己触发所注册的相应事件\n  $XML = WeChatManager::getInstance()-&gt;weChat('default')-&gt;officialAccount()-&gt;server()-&gt;parserRequest($rawContent);\n\n} catch (\\Throwable $throwable) {\n  // 这里我建议开发者 catch 住异常 无论如何给用户响应友好的提示 防止出现公众号异常的问题\n  // TODO: 这里实现一个异常记录 和发送服务器异常通知给开发者的代码\n}\n\n$this-&gt;response()-&gt;withStatus(Status::CODE_OK);\n$this-&gt;response()-&gt;write($XML ?? 'success');\n\n注：本篇章所写内容为触发相应事件后相关类型的内容如何回复，MediaId是指素材库中的媒体文件\n回复文本消息\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\Message\\Text;\n\n// 获取Text Bean实例\n$text = new Text();\n// 设置回复内容\n$text-&gt;setContent('这里是EasySwoole，您发送的消息为'.$content);\n// 获取回复内容\n$text-&gt;getContent();\n// 返回信息\nreturn $text;\n回复图片消息\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\Message\\Image;\n\n// 获取Image Bean实例\n$image = new Image();\n// 设置通过素材管理中的接口上传多媒体文件，得到的id。\n$image-&gt;setMediaId(932625047);\n// 获取素材ID。\n$image-&gt;getMediaId();\n// 返回信息\nreturn $image;\n回复语音消息\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\Message\\Voice;\n\n// 获取Voice Bean实例\n$voice = new Voice();\n// 设置通过素材管理中的接口上传多媒体文件，得到的id。\n$voice-&gt;setMediaId(932625047);\n// 获取素材ID。\n$voice-&gt;getMediaId();\n// 返回信息\nreturn $voice;\n回复视频消息\n对象方式设置\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\Message\\Video;\n\n// 获取Video Bean实例\n$video = new Video();\n// 设置通过素材管理中的接口上传多媒体文件，得到的id。\n$video-&gt;setMediaId(932625047);\n// 设置视频消息的标题\n$video-&gt;setTitle('EasySwoole教学视频');\n// 视频消息的描述\n$video-&gt;setDescription('EasySwoole轻轻松松学技术');\n\n// 获取素材ID。\n$video-&gt;getMediaId();\n// 获取视频消息的标题\n$video-&gt;getTitle();\n// 获取视频消息的描述\n$video-&gt;getDescription();\n\n// 数组方式获取\n$video-&gt;getVideoData()\n\nreturn $video;\n数组方式设置\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\Message\\Video;\n\n// 获取Video Bean实例\n$video = new Video();\n\n// 数组方式设置\n$data = [\n  'MediaId'         =&gt; 932625047,\n  'Title'               =&gt; 'EasySwoole教学视频',\n  'Description' =&gt; 'EasySwoole轻轻松松学技术'\n];\n$video-&gt;setVideoData($data);\n\n// 获取素材ID。\n$video-&gt;getMediaId();\n// 获取视频消息的标题\n$video-&gt;getTitle();\n// 获取视频消息的描述\n$video-&gt;getDescription();\n\n// 数组方式获取\n$video-&gt;getVideoData()\n\nreturn $video;\n回复音乐消息\n对象方式设置\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\Message\\Music;\n\n// 获取Music Bean实例\n$music = new Music();\n// 音乐消息的标题\n$music-&gt;setTitle('EasySwoole教学视频');\n// 音乐消息的描述\n$music-&gt;setDescription('EasySwoole轻轻松松学技术');\n// 音乐消息的链接\n$music-&gt;setMusicURL('https://www.easyswoole.com/hai.mp3');\n// 高质量音乐链接，WIFI环境优先使用该链接播放音乐\n$music-&gt;setHQMusicUrl('https://www.easyswoole.com/hai.mp3');\n// 缩略图的媒体id，通过素材管理中的接口上传多媒体文件，得到的id\n$music-&gt;setThumbMediaId(932625047);\n\n// 获取音乐消息的标题\n$music-&gt;setTitle();\n// 获取音乐消息的描述\n$music-&gt;setDescription();\n// 获取音乐消息的链接\n$music-&gt;setMusicURL();\n// 获取高质量音乐链接，WIFI环境优先使用该链接播放音乐\n$music-&gt;setHQMusicUrl();\n// 获取缩略图的媒体id，通过素材管理中的接口上传多媒体文件，得到的id\n$music-&gt;setThumbMediaId();\n\n// 数组方式获取\n$music-&gt;getMusicData();\n\nreturn $music;\n数组方式设置\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\Message\\Music;\n\n// 获取Music Bean实例\n$music = new Music();\n\n// 数组方式设置\n$data = [\n    'Title'        =&gt; 'EasySwoole教学视频'\n    'Description'  =&gt; 'EasySwoole轻轻松松学技术'\n    'MusicURL'     =&gt; 'https://www.easyswoole.com/hai.mp3'\n    'HQMusicUrl'   =&gt; 'https://www.easyswoole.com/hai-hd.mp3'\n    'ThumbMediaId' =&gt; 932625047\n];\n\n$music-&gt;setMusicData($data);\n\n// 获取音乐消息的标题\n$music-&gt;setTitle();\n// 获取音乐消息的描述\n$music-&gt;setDescription();\n// 获取音乐消息的链接\n$music-&gt;setMusicURL();\n// 获取高质量音乐链接，WIFI环境优先使用该链接播放音乐\n$music-&gt;setHQMusicUrl();\n// 获取缩略图的媒体id，通过素材管理中的接口上传多媒体文件，得到的id\n$music-&gt;setThumbMediaId();\n\n// 数组方式获取\n$music-&gt;getMusicData();\n\nreturn $music;\n回复图文消息\n对象方式设置\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\Message\\News;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\Message\\NewsItem;\n\n// 获取News Bean实例\n$news = new News();\n\n// 获取NewsItem Bean实例\n$newsItem = new NewsItem();\n// 设置图文消息标题\n$newItem-&gt;setTitle();\n// 设置图文消息描述\n$newItem-&gt;setDescription();\n// 设置图片链接：支持JPG、PNG格式，较好的效果为大图360*200，小图200*200\n$newItem-&gt;setPicUrl();\n// 设置图文消息跳转链接\n$newItem-&gt;setUrl();\n\n// 调用News Bean实例的push方法传入NewsItem Bean实例\n$news-&gt;push($newsItem);\n\nreturn $news;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\Message\\News;\n\n// 获取News Bean实例\n$news = new News();\n/**\n * 图文消息；\n * 图文消息个数；当用户发送文本、图片、视频、图文、地理位置这五种消息时开发者只能回复1条图文消息；\n * 其余场景最多可回复8条图文消息；\n */ \n$news-&gt;setNews(\n  [\n    [\n      'Title'=&gt;'EasySwoole官方一群',\n      'Description'=&gt;'633921431(已满,但可以试试挤挤)',\n      'PicUrl'=&gt;'https://www.easyswoole.com/Images/docNavLogo.png',\n      'Url'=&gt;'https://www.easyswoole.com',\n    ],\n    [\n      'Title'=&gt;'EasySwoole官方二群',\n      'Description'=&gt;'709134628(已满,但可以试试挤挤)',\n      'PicUrl'=&gt;'https://www.easyswoole.com/Images/docNavLogo.png',\n      'Url'=&gt;'https://www.easyswoole.com',\n    ],\n    [\n      'Title'=&gt;'EasySwoole官方三群',\n      'Description'=&gt;'932625047',\n      'PicUrl'=&gt;'https://www.easyswoole.com/Images/docNavLogo.png',\n      'Url'=&gt;'https://www.easyswoole.com',\n    ]\n  ]\n);\n\n// 数组方式获取\n$news-&gt;getNews();\n\nreturn $news;\n\n客服消息\n当用户和公众号产生特定动作的交互时（具体动作列表请见下方说明），微信将会把消息数据推送给开发者，开发者可以在一段时间内（目前修改为48小时）调用客服接口，通过POST一个JSON数据包来发送消息给普通用户。此接口主要用于客服等有人工消息处理环节的功能，方便开发者为用户提供更加优质的服务。\n添加客服帐号\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\CustomerService;\n\n// 获取CustomerService实例\n$customerService = new CustomerService();\n// 设置客服账户，自定义名称@您的公众号的微信号\n$customerService-&gt;setKfAccount('Easy4@Swoole');\n// 设置昵称\n$customerService-&gt;setNickname('客服服务号004');\n// 使用service获取实例，调用addServiceAccount发送设置消息,成功返回bool值true\n修改客服账号\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\CustomerService;\n\n// 获取CustomerService实例\n$customerService = new CustomerService();\n// 设置客服账户，自定义名称@您的公众号的微信号\n$customerService-&gt;setKfAccount('Easy5@Swoole');\n// 设置昵称\n$customerService-&gt;setNickname('客服服务号05');\n// 使用service获取实例，调用update传入CustomerService实例\n$weChat-&gt;officialAccount()-&gt;service()-&gt;update($customerService);\n删除客服账号\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\CustomerService;\n\n// 使用service获取实例，调用delete传入客服账号\n$weChat-&gt;officialAccount()-&gt;service()-&gt;delete('EasySwoole1@EasySwoole3');\n设置客服账号头像\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\PostFile;\n\n// 获取PostFile实例\n$postFile = new PostFile();\n// 设置文件路径\n$postFile-&gt;setPath($path);\n// 使用service获取实例，调用setAvatar传入客服账号和PostFile实例\n$weChat-&gt;officialAccount()-&gt;service()-&gt;setAvatar('Easy3@Swoole', $postFile);\n获取所有客服账号列表\nuse EasySwoole\\WeChat\\WeChat;\n\n// 使用service获取实例，调用getAllServiceList来请求获取所有客服账户列表\n$list = $weChat-&gt;officialAccount()-&gt;service()-&gt;getAllServiceList();\n客服接口-发消息\n发送文本消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\ServiceMessage\\Text;\n\n// 获取Text Bean消息实例\n$text = new Text();\n// 设置OPENID\n$text-&gt;setTouser('oofFl0_HuZ');\n/**\n* 设置消息内容，发送文本消息时，支持插入跳小程序的文字链例：\n* 文本内容&lt;a href=\"http://www.qq.com\" data-miniprogram-appid=\"appid\" data-miniprogram-path=\"pages/index/index\"&gt;点击跳小程序&lt;/a&gt;\n*/\n$text-&gt;setContent('快到EasySwoole碗里来！');\n// 使用service获取实例，调用sendServiceMsg传入Text Bean实例发送消息\n$weChat-&gt;officialAccount()-&gt;service()-&gt;sendServiceMsg($text);\n发送图片消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\ServiceMessage\\Image;\n\n// 获取Image Bean消息实例\n$image = new Image();\n// 设置OPENID\n$image-&gt;setTouser('oofFl0_HuZ');\n// 发送的图片/语音/视频/图文消息（点击跳转到图文消息页）的媒体ID\n$image-&gt;setMediaId('932625047');\n// 使用service获取实例，调用sendServiceMsg传入Image Bean实例发送消息\n$weChat-&gt;officialAccount()-&gt;service()-&gt;sendServiceMsg($image);\n发送语音消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\ServiceMessage\\Voice;\n\n// 获取Voice Bean消息实例\n$voice = new Voice();\n// 设置OPENID\n$voice-&gt;setTouser('oofFl0_HuZ3');\n// 发送的图片/语音/视频/图文消息（点击跳转到图文消息页）的媒体ID\n$voice-&gt;setMediaId(932625047);\n// 使用service获取实例，调用sendServiceMsg传入Voice Bean实例发送消息\n$weChat-&gt;officialAccount()-&gt;service()-&gt;sendServiceMsg($voice);\n发送视频消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\ServiceMessage\\Video;\n\n// 获取Video Bean消息实例\n$video = new Video();\n// OPENID\n$video-&gt;setTouser('oofFl0_HuZ3');\n// 发送的图片/语音/视频/图文消息（点击跳转到图文消息页）的媒体ID\n$video-&gt;setMediaId('932625047');\n// 缩略图/小程序卡片图片的媒体ID，小程序卡片图片建议大小为520*416\n$video-&gt;setThumbMediaId('932625047');\n// 标题\n$video-&gt;setTitle('’快到EasySwoole碗里来！');\n// 描述\n$video-&gt;setDescription('快到EasySwoole碗里来！');\n// 使用service获取实例，调用sendServiceMsg传入Video Bean实例发送消息\n$weChat-&gt;officialAccount()-&gt;service()-&gt;sendServiceMsg($video);\n发送音乐消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\ServiceMessage\\Music;\n\n// 获取Music Bean消息实例\n$music = new Music();\n// OPENID\n$music-&gt;setTouser('oofFl0_HuZ3');\n// 标题\n$music-&gt;setTitle('音乐标题');\n// 描述\n$music-&gt;setDescription('oofFl0_HuZ3');\n// 音乐链接\n$music-&gt;setMusicUrl('https://www.easyswoole.com');\n// 高品质音乐链接，wifi环境优先使用该链接播放音乐\n$music-&gt;setHqMusicUrl('https://www.easyswoole.com');\n// 缩略图/小程序卡片图片的媒体ID，小程序卡片图片建议大小为520*416\n$music-&gt;setThumbMediaId('666666666');\n// 使用service获取实例，调用sendServiceMsg传入Music Bean实例发送消息\n$weChat-&gt;officialAccount()-&gt;service()-&gt;sendServiceMsg($music);\n发送图文消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\ServiceMessage\\News;\n\n// 获取News Bean消息实例\n$news = new News();\n// 设置OPENID\n$news-&gt;setTouser('oofFl0_HuZ3');\n/**\n* 设置相关数据（news方式的数据设置）\n*/\n$news-&gt;setTitle('音乐标题');\n$news-&gt;setDescription('我是EasySwoole的描述君。');\n$news-&gt;setUrl('https://www.easyswoole.com');\n$news-&gt;setPicUrl('https://www.easyswoole.com/Images/docNavLogo.png');\n/**\n* 设置MediaId值将以mpnews方式发送数据，News的设置则失效\n*/\n// $news-&gt;setMediaId('666666666');\n\n// 使用service获取实例，调用sendServiceMsg传入Video Bean实例发送消息\n$weChat-&gt;officialAccount()-&gt;service()-&gt;sendServiceMsg($news);\n发送菜单消息\nuse EasySwoole\\WeChat\\WeChat;\nuse \\EasySwoole\\WeChat\\Bean\\OfficialAccount\\ServiceMessage\\MsgMenu;\n\n// 获取MsgMenu Bean消息实例\n$msgMenu = new MsgMenu();\n/**\n* 设置相关数据（news方式的数据设置）\n*/\n// OPENID\n$msgMenu-&gt;setTouser('oofFl0_HuZ3');\n// 菜单头部内容\n$msgMenu-&gt;setHeadContent('您对本次服务是否满意呢');\n// 菜单选项\n$msgMenu-&gt;setList([\n  ['id'=&gt;101, \"content\"=&gt;'满意'],\n  ['id'=&gt;102, \"content\"=&gt;'不满意'],\n]);\n// 菜单底部内容\n$msgMenu-&gt;setTailContent('欢迎再次光临EasySwoole');\n\n// 使用service获取实例，调用sendServiceMsg传入MsgMenu Bean实例发送消息\n$weChat-&gt;officialAccount()-&gt;service()-&gt;sendServiceMsg($msgMenu);\n按照上述例子，用户会看到这样的菜单消息：\n\n“您对本次服务是否满意呢？\n满意\n不满意\n欢迎再次光临EasySwoole”\n\n其中，“满意”和“不满意”是可点击的，当用户点击后，微信会发送一条XML消息到开发者服务器，格式如下：\n&lt;xml&gt;\n&lt;ToUserName&gt;&lt;![CDATA[ToUser]]&gt;&lt;/ToUserName&gt;\n&lt;FromUserName&gt;&lt;![CDATA[FromUser]]&gt;&lt;/FromUserName&gt;\n&lt;CreateTime&gt;1500000000&lt;/CreateTime&gt;\n&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;\n&lt;Content&gt;&lt;![CDATA[满意]]&gt;&lt;/Content&gt;\n&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;\n&lt;bizmsgmenuid&gt;101&lt;/bizmsgmenuid&gt;\n&lt;/xml&gt;\nXML参数说明：\n\n\n\n参数\n说明\n\n\n\n\nToUserName\n开发者帐号\n\n\nFromUserName\n接收方帐号（OpenID）\n\n\nCreateTime\n消息创建时间戳\n\n\nMsgType\nText\n\n\nContent\n点击的菜单名\n\n\nMsgId\n消息ID\n\n\nbizmsgmenuid\n点击的菜单ID\n\n\n\n收到XML推送之后，开发者可以根据提取出来的bizmsgmenuid和Content识别出微信用户点击的是哪个菜单。\n发送卡卷消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\ServiceMessage\\WxCard;\n\n// 获取WxCard Bean消息实例\n$wxCard = new WxCard();\n// 设置OPENID\n$wxCard-&gt;setTouser('oofFl0_HuZ3');\n// 设置卡卷ID\n$wxCard-&gt;setCardId('66666666666');\n// 使用service获取实例，调用sendServiceMsg传入WxCard Bean实例发送消息\n$weChat-&gt;officialAccount()-&gt;service()-&gt;sendServiceMsg($wxCard);\n发送小程序卡片消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\ServiceMessage\\MiniProgramPage;\n\n// 获取MiniProgramPage Bean消息实例\n$miniprogrampage = new MiniProgramPage();\n// 设置OPENID\n$miniprogrampage-&gt;setTouser('oofFl0_HuZ3');\n// 标题\n$miniprogrampage-&gt;setTitle('我是标题');\n// 小程序APPID\n$miniprogrampage-&gt;setAppid('wx9c04');\n// 小程序页面\n$miniprogrampage-&gt;setPagepath('index/index');\n// 缩略图/小程序卡片图片的媒体ID，小程序卡片图片建议大小为520*416\n$miniprogrampage-&gt;setThumbMediaId('66666666');\n// 设置以哪个客服账号发送小程序卡片，不设置以公众号发送\n$miniprogrampage-&gt;setKfAccount('EasySwoole1@EasySwoole');\n// 使用service获取实例，调用sendServiceMsg传入MiniProgramPage Bean实例发送消息\n$weChat-&gt;officialAccount()-&gt;service()-&gt;sendServiceMsg($miniprogrampage);\n客服接口-客服输入状态\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\ServiceMessage\\Command;\n\n// 获取Command Bean实例\n$command = new Command();\n// 设置OPENID\n$command-&gt;setTouser('oofFl0_HuZ3');\n// 调用此方法即下发\"正在输入\"状态，不调用则取消下发的状态\n$command-&gt;setCommand();\n// 使用service获取实例，调用sendServiceCommand传入Command Bean实例发送消息\n$weChat-&gt;officialAccount()-&gt;service()-&gt;sendServiceCommand($command);\n群发接口\n\n在公众平台网站上，为订阅号提供了每天一条的群发权限，为服务号提供每月（自然月）4条的群发权限。而对于某些具备开发能力的公众号运营者，可以通过高级群发接口，实现更灵活的群发能力。\n注：need_open_comment 和 only_fans_can_comment 的设置需要公众号具备留言功能的权限\n注：群发接口 clientmsgid 参数，调用群发接口时可以主动设置 clientmsgid 参数，避免重复推送。\n\n上传图文消息内的图片获取URL\n\n【订阅号与服务号认证后均可用】\n请注意，本接口所上传的图片不占用公众号的素材库中图片数量的5000个的限制。图片仅支持jpg/png格式，大小必须在1MB以下。\n\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\MediaRequest;\n\n// 图片路径\n$path = '/Volumes/Web Server/easyswoole/123.jpg';\n// 获取 MediaRequest 媒体实例\n$mediaRequest = new MediaRequest();\n// 设置文件路径\n$mediaRequest-&gt;setPath($path);\n// 使用material获取该实例，调用uploadArticleImage传入MediaRequest实例\n$weChat-&gt;officialAccount()-&gt;material()-&gt;uploadArticleImage($mediaRequest);\n返回说明 正常情况下的返回结果为：\n{                                \"url\":\"http://mmbiz.qpic.cn/mmbiz/gLO17UPS6FS2xsypf378iaNhWacZ1G1UplZYWEYfwvuU6Ont96b1roYs CNFwaRrSaKTPCUdBK9DgEHicsKwWCBRQ/0\"\n}\n其中url就是上传图片的URL，可用于后续群发中，放置到图文消息中。\n错误时微信会返回错误码等信息，请根据错误码查询错误信息\n\n上传图文消息素材（临时素材）\n\n【订阅号与服务号认证后均可用】\n注：根据微信规定，该接口中的 “thumb_media_id” 只允许使用临时素材的id，使用永久素材会报错，且使用该接口上传成功后的图文消息是临时素材，在素材库中查询不到。\n\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\MediaArticle;\n\n// 构建图文数据1\n$articleOne = [\n  'title'                 =&gt; 'EasySwoole，Wechat！',\n  'thumb_media_id'        =&gt; 'Qk6KMVRN7vWHPjr9hwfluiguE8CZVlU0rOPSFHfD7jk',\n  'author'                =&gt; 'EasySwoole/Wechat',\n  'show_cover_pic'        =&gt; 1,\n  'digest'                =&gt; 'digest',\n  'content'               =&gt; 'content',\n  'content_source_url'    =&gt; 'https://www.easyswoole.com',\n  'need_open_comment'     =&gt; 1,\n  'only_fans_can_comment' =&gt; 1\n];\n// 构建图文数据2\n$articleTwo = [\n  'title'                 =&gt; 'Wechat，EasySwoole！',\n  'thumb_media_id'        =&gt; 'Qk6KMVRN7vWHPjr9hwfluiguE8CZVlU0rOPSFHfD7jk',\n  'author'                =&gt; 'EasySwoole/WeChat',\n  'show_cover_pic'        =&gt; 1,\n  'digest'                =&gt; 'digest',\n  'content'               =&gt; 'content',\n  'content_source_url'    =&gt; 'https://www.easyswoole.com',\n  'need_open_comment'     =&gt; 1,\n  'only_fans_can_comment' =&gt; 0\n];\n// 获取MediaArticle Bean实例时传入构建数据1\n$mediaArticle1 = new MediaArticle($articleOne);\n// 获取MediaArticle Bean实例时传入构建数据2\n$mediaArticle2 = new MediaArticle($articleTwo);\n// 使用media获取实例调用uploadNew方法传入构建的数据即可\n$weChat-&gt;officialAccount()-&gt;media()-&gt;uploadNews($mediaArticle1, $mediaArticle2);\n如果需要在群发图文中插入小程序，则在调用上传图文消息素材接口时，需在content字段中添加小程序跳转链接，有以下三种样式的可供选择。\n小程序卡片跳转小程序，代码示例：\n&lt;mp-miniprogram data-miniprogram-appid=\"wx123123123\" data-miniprogram-path=\"pages/index/index\" data-miniprogram-title=\"小程序示例\" data-progarm-imageurl=\"http://mmbizqbic.cn/demo.jpg\"&gt;&lt;/mp-miniprogram&gt;\n文字跳转小程序，代码示例：\n&lt;p&gt;&lt;a data-miniprogram-appid=\"wx123123123\" data-miniprogram-path=\"pages/index\" href=\"\"&gt;点击文字跳转小程序&lt;/a&gt;&lt;/p&gt;\n图片跳转小程序，代码示例：\n&lt;p&gt;&lt;a data-miniprogram-appid=\"wx123123123\" data-miniprogram-path=\"pages/index\" href=\"\"&gt;&lt;img src=\"http://mmbiz.qpic.cn/mmbiz_jpg/demo/0?wx_fmt=jpg\" alt=\"\" data-width=\"null\" data-ratio=\"NaN\"&gt;&lt;/a&gt;&lt;/p&gt;\n根据标签进行群发\n图文消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\GroupSendingMessage\\News;\n\n// 获取News Bean实例\n$news = new News();\n// 设定是否向全部用户发送，选择true该消息群发给所有用户，选择false可根据tag_id发送给指定群组的用户\n$news-&gt;setIsToAll(false);\n// 设定群发到的标签的tag_id\n$news-&gt;setTagId(100);\n// 用于群发的消息的media_id\n$news-&gt;setMediaId('Qk6KMVRN7vWHPjr9hwflutq。。。');\n// 图文消息被判定为转载时，是否继续群发。 1为继续群发（转载），0为停止群发。 该参数默认为0。\n$news-&gt;setSendIgnoreReprint(1);\n// 避免重复推送\n$news-&gt;setClientMsgID('send_tag_2');\n// 使用groupSending获取实例并调用sendAllTag方法传入News Bean实例进行发送\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;sendAllTag($news);\n文本消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\GroupSendingMessage\\Text;\n\n// 获取Text Bean实例\n$text = new Text();\n// 设定是否向全部用户发送，选择true该消息群发给所有用户，选择false可根据tag_id发送给指定群组的用户\n$text-&gt;setIsToAll(false);\n// 设定群发到的标签的tag_id\n$text-&gt;setTagId(100);\n// 设定群发的内容\n$text-&gt;setContent('EaswSwoole群发提醒您！');\n// 避免重复推送\n$text-&gt;setClientMsgID('send_tag_2');\n// 使用groupSending获取实例并调用sendAllTag方法传入Text Bean实例进行发送\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;sendAllTag($text);\n语音音频\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\GroupSendingMessage\\Voice;\n\n// 获取Voice Bean实例\n$voice = new Voice();\n// 设定是否向全部用户发送，选择true该消息群发给所有用户，选择false可根据tag_id发送给指定群组的用户\n$voice-&gt;setIsToAll(false);\n// 设定群发到的标签的tag_id\n$voice-&gt;setTagId(100);\n// 用于群发的消息的media_id\n$voice-&gt;setMediaId('Qk6KMVRN7vWHPjr9hw。。。');\n// 避免重复推送\n$voice-&gt;setClientMsgID('send_tag_2');\n// 使用groupSending获取实例并调用sendAllTag方法传入Voice Bean实例进行发送\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;sendAllTag($voice);\n图片消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\GroupSendingMessage\\Image;\n\n// 获取Image Bean实例\n$image = new Image();\n// 设定是否向全部用户发送，选择true该消息群发给所有用户，选择false可根据tag_id发送给指定群组的用户\n$image-&gt;setIsToAll(false);\n// 设定群发到的标签的tag_id\n$image-&gt;setTagId(100);\n// 用于群发的消息的media_id是数组\n$image-&gt;setMediaIds([\n  'Qk6KMVRN7vWHPjr9hwfluv。。。1',\n  'Qk6KMVRN7vWHPjr9hwfluv。。。2'\n]);\n// 推荐语，不填则默认为“分享图片”\n$image-&gt;setRecommend('精彩图片');\n//  是否打开评论，0不打开，1打开\n$image-&gt;setNeedOpenComment(1);\n// 是否粉丝才可评论，0所有人可评论，1粉丝才可评论\n$image-&gt;setOnlyFansCanComment(1);\n// 避免重复推送\n$image-&gt;setClientMsgID('send_tag_2');\n// 使用groupSending获取实例并调用sendAllTag方法传入Image Bean实例进行发送\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;sendAllOpenID($image);\n视频消息\n注：视频消息的media_id如果是临时素材需要进行转换\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\GroupSendingMessage\\Video;\n\n// 获取Video Bean实例\n$video = new Video();\n// 设定是否向全部用户发送，选择true该消息群发给所有用户，选择false可根据tag_id发送给指定群组的用户\n$video-&gt;setIsToAll(false);\n// 设定群发到的标签的tag_id\n$video-&gt;setTagId(100);\n// 用于群发的消息的media_id\n$video-&gt;setMediaId('Qk6KMVRN7vWHPjr9hwf。。。');\n// 避免重复推送\n$video-&gt;setClientMsgID('send_tag_2');\n// 如果是发送临时视频素材需要设置以下三个数据\n\n// // true为启用临时素材的media_id转换，默认false为永久素材，不需要转换\n// $video-&gt;setIsTemporary(true); \n// $video-&gt;setTitle(\"标题\");\n// $video-&gt;setDescription(\"描述\");\n\n// 使用groupSending获取实例并调用sendAllTag方法传入Video Bean实例进行发送\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;sendAllTag($video);\n卡卷消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\GroupSendingMessage\\WxCard;\n\n// 获取WxCard Bean实例\n$wxCard = new WxCard();\n// 设置相关信息\n// 设定是否向全部用户发送，选择true该消息群发给所有用户，选择false可根据tag_id发送给指定群组的用户\n$video-&gt;setIsToAll(false);\n// 设定群发到的标签的tag_id\n$video-&gt;setTagId(100);\n// 用于群发的消息的卡卷card_id\n$wxCard-&gt;setCardId('Qk6KMVRN7vWHPjr9hwfluuBErNV7。。。');\n// 避免重复推送\n$wxCard-&gt;setClientMsgID('send_tag_2');\n// 使用groupSending获取实例并调用sendAllTag方法传入WxCard Bean实例进行发送\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;sendAllTag($wxCard);\n根据OpenID列表群发\n【订阅号不可用，服务号认证后可用】\n使用方法\n”OpenID群发“与”标签群发“ 的内容设定方式一样只有发送对象的方式设定不一样\n唯一不同地方，示例：\n// 标签群发使用setIsToAll和setTagId来指定群发范围\n$text-&gt;setIsToAll(false);\n$text-&gt;setTagId(101);\n\n// OpenID群发使用setTouser传入一个数组来指定接收群发的用户，最少2个最多10000个\n$text-&gt;setTouser([\n  'oofFl07U3fwsg。。。1',\n  'oofFl07U3fwsg。。。2'\n]);\n删除群发\n// 使用groupSending获取实例并调用delete方法传入消息ID（msg_id）和条目位置（article_idx），默认全部\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;delete(3147483663); // 删除全部\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;delete(3147483663，2); // 删除的文章在图文消息中的位置（第二篇）\n预览接口\n文本预览\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\GroupSendingMessage\\Text;\n\n// 获取Text Bean实例\n$text = new Text();\n/*\n* 接收消息用户对应该公众号的openid，该字段也可以改为towxname，以实现对微信号的预览\n* $text-&gt;setToWxName('微信号');\n*/\n$text-&gt;setTouser('oofFl0_HuZ3Xa。。。g');\n// 设定预览内容\n$text-&gt;setContent('EaswSwoole群发提醒您！');\n// 使用groupSending获取实例并调用sendPreview方法传入Text Bean实例进行发送\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;sendPreview($text);\n卡卷预览\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\GroupSendingMessage\\WxCard;\n\n// 获取WxCard Bean实例\n$wxCard = new WxCard();\n/*\n* 接收消息用户对应该公众号的openid，该字段也可以改为towxname，以实现对微信号的预览\n* $text-&gt;setToWxName('微信号');\n*/\n$wxCard-&gt;setTouser('oofFl0_HuZ3Xa。。。g');\n// 设定卡卷ID\n$wxCard-&gt;setCardId('Qk6KMVRN7vWHPjr9hw...');\n// 使用groupSending获取实例并调用sendPreview方法传入WxCard Bean实例进行发送\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;sendPreview($wxCard);\n其他类型预览\n其他类型信息的预览使用方式一样，根据想要预览的类型不同获取不同的类型实例即可。\nuse EasySwoole\\WeChat\\WeChat;  \nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\GroupSendingMessage\\News;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\GroupSendingMessage\\Voice;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\GroupSendingMessage\\Image;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\GroupSendingMessage\\Video;\n\n/*\n* 根据自己的预览需求 new不同的类型即可\n*/\n$bean = new News();  // 图文\n$bean = new Voice(); // 音频\n$bean = new Image(); // 图片\n$bean = new Video(); // 视频\n\n/*\n* 接收消息用户对应该公众号的openid，该字段也可以改为towxname，以实现对微信号的预览\n* $bean-&gt;setToWxName('微信号');\n*/\n$bean-&gt;setTouser('oofFl0_HuZ3Xa。。。g');\n$bean-&gt;setMediaId('Qk6KMVRN7vWHPjr9hwf......');\n\n// 使用groupSending获取实例并调用sendPreview方法传入Bean实例进行发送\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;sendPreview($bean);\n\n查询群发消息发送状态\n// 使用groupSending获取实例并调用queryState方法传入msg_id即可\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;queryState(3147483663);\n控制群发速度\n获取群发速度\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;getSendingSpeed();\n设置群发速度\n// 传入0~4的int型数字\n$weChat-&gt;officialAccount()-&gt;groupSending()-&gt;setSendingSpeed(3);\n模板消息接口\n\n关于使用规则，请注意：\n\n所有服务号都可以在功能->添加功能插件处看到申请模板消息功能的入口，但只有认证后的服务号才可以申请模板消息的使用权限并获得该权限；\n需要选择公众账号服务所处的2个行业，每月可更改1次所选行业；\n在所选择行业的模板库中选用已有的模板进行调用；\n每个账号可以同时使用25个模板。\n当前每个账号的模板消息的日调用上限为10万次，单个模板没有特殊限制。【2014年11月18日将接口调用频率从默认的日1万次提升为日10万次，可在MP登录后的开发者中心查看】。当账号粉丝数超过10W/100W/1000W时，模板消息的日调用上限会相应提升，以公众号MP后台开发者中心页面中标明的数字为准。\n\n\n\n关于接口文档，请注意：\n\n模板消息调用时主要需要模板ID和模板中各参数的赋值内容；\n模板中参数内容必须以\".DATA\"结尾，否则视为保留字；\n模板保留符号\"\"。\n\n\n设置所属行业\nuse EasySwoole\\WeChat\\WeChat;\n\n// 设置所属行业(传入参数为mixed类型，返回bool)\n$weChat-&gt;officialAccount()-&gt;templateMsg()-&gt;setIndustry(1,2,3,4,5);\n获取设置的行业信息\nuse EasySwoole\\WeChat\\WeChat;\n\n// 设置所属行业(传入参数为mixed类型，返回bool)\n$weChat-&gt;officialAccount()-&gt;templateMsg()-&gt;setIndustry(1,2,3,4,5);\n获得模板ID\nuse EasySwoole\\WeChat\\WeChat;\n\n// 获得模板id (传入模板库编号)\n$tempID = $weChat-&gt;officialAccount()-&gt;templateMsg()-&gt;addTemplate('OPENTM405653850');\n获取模板列表\nuse EasySwoole\\WeChat\\WeChat;\n\n// 获取模板消息列表\n$tempMsgList = $weChat-&gt;officialAccount()-&gt;templateMsg()-&gt;getPrivateTemplates();\n删除模板\nuse EasySwoole\\WeChat\\WeChat;\n\n// 删除模板消息(传入模板id)\n$weChat-&gt;officialAccount()-&gt;templateMsg()-&gt;deletePrivateTemplate('defKN5rpMMhwky9...');\n发送模板消息\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\TemplateMsg;\n/**\n  * 发送模板消息例如以下模板消息\n  * \n  array(6) {\n        [\"template_id\"]=&gt;\n        string(43) \"JfZ-AIkdeftPafZKN5rpMMhwky9r1DzflOZKw_QHDiU\"\n        [\"title\"]=&gt;\n        string(18) \"下单成功通知\"\n        [\"primary_industry\"]=&gt;\n        string(8) \"IT科技\"\n        [\"deputy_industry\"]=&gt;\n        string(22) \"互联网|电子商务\"\n        [\"content\"]=&gt;\n        string(96) \"{{first.DATA}}\n        服务内容：{{keyword1.DATA}}\n        预约时间：{{keyword2.DATA}}\n        {{remark.DATA}}\"\n        [\"example\"]=&gt;\n        string(215) \"感谢您选择神工007，您的订单[D234254433]正在分配工人，请稍候。\n        服务内容：吊灯安装等\n        预约时间：2016-05-15 上午\n        如有疑问，请联系神工007客服电话：400-007-1515。\"\n   }\n   */\n\n// 获取TemplateMsg Bean 实例\n$templateMsg = new TemplateMsg();\n// 设置openID\n$templateMsg-&gt;setTouser('oE4W1t7_CfmqeG2D....');\n// 设置所需跳转到的小程序appid\n$templateMsg-&gt;setAppid('xiaochengxuappid12345');\n// 设置所需跳转到的小程序路径\n$templateMsg-&gt;setPagepath('index?foo=bar');\n// 设置模板template_id\n$templateMsg-&gt;setTemplateId('JfZ-AIkdeftPafZKN5rpMMhw....');\n// 设置模板发送数据\n$tempData = [\n  'first'    =&gt; '恭喜你购买成功',\n  'keyword1' =&gt; 'EasySwoole手把屌教学服务',\n  'keyword2' =&gt; date('Y-m-d H:i:s', time()),\n  'remark'   =&gt; '往后的日子大佬将带你飞飞飞飞飞飞飞飞飞飞',\n];\n$templateMsg-&gt;setData($tempData);\n// 发送\n$weChat-&gt;officialAccount()-&gt;templateMsg()-&gt;send($templateMsg);\n一次性订阅消息\n开发者可以通过一次性订阅消息授权让微信用户授权第三方移动应用（接入说明）或公众号，获得发送一次订阅消息给到授权微信用户的机会。\n授权微信用户可以不需要关注公众号。微信用户每授权一次，开发者可获得一次下发消息的权限。（注意：同一用户在同一scene场景值下的多次授权不累积下发权限，只能下发一条。若要订阅多条，需要不同scene场景值）\n第一步：用户授权\n需要用户同意授权，获取一次给用户推送一条订阅模板消息的机会\n在确保微信公众帐号拥有订阅消息授权的权限的前提下（已认证的公众号即有权限，可登录公众平台在接口权限列表处查看），引导用户在微信客户端打开如下链接：\n\nhttps://mp.weixin.qq.com/mp/subscribemsg?action=get_confirm&amp;appid=wxaba38c7f163.....&amp;scene=1000&amp;template_id=1uDxHNXwYQfBmXOfPJcjAS3FynHArD8aWMEFNRGSbCc&amp;redirect_url=http%3a%2f%2fsupport.qq.com&amp;reserved=test#wechat_redirect\n\n参数说明\n\n\n\n参数\n是否必须\n说明\n\n\n\n\naction\n是\n直接填get_confirm即可\n\n\nappid\n是\n公众号的唯一标识\n\n\nscene\n是\n重定向后会带上scene参数，开发者可以填0-10000的整形值，用来标识订阅场景值\n\n\ntemplate_id\n是\n订阅消息模板ID，登录公众平台后台，在接口权限列表处可查看订阅模板ID\n\n\nredirect_url\n是\n授权后重定向的回调地址，请使用UrlEncode对链接进行处理。 注：要求redirect_url的域名要跟登记的业务域名一致，且业务域名不能带路径。 业务域名需登录公众号，在设置-公众号设置-功能设置里面对业务域名设置。\n\n\nreserved\n否\n用于保持请求和回调的状态，授权请后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验，开发者可以填写a-zA-Z0-9的参数值，最多128字节，要求做urlencode\n\n\n#wechat_redirect\n是\n无论直接打开还是做页面302重定向时，必须带此参数\n\n\n\n用户同意或取消授权后会返回相关信息\n如果用户点击同意或取消授权，页面将跳转至：\n\nredirect_url/?openid=OPENID&amp;template_id=TEMPLATE_ID&amp;action=ACTION&amp;scene=SCENE\n\n参数说明\n\n\n\n参数\n说明\n\n\n\n\nopenid\n用户唯一标识，只在用户确认授权时才会带上\n\n\ntemplate_id\n订阅消息模板ID\n\n\naction\n用户点击动作，&quot;confirm&quot;代表用户确认授权，&quot;cancel&quot;代表用户取消授权\n\n\nscene\n订阅场景值\n\n\nreserved\n请求带入原样返回\n\n\n\n第二步：发送信息\n通过API推送订阅模板消息给到授权微信用户\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\TemplateMsg;\n\n// 获取TemplateMsg Bean实例\n$template = new TemplateMsg();\n// 设定openid\n$template-&gt;setTouser('oofFl0_HuZ3Xa9....');\n// 设定订阅消息模板ID，登录公众平台后台，在接口权限列表处可查看订阅模板ID\n$template-&gt;setTemplateId('eMuG4etIdo5amBf3bcWBT...');\n// 设定点击消息跳转的链接，需要有ICP备案\n$template-&gt;setUrl('http://wechat.easyswoole.com/');\n// 设定跳转到的小程序appid（appid必须与公众号是绑定关系，并且小程序要求是已发布的）\n$template-&gt;setAppid('wx9c041....');\n// 设定跳转到小程序的具体页面路径，支持带参数,（示例index?foo=bar）\n$template-&gt;setPagepath('pages/info/info?id=88');\n// 设定订阅场景值，该值必须与第一步的scene值相同不然会发送失败\n$template-&gt;setScene(99);\n// 消息标题\n$template-&gt;setTitle('骑着小摩托');\n/*\n* 消息正文，value为消息内容文本（200字以内），没有固定格式，可用\\n换行.\n* color为整段消息内容的字体颜色（目前仅支持整段消息为一种颜色）\n*/\n$template-&gt;setData([\n  'content' =&gt; [\n    'value' =&gt; '骑着我心爱的小摩托~~~嘟嘟嘟嘟！',\n    'color' =&gt; '#bf9f28'\n  ]\n]);\n// 传入TemplateMsg Bean实例发送\n$weChat-&gt;officialAccount()-&gt;templateMsg()-&gt;sendSubscription($template);\n微信网页开发\n网页授权\n第一步：用户同意授权，获取code\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\JsAuthRequest;\n\n// 获取JsApi对象\n$jsApi = $weChat-&gt;officialAccount()-&gt;jsApi();\n\n// 创建微信授权跳转连接\n$jsAuthRequest = new JsAuthRequest();\n// 设置授权后回调地址\n$jsAuthRequest-&gt;setRedirectUri('http://m.easyswoole.cn');\n// 设置 state\n$jsAuthRequest-&gt;setState('test');\n// 设置授权类型\n$jsAuthRequest-&gt;setType($jsAuthRequest::TYPE_USER_INFO);\n// 返回生成地址 需要开发者自行重定向用户\n$link = $jsApi-&gt;auth()-&gt;generateURL($jsAuthRequest);\n第二步：通过code换取网页授权access_token\n\n使用微信回调时提供的 code 获取AccessToken\n从微信回调时附带在 url的get参数上 前端或者后端获取都可以\n\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\JsAuthRequest;\n\n$code = '这是回调获取到的code';\n// code换去授权\n$snsAuthBean  = $jsApi-&gt;auth()-&gt;codeToToken($code);\n// 用户授权的作用域，使用逗号（,）分隔\n$snsAuthBean-&gt;getScope();\n// 用户唯一标识，请注意，在未关注公众号时，用户访问公众号的网页，也会产生一个用户和公众号唯一的OpenID\n$snsAuthBean-&gt;getOpenid();\n// 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同\n$snsAuthBean-&gt;getAccessToken();\n// 用户刷新access_token用的\n$snsAuthBean-&gt;getRefreshToken();\n// 用户刷新access_token\n$snsAuthBean-&gt;getExpiresIn();\n第三步：刷新access_token（如果需要）\n// 获取第二步的refresh_token\n$token = $snsAuthBean-&gt;getRefreshToken();\n// 传入token\n$snsAuthBean = $jsApi-&gt;auth()-&gt;refreshToken($token);\n第四步：拉取用户信息(需scope为 snsapi_userinfo)\n// 使用上面提供的 $snsAuthBean对象 获取用户信息\n$user = $jsApi-&gt;auth()-&gt;tokenToUser($snsAuthBean);\n$user-&gt;getOpenid();\n$user-&gt;getHeadimgurl();\n$user-&gt;getNickname();\n// 更多信息自行阅读源码\n附：快速获取\n是上述的封装\n// 直接使用 code 获取用户信息，是上述操作的快捷封装\n$user = $jsApi-&gt;auth()-&gt;codeToUser($code);\n附：检验授权凭证（access_token）是否有效\n$snsAuthBean-&gt;setOpenid();\n$snsAuthBean-&gt;setAccessToken();\n$check = $jsApi-&gt;auth()-&gt;authCheck($snsAuthBean);\n服务JS-SDK\n$url = '这里是URL地址';  \n// 获取前端注册wx.config使用的签名包\n$jsApiSignaturePack = $jsApi-&gt;sdk()-&gt;signature($url);\n// 获取相关信息\n$jsApiSignaturePack-&gt;getAppId();\n$jsApiSignaturePack-&gt;getNonceStr();\n$jsApiSignaturePack-&gt;getSignature();\n$jsApiSignaturePack-&gt;getTimestamp();\n注意，1.2.0版本开始的wechat sdk自带的Ticket管理机制不再实行自动刷新(出于分布式考虑)。用户可以起一个自定义进程，或者是worker进程实现定时更新。示例代码如下：\nCoroutine::create(function (){\n    while (1){\n    //定时刷新\n        WeChatSDK::getInstance()-&gt;officialAccount()-&gt;jsApi()-&gt;sdk()-&gt;jsTicket()-&gt;refreshTicket();\n        Coroutine::sleep(7100);\n    }\n});\n自定义Ticker实现\n注意，仅1.2.0版本开始支持\n    // 传入自定义实现了接口JsTicketInterface的Ticket管理替代自身的JsTicket\n    $weChat-&gt;officialAccount()-&gt;jsApi()-&gt;sdk()-&gt;setTicketnManager($ticketManager);\n素材管理\n\n新增参数 ：\nneed_open_comment —— 是否打开评论，0不打开，1打开\nonly_fans_can_comment —— 是否粉丝才可评论，0所有人可评论，1粉丝才可评论。\n注意，这两个参数只有在具有留言功能的公众号上能使用，但是目前新注册微信公众号不开放该功能，只有以前注册的公众号具有该功能。\n\n\n新增临时素材\n\n注：临时的图文素材去这里 --> 上传图文消息素材（临时素材）请点我\n1、临时素材media_id是可复用的。\n2、媒体文件在微信后台保存时间为3天，即3天后media_id失效。\n3、上传临时素材的格式、大小限制与公众平台官网一致。\n图片（image）: 2M，支持PNG\\JPEG\\JPG\\GIF格式\n语音（voice）：2M，播放长度不超过60s，支持AMR\\MP3格式\n视频（video）：10MB，支持MP4格式\n缩略图（thumb）：64KB，支持JPG格式\n\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\MediaRequest;\n\n    if (!$path) {\n  // 上传文件路径\n  $path = '/Volumes/Web Server/easyswoole/img/3.jpg';\n    }\n// 获取MediaRequest Bean实例\n$media = new MediaRequest();\n// 设定素材类型，分别有图片（image）、语音（voice）、视频（video）和缩略图（thumb）\n$media-&gt;setType($media::TYPE_THUMB);\n// 设定素材的本地路径\n$media-&gt;setPath($path);\n// 传入MediaRequest Bean实例即可\n$weChat-&gt;officialAccount()-&gt;media()-&gt;upload($media);\n获取临时素材\n获取素材\nuse EasySwoole\\WeChat\\WeChat;\n\n// 传入临时素材的media_id;\n$mediaResponse = $weChat-&gt;officialAccount()-&gt;media()-&gt;get('Ki4ucYa5lj071...');\n\n// 使用save方法传入保存地址,成功返回文件名。save(地址,自定义名称=null,超时时间=15),超时仅获取视频时有效\n$fileName = $mediaResponse-&gt;save('/Volumes/Web Server/easyswoole/img/');\n// 也可使用saveAs方法传入保存地址和文件名\n$mediaResponse-&gt;saveAs('/Volumes/Web Server/easyswoole/img/', 'newFileName');\n获取高清语音素材\n获取从JSSDK的uploadVoice接口上传的临时语音素材(高清16K采样率)\nuse EasySwoole\\WeChat\\WeChat;\n\n// 传入临时素材的media_id;\n$mediaResponse = $weChat-&gt;officialAccount()-&gt;media()-&gt;getHdVoice('Ki4ucYa5lj071...');\n\n// 使用save方法传入保存地址,成功返回文件名。save(地址,自定义名称=null,超时时间=15),超时仅获取视频时有效\n$fileName = $mediaResponse-&gt;save('/Volumes/Web Server/easyswoole/img/');\n// 也可使用saveAs方法传入保存地址和文件名\n$mediaResponse-&gt;saveAs('/Volumes/Web Server/easyswoole/img/', 'newFileName');\n新增永久素材\n新增永久图文素材\n若新增的是多图文素材，则设定多个articles结构\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\MediaArticle;\n\n// 构建图文数据1\n$articleOne = [\n      'title'              =&gt; 'EasySwoole，Wechat！',\n      'thumb_media_id'     =&gt; 'Qk6KMVRN7vWHPjr9hwfluummlx7....',\n      'author'             =&gt; 'EasySwoole/Wechat',\n      'show_cover_pic'     =&gt; 1,\n      'digest'             =&gt; 'digest',\n      'content'            =&gt; 'content',\n      'content_source_url' =&gt; 'https://www.easyswoole.com',\n    ];\n// 构建图文数据2\n$articleTwo = [\n      'title'              =&gt; 'Wechat，EasySwoole！',\n      'thumb_media_id'     =&gt; 'Qk6KMVRN7vWHPjr9hwfl....',\n      'author'             =&gt; 'EasySwoole/WeChat',\n      'show_cover_pic'     =&gt; 1,\n      'digest'             =&gt; 'digest',\n      'content'            =&gt; 'content',\n      'content_source_url' =&gt; 'https://www.easyswoole.com',\n    ];\n// 获取MediaArticle Bean实例时传入构建数据1\n$mediaArticle1 = new MediaArticle($articleOne);\n// 获取MediaArticle Bean实例时传入构建数据2\n$mediaArticle2 = new MediaArticle($articleTwo);\n    // 传入两个实例即可！\n$weChat-&gt;officialAccount()-&gt;material()-&gt;uploadArticle($mediaArticle1, $mediaArticle2);\n新增其他类型永久素材\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\MediaRequest;\n\n// 上传文件路径\n$path = '/Volumes/Web Server/easyswoole/image/2.jpg';\n// 获取MediaRequest Bean实例\n$mediaRequest = new MediaRequest();\n// 设定素材类型\n$mediaRequest-&gt;setType($mediaRequest::TYPE_IMAGE);\n// 设定素材路径\n$mediaRequest-&gt;setPath($path);\n\n// 传入MediaRequest Bean实例\n$weChat-&gt;officialAccount()-&gt;material()-&gt;upload($mediaRequest);\n\n注：新增”视频类型“永久素材时还需设定以下两项\n$mediaRequest->setTitle('关键时刻怎么能掉链子?');\n$mediaRequest->setIntroduction('别让你的电脑影响了你的业务！');\n点我查看上传图文消息内的图片获取URL\n请注意，本接口所上传的图片不占用公众号的素材库中图片数量的5000个的限制。图片仅支持jpg/png格式，大小必须在1MB以下。\n\n获取永久素材\nuse EasySwoole\\WeChat\\WeChat;\n\n// 传入临时素材的media_id;\n$mediaResponse = $weChat-&gt;officialAccount()-&gt;material()-&gt;get('Ki4ucYa5lj071...');\n// 使用save方法传入保存地址,成功返回文件名。save(地址,自定义名称=null,超时时间=15),超时仅获取视频时有效\n$fileName = $mediaResponse-&gt;save('/Volumes/Web Server/easyswoole/img/');\n// 也可使用saveAs方法传入保存地址和文件名\n$mediaResponse-&gt;saveAs('/Volumes/Web Server/easyswoole/img/', 'newFileName');\n删除永久素材\nuse EasySwoole\\WeChat\\WeChat;\n\n// 传入media_id即可删除\n$weChat-&gt;officialAccount()-&gt;material()-&gt;delete('Qk6KMVRN7vWHPjr9hwf...');\n修改永久图文素材\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\MediaRequest;\n\n// 设置修改内容\n$articles = [\n      'title'              =&gt; 'Hi！ EasySwoole!',\n      'thumb_media_id'     =&gt; 'Qk6KMVRN7vWHPjr9hwf...',\n      'author'             =&gt; 'Hi！ EasySwoole!',\n      'show_cover_pic'     =&gt; 1,\n      'digest'             =&gt; 'digest',\n      'content'            =&gt; 'content',\n      'content_source_url' =&gt; 'https://www.easyswoole.com',\n    ];\n// 传入内容，获取MediaArticle Bean实例\n$mediaArticle = new MediaArticle($articles);\n\n/*\n* 传入响应参数执行修改\n* updateArticle('media_id', MediaArticle Bean实例, '文章在图文消息中的位置');\n* 要更新的文章在图文消息中的位置（多图文消息时，此字段才有意义），第一篇为0\n*/\n$weChat-&gt;officialAccount()-&gt;material()-&gt;updateArticle('Qk6KM7P...', $mediaArticle, 0);\n获取素材总数\nuse EasySwoole\\WeChat\\WeChat;\n\n// 获取素材总数\n$weChat-&gt;officialAccount()-&gt;material()-&gt;stats();\n获取素材列表\nuse EasySwoole\\WeChat\\WeChat;\n/*\n* list(素材类型，开始位置，获取数量)\n* 素材的类型，图片（image）、视频（video）、语音 （voice）、图文（news）\n* 从全部素材的该偏移位置开始返回，0表示从第一个素材 返回\n* 返回素材的数量，取值在1到20之间\n*/\n$weChat-&gt;officialAccount()-&gt;material()-&gt;list('news', 0, 20);\n图文消息留言管理\n打开已群发文章的评论功能\nuse EasySwoole\\WeChat\\WeChat;\n\n// close（群发返回的msg_data_id，指定第几篇从0开始默认第一篇）\n$weChat-&gt;officialAccount()-&gt;comment()-&gt;open(2649279340, 0);\n关闭已群发文章的评论功能\nuse EasySwoole\\WeChat\\WeChat;\n\n// open（群发返回的msg_data_id，指定第几篇从0开始默认第一篇）\n$weChat-&gt;officialAccount()-&gt;comment()-&gt;close(2649279340, 0);\n查看指定文章的评论数据\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，群发返回的msg_data_id\n* 2，起始位置\n* 3，获取数目（&gt;=50会被拒绝）\n* 4，type=0 普通评论&amp;精选评论 type=1 普通评论 type=2 精选评论\n* 5，多图文时，用来指定第几篇图文，从0开始，不带默认返回该msg_data_id的第一篇图文\n*/\n$weChat-&gt;officialAccount()-&gt;comment()-&gt;view(1, 2, 3, 4, 5);\n将评论标记精选\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，群发返回的msg_data_id\n* 2，评论id\n* 3，多图文时，用来指定第几篇图文，从0开始，不带默认返回该msg_data_id的第一篇图文\n*/\n$weChat-&gt;officialAccount()-&gt;comment()-&gt;markelect(1, 2, 3);\n将评论取消精选\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，群发返回的msg_data_id\n* 2，评论id\n* 3，多图文时，用来指定第几篇图文，从0开始，不带默认返回该msg_data_id的第一篇图文\n*/\n$weChat-&gt;officialAccount()-&gt;comment()-&gt;unMarkelect(1, 2, 3);\n删除评论\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，群发返回的msg_data_id\n* 2，评论id\n* 3，多图文时，用来指定第几篇图文，从0开始，不带默认返回该msg_data_id的第一篇图文\n*/\n$weChat-&gt;officialAccount()-&gt;comment()-&gt;delete(1, 2, 3);\n回复评论\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，群发返回的msg_data_id\n* 2，评论id\n* 3，回复内容\n* 4，多图文时，用来指定第几篇图文，从0开始，不带默认返回该msg_data_id的第一篇图文\n*/\n$weChat-&gt;officialAccount()-&gt;comment()-&gt;reply(1, 2, 3, 4);\n删除回复\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，群发返回的msg_data_id\n* 2，评论id\n* 3，多图文时，用来指定第几篇图文，从0开始，不带默认返回该msg_data_id的第一篇图文\n*/\n$weChat-&gt;officialAccount()-&gt;comment()-&gt;deleteReply(1, 2, 3, 4);\n用户管理\n开发者可以使用用户标签管理的相关接口，实现对公众号的标签进行创建、查询、修改、删除等操作，也可以对用户进行打标签、取消标签等操作。\n\n用户标签管理\n标签管理\n创建标签\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入标签名称\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;tagCreate('测试C');\n获取公众号已创建的标签\nuse EasySwoole\\WeChat\\WeChat;\n\n$weChat-&gt;officialAccount()-&gt;user()-&gt;tagList();\n编辑标签\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，标签id\n* 2，标签名\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;tagUpdate(116, '测试测试c');\n删除标签\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，标签id\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;tagDelete(116);\n获取标签下粉丝列表\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，标签id\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;usersOfTag(116);\n用户管理\n批量为用户打标签\nuse EasySwoole\\WeChat\\WeChat;\n\n$openid = [\n  'ov3tQwtq3faIn...',\n  'ov3tQwkHO_wc2egq...'\n];\n\n/*\n* 传入参数\n* 1，openid数组\n* 2，标签ID\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;tagUsers($openid, 104);\n批量为用户取消标签\nuse EasySwoole\\WeChat\\WeChat;\n\n$openid = [\n  'ov3tQwtq3faIn...',\n  'ov3tQwkHO_wc2egq...'\n];\n/*\n* 传入参数\n* 1，openid数组\n* 2，标签ID\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;untagUsers($openid, 104);\n获取用户身上的标签列表\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，openid\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;userTags('ov3tQwkHO_wc2egq...');\n设置用户备注名\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，openid\n* 2，需要备注的名称\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;remark('ov3tQwkHO_wc2egquwbPzwxAOawU','备注名');\n获取用户基本信息\n获取用户基本信息（包括UnionID机制）\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，openid\n* 2，返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;get('ov3tQwkHO_wc2egquwbPzwxAOawU','zh_CN');\n批量获取用户基本信息\n\n返回内容中字段subscribe_scene是用户关注的渠道来源：\n\nADD_SCENE_SEARCH 公众号搜索，\nADD_SCENE_ACCOUNT_MIGRATION 公众号迁移，\nADD_SCENE_PROFILE_CARD 名片分享，ADD_SCENE_QR_CODE 扫描二维码，\nADD_SCENE_PROFILE_LINK 图文页内名称点击，\nADD_SCENE_PROFILE_ITEM 图文页右上角菜单，\nADD_SCENE_PAID 支付后关注，\nADD_SCENE_OTHERS 其他\n\n\nuse EasySwoole\\WeChat\\WeChat;\n\n$openid = [\n  'ov3tQwtq3faIn...',\n  'ov3tQwkHO_wc2egq...'\n];\n\n/*\n* 传入参数\n* 1，openid数组\n* 2，返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;select($openid,'zh_CN');\n获取用户列表\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，第一个拉取的OPENID，不填默认从头开始拉取\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;list('ov3tQwtq3faInMKywZYtoMynLUxs');\n获取用户地理位置\n\n这是一个 LOCATION事件类型的事件推送\n接收事件参考\n相关参考 查看接收事件推送请点我\n\n黑名单管理\n获取公众号的黑名单列表\nuse EasySwoole\\WeChat\\WeChat;\n\n/*\n* 传入参数\n* 1，第一个拉取的OPENID，不填默认从头开始拉取\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;blacklist('ov3tQwtq3faInMKywZYtoMynLUxs');\n拉黑用户\nuse EasySwoole\\WeChat\\WeChat;\n\n$openid = [\n  'ov3tQwkHO_wc2egquwbPzwxAOawU'\n];\n\n/*\n* 传入参数\n* 1，需要拉入黑名单的用户的openid，一次拉黑最多允许20个\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;black($openid);\n取消拉黑用户\nuse EasySwoole\\WeChat\\WeChat;\n\n$openid = [\n  'ov3tQwkHO_wc2egquwbPzwxAOawU'\n];\n\n/*\n* 传入参数\n* 1，需要拉入黑名单的用户的openid，一次拉黑最多允许20个\n*/\n$weChat-&gt;officialAccount()-&gt;user()-&gt;unblack($openid);\n账号管理\n生成带参数的二维码\n创建二维码ticket\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\QrCodeRequest;\n\n// 获取QrCodeRequest Bean实例\n$qrCodeRequest = new QrCodeRequest();\n\n/*\n* 当二维码类型为临时的时候该设定生效\n* 二维码有效时间，以秒为单位。 最大不超过2592000（即30天），此字段如果不填，则默认有效期为30秒。\n*/\n$qrCodeRequest-&gt;setExpireSeconds(30);\n\n/*\n* 二维码类型\n* QR_SCENE为临时的整型参数值，QR_STR_SCENE为临时的字符串参数值\n* QR_LIMIT_SCENE为永久的整型参数值，QR_LIMIT_STR_SCENE为永久的字符串参数值\n*/\n$qrCodeRequest-&gt;setActionName($qrCodeRequest::QR_SCENE);\n\n// 二维码详细信息(数组形式)\n$scene = [\n  \"scene\" =&gt; [\n    \"scene_id\"  =&gt; 555,\n    \"scene_str\" =&gt; \"test\"\n  ]\n];\n$qrCodeRequest-&gt;setActionInfo($scene);\n\n/*\n* 二维码详细信息不用数组形式设定\n*\n* 场景值ID，临时二维码时为32位非0整型，永久二维码时最大值为100000（目前参数只支持1--100000）\n* $qrCodeRequest-&gt;setSceneId(666);\n*\n* 场景值ID（字符串形式的ID），字符串类型，长度限制为1到64\n* $qrCodeRequest-&gt;setSceneStr('EasySwoole');\n*/\n\n// 获取qrCode实例\n$qrCode = $weChat-&gt;officialAccount()-&gt;qrCode();\n\n// 获取ticket\n$tick = $qrCode-&gt;getTick($qrCodeRequest);\n\n// 通过ticket换取二维码\n$qrCode::tickToImageUrl($tick);\n通过ticket换取二维码\n就是上文中最后一步\n// 通过ticket换取二维码\n$qrCode::tickToImageUrl($ss);\n长链接转短链接接口\nuse EasySwoole\\WeChat\\WeChat;\n\n$url = 'https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQFB8DwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyekJaZW9LX1';\n// 传入url返回字符串地址\n$$weChat-&gt;officialAccount()-&gt;qrCode()-&gt;shorturl($url);\n数据统计\n用户分析\n获取用户增减数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-07');\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUserCumulate($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取累计用户数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-07');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUserSummary($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n图文分析\n获取图文群发每日数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getArticleSummary($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取图文群发总数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getArticleTotal($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取图文统计数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUserRead($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取图文统计分时数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUserReadHour($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取图文分享转发数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUserShare($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取图文分享转发分时数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUserShareHour($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n消息分析\n获取消息发送概况数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUpStreamMsg($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取消息发送分时数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUpStreamMsgHour($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取消息发送周数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUpStreamMsgWeek($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取消息发送月数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUpStreamMsgMonth($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取消息发送分布数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUpStreamMsgDist($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取消息发送分布周数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUpStreamMsgDistWeek($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取消息发送分布月数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getUpStreamMsgDistMonth($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n广告分析\n分广告位数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;publisherAdposGeneral($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n返佣商品数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;publisherCpsGeneral($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n结算收入数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;publisherSettlement($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n接口分析\n获取接口分析数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;getInterfaceSummary($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\n获取接口分析分时数据\nuse EasySwoole\\WeChat\\WeChat;\nuse EasySwoole\\WeChat\\Bean\\OfficialAccount\\DataCubeRequest;\n\n/*\n* 实例化DataCubeRequest对象并设置参数\n*/\n$dataCube = new DataCubeRequest();\n$dataCube-&gt;setBeginDate('2020-05-01');\n$dataCube-&gt;setEndDate('2020-05-01');\n\n// 返回DataCubeRequest对象\n$data = $weChat-&gt;officialAccount()-&gt;dataCube()-&gt;publisherSettlement($dataCube);\n// 获取返回数据列表\nvar_dump($data-&gt;getList());\nRequestConst预定义常量查看\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018-12-30\n * Time: 17:14\n */\n\nnamespace EasySwoole\\WeChat\\Bean\\OfficialAccount;\n\nclass RequestConst\n{\n/*\n* https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140453\n*/\n    const DEFAULT_ON_MESSAGE = '__DEFAULT_ON_MESSAGE__';\n    const DEFAULT_ON_EVENT   = '__DEFAULT_ON_EVENT__';\n\n    const MSG_TYPE_TEXT        = 'text';\n    const MSG_TYPE_EVENT       = 'event';\n    const MSG_TYPE_IMAGE       = 'image';\n    const MSG_TYPE_MUSIC       = 'music';\n    const MSG_TYPE_VOICE       = 'voice';\n    const MSG_TYPE_VIDEO       = 'video';\n    const MSG_TYPE_SHORT_VIDEO = 'shortvideo';\n    const MSG_TYPE_LOCATION    = 'location';\n    const MSG_TYPE_LINK        = 'link';\n    const MSG_TYPE_NEWS        = 'news';\n\n/**\n * 客服发送消息中出现\n */\n    const MSG_TYPE_MPNEWS          = 'mpnews';\n    const MSG_TYPE_MSGMENU         = 'msgmenu';\n    const MSG_TYPE_WXCARD          = 'wxcard';\n    const MSG_TYPE_MINIPROGRAMPAGE = 'miniprogrampage';\n\n/**\n * 群发消息中出现\n */\n    const MSG_TYPE_MPVIDEO = 'mpvideo';\n\n/*\n * 事件大小写不同，主要是微信自己本身事件大小写就不一样，不规范\n */\n// 用户关注事件\n    const EVENT_SUBSCRIBE = 'subscribe';\n// 用户取消关注事件\n    const EVENT_UNSUBSCRIBE = 'unsubscribe';\n// 用户已关注事件\n    const EVENT_SCAN = 'SCAN';\n// 上报地理位置事件\n    const EVENT_LOCATION = 'LOCATION';\n// 点击自定义菜单拉取消息事件\n    const EVENT_CLICK = 'CLICK';\n// 点击自定义菜单跳转事件\n    const EVENT_VIEW = 'VIEW';\n// 发送模板消息通知事件\n    const EVENT_TEMPLATE_SEND_JOB_FINISH = 'TEMPLATESENDJOBFINISH';\n// 群发结果事件\n    const EVENT_MASS_SEND_JOB_FINISH           = 'MASSSENDJOBFINISH';\n//扫码推事件的事件推送\n    const EVENT_SCANCODE_PUSH = 'scancode_push';\n//扫码推事件且弹出“消息接收中”提示框的事件推送\n    const EVENT_SCANCODE_WAITMSG = 'scancode_waitmsg';\n//弹出系统拍照发图的事件推送\n    const EVENT_PIC_SYSPHOTO = 'pic_sysphoto';\n//弹出拍照或者相册发图的事件推送\n    const EVENT_PIC_PHOTO_OR_ALBUM = 'pic_photo_or_album';\n//弹出微信相册发图器的事件推送\n    const EVENT_PIC_WEIXIN = 'pic_weixin';\n//弹出地理位置选择器的事件推送\n    const EVENT_LOCATION_SELECT = 'location_select';\n//点击菜单跳转小程序的事件推送\n    const EVENT_VIEW_MINIPROGRAM = 'view_miniprogram';\n\n}\n","link":"/Components/WeChat/officialAccount.html"},{"id":244,"title":"小程序","content":"微信小程序\n获取小程序对象\n$wxa = new \\EasySwoole\\WeChat\\MiniProgram\\MiniProgram;\n$wxa-&gt;getConfig()-&gt;setAppId('your appid')-&gt;setAppSecret('your appsecret');\n获取小程序session\n详细信息请参阅 微信小程序登陆\n$code = '';\n$session = $wxa-&gt;auth()-&gt;session($code);\n你会返回一个包含下面文档中提到的参数的数组\ncode2Session\n创建二维码\n参阅文档documentation\n我们可以使用一下三种方式创建二维码\n    /** 二维码 - 永久小程序码 Api: $wxa-&gt;qrCode()-&gt;getWxaCode()\n     * @param $path             扫码进入的小程序页面路径，最大长度 128 字节\n     * @param int $width        二维码的宽度\n     * @param bool $autoColor   自动配置线条颜色\n     * @param null $lineColor   auto_color 为 false 时生效，使用 rgb 设置颜色 例如 {\"r\":\"xxx\",\"g\":\"xxx\",\"b\":\"xxx\"} 十进制表示\n     * @param bool $isHyaline   是否需要透明底色\n     */\n    function getWxaCode($path, $width = 430, $autoColor = false, $lineColor = null, $isHyaline = false)\n\n     /**\n     * 二维码 - 临时小程序码 Api: $wxa-&gt;qrCode()-&gt;getWxaCodeUnLimit()\n     * @param $path             已经发布的小程序存在的页面\n     * @param $scene            最大32个可见字符\n     * @param int $width        二维码的宽度\n     * @param bool $autoColor   自动配置线条颜色\n     * @param null $lineColor   auto_color 为 false 时生效，使用 rgb 设置颜色 例如 {\"r\":\"xxx\",\"g\":\"xxx\",\"b\":\"xxx\"} 十进制表示\n     * @param bool $isHyaline   是否需要透明底色\n     */\n     function getWxaCodeUnLimit($path, $scene, $width = 430, $autoColor = false, $lineColor = null, $isHyaline = false)\n\n     /**\n     * 二维码 - 永久二维码 Api:  $wxa-&gt;qrCode()-&gt;createWxaQrCode()\n     * @param $path             扫码进入的小程序页面路径，最大长度 128 字节\n     * @param int $width        二维码的宽度\n     */\n      function createWxaQrCode($path, $width = 430)\n\n获取帐号下已存在的模板列表\n$wxa-&gt;templateMsg()-&gt;getTemplateList(int $offset, int $count)\n获取模板库某个模板标题下关键词库\n$wxa-&gt;templateMsg()-&gt;getTemplateLibraryById(string $id)\n组合模板并添加至帐号下的个人模板库\n$wxa-&gt;templateMsg()-&gt;addTemplate(string $id, array $keywordIdList)\n删除帐号下的某个模板\n$wxa-&gt;templateMsg()-&gt;deleteTemplate(string $templateId)\n获取小程序模板库标题列表\n$wxa-&gt;templateMsg()-&gt;getTemplateLibraryList(int $offset, int $count)\n发送模板消息\n//要传递的参数数组，下面实际方法中是传入Bean\n$templateMsg = [\n    'touser' =&gt; 'user-openid',\n    'template_id' =&gt; 'template-id',\n    'page' =&gt; 'index',\n    'form_id' =&gt; 'form-id',\n    'data' =&gt; [\n        'keyword1' =&gt; 'VALUE',\n        'keyword2' =&gt; 'VALUE2',\n    ],\n];\n\n$wxa-&gt;templateMsg()-&gt;send(TemplateMsgBean $templateMsg)\n\n微信小程序消息解密(获取电话等功能，信息是加密的，需要解密)\n$wxa-&gt;encryptor()-&gt;decryptData(string $sessionKey, string $iv, string $encryptedData)\n检查一段文本是否含有违法违规内容\n$wxa-&gt;checkFile()-&gt;msgSecCheck(string $content)\n校验一张图片是否含有违法违规内容\n$wxa-&gt;checkFile()-&gt;imgSecCheck(ImgUploadBean $imgUpload)\n异步校验图片/音频是否含有违法违规内容\n$wxa-&gt;checkFile()-&gt;mediaCheckAsync(string $mediaUrl ,int $mediaType)\n物流助手(小程序)\n/**\n * 绑定、解绑物流账号 Api: $wxa-&gt;logisticsProgram()-&gt;bindAccount()\n * @param BindAccount $bindAccount\n */\nfunction bindAccount(BindAccount $bindAccount)\n\n//例子\n//要传递的参数数组，下面实际方法中是传入Bean\n$bindAccount = [\n    'type'          =&gt; 'bind',  //bind表示绑定，unbind表示解除绑定\n    'biz_id'        =&gt; '1',     //快递公司客户编码\n    'delivery_id'   =&gt;  '1',     //快递公司ID\n    'password'      =&gt;  '***',     //快递公司客户密码\n    'remark_content'=&gt;  '测试'      //备注内容（提交EMS审核需要）\n];\n\n$wxa-&gt;logisticsProgram()-&gt;bindAccount($bindAccount);\n\n /**获取所有绑定的物流账号 Api: $wxa-&gt;logisticsProgram()-&gt;getAllAccount()\n  *\n  */\n function getAllAccount()\n\n /**\n * 获取电子面单余额。仅在使用加盟类快递公司时，才可以调用。 Api: $wxa-&gt;logisticsProgram()-&gt;getQuota()\n * @param string $deliveryId    快递公司ID  \n * @param string $bizId         快递公司客户编码\n */\nfunction getQuota(string $deliveryId ,string $bizId)\n\n/**\n * 生成运单 Api: $wxa-&gt;logisticsProgram()-&gt;addOrder()\n * @param AddOrder $addOrder\n * 具体参数请参考文档： https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/express/by-business/logistics.addOrder.html\n */\nfunction addOrder(AddOrder $addOrder)\n\n/**\n * 取消运单 Api: $wxa-&gt;logisticsProgram()-&gt;cancelOrder()\n * @param string $orderId       订单 ID，需保证全局唯一\n * @param string $openid        用户openid，当add_source=2时无需填写（不发送物流服务通知）\n * @param string $deliveryId    快递公司ID\n * @param string $waybillId     运单ID\n */\nfunction cancelOrder(string $orderId ,string $openid ,string $deliveryId ,string $waybillId)\n\n/**\n * 获取支持的快递公司列表 Api: $wxa-&gt;logisticsProgram()-&gt;getAllDelivery()\n */\nfunction getAllDelivery()\n\n/* 获取运单数据 Api:  $wxa-&gt;logisticsProgram()-&gt;getOrder()\n * @param string $orderId       订单 ID，需保证全局唯一\n * @param string $openid        用户openid，当add_source=2时无需填写（不发送物流服务通知）\n * @param string $deliveryId    快递公司ID\n * @param string $waybillId     运单ID\n */\nfunction getOrder(string $orderId ,string $openid ,string $deliveryId ,string $waybillId)\n\n/* 查询运单轨迹 Api:  $wxa-&gt;logisticsProgram()-&gt;getPath()\n * @param string $orderId       订单 ID，需保证全局唯一\n * @param string $openid        用户openid，当add_source=2时无需填写（不发送物流服务通知）\n * @param string $deliveryId    快递公司ID\n * @param string $waybillId     运单ID\n */\n function getPath(string $orderId ,string $openid ,string $deliveryId ,string $waybillId)\n\n//获取打印员。若需要使用微信打单 PC 软件，才需要调用。 Api: $wxa-&gt;logisticsProgram()-&gt;getPrinter()\n function getPrinter()\n\n /**\n * 配置面单打印员,若需要使用微信打单 PC 软件，才需要调用。 Api: $wxa-&gt;logisticsProgram()-&gt;updatePrinter()\n * @param string $openid        打印员 openid\n * @param string $updateType    更新类型\n * @param string $tagidList     用于平台型小程序设置入驻方的打印员面单打印权限，同一打印员最多支持10个tagid，使用逗号分隔，如填写123，456，表示该打印员可以拉取到tagid为123和456的下的单，非平台型小程序无需填写该字段\n */\n function updatePrinter(string $openid ,string $updateType ,string $tagidList)\n\n物流助手(服务端)\n/**\n * 获取面单联系人信息 Api: $wxa-&gt;logisticsService()-&gt;getContact()\n * @param string $tokens        商户侧下单事件中推送的 Token 字段\n * @param string $waybillId     运单 ID\n */\nfunction getContact(string $tokens ,string $waybillId)\n\n /**\n * 预览面单模板。用于调试面单模板使用。 Api:  $wxa-&gt;logisticsService()-&gt;previewTemplate()\n * @param string $waybillId         运单 ID\n * @param string $waybillTemplate   面单 HTML 模板内容（需经 Base64 编码）\n * @param string $waybillData       面单数据\n * @param AddOrder $addOrder        商户下单数据\n * 具体参数文档地址：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/express/by-provider/logistics.previewTemplate.html\n */\n  function previewTemplate(string $waybillId ,string $waybillTemplate ,string $waybillData,AddOrder $addOrder)\n\n/**\n * 更新商户审核结果 Api:  $wxa-&gt;logisticsService()-&gt;updateBusiness()\n * @param string $shopAppId     商户的小程序AppID\n * @param string $bizId         商户账户\n * @param int $resultCode       审核结果，0 表示审核通过，其他表示审核失败\n * @param string $resultMsg     审核错误原因，仅 result_code 不等于 0 时需要设置\n */\nfunction updateBusiness(string $shopAppId ,string $bizId ,int $resultCode ,string $resultMsg)\n\n/**\n     * 更新运单轨迹 Api: $wxa-&gt;logisticsService()-&gt;updatePath()\n     * @param UpdatePath $updatePath\n     * 具体参数文档地址：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/express/by-provider/logistics.updatePath.html\n     */\n    function updatePath(UpdatePath $updatePath)\n\n生物认证\n/**\n     * SOTER 生物认证秘钥签名验证 Api: $wxa-&gt;attest()-&gt;verifySignature()\n     * @param string $openid        用户 openid\n     * @param string $jsonString    通过 wx.startSoterAuthentication 成功回调获得的 resultJSON 字段\n     * @param string $jsonSignature 通过 wx.startSoterAuthentication 成功回调获得的 resultJSONSignature 字段\n     */\n    function verifySignature(string $openid ,string $jsonString ,string $jsonSignature)\n\n插件管理\n/**\n *向插件开发者发起使用插件的申请 Api: $wxa-&gt;plugin()-&gt;applyPlugin()\n * @param string $action        此接口下填写 \"apply\"\n * @param string $pluginAppid   插件 appId\n * @param string $reason        申请使用理由\n */\nfunction applyPlugin(string $action = 'apply' ,string $pluginAppid ,string $reason = '')\n\n/**\n * 获取当前所有插件使用方（供插件开发者调用）Api: $wxa-&gt;plugin()-&gt;getPluginDevApplyList()\n * @param string $action    此接口下填写 \"dev_apply_list\"\n * @param int $page         要拉取第几页的数据\n * @param int $num          每页的记录数\n */\nfunction getPluginDevApplyList(string $action = 'dev_apply_list' ,int $page = 1 ,int $num = 10)\n\n/**\n * 查询已添加的插件 Api: $wxa-&gt;plugin()-&gt;getPluginList()\n * @param string $action    此接口下填写 \"list\"\n */\nfunction getPluginList(string $action = 'list')\n\n/**\n * 修改插件使用申请的状态（供插件开发者调用）Api: $wxa-&gt;plugin()-&gt;setDevPluginApplyStatus()\n * @param string $action    修改操作\n * @param string $appid     使用者的 appid。同意申请时填写。    \n * @param string $reason    拒绝理由。拒绝申请时填写\n */\nfunction setDevPluginApplyStatus(string $action ,string $appid = '' ,string $reason = '')\n\n/**\n * 删除已添加的插件 Api:  $wxa-&gt;plugin()-&gt;unbindPlugin()\n * @param string $action        此接口下填写 \"unbind\"\n * @param string $pluginAppid   插件 appId\n */\nfunction unbindPlugin(string $action = 'unbind' ,string $pluginAppid)\n\n附近的小程序\n/**\n * 添加地点 Api: $wxa-&gt;program()-&gt;add()\n * @param ProgramBean $program\n * 参数文档： https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/nearby-poi/nearbyPoi.add.html\n */\nfunction add(ProgramBean $program)\n\n//例子\n\n$program = [\n    'kf_info' =&gt; '{\"open_kf\":true,\"kf_headimg\":\"http://mmbiz.qpic.cn/mmbiz_jpg/kKMgNtnEfQzDKpLXYhgo3W3Gndl34gITqmP914zSwhajIEJzUPpx40P7R8fRe1QmicneQMhFzpZNhSLjrvU1pIA/0?wx_fmt=jpeg\",\"kf_name\":\"Harden\"}',\n    'pic_list' =&gt; '{\"list\":[\"http://mmbiz.qpic.cn/mmbiz_jpg/kKMgNtnEfQzDKpLXYhgo3W3Gndl34gITqmP914zSwhajIEJzUPpx40P7R8fRe1QmicneQMhFzpZNhSLjrvU1pIA/0?wx_fmt=jpeg\",\"http://mmbiz.qpic.cn/mmbiz_jpg/kKMgNtnEfQzDKpLXYhgo3W3Gndl34gITRneE5FS9uYruXGMmrtmhsBySwddEWUGOibG8Ze2NT5E3Dyt79I0htNg/0?wx_fmt=jpeg\"]}',\n    'service_infos' =&gt; '{\"service_infos\":[{\"id\":2,\"type\":1,\"name\":\"快递\",\"appid\":\"wx1373169e494e0c39\",\"path\":\"index\"},{\"id\":0,\"type\":2,\"name\":\"测试\",\"appid\":\"wx1373169e494e0c39\",\"path\":\"index\"}]}',\n    'store_name' =&gt; '测试测试',\n    'contract_phone' =&gt; '1769360227',\n    'hour' =&gt; '00:00-11:11',\n    'company_name' =&gt; '测试数据啊',\n    'credential' =&gt; '13082741523645',\n    'address' =&gt; 'xxxxxxxx',\n    'qualification_list' =&gt; '3LaLzqiTrQcD20DlX_o-OV1-nlYMu7sdVAL7SV2PrxVyjZFZZmB3O6LPGaYXlZWq',\n];\n\n$wxa-&gt;program()-&gt;add($program);\n /**\n * 删除地点 Api: $wxa-&gt;program()-&gt;delete()\n * @param string $poiId 附近地点 ID\n */\nfunction delete(string  $poiId)\n\n/**\n * 查看地点列表 Api:  $wxa-&gt;program()-&gt;getList()\n * @param int $page     起始页id（从1开始计数）\n * @param int $pageRows 每页展示个数（最多1000个）\n */\nfunction getList(int $page = 1 ,int $pageRows)\n\n/**\n * 展示/取消展示附近小程序 Api: $wxa-&gt;program()-&gt;setShowStatus()\n * @param string $poiId 附近地点 ID\n * @param int $status   是否展示 0: 不展示，1：展示\n */\nfunction setShowStatus(string $poiId ,int $status)\n","link":"/Components/WeChat/miniProgram.html"},{"id":245,"title":"安装","content":"EasySwoole Pay\nEasySwoole Pay 是一个基于 Swoole 4.x 全协程支持的支付SDK库，告别同步阻塞。\n组件要求\n\next-json &gt;= 1.0\next-openssl &gt;= 1.0\next-bcmath: *\neasyswoole/http &gt;= ^1.2\neasyswoole/spl &gt;= ^1.1\neasyswoole/http-client &gt;= ^1.2.5\neasyswoole/utility &gt;= ^1.0\n\n\n注意：请务必检查你的 php 环境有没有安装 php-bcmath 扩展，没有安装 php-bcmath 扩展时安装的 pay 组件的版本是 1.2.17 之前的版本(不是最新)。想要使用最新稳定版 pay 组件的功能，请先安装 php-bcmath 扩展，php 安装此扩展的方法请自行查询。\n\n安装方法\n\ncomposer require easyswoole/pay\n\n仓库地址\neasyswoole/pay","link":"/Components/Pay/install.html"},{"id":246,"title":"微信","content":"协程支付网关(微信支付)\n组件安装方法和说明\n\n注意：请务必检查你的 php 环境有没有安装 php-bcmath 扩展，没有安装 php-bcmath 扩展时安装的 pay 组件的版本是 1.2.17 之前的版本(不是最新)。想要使用最新稳定版 pay 组件的功能，请先安装 php-bcmath 扩展，php 安装此扩展的方法请自行查询。\n\ncomposer require easyswoole/pay\n微信支付方法\n微信支付目前支持 6 种支付方法，对应的支付 method 如下：\n\n\n\nmethod\n说明\n参数\n返回值\n\n\n\n\nwap\n手机网站支付\nRequest\nResponse\n\n\nofficialAccount\n公众号支付\nRequest\nResponse\n\n\nscan\n扫码支付\nRequest\nResponse\n\n\nminiProgram\n小程序支付\nRequest\nResponse\n\n\nbarCode\n条码当面支付\nRequest\nResponse\n\n\nApp\nApp支付\nRequest\nResponse\n\n\n\n微信参数配置\n$wechatConfig = new Config();\n$wechatConfig-&gt;setAppId('xxxxxx');      // 除了小程序以外使用该APPID\n$wechatConfig-&gt;setMiniAppId('xxxxxx');  // 小程序使用该APPID\n$wechatConfig-&gt;setMchId('xxxxxx');\n$wechatConfig-&gt;setKey('xxxxxx');\n$wechatConfig-&gt;setNotifyUrl('xxxxx');\n$wechatConfig-&gt;setApiClientCert('xxxxxxx');//客户端证书\n$wechatConfig-&gt;setApiClientKey('xxxxxxx'); //客户端证书秘钥\n\n由于小程序拥有独立的APPID，只需要在配置里同时配置上AppId和MiniAppId两个配置项，在支付的时候会自动选择对应的APPID来发起支付\n\n公众号支付\n$officialAccount = new OfficialAccount();\n$officialAccount-&gt;setOpenid('xxxxxxx');\n$officialAccount-&gt;setOutTradeNo('CN' . date('YmdHis') . rand(1000, 9999));\n$officialAccount-&gt;setBody('xxxxx-测试' . $outTradeNo);\n$officialAccount-&gt;setTotalFee(1);\n$officialAccount-&gt;setSpbillCreateIp('xxxxx');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$params = $pay-&gt;weChat($wechatConfig)-&gt;officialAccount($officialAccount);\n可以参考demo/wechat/index.php \n\n在使用微信支付时，商品名称中如果出现特殊字符，如 &amp; 请自行使用urlencode在生成签名传参时进行编码\n\nH5支付\n$wap = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\Wap();\n$wap-&gt;setOutTradeNo('CN' . date('YmdHis') . rand(1000, 9999));\n$wap-&gt;setBody('xxxxx-WAP测试' . $outTradeNo);\n$wap-&gt;setTotalFee(1);\n$wap-&gt;setSpbillCreateIp('xxxxx');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$params = $pay-&gt;weChat($wechatConfig)-&gt;wap($wap);\n小程序支付\n$bean = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\MiniProgram();\n$bean-&gt;setOpenid('xxxxxxxxx');\n$bean-&gt;setOutTradeNo('CN' . date('YmdHis') . rand(1000, 9999));\n$bean-&gt;setBody('xxxx-测试' . $outTradeNo);\n$bean-&gt;setTotalFee(1);\n$bean-&gt;setSpbillCreateIp($this-&gt;request()-&gt;getHeader('x-real-ip')[0]);\n$pay = new \\EasySwoole\\Pay\\Pay();\n$params = $pay-&gt;weChat($this-&gt;wechatConfig)-&gt;miniProgram($bean);\nApp支付\n$app = new App();\n$app-&gt;setNonceStr('xxxxx');\n$app-&gt;setSign('xxxxx');\n$app-&gt;setBody('app支付测试');\n$app-&gt;setOutTradeNo(date(YmdHis).rand(1000,999));\n$app-&gt;setTotalFee(1);\n$app-&gt;setSpbillCreateIp('xxxx');\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n$result = $pay-&gt;weChat($wechatConfig)-&gt;app($app);\n扫码支付\n模式一\n生成扫码链接 然后生成二维码 具体请查看demo/wechat/index.php\n$biz = new Biz();\n$biz-&gt;setProductId('123456789');\n$biz-&gt;setTimeStamp(time());\n$biz-&gt;setAppId($wechatConfig-&gt;getAppId());\n$biz-&gt;setMchId($wechatConfig-&gt;getMchid());\n$data = $biz-&gt;toArray();\n$u = new Utility($wechatConfig);\n$sign = $u-&gt;generateSign($data);\n$biz-&gt;setSign($sign);\n$url1 = \"weixin://wxpay/bizpayurl?\" . $this-&gt;ToUrlParams($biz-&gt;toArray());\n扫码回调地址（ps:公众号平台设置）\n $xml = $this-&gt;request()-&gt;getBody()-&gt;__toString();\n$pay = new Pay();\n$data = $pay-&gt;weChat($this-&gt;wechatConfig)-&gt;verify($xml);\n$bean = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\Scan();\n$bean-&gt;setOutTradeNo('CN' . date('YmdHis') . rand(1000, 9999));\n$bean-&gt;setOpenid('xxxxxx');\n$bean-&gt;setProductId($data['product_id']);\n$bean-&gt;setBody('xxxxxx-SCAN测试' . $outTradeNo);\n$bean-&gt;setTotalFee(1);\n$bean-&gt;setSpbillCreateIp($this-&gt;request()-&gt;getHeader('x-real-ip')[0]);\n$response = $pay-&gt;weChat($this-&gt;wechatConfig)-&gt;scan($bean);\n$nativeResponse = new NativeResponse([\n    'appid' =&gt; $this-&gt;wechatConfig-&gt;getAppId(),\n    'mch_id' =&gt; $this-&gt;wechatConfig-&gt;getMchId(),\n    'prepay_id' =&gt; $response-&gt;getPrepayId(),\n    'nonce_str' =&gt; $response-&gt;getNonceStr()]);\n$u = new Utility($this-&gt;wechatConfig);\n$nativeResponse-&gt;setSign($u-&gt;generateSign($nativeResponse-&gt;toArray()));\n$xml = (new SplArray($nativeResponse-&gt;toArray()))-&gt;toXML();\n$this-&gt;response()-&gt;write($xml);\n模式二\n$bean = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\Scan();\n$bean-&gt;setOutTradeNo($outTradeNo);\n$bean-&gt;setProductId('123456789');\n$bean-&gt;setBody('xxxx-SCAN2测试' . $outTradeNo);\n$bean-&gt;setTotalFee(1);\n$bean-&gt;setSpbillCreateIp($this-&gt;request()-&gt;getHeader('x-real-ip')[0]);\n$pay = new Pay();\n$data = $pay-&gt;weChat($this-&gt;wechatConfig)-&gt;scan($bean);\n$url2 = $data-&gt;getCodeUrl();\n订单查询\ngo(function () use ($wechatConfig) {\n    $orderFind = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\OrderFind();\n    $orderFind-&gt;setOutTradeNo('CN201903181044383609');\n    $pay = new \\EasySwoole\\Pay\\Pay();\n    $info = $pay-&gt;weChat($wechatConfig)-&gt;orderFind($orderFind);\n    print_r((array)$info);\n});\n申请退款\ngo(function () use ($wechatConfig) {\n    $refund = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\Refund();\n    $refund-&gt;setOutTradeNo('CN201903181111275823');\n    $refund-&gt;setOutRefundNo('TK' . date('YmdHis') . rand(1000, 9999));\n    $refund-&gt;setTotalFee(1);\n    $refund-&gt;setRefundFee(1);\n    $refund-&gt;setNotifyUrl('xxxxx');\n    $pay = new \\EasySwoole\\Pay\\Pay();\n    $info = $pay-&gt;weChat($wechatConfig)-&gt;refund($refund);\n    print_r($info);\n});\n退款查询\ngo(function () use ($wechatConfig) {\n    $refundFind = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\RefundFind();\n    $refundFind-&gt;setOutTradeNo('CN201903181044383609');\n    $pay = new \\EasySwoole\\Pay\\Pay();\n    $info = $pay-&gt;weChat($wechatConfig)-&gt;refundFind($refundFind);\n    print_r((array)$info);\n});\n关闭订单\ngo(function () use ($wechatConfig) {\n    $close = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\Close();\n    $close-&gt;setOutTradeNo('CN201903151343107239');\n    $pay = new \\EasySwoole\\Pay\\Pay();\n    $info = $pay-&gt;weChat($wechatConfig)-&gt;close($close);\n    print_r((array)$info);\n});\n下载对账单\ngo(function () use ($wechatConfig) {\n    $download = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\Download();\n    $download-&gt;setBillDate('20190312');\n    $download-&gt;setBillType('ALL');//这个参数必传\n    $pay = new \\EasySwoole\\Pay\\Pay();\n    $info = $pay-&gt;weChat($wechatConfig)-&gt;download($download);\n    echo htmlspecialchars($info, ENT_QUOTES);\n});\n下载资金对账单\ngo(function () use ($wechatConfig) {\n    $download = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\DownloadFundFlow();\n    $download-&gt;setBillDate('20190312');\n    $download-&gt;setAccountType('Basic');\n    $pay = new \\EasySwoole\\Pay\\Pay();\n    $info = $pay-&gt;weChat($wechatConfig)-&gt;downloadFundFlow($download);\n    echo htmlspecialchars($info, ENT_QUOTES);\n});\n验证签名\n$pay = new \\EasySwoole\\Pay\\Pay();\n$content = '';//content为xml原始数据,在easyswoole中可通过$this-&gt;request()-&gt;getBody()-&gt;__toString()取出\n$data = $pay-&gt;weChat($wechatConfig)-&gt;verify($content  )\n服务器确认收到异步通知字符串获取\n\\EasySwoole\\Pay\\WeChat\\WeChat::success();//成功响应\n\\EasySwoole\\Pay\\WeChat\\WeChat::fail();//失败响应","link":"/Components/Pay/wechat.html"},{"id":247,"title":"支付宝","content":"协程支付网关(支付宝支付)\n组件安装方法和说明\n\n注意：请务必检查你的 php 环境有没有安装 php-bcmath 扩展，没有安装 php-bcmath 扩展时安装的 pay 组件的版本是 1.2.17 之前的版本(不是最新)。想要使用最新稳定版 pay 组件的功能，请先安装 php-bcmath 扩展，php 安装此扩展的方法请自行查询。\n\ncomposer require easyswoole/pay\n支付宝\n支付方法\n支付宝支付目前支持 7 种支付方法，对应的支付 method 如下：\n\n\n\nmethod\n说明\n参数\n返回值\n\n\n\n\nweb\n电脑支付\nRequest\nResponse\n\n\nwap\n手机网站支付\nRequest\nResponse\n\n\napp\nAPP 支付\nRequest\nResponse\n\n\npos\n刷卡支付\nRequest\nResponse\n\n\nscan\n扫码支付\nRequest\nResponse\n\n\ntransfer\n账户转账\nRequest\nResponse\n\n\nmini\n小程序支付\nRequest\nResponse\n\n\nbarCode\n条码当面支付\nRequest\nResponse\n\n\n\n注意，easyswoole/pay 支付宝支付组件的默认签名为 RSA2 普通公钥方式签名，也支持 RSA2 公钥证书的签名方式。放置应用公私钥证书、支付宝证书路径、支付宝根证书路径的时候切记核对。\n电脑支付\n统一收单下单并支付页面接口\n/**\n * 普通公钥方式生成密钥验签(签名和验签方式)\n */\n// 设置支付配置\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 return_url(默认为 null，可选参数)\n//   $aliConfig-&gt;setReturnUrl(null);\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n// 设置 阿里应用公钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于支付回调时验证签名\n$aliConfig-&gt;setPublicKey('阿里应用公钥字符串'); // 示例应用公钥字符串\n// 设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串'); // 示例应用私钥字符串\n\n/**\n * 公钥证书方式生成密钥验签(签名和验签方式)\n */\n/*\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 return_url(默认为 null，可选参数)\n//   $aliConfig-&gt;setReturnUrl(null);\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n\n// (必须)设置 使用公钥证书方式生密钥延签(签名和验签方式)\n$aliConfig-&gt;setCertMode(true);\n// (必须)设置 支付宝公钥文件路径\n$aliConfig-&gt;setCertPath(__DIR__ . '/cert/alipayCertPublicKey_RSA2.crt'); // 示例支付宝公钥文件路径\n// (必须)设置 支付宝根证书文件路径\n$aliConfig-&gt;setRootCertPath(__DIR__ . '/cert/alipayRootCert.crt'); // 示例支付宝公钥根证书文件路径\n// (必须)设置 阿里应用公钥证书文件路径\n$aliConfig-&gt;setMerchantCertPath(__DIR__ . '/cert/appCertPublicKey_2016091800538780.crt');\n// (必须)设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串'); // 示例应用私钥字符串\n*/\n\n// 以上【普通公钥方式】 和 【公钥证书方式】 生成密钥验签(签名和验签方式) 这 2 种方式，用户可自行选择一种】\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n## (面向对象风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Web();\n// (必须)设置 商户订单号(商户订单号。64 个字符以内的大小，仅支持字母、数字、下划线。需保证该参数在商户端不重复。)\n$order-&gt;setOutTradeNo(time() . '123456'); // 示例订单号(仅供参考)\n// (必须)设置 订单总金额\n$order-&gt;setTotalAmount('0.01'); // 示例订单总金额，单位：元(仅供参考)\n// (必须)设置 商品标题/交易标题/订单标题/订单关键字等。注意：不可使用特殊字符，如 /，=，&amp; 等。\n$order-&gt;setSubject('测试'); // 示例商品标题(仅供参考)\n// (可选)设置 订单描述，默认为 null\n//   $order-&gt;setBody(null);\n// (可选)设置 在订单中设置支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $order-&gt;setNotifyUrl(null); // 等价于在配置中设置 支付回调地址，两者中只要设置一次即可\n// (可选)设置 return_url(默认为 null，可选参数)\n//   $order-&gt;setReturnUrl(null); // 等价于在配置中设置 return_url，两者中只要设置一次即可\n// 本库只预置了常用的请求参数，没预置的参数请求使用：$order-&gt;addProperty('其他字段','其他字段值');\n// 支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n\n## (数组风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n/*\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Web([\n    'out_trade_no' =&gt; time() . '123456', // 示例订单号(仅供参考)\n    'total_amount' =&gt; '0.01', // 示例订单总金额，单位：元(仅供参考)\n    'subject' =&gt; '测试', // 示例商品标题(仅供参考)\n    '额外的字段键值' =&gt; '额外字段值', // 示例支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n], true);\n*/\n\n// 以上 2 种风格设置请求参数，用户可根据个人需要，选其一即可\n\n// 获取构造请求参数对象\n$res = $pay-&gt;aliPay($aliConfig)-&gt;web($order);\n// 将所有请求参数转为数组\nvar_dump($res-&gt;toArray());\n\n// 构造请求表单(buildPayHtml 该方法的实现请看下文)  \n$html = buildPayHtml(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL, $res-&gt;toArray());\nfile_put_contents('test.html', $html); \n订单配置参数\n所有订单配置中，对于客观非必选参数，用户可以自行选择是否进行配置，也可以不进行配置，扩展包已经为您自动处理了，比如，product_code 等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考 这里，查看「请求参数」一栏。\n参数查询：https://opendocs.alipay.com/apis/api_1/alipay.trade.page.pay\n生成支付的跳转 html 示例\nfunction buildPayHtml($endpoint, $payload)\n{\n    $sHtml = \"&lt;form id='alipaysubmit' name='alipaysubmit' action='\".$endpoint.\"' method='POST'&gt;\";\n    foreach ($payload as $key =&gt; $val) {\n        $val = str_replace(\"'\", '&amp;apos;', $val);\n        $sHtml .= \"&lt;input type='hidden' name='\".$key.\"' value='\".$val.\"'/&gt;\";\n    }\n    $sHtml .= \"&lt;input type='submit' value='ok' style='display:none;'&gt;&lt;/form&gt;\";\n    $sHtml .= \"&lt;script&gt;document.forms['alipaysubmit'].submit();&lt;/script&gt;\";\n    return $sHtml;\n}\n手机网站支付接口 2.0\n/**\n * 普通公钥方式生成密钥验签(签名和验签方式)\n */\n// 设置支付配置\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 return_url(默认为 null，可选参数)\n//   $aliConfig-&gt;setReturnUrl(null);\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n// 设置 阿里应用公钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于支付回调时验证签名\n$aliConfig-&gt;setPublicKey('阿里应用公钥字符串'); // 示例应用公钥字符串\n// 设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串'); // 示例应用私钥\n\n/**\n * 公钥证书方式生成密钥验签(签名和验签方式)\n */\n/*\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 return_url(默认为 null，可选参数)\n//   $aliConfig-&gt;setReturnUrl(null);\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n\n// (必须)设置 使用公钥证书方式生密钥延签(签名和验签方式)\n$aliConfig-&gt;setCertMode(true);\n// (必须)设置 支付宝公钥文件路径\n$aliConfig-&gt;setCertPath(__DIR__ . '/cert/alipayCertPublicKey_RSA2.crt'); // 示例支付宝公钥文件路径\n// (必须)设置 支付宝根证书文件路径\n$aliConfig-&gt;setRootCertPath(__DIR__ . '/cert/alipayRootCert.crt'); // 示例支付宝公钥根证书文件路径\n// (必须)设置 阿里应用公钥证书文件路径\n$aliConfig-&gt;setMerchantCertPath(__DIR__ . '/cert/appCertPublicKey_2016091800538780.crt');\n// (必须)设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串');\n*/\n\n// 以上【普通公钥方式】 和 【公钥证书方式】 生成密钥验签(签名和验签方式) 这 2 种方式，用户可自行选择一种】\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n## (面向对象风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Wap();\n// (必须)设置 商品标题/交易标题/订单标题/订单关键字等。注意：不可使用特殊字符，如 /，=，&amp; 等。\n$order-&gt;setSubject('测试'); // 示例商品标题(仅供参考)\n// (必须)设置 商户订单号(商户订单号。64 个字符以内的大小，仅支持字母、数字、下划线。需保证该参数在商户端不重复。)\n$order-&gt;setOutTradeNo(time() . '123456'); // 示例订单号(仅供参考)\n// (必须)设置 订单总金额\n$order-&gt;setTotalAmount('0.01'); // 示例订单总金额，单位：元(仅供参考)\n// (必须)设置 用户付款中途退出返回商户网站的地址\n$order-&gt;addProperty('quit_url', 'http://www.easyswoole.com'); // 示例中途退出返回商户网站的地址(仅供参考)\n\n// (可选)设置 订单描述，默认为 null\n//   $order-&gt;setBody(null);\n// (可选)设置 在订单中设置支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $order-&gt;setNotifyUrl(null); // 等价于在配置中设置 支付回调地址，两者中只要设置一次即可\n// (可选)设置 return_url(默认为 null，可选参数)\n//   $order-&gt;setReturnUrl(null); // 等价于在配置中设置 return_url，两者中只要设置一次即可\n// 本库只预置了常用的请求参数，没预置的参数请求使用：$order-&gt;addProperty('其他字段','其他字段值');\n// 支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n\n## (数组风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n/*\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Wap([\n    'out_trade_no' =&gt; time() . '123456', // 示例订单号(仅供参考)\n    'total_amount' =&gt; '0.01', // 示例订单总金额，单位：元(仅供参考)\n    'subject' =&gt; '测试', // 示例商品标题(仅供参考)\n    'quit_url' =&gt; 'http://www.easyswoole.com', // 示例中途退出返回商户网站的地址(仅供参考)\n    '额外的字段键值' =&gt; '额外字段值', // 示例支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n], true);\n*/\n\n// 以上 2 种风格设置请求参数，用户可根据个人需要，选其一即可\n\n// 获取构造请求参数对象\n$res = $pay-&gt;aliPay($aliConfig)-&gt;wap($order);\n// 将所有请求参数转为数组\nvar_dump($res-&gt;toArray());\n\n// 构造请求表单(buildPayHtml 该方法的实现请看上文)  \n$html = buildPayHtml(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL, $res-&gt;toArray());\nfile_put_contents('test.html', $html);\n订单配置参数\n所有订单配置中，对于客观非必选参数，用户可以自行选择是否进行配置，也可以不进行配置，扩展包已经为您自动处理了，比如，product_code 等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考 这里，查看「请求参数」一栏。\n参数查询：https://opendocs.alipay.com/apis/api_1/alipay.trade.wap.pay\nAPP支付接口 2.0\n/**\n * 普通公钥方式生成密钥验签(签名和验签方式)\n */\n// 设置支付配置\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 return_url(默认为 null，可选参数)\n//   $aliConfig-&gt;setReturnUrl(null);\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n// 设置 阿里应用公钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于支付回调时验证签名\n$aliConfig-&gt;setPublicKey('阿里应用公钥字符串'); // 示例应用公钥字符串\n// 设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串'); // 示例应用私钥\n\n/**\n * 公钥证书方式生成密钥验签(签名和验签方式)\n */\n/*\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 return_url(默认为 null，可选参数)\n//   $aliConfig-&gt;setReturnUrl(null);\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n\n// (必须)设置 使用公钥证书方式生密钥延签(签名和验签方式)\n$aliConfig-&gt;setCertMode(true);\n// (必须)设置 支付宝公钥文件路径\n$aliConfig-&gt;setCertPath(__DIR__ . '/cert/alipayCertPublicKey_RSA2.crt'); // 示例支付宝公钥文件路径\n// (必须)设置 支付宝根证书文件路径\n$aliConfig-&gt;setRootCertPath(__DIR__ . '/cert/alipayRootCert.crt'); // 示例支付宝公钥根证书文件路径\n// (必须)设置 阿里应用公钥证书文件路径\n$aliConfig-&gt;setMerchantCertPath(__DIR__ . '/cert/appCertPublicKey_2016091800538780.crt');\n// (必须)设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串');\n*/\n\n// 以上【普通公钥方式】 和 【公钥证书方式】 生成密钥验签(签名和验签方式) 这 2 种方式，用户可自行选择一种】\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n## (面向对象风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\App();\n// (必须)设置 订单总金额\n$order-&gt;setTotalAmount('0.01'); // 示例订单总金额，单位：元(仅供参考)\n// (必须)设置 商品标题/交易标题/订单标题/订单关键字等。注意：不可使用特殊字符，如 /，=，&amp; 等。\n$order-&gt;setSubject('测试'); // 示例商品标题(仅供参考)\n// (必须)设置 商户订单号(商户订单号。64 个字符以内的大小，仅支持字母、数字、下划线。需保证该参数在商户端不重复。)\n$order-&gt;setOutTradeNo(time() . '123456'); // 示例订单号(仅供参考)\n// (可选)设置 销售产品码，商家和支付宝签约的产品码，默认为 QUICK_MSECURITY_PAY（App支付）。\n//   $order-&gt;addProperty('product_code', 'QUICK_MSECURITY_PAY'); // 示例销售产品码(仅供参考)\n// (可选)设置 订单描述，默认为 null\n//   $order-&gt;setBody(null);\n// (可选)设置 在订单中设置支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $order-&gt;setNotifyUrl(null); // 等价于在配置中设置 支付回调地址，两者中只要设置一次即可\n// (可选)设置 return_url(默认为 null，可选参数)\n//   $order-&gt;setReturnUrl(null); // 等价于在配置中设置 return_url，两者中只要设置一次即可\n// 本库只预置了常用的请求参数，没预置的参数请求使用：$order-&gt;addProperty('其他字段','其他字段值');\n// 支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n\n## (数组风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n/*\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Wap([\n    'out_trade_no' =&gt; time() . '123456', // 示例订单号(仅供参考)\n    'total_amount' =&gt; '0.01', // 示例订单总金额，单位：元(仅供参考)\n    'subject' =&gt; '测试', // 示例商品标题(仅供参考)\n    '额外的字段键值' =&gt; '额外字段值', // 示例支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n], true);\n*/\n\n// 以上 2 种风格设置请求参数，用户可根据个人需要，选其一即可\n\n// 获取构造请求参数对象\n$res = $pay-&gt;aliPay($aliConfig)-&gt;app($order);\n// 将所有请求参数转为数组\nvar_dump($res-&gt;toArray());\n订单配置参数\n所有订单配置中，对于客观非必选参数，用户可以自行选择是否进行配置，也可以不进行配置，扩展包已经为您自动处理了，比如，product_code 等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考 这里，查看「请求参数」一栏。\n参数查询：https://opendocs.alipay.com/apis/api_1/alipay.trade.app.pay\n刷卡支付\n/**\n * 普通公钥方式生成密钥验签(签名和验签方式)\n */\n// 设置支付配置\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n// 设置 阿里应用公钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于支付回调时验证签名\n$aliConfig-&gt;setPublicKey('阿里应用公钥字符串'); // 示例应用公钥字符串\n// 设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串'); // 示例应用私钥\n\n/**\n * 公钥证书方式生成密钥验签(签名和验签方式)\n */\n/*\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n\n// (必须)设置 使用公钥证书方式生密钥延签(签名和验签方式)\n$aliConfig-&gt;setCertMode(true);\n// (必须)设置 支付宝公钥文件路径\n$aliConfig-&gt;setCertPath(__DIR__ . '/cert/alipayCertPublicKey_RSA2.crt'); // 示例支付宝公钥文件路径\n// (必须)设置 支付宝根证书文件路径\n$aliConfig-&gt;setRootCertPath(__DIR__ . '/cert/alipayRootCert.crt'); // 示例支付宝公钥根证书文件路径\n// (必须)设置 阿里应用公钥证书文件路径\n$aliConfig-&gt;setMerchantCertPath(__DIR__ . '/cert/appCertPublicKey_2016091800538780.crt');\n// (必须)设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串');\n*/\n\n// 以上【普通公钥方式】 和 【公钥证书方式】 生成密钥验签(签名和验签方式) 这 2 种方式，用户可自行选择一种】\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n## (面向对象风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Pos();\n// (必须)设置 商户订单号(商户订单号。64 个字符以内的大小，仅支持字母、数字、下划线。需保证该参数在商户端不重复。)\n$order-&gt;setOutTradeNo(time() . '123456'); // 示例订单号(仅供参考)\n// (必须)设置 支付授权码(详细说明请看支付宝官网文档：https://opendocs.alipay.com/apis/api_1/alipay.trade.pay?scene=common)\n$order-&gt;setAuthCode('289756915257123456'); // 示例支付授权码(仅供参考)\n// (必须)设置 商品标题/交易标题/订单标题/订单关键字等。注意：不可使用特殊字符，如 /，=，&amp; 等。\n$order-&gt;setSubject('测试'); // 示例商品标题(仅供参考)\n// (可选)设置 支付场景，（默认为 'bar_code'）\n//   $order-&gt;addProperty('scene', 'bar_code');\n// (可选)设置 产品码，默认为 'FACE_TO_FACE_PAYMENT'（当面付）\n//   $order-&gt;addProperty('product_code', 'FACE_TO_FACE_PAYMENT');\n// (可选)设置 订单描述，默认为 null\n//   $order-&gt;setBody(null);\n// (可选)设置 在订单中设置支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $order-&gt;setNotifyUrl(null); // 等价于在配置中设置 支付回调地址，两者中只要设置一次即可\n// 本库只预置了常用的请求参数，没预置的参数请求使用：$order-&gt;addProperty('其他字段','其他字段值');\n// 支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n\n## (数组风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n/*\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Wap([\n    'out_trade_no' =&gt; time() . '123456', // 示例订单号(仅供参考)\n    'auth_code' =&gt; '289756915257123456', // 示例支付授权码(仅供参考)\n    'product_code' =&gt; 'FACE_TO_FACE_PAYMENT', // 示例产品码，默认为 'FACE_TO_FACE_PAYMENT'（当面付）\n    'subject' =&gt; '测试', // 示例商品标题(仅供参考)\n    '额外的字段键值' =&gt; '额外字段值', // 示例支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n], true);\n*/\n\n// 以上 2 种风格设置请求参数，用户可根据个人需要，选其一即可\n\n// 获取构造请求参数对象\n$res = $pay-&gt;aliPay($aliConfig)-&gt;pos($order);\n// 将所有请求参数转为数组\n$data = $res-&gt;toArray();\n订单配置参数\n所有订单配置中，对于客观非必选参数，用户可以自行选择是否进行配置，也可以不进行配置，扩展包已经为您自动处理了，比如，product_code、auth_code、scene等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考 这里，查看「请求参数」一栏。\n参数查询：https://opendocs.alipay.com/apis/api_1/alipay.trade.pay\n扫码支付\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Scan();\n$order-&gt;setSubject('测试');\n$order-&gt;setTotalAmount('0.01');\n$order-&gt;setOutTradeNo(time());\n\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;scan($order)-&gt;toArray();\n$response = $aliPay-&gt;preQuest($data);\nvar_dump($response);\n// qr_code 当前预下单请求生成的二维码码串，可以用二维码生成工具根据该码串值生成对应的二维码  https://qr.alipay.com/bavh4wjlxf12tper3a\n订单配置参数\n所有订单配置中，客观参数均不用配置，扩展包已经为大家自动处理了，比如，product_code 等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考这里，查看「请求参数」一栏。\n参考参数：https://docs.open.alipay.com/api_1/alipay.trade.precreate\n单笔转账到支付宝账户接口\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Transfer();\n$order-&gt;setSubject('测试');\n$order-&gt;setAmount('0.01');\n/*\n    收款方账户类型。可取值：\n    1、ALIPAY_USERID：支付宝账号对应的支付宝唯一用户号。以2088开头的16位纯数字组成。\n    2、ALIPAY_LOGONID：支付宝登录号，支持邮箱和手机号格式。\n*/\n$order-&gt;setPayeeType('ALIPAY_LOGONID');\n$order-&gt;setPayeeAccount('hcihsn8174@sandbox.com');\n\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;transfer($order)-&gt;toArray();\n$aliPay-&gt;preQuest($data);\nvar_dump($data);\n\n本接口用的是老版本的 https://docs.open.alipay.com/309/alipay.fund.trans.toaccount.transfer\n\n订单配置参数\n所有订单配置中，客观参数均不用配置，扩展包已经为大家自动处理了，比如，product_code 等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考这里，查看「请求参数」一栏。\n参数查询：https://docs.open.alipay.com/api_28/alipay.fund.trans.toaccount.transfer\n小程序支付\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\MiniProgram();\n$order-&gt;setSubject('测试');\n$order-&gt;setOutTradeNo(time().'123456');\n$order-&gt;setTotalAmount('0.01');\n$order-&gt;setBuyerId('hcihsn8174@sandbox.com');\n\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;miniProgram($order)-&gt;toArray();\nvar_dump($data);\n订单配置参数\n所有订单配置中，客观参数均不用配置，扩展包已经为大家自动处理了，比如，product_code 等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考这里，查看「请求参数」一栏。\n小程序支付接入文档：https://docs.alipay.com/mini/introduce/pay。\n参数查询：\n订单查询\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\OrderFind();\n$order-&gt;setOutTradeNo(time().'123456');\n$aliPay = $pay-&gt;aliPay($aliConfig);\n\nvar_dump($aliPay-&gt;orderFind($order)-&gt;toArray());\n官方参数查询：https://docs.open.alipay.com/api_1/alipay.trade.fastpay.refund.query\n退款查询\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\RefundFind();\n$order-&gt;setOutTradeNo('20150320010101001');\n$order-&gt;setOutRequestNo(time().'2014112611001004680073956707');\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;refundFind($order)-&gt;toArray();\nvar_dump($aliPay-&gt;preQuest($data));\n官方参数查询：https://docs.open.alipay.com/api_1/alipay.trade.refund\n查询转账订单接口\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\TransferFind();\n$order-&gt;setOutBizNo('3142321423432');\n// 二选一\n//  $order-&gt;setOrderId('20160627110070001502260006780837');\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;transferFind($order)-&gt;toArray();\nvar_dump($aliPay-&gt;preQuest($data));\n官方参数查询：https://docs.open.alipay.com/api_28/alipay.fund.trans.order.query\n交易撤销接口\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Cancel();\n$order-&gt;setOutTradeNo('20150320010101001');\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;cancel($order)-&gt;toArray();\nvar_dump($aliPay-&gt;preQuest($data));\n官方参数查询：https://docs.open.alipay.com/api_1/alipay.trade.cancel\n交易关闭接口\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Close();\n$order-&gt;setOutTradeNo(time().'123456');\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;close($order)-&gt;toArray();\nvar_dump($aliPay-&gt;preQuest($data));\n官方参数查询：https://docs.open.alipay.com/api_1/alipay.trade.close\n查询对账单下载地址\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Download();\n$order-&gt;setBillType('trade');\n$order-&gt;setBillDate('2016-04-05');\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;download($order)-&gt;toArray();\nvar_dump($aliPay-&gt;preQuest($data));\n官方参数查询：https://docs.open.alipay.com/api_15/alipay.data.dataservice.bill.downloadurl.query\n验证服务器数据\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n$param = [];//伪代码,post数据\nunset($param['sign_type']);//需要忽略sign_type组装\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\NotifyRequest($param,true);\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$result = $aliPay-&gt;verify($order);\nvar_dump($result);\n服务器确认收到异步通知字符串获取\n\\EasySwoole\\Pay\\AliPay::success();//成功响应\n\\EasySwoole\\Pay\\AliPay::fail();//失败响应","link":"/Components/Pay/ali.html"},{"id":248,"title":"加密原理","content":"这是一个很笨的加密器\n我们可以经常在某些经过加密文件的php文件代码格式大体如下：\nxxx_loader_lable\n&lt;?php\nif(!function_exists(\"xxx_loader\")){\n   die('xxx_loader not install');\n}\n//encrypt part\nxxxxxxxxxxx\n我们就以swoole_loader为例子，它加密后的文件格式大体如下\nSWOOLEC&lt;?php extension_loaded('swoole_loader') or die(' Loader ext not installed');?&gt;\n//encrypt part\nxxxxxxxxxxxxxxxxxxxxx\n这个文件。正常情况下,php是无法解析的。但是呢，zend_vm的一些接口，允许我们载入某些文件的时候，对文件进行预处理。因此我的拓展需要做的事情就是，如果遇到这样格式的文件，那么我把他解析为以下两部分：\n\n部分1\n&lt;?php\nif(!function_exists(\"xxx_loader\")){\ndie('xxx_loader not install');\n}\n\n部分2\n//encrypt part\nxxxxxxxxxxx\n\n\n因此，code就是我经过加密后的目标字符串，显然，我们需要完成的一个步骤就是、字符串到代码的转变。而这个时候，如果有敏感的同学，就会想到一个东西，那就是\neval()。因此以上代码等价于：\n&lt;?php\nif(!function_exists(\"xxx_loader\")){\n   die('xxx_loader not install');\n}\neval(encrypt part);\n但是实际上，并没有这么简单，如果我需要实现对机器授权的限制，那么应该是这样的。\n$info = xxx_loader-&gt;decode(encrypPart);\n$license = $info-&gt;licenseCheck();\nif($license){\n    eval($info-&gt;realyCode);\n}\n因此，如何保护我这个xxx_loader的实现逻辑，或者是加密秘钥，成为了代码加解密的关键。但是用php的话，容易出现，被逆向比如目前场景的php混淆，很容易破解。\n因此就有人提出想法，如果我把这个加密的函数协程php拓展编译成so动态库文件，然后so在做加壳混淆，不就完美的解决了吗。毕竟、so加壳混淆的方案，可是非常成熟的。","link":"/Components/CodeEncrypt/intro.html"},{"id":249,"title":"使用","content":"使用\n环境要求\n\n保证 PHP 版本大于等于 7.1\n\n使用 Linux / FreeBSD / MacOS 这三类操作系统\n使用 Composer 作为依赖管理工具\n\n安装拓展\n\n克隆仓库 https://github.com/easy-swoole/compiler\n\nphpize\n./configure\nmake install\nphp.ini加入extension=easy_compiler.so\n\n\n\n注意swoole4.x的library hook也用到了此技术，请在swoole.so后引入easy_compiler.so。另外，swoole加密器也可能用到了该方式，因此可能会有冲突\n\n修改默认加密密钥\n在/src/config.h文件中可以修改自己的密钥。\ncomposer助手脚本\ncomposer require easyswoole/compiler=dev-master\n对任意文件加密\n php vendor/easyswoole/compiler/bin/easy-compiler App/HttpController/Index.php \n\n会自动替换文件，并生成App/HttpController/Index.php.bak\n\n效果如下\n","link":"/Components/CodeEncrypt/usage.html"},{"id":250,"title":"代码实现","content":"实现原理\n\n在拓展层实现代码加密，生成新代码\n在拓展层解密代码\n\nhook校验\nopcode混淆\n\n\n在拓展层执行解密后代码\n\n知识储备\n首先，对于一个php文件的执行，我们需要知道其大概的步骤：\n\n基础环境初始化\n调用zend_compile_file解析文件生成opcode\n调用zend_execute执行生成的opcode\n\n相关函数\nstatic zend_op_array *(*zend_compile_string)(zval *source_string, char *filename TSRMLS_DC);\nstatic zend_op_array *(*zend_compile_string)(zval *source_string, char *filename TSRMLS_DC);\nstatic void zend_execute(zend_op_array *op_array,zval *return_value);\n替换PHP默认方法\nPHP_MINIT_FUNCTION(decrypt_code)\n{\n    zend_compile_file = decrypt_compile_file;\n    orig_compile_string = zend_compile_string;\n    zend_compile_string = decrypt_compile_string;\n    return SUCCESS;\n}\n\nPHP_MSHUTDOWN_FUNCTION(myShut)\n{\n    zend_compile_string = orig_compile_string;\n    return SUCCESS;\n}\n我们在php加载拓展的时候，替换了php默认的 zend_compile_file和orig_compile_string。当然，在Easyswoole中实现的执行代码的方式，\n不会被这两个函数hook，这个两个可以用来破解纯php层的混淆加密。相关安全问题在注意事项章节讲解。\n定义加密方法\nPHP_FUNCTION(easy_compiler_encrypt) {\n    unsigned char *raw_string;\n    size_t *raw_string_len;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &amp;raw_string, &amp;raw_string_len) == FAILURE) {\n        RETURN_NULL();\n    }\n    unsigned char *pkcs7 = (unsigned char *)malloc(sizeof(unsigned char*)*PKCS7_MAX_LEN);\n    memcpy(pkcs7,raw_string,raw_string_len);\n    size_t after_padding_len = PKCS7Padding(pkcs7,raw_string_len);\n\n    struct AES_ctx ctx;\n    AES_init_ctx_iv(&amp;ctx, AES_KEY, AES_IV_KEY);\n    AES_CBC_encrypt_buffer(&amp;ctx,pkcs7,after_padding_len);\n    zend_string *zend_encode_string = zend_string_init(pkcs7,after_padding_len,0);\n    zend_string *base64;\n    base64 = php_base64_encode((const unsigned char*)ZSTR_VAL(zend_encode_string),ZSTR_LEN(zend_encode_string));\n    char *res = ZSTR_VAL(base64);\n    zend_string_release(base64);\n    zend_string_release(zend_encode_string);\n    free(pkcs7);\n    RETURN_STRING(res);\n};\n定义解密方法\nPHP_FUNCTION(easy_compiler_decrypt) {\n    unsigned char *base64;\n    size_t *base64_len;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &amp;base64, &amp;base64_len) == FAILURE) {\n        RETURN_NULL();\n    }\n    zend_string *encrypt_z_str;\n    encrypt_z_str = php_base64_decode(base64,base64_len);\n    size_t encrypt_len = NULL;\n    encrypt_len = ZSTR_LEN(encrypt_z_str);\n    unsigned char *pkcs7 = (unsigned char *)malloc(sizeof(unsigned char*)*PKCS7_MAX_LEN);\n    memcpy(pkcs7,(const char*)ZSTR_VAL(encrypt_z_str),encrypt_len);\n    struct AES_ctx ctx;\n    AES_init_ctx_iv(&amp;ctx, AES_KEY, AES_IV_KEY);\n    AES_CBC_decrypt_buffer(&amp;ctx,pkcs7,encrypt_len);\n    encrypt_len = PKCS7Cutting(pkcs7,encrypt_len);\n    zend_string *eval_string = zend_string_init(pkcs7,encrypt_len,0);\n    zval z_str;\n    ZVAL_STR(&amp;z_str,eval_string);\n    zend_op_array *new_op_array;\n    char *filename = zend_get_executed_filename(TSRMLS_C);\n    new_op_array =  easy_compiler_compile_string(&amp;z_str, filename TSRMLS_C);\n    if(new_op_array){\n        zend_try {\n            zend_execute(new_op_array,return_value);\n        } zend_catch {\n\n        } zend_end_try();\n        destroy_op_array(new_op_array);\n        efree(new_op_array);\n    }\n    zend_string_release(encrypt_z_str);\n    zend_string_release(eval_string);\n    zval_ptr_dtor(&amp;z_str);\n    free(pkcs7);\n};\n\n就是在这一步解析加密后的代码，并执行对应的opcode\n\n更多细节源码\nEasySwoole Compiler","link":"/Components/CodeEncrypt/achieve.html"},{"id":251,"title":"注意事项","content":"注意！！！！！\n首先世界上没有绝对的安全，只有破解代价与利益是否等价\n别说啥PHP不安全，其他语言安全。例子：\n\nwindows牛逼不，被破解了\nphotoshop牛逼不，被破解了\n等等等\n\n默认加密方式\n目前默认加密方式是AES_CBC,用的TINY-AES-C实现。编译的时候，可以修改自己的密钥。在源码中的：\n/src/config.h\n未处理项目\n文件校验\n目前加密的文件数据，仅有代码数据。为了安全用户可以加上自己的校验数据。例如以下结构体\nstruct {\n    char *ip\n    char *mac\n    char *phpCode\n    int expire\n}\n从而实现，机器的ip、mac地址、还有过期时间限制\n未完善\nmixed_opcode\nstatic void mixed_opcode(zend_op_array* opline) {\n  if (NULL != opline) {\n    for (size_t i = 0; i &lt; opline-&gt;last; i++) {\n      zend_op* orig_opline = &amp;(opline-&gt;opcodes[i]);\n      if (orig_opline-&gt;opcode == ZEND_IS_EQUAL) {\n        orig_opline-&gt;opcode = ZEND_IS_IDENTICAL;\n        zend_vm_set_opcode_handler(orig_opline);\n      } else if (orig_opline-&gt;opcode == ZEND_IS_NOT_EQUAL) {\n        orig_opline-&gt;opcode = ZEND_IS_NOT_IDENTICAL;\n        zend_vm_set_opcode_handler(orig_opline);\n      }\n    }\n  }\n}\n目前，对zend_op_array的混淆，仅仅做了简单处理。这一步是为了防止有人从op code逆向出代码(编译原理AST语法树相关知识)。\nzend_execute等hook\n讲道理，用户可以修改编译自己的php,从而从关键位置拿到数据，也就是拿内存数据。为此，\n一些关键函数，例如zend_execute等，一定要加入例如Easyswoole Compiler实例代码中compile_string函数的hook校验\nso文件加壳\nso文件加壳是避免你加密方法，还有加密文件泄漏的重要方式！！！！至于加壳方法，百度一大堆，本文不再讲述\n弊端\nPHP的加密之所以困难，原因在于、PHP是开源的，无论你再怎么编译加密，最终都需要去执行opcode。问题在于，我php是开源的，因此、、、我可以在zen_execute等对应的方法修改源码，打印出来opcode数据进行逆向。为此。。如果需要避免这种方式，那就是我调用自己声明的库。\n因此我们可以看到，类似swoole_loader，需要分php版本下载，很大一部分原因，就如我们实现的原理一样，我把php对应版本zend目录下的核心文件，提前引入，防止hook\n结束语\n讲真，写这个文章来讲解原理，也不是为了拆台，zend的加密器都能被破解，你写的再牛逼，无非就是利益够不够的问题。这是为了帮助大家，更了解深入PHP源码的加密。不论什么语言，真想破解，一定是有办法的。因此，最好的方式那就是核心API放自己的服务器，以SASS方式提供服务。\n当然，加密也并不是意义全无、至少、、、心里都会权衡一下，看你是要自己开发划算、还是破解我的划算。","link":"/Components/CodeEncrypt/caution.html"},{"id":252,"title":"如何学习swoole","content":"学习Swoole之如何避免成为被坑哭的程序员\n很多刚从传统fpm模式转到swoole内存常驻模式的phper，总会觉得内心委屈，甚至想哭，原因swoole总会让你怀疑人生，这真的是我之前所认知的那个php语言吗？怎么那么坑啊。\nswoole下常见的&quot;坑&quot;\n\n\n为何全局变量无法共享呢\n例如，在以下代码中\n$http = new swoole_http_server(\"127.0.0.1\", 9501);\n$http-&gt;on(\"request\", function ($request, $response) {\n    static $i;\n    $response-&gt;end($i);\n    $i++;\n});\n\n$http-&gt;start();\n就会有人发现在swoole下static $i 和在fpm下所理解的输出不一致。这是在于出现了进程克隆，而每个进程之间的数据都是不一致的。\n\n\necho var_dump 无法输出到浏览器(http响应)\n我们在fpm模式下，echo $a 是可以把结果输出到浏览器中的，为何在swoole中就不行呢，原因在于模式的变更，swoole的运行模式不再是fpm，而是cli，如果你需要把数据响应给浏览器，你只能\n通过Http request回调中的response对象进行响应\n\n\nhttp请求参数获取\n在同swoole的http服务的时候，很多人会发现$_GET、$_POST等常见全局变量无法使用。这是因为$_GET、$_POST等变量都是全局的，在swoole当中会出现问题，如果想获取请求参数，可以用swoole回调时提供的Request对象来进行获取\n\n\nswoole不能使用die/exit\nphper都习惯用die/exit来调试代码，这是因为这个命令会直接退出当前进程，对于fpm来讲，每个请求都对应一个独立进程，退出了问题不大，但是在swoole当中，可能一个进程中会有多个请求同时在处理，如果你exit或者die来退出当前进程，会导致数据丢失。\n\n\nswoole下为何需要断线重连      \n很多程序员都习惯性的把数据库连接做单例化处理，这样很明显带来的好处就是节约了每次请求数据库需要连接多次的开销。那么为何在swoole下总是报错提示我数据库断线了呢？\n原因在于，传统fpm下，请求结束了，那么就会执行进程清理，数据库连接也被清理了，下次进来的时候，才会执行重新连接。这样就保证了连接都是可用的状态。但是在swoole常驻内存的情况下，\n请求结束后，该连接并不会被清理，依旧保留在内存空间内，而该连接若是长时间没有使用，或者是因为网络波动，那么就会断开。下次请求进来的时候，你没有判断连接状态，就直接去执行sql语句，那么就意味着你操作了一个断线的数据库连接，因此肯定会报错。\n\n\n内存泄露\n很多人用swoole写服务的时候，总是跑着跑着就莫名其妙的内存不足。这是因为swoole是一个常驻进程型的模型，在fpm下，请求结束之后会将进程内的变量进行清理，而swoole进程全局期的变量并不会因为请求的结束而被清理，会一直保存在内存中，一方面提高了效率，但是也让开发者必须注意到变量回收的必要性。\n\n\n协程上下文访问安全\n使用swoole协程的时候，会有人遇到变量的值不符合预期的情况，这里面可能是变量污染在作祟，在传统php 同步阻塞的编程模式下，所有的执行都是强制顺序执行的。但是在swoole中，多个协程之间是交替执行的，可能a协程让出执行权的时候b协程对某个跨协程变量进行了修改，那么当a协程恢复执行权的时候这个跨协程变量将不是让出时的值了(如果你对mysql有一定了解，就会发现这个情况并不难理解)。\n同时为了解决这个问题，我们通常在编程是要注意跨协程变量的使用，以及使用协程单例的方式来控制变量。\n使用swoole要学习的知识点\n\n\n以下内容中，必须 代表一定要先学习的部分，如果不懂会导致学习困难和跑偏，写的代码无法应用在生产环境； 应该 代表建议学习的知识点，但是也可以只是了解； 可以 代表推荐去学习，通常是开发者的弱点。\n\n\n基础编程知识\n\n\n应该了解阻塞和非阻塞的区别\n\n必须清楚PHP的GC机制 这个必须清楚，大多数php开发者都不清楚\n\n必须清楚php面向对象编程 这里一定要搞清楚对象引用机制和对象与内存之间的关系\n\n必须清楚资源及连接句柄的相关知识\n\n\n\n多进程编程\n\n\n必须清楚fpm和swoole的多进程模型及其区别\n\n必须了解 进程间通讯和进程隔离，应该了解进程信号量\n\n\n\n\n基础的TCP/UDP认知\n\n\n应该清楚TCP和UDP的区别\n\n\n应该清楚客户端和服务端的区别\n\n必须了解OSI七层模型中的上四层 了解常见应用层协议如http ftp smtp等\n\n\n\n协程\n\n\n必须清楚swoole协程工作模式\n\n必须清楚如何判断变量是否会跨协程使用\n\n\n\n总结\n总而言之，大多数php开发者学习swoole时候都会觉得坑的原因是来自于自身知识储备的不足。对于很多其他语言开发者必须掌握的知识，php开发时可能就无需掌握，但是这也是欠的技术债，会在进一步提升的时候遇到的瓶颈；导致在使用swoole的时候出了各种各样的问题。实际上，swoole是一个很强大的php拓展，他重新定义了php，让php有了更强的生命力。","link":"/Other/learnSwoole.html"},{"id":253,"title":"队列消费/自定义进程问题","content":"如何实现队列消费/自定义进程\n可能我们会经常遇见需要不断消费队列内内容的场景，我们以EasySwoole中自定义进程的方式，来实现这一功能。\n实现代码\n定义消费进程逻辑\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2018/10/18 0018\n * Time: 9:43\n */\n\nnamespace App\\Process;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse Swoole\\Process;\n\nclass Consumer extends AbstractProcess\n{\n    private $isRun = false;\n    public function run($arg)\n    {\n        // TODO: Implement run() method.\n        /*\n         * 举例，消费redis中的队列数据\n         * 定时500ms检测有没有任务，有的话就while死循环执行\n         */\n        $this-&gt;addTick(500,function (){\n            if(!$this-&gt;isRun){\n                $this-&gt;isRun = true;\n                $redis = new \\redis();//此处为伪代码，请自己建立连接或者维护redis连接\n                while (true){\n                    try{\n                        $task = $redis-&gt;lPop('task_list');\n                        if($task){\n                            // do you task\n                        }else{\n                            break;\n                        }\n                    }catch (\\Throwable $throwable){\n                        break;\n                    }\n                }\n                $this-&gt;isRun = false;\n            }\n            var_dump($this-&gt;getProcessName().' task run check');\n        });\n    }\n\n    public function onShutDown()\n    {\n        // TODO: Implement onShutDown() method.\n    }\n\n    public function onReceive(string $str, ...$args)\n    {\n        // TODO: Implement onReceive() method.\n    }\n}\n注册消费进程\n在EasySwoole的全局事件中，注册消费进程。\n&lt;?php\nuse App\\Process\\TestProcess;\nuse EasySwoole\\Component\\Process\\Manager;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\npublic static function mainServerCreate(EventRegister $register)\n{\n\n    $allNum = 3;\n    for ($i = 0 ;$i &lt; $allNum;$i++){\n        $processConfig= new \\EasySwoole\\Component\\Process\\Config();\n        $processConfig-&gt;setProcessName('testProcess'.$i);//设置进程名称\n        Manager::getInstance()-&gt;addProcess(new TestProcess($processConfig));\n    }\n}\n爬虫例子：https://github.com/HeKunTong/easyswoole3_demo","link":"//Other/process.html"},{"id":254,"title":"redis/kafka订阅","content":"自定义进程实现redis订阅\n实现代码\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2018/10/18 0018\n * Time: 10:28\n */\n\nnamespace App\\Process;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse Swoole\\Process;\n\nclass Subscribe extends AbstractProcess\n{\n    public function run($arg)\n    {\n        // TODO: Implement run() method.\n        $redis = new \\Redis();//此处为伪代码，请自己建立连接或者维护\n        $redis-&gt;connect('127.0.0.1');\n        $redis-&gt;subscribe(['ch1'],function (){\n            var_dump(func_get_args());\n        });\n    }\n\n    public function onShutDown()\n    {\n        // TODO: Implement onShutDown() method.\n    }\n\n    public function onReceive(string $str, ...$args)\n    {\n        // TODO: Implement onReceive() method.\n    }\n\n}\n接下来，需要做的事情，就是到EasySwooleEvent.php的主服务创建事件中，注册该进程即可。\nuse App\\Process;\nuse EasySwoole\\Core\\Swoole\\Process\\ProcessManager;\n\n\\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new Subscribe('sub'));","link":"/Other/redisSubscribe.html"},{"id":255,"title":"内核优化","content":"内核参数调整\nulimit设置\nulimit -n 要调整为100000甚至更大。 命令行下执行 ulimit -n 100000即可修改。如果不能修改，需要设置  /etc/security/limits.conf，加入\n* soft nofile 262140\n* hard nofile 262140\nroot soft nofile 262140\nroot hard nofile 262140\n* soft core unlimited\n* hard core unlimited\nroot soft core unlimited\nroot hard core unlimited\n注意，修改limits.conf文件后，需要重启系统生效\n内核设置\nLinux操作系统修改内核参数有3种方式：\n\n修改/etc/sysctl.conf文件，加入配置选项，格式为key = value，修改保存后调用sysctl -p加载新配置\n使用sysctl命令临时修改，如：sysctl -w net.ipv4.tcp_mem=\"379008       505344  758016\"\n\n直接修改/proc/sys/目录中的文件，如：echo \"379008       505344  758016\" &gt; /proc/sys/net/ipv4/tcp_mem\n\n\n第一种方式在操作系统重启后会自动生效，第二和第三种方法重启后失效\nnet.unix.max_dgram_qlen = 100\nswoole使用unix socket dgram来做进程间通信，如果请求量很大，需要调整此参数。系统默认为10，可以设置为100或者更大。\n或者增加worker进程的数量，减少单个worker进程分配的请求量。\nnet.core.wmem_max\n修改此参数增加socket缓存区的内存大小  \nnet.ipv4.tcp_mem  =   379008       505344  758016\nnet.ipv4.tcp_wmem = 4096        16384   4194304\nnet.ipv4.tcp_rmem = 4096          87380   4194304\nnet.core.wmem_default = 8388608\nnet.core.rmem_default = 8388608\nnet.core.rmem_max = 16777216\nnet.core.wmem_max = 16777216\nnet.ipv4.tcp_tw_reuse\n是否socket reuse，此函数的作用是Server重启时可以快速重新使用监听的端口。如果没有设置此参数，会导致server重启时发生端口未及时释放而启动失败\nnet.ipv4.tcp_tw_recycle\n使用socket快速回收，短连接Server需要开启此参数。此参数表示开启TCP连接中TIME-WAIT sockets的快速回收，Linux系统中默认为0，表示关闭。打开此参数可能会造成NAT用户连接不稳定，请谨慎测试后再开启。\n消息队列设置\n当使用消息队列作为进程间通信方式时，需要调整此内核参数\n\nkernel.msgmnb = 4203520，消息队列的最大字节数\nkernel.msgmni = 64，最多允许创建多少个消息队列\nkernel.msgmax = 8192，消息队列单条数据最大的长度\n\nFreeBSD/MacOS\n\nsysctl -w net.local.dgram.maxdgram=8192\nsysctl -w net.local.dgram.recvspace=200000\n修改Unix Socket的buffer区尺寸\n\n开启CoreDump\n设置内核参数\nkernel.core_pattern = /data/core_files/core-%e-%p-%t\n通过ulimit -c命令查看当前coredump文件的限制\nulimit -c\n如果为0，需要修改/etc/security/limits.conf，进行limit设置。\n开启core-dump后，一旦程序发生异常，会将进程导出到文件。对于调查程序问题有很大的帮助\n其他重要配置\n\nnet.ipv4.tcp_syncookies=1\nnet.ipv4.tcp_max_syn_backlog=81920\nnet.ipv4.tcp_synack_retries=3\nnet.ipv4.tcp_syn_retries=3\nnet.ipv4.tcp_fin_timeout = 30\nnet.ipv4.tcp_keepalive_time = 300\nnet.ipv4.tcp_tw_reuse = 1\nnet.ipv4.tcp_tw_recycle = 1\nnet.ipv4.ip_local_port_range = 20000    65000\nnet.ipv4.tcp_max_tw_buckets = 200000\nnet.ipv4.route.max_size = 5242880\n\n查看配置是否生效\n如：修改net.unix.max_dgram_qlen = 100后，通过\ncat /proc/sys/net/unix/max_dgram_qlen\n如果修改成功，这里是新设置的值。","link":"/Other/kernelOptimization.html"},{"id":256,"title":"随机生成问题","content":"随机生成问题\n由于Swoole本身的原因，在使用随机数时，需要额外注意，如果在父进程内调用了mt_rand，不同的子进程内再调用mt_rand返回的结果会是相同的。所以必须在每个子进程内调用mt_srand重新播种。\nshuffle和array_rand等依赖随机数的PHP函数同样会受到影响\n场景例子\n在异步任务，异步进程中，都需要注意随机数播种的问题，如下面的例子\nmt_rand(0, 1);    // 此处调用了 mt_rand 已经在父进程内自动播种\n$worker_num = 16;\n\n// fork 进程\nfor ($i = 0; $i &lt; $worker_num; $i++) {\n    $process = new swoole_process('child_async', false, 2);\n    $pid = $process-&gt;start();\n}\n\nfunction child_async(swoole_process $worker)\n{\n    mt_srand();  // 此处 必须要重新播种 否则会得到相同的结果\n    echo mt_rand(0, 100) . PHP_EOL;\n    $worker-&gt;exit();\n}","link":"/Other/random.html"},{"id":257,"title":"trait与单例","content":"Trait与单例\n\ntrait A{\n    private static $instance;\n    static function getInstance()\n    {\n        if(!isset(self::$instance)){\n            self::$instance = new static();\n        }\n        return self::$instance;\n    }\n}\n\nclass B{\n    use A;\n    function a()\n    {\n        var_dump('call at B');\n    }\n}\n\nclass C extends B{\n    function a()\n    {\n        var_dump('call at c');\n        parent::a(); // TODO: Change the autogenerated stub\n    }\n}\n\nclass D extends B{\n    use A;\n    function a()\n    {\n        var_dump('call at D');\n        parent::a(); // TODO: Change the autogenerated stub\n    }\n}\n$b = B::getInstance();\n$c = C::getInstance();\n$d = D::getInstance();\n\n$c-&gt;a();\n$d-&gt;a();\n\n以上输出:\nstring(9) \"call at B\"\nstring(9) \"call at D\"\nstring(9) \"call at B\"\n","link":"/Other/traitSingleTon.html"},{"id":258,"title":"mysql索引降维","content":"Mysql索引降维\n很多人都知道，mysql有索引这个概念，但是却很少去较真，如何利用索引去对数据降维，以提高查询速度。\n举个常见的场景，那就是用户日志（订单），例如，在中国移动的通话记录系统中，需要记录\n呼出手机号，被呼号码和呼出时间，而在该系统中，最常见或用的最多的需求，就是查询某个用户在某个时间段内的通话记录。我们做出以下数据特征模拟：\n\n一个月内，有一万个账户，每天打出三万通话记录。\n\n数据模拟生成代码：\n&lt;?php\n\nrequire 'vendor/autoload.php';\n\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n//::: warning \n//在3.3.7版本后,initialize事件调用改为:`EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()-&gt;globalInitialize();`\n//:::\n\nfunction generatePhoneList()\n{\n    $list = [];\n    for ($i=0;$i &lt;= 10000; $i++){\n        array_push($list,'155'.\\EasySwoole\\Utility\\Random::number(8));\n    }\n    return $list;\n}\n\nfunction generateTimeList(int $startTime,$max = 30000)\n{\n    $list = [];\n    for ($i=0;$i&lt;=$max;$i++){\n        //模拟从早上7点到凌晨\n        $t = mt_rand(\n            25200,86400\n        );\n        array_push($list,$startTime+$t);\n    }\n    sort($list);\n    return $list;\n}\n\n$config = \\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL');\n$db = new \\App\\Utility\\Pools\\MysqlPoolObject($config);\n$phoneList = generatePhoneList();\n//模拟一个月的时间数据\n$start = strtotime('20180101');\n//\nfor ($i = 0; $i&lt;=30; $i++){\n    $timeList = generateTimeList($start);\n    foreach ($timeList as $time){\n        $phone = $phoneList[mt_rand(0,10000)];\n        $target = $phoneList[mt_rand(0,10000)];\n        $db-&gt;insert('user_phone_record',[\n            'phone'=&gt;$phone,\n            'targetPhone'=&gt;$target,\n            'callTime'=&gt;$time\n        ]);\n\n    }\n    $start += 86400;\n}\n在本次讲解中，以数据量50万为例子，懒得等数据生成。phone，callTime为索引字段。\n需求\n查询某个时间段内某个账户的全部通话记录。\n那么此刻，很多人可能就直接写：\nSELECT * FROM test.user_phone_record where callTime &gt;=  1514768050 and  callTime &lt;= 1514871213 and  phone = 15587575857;\n以上语句在我的测试机中执行了0.26s，但是，若我调整一下where 的顺序：\nSELECT * FROM test.user_phone_record where phone = 15587575857 and callTime &gt;=  1514768050 and  callTime &lt;= 1514871213 ;\n那么久仅仅需要0.1s，节约了一半的时间。那么这两个看起来差不多的语句，为啥执行的时间不一样呢。\n直观解释\n首先，我们分别执行两个sql并查看结果(别说为啥不用explain和profiling解释，只想给你们最直观的解释)。\n\n SELECT count(*) FROM test.user_phone_record where phone = 15587575857 \n结果为15条记录。\nSELECT count(*) FROM test.user_phone_record where callTime >=  1514768050 and  callTime \n结果为76491条记录。\n\n那么最直观的解释来了：先where callTime再where phone，那么mysql做的事情就是：\n先找出76491条记录，再从76491条记录中找出account为15587575857的记录。同理，先where phone，再筛选时间，肯定是更加快的了。\n为什么会这样？\n这是和特定的数据结构与场景才可以这样去调优的，由前提条件：\n\n一个月内，有一万个账户，每天打出三万通话记录\n\n可知，单用户的通话频度不高，因此，先定位phone索引集再排除时间的搜索方式，肯定比先定时间再定账户的效率高。\n注意，这是特定场景！！！具体请以explain与profiling去分析，MYSQL的执行解释器，没有这么简单。","link":"/Other/mysqlIndexReduce.html"},{"id":259,"title":"tporm使用问题","content":"TP ORM使用问题\n由于swoole 是在常驻内存+协程环境下运行的,使用TP ORM 时,TP ORM自带了很多静态变量,将会出现问题,具体分析如下:  \n非协程常驻内存模式\n在同步,非协程模式下,一个worker在一个时间内只处理一个请求,到max_request时也将重启进程,可以勉强操作sql,但是以下静态变量会出现问题:\nthink\\Db 静态变量:\nprotected static $config = [];\n//数据库配置,几乎没有影响\n\nprotected static $query;\n//查询类名,没有影响\n\nprotected static $queryMap = [\n    'mongo' =&gt; '\\\\think\\\\db\\Mongo',\n];\n//查询类自动映射,没有影响\n\npublic static $queryTimes = 0;\n//数据库查询次数\n//常驻内存下是全局查询次数\n\npublic static $executeTimes = 0;\n//执行次数\n//常驻内存下其实是全局执行执行次数\n\nprotected static $cacheHandler;\n//缓存对象,没有影响\n\nthink\\Model 静态变量:\nprotected static $initialized = [];\n//初始化过的模型.\n//原本作用：确保一个模型类中的init方法在一次请求中只被执行一次\n//常驻内存下：一个模型只在第一次请求时执行该方法，后续请求不再执行，极有可能会造成bug\n\nprotected static $readMaster;\n//是否从主库读取数据\n//几乎没有影响\n\nthink\\db\\Connection 静态变量:\nprotected static $instance = [];\n//PDO操作实例\n//建立的连接管理实例\n//协程模式，高并发下可能会导致数据库操作bug\n\nprotected static $event = [];\n//监听回调\n//原本作用：给模型设置的事件回调\n//常驻内存下：随着运行时间不断增加将不断增加运行内存，一次请求增加的事件将影响到另外一次请求\n\nprotected static $info = [];\n// 数据表信息\n// 几乎没有影响\n\nprotected static $log = [];\n// 数据库日志\n// 原本作用: 记录一个请求的所有日志操作\n// 常驻内存: 随着数据库的不断操作,会使该变量不断增加,会造成内存溢出\n\nthink\\db\\Query 静态变量:\nprotected static $connections = [];\n// 数据库Connection对象\n// 暂时没发现使用的地方\n\nprivate static $event = [];\n//回调事件\n//原本作用:一次请求下,设置自身的回调事件\n//常驻内存下：一次请求增加的事件将影响到另外一次请求\n\nprivate static $extend = [];\n//扩展查询方法\n//几乎没有影响\n\nprivate static $readMaster = [];\n//需要读取主库的表\n//原本作用：设置某一个或者全部模型是否从主库读取数据\n//常驻内存下：如果在一个请求执行了Query::readMaster()方法，Query::$readMaster不会释放，将会影响到其他请求\n\nthink\\Db\\ModelEvent 静态变量:\nprivate static $event = [];\n// 回调事件\n//原本作用：给模型设置的事件回调\n//常驻内存下：随着运行时间不断增加将不断增加运行内存，一次请求增加的事件将影响到另外一次请求\n\nprotected static $observe = ['before_write', 'after_write', 'before_insert', 'after_insert', 'before_update', 'after_update', 'before_delete', 'after_delete', 'before_restore', 'after_restore'];\n//模型事件观察\n//没有影响\n\n协程常驻内存模式\n在协程模式下,多个客户端共用一个数据库连接,将会出现数据库操作异常问题,\n例如:\n\n用户A访问业务A,数据库开启事务-&gt;支付逻辑-&gt;完成事务\n用户B同时访问业务B,插入n条数据\n用户C同时访问业务A,数据库开启事务-&gt;支付逻辑-&gt;逻辑出错,回滚\n\n在这个逻辑中,由于都是共享一个数据库操作,并且受协程切换影响,数据库执行步骤可能会变为:\n用户A数据库开启事务-&gt;用户B插入n条数据-&gt;用户C开启事务-&gt;用户A支付逻辑-&gt;用户C支付逻辑-&gt;用户C逻辑错误,回滚事务-&gt;用户A完成事务\n当数据库这样执行时,用户A,B,C的所有数据库操作都将回滚,但是前端可能却会返回成功.  \n同样,由于静态变量共用,其他回调事件等问题同样存在","link":"/Other/tpORM.html"},{"id":260,"title":"curlssl错误","content":"CURL SSL错误\n在低版本的CURL中，若在服务启动前执行CURL一个ssl连接  那么此后在回调函数内再次执行该curl，会报错：\nA PKCS #11 module returned CKR_DEVICE_ERROR, indicating that a problem has occurred with the token or slot.\n若不在服务启动前执行CURL SSL连接，则不报错。\n相关代码\n$a = function (){\n    $ch = curl_init(\"https://www.baidu.com\");\n    $curlOPt = array(\n        CURLOPT_CONNECTTIMEOUT=&gt;3,\n        CURLOPT_TIMEOUT=&gt;10,\n        CURLOPT_AUTOREFERER=&gt;true,\n        CURLOPT_USERAGENT=&gt;\"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C; .NET4.0E)\",\n        CURLOPT_FOLLOWLOCATION=&gt;true,\n        CURLOPT_RETURNTRANSFER=&gt;true,\n        CURLOPT_SSL_VERIFYPEER=&gt;false,\n        CURLOPT_SSL_VERIFYHOST=&gt;false,\n        CURLOPT_HEADER=&gt;true,\n    );\n    curl_setopt_array($ch,$curlOPt);\n    $result = curl_exec($ch);\n    var_dump(curl_error($ch));\n    curl_close($ch);\n};\n\n$a();\n\nif(pcntl_fork()){\n    $a();\n}else{\n    $a();\n}\n\nswoole中同理。\n解决方案\n更新libcurl至最新的7.5.x,并重新编译php curl拓展。\n查看拓展版本：\nphp --ri curl","link":"/Other/curlSsl.html"},{"id":261,"title":"chromeheadless","content":"Chrome Headless\n什么是Chrome Headless\nHeadless Chrome 是 Chrome 浏览器的无界面形态，可以在不打开浏览器的前提下，使用所有 Chrome 支持的特性运行你的程序,简而言之，除了没有图形界面，headless chrome具有所有现代浏览器的特性，可以像在其他现代浏览器里一样渲染目标网页，并能进行网页截图，获取cookie，获取html等操作。\n而对于写爬虫的同学，很多都会面临都一个问题，那就是数据都是通过动态渲染，甚至是加密得到的，普通的分析接口模式早已无法满足需求，因此我们引入Chrome Headless 来解决数据渲染问题。\n部署 Chrome Headless\n因为环境部署不是本文的重点，因此我们直接推荐docker。\ndocker pull alpeware/chrome-headless-trunk\ndocker run -d -p 9222:9222 alpeware/chrome-headless-trunk\n访问debug 地址即可得到接口信息\ncurl http://{HOST}:9222/josn\n以下例子中，{HOST}定义的IP主机响\n驱动Chrome Headless\nChrome Headless 可以通过websocket协议进行远程驱动debug。首先我们引入easyswoole的websocket客户端。\ncomposer require easyswoole/http-client\n我们以网站 https://datacenter.jin10.com/price 为例子，我们打开可以发现，里面的数据都是通过websocket实时刷新的，这个时候，通过传统手段抓接口的手段，是很难实现的。模拟实现如下：\nuse EasySwoole\\HttpClient\\HttpClient;\nuse EasySwoole\\Spl\\SplBean;\nuse Swoole\\WebSocket\\Frame;\n\nstatic $i = 0;\n\n//定义命令bean,具体协议格式可以看 Chrome Headless 文档\n\nclass Command extends SplBean{\n    protected $method;\n    protected $id;\n    protected $params;\n    protected function initialize(): void\n    {\n        if(empty($this-&gt;id)){\n            global $i;\n            $i++;\n            $this-&gt;id = $i;\n        }\n    }\n}\n//用websocket协议去驱动Chrome Headless\ngo(function (){\n    $targetUrl = 'https://datacenter.jin10.com/price';\n    $ch = curl_init('http://{HOST}:9222/json');\n    curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);\n    $data = json_decode( curl_exec($ch) ,true);\n    $client = new HttpClient($data[0]['webSocketDebuggerUrl']);\n    if($client-&gt;upgrade()){\n        //打开URL\n        $command = new Command([\n            'method'=&gt;'Page.navigate',\n            'params'=&gt;[\n                'url'=&gt;$targetUrl\n            ]\n        ]);\n        $client-&gt;getClient()-&gt;push($command-&gt;__toString());\n        $client-&gt;recv(1);\n        //模拟等待渲染\n        \\co::sleep(2);\n        //实现 js 语句\n        $command = new Command([\n            'method'=&gt;'Runtime.evaluate',\n            'params'=&gt;[\n                'expression'=&gt;\"var p = document.querySelector('#J_pricewall &gt; div:nth-child(1) &gt; ul &gt; li:nth-child(1)').innerHTML;p;\"\n            ]\n        ]);\n        $client-&gt;getClient()-&gt;push($command-&gt;__toString());\n        //此处就可以得到渲染后的数据了\n        $data = json_decode($client-&gt;recv()-&gt;data,true)['result']['result']['value'];\n        var_dump($data);\n\n    }else{\n        var_dump('handshake fail');\n    }\n});\n\n以上教程仅供学习之用，请勿用于非法用途","link":"/Other/chromeHeadless.html"},{"id":262,"title":"graphql","content":"GraphQL\n本文档假定你熟悉GraphQL的概念。如果不是这样，请首先在官方网站上面了解 GraphQL。\n依赖类库\ncomposer require webonyx/graphql-php\nEasySwoole Http 中使用\n其实在EasySwoole Http服务器中使用，本质问题在于，如何得到RAW_POST过来的json数据。我们直接贴代码：\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\GraphQL;\nuse GraphQL\\Type\\Schema;\n\nclass Index extends Controller\n{\n\n    function index()\n    {\n        $queryType = new ObjectType([\n            'name' =&gt; 'Query',\n            'fields' =&gt; [\n                'echo' =&gt; [\n                    'type' =&gt; Type::string(),\n                    'args' =&gt; [\n                        'message' =&gt; Type::nonNull(Type::string()),\n                    ],\n                    'resolve' =&gt; function ($root, $args) {\n                        return $root['prefix'] . $args['message'];\n                    }\n                ],\n            ],\n        ]);\n        $schema = new Schema([\n            'query' =&gt; $queryType\n        ]);\n\n        $input = $this-&gt;json();\n        $query = $input['query'];\n        $variableValues = isset($input['variables']) ? $input['variables'] : null;\n        try {\n            $rootValue = ['prefix' =&gt; 'You said: '];\n            $result = GraphQL::executeQuery($schema, $query, $rootValue, null, $variableValues);\n            $output = $result-&gt;toArray();\n        } catch (\\Exception $e) {\n            $output = [\n                'errors' =&gt; [\n                    [\n                        'message' =&gt; $e-&gt;getMessage()\n                    ]\n                ]\n            ];\n        }\n\n        $this-&gt;writeJson(200,$output);\n    }\n}","link":"/Other/graphQL.html"},{"id":263,"title":"双机热备","content":"1. 介绍\n\n文章主要介绍，EasySwoole使用双机热备思路实现代码不中断部署。\n\n2. 学习案例\n\n\n\n先部署9501服务\n\n\n\n\n单起一个进程，定时轮询Git分支是否有新版本发布\n\n\n\n\n如有新版本发布，clone一份\n\n\n\n\ncomposer update 更新库\n\n\n\n\n启动9502服务\n\n\n6 更改nginx配置为9502并重启\n\n\n只要有新版本发布，就轮询上面那几个步骤\n\n整个过程的简单架构图\n\n3. 提前需要了解的知识点\n\nNginx负载均衡和反向代理\nEasySwoole自定义进程\nNginx reload 和 restart的区别\n双机热备\n\n4. Nginx 配置\nnginx.conf\n\n当有新版本发布的时候EasySwoole自定义进程会将nginx.conf 的端口改为最新服务\n\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    sendfile        on;\n\n    keepalive_timeout  65;\n\n    // 轮询配置(这里是重点)\n    upstream  easyswoole.relase.com {\n           server    127.0.0.1:9501;\n    }\n\n    server {\n        listen       8080;\n        server_name  localhost;\n    }\n\n    include servers/*;\n}\n\nes-release.conf\nserver {\n        listen       80;\n        server_name  easyswoole.relase.com;\n\n        location / {\n            root html;\n            index index.html index.htm;\n            proxy_pass http://easyswoole.relase.com; // 这里是重点\n        }\n\n        access_log /usr/local/etc/nginx/logs/es.access.log main;\n        error_log /usr/local/etc/nginx/logs/es.error.log error;\n}%\n5. EasySwoole 代码实现\n\n代码只提供实现思路，并且这种脚本，最好单独去做，比如用shell脚本,防止服务down调无法正常部署代码\n\n自定义进程文件\n&lt;?php\nnamespace App\\Relase;\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse Swoole\\Coroutine;\nclass Relase extends AbstractProcess\n{\n\n    protected function run($arg)\n    {\n        go(static function () {\n            while (true)\n            {\n\n                $shellLog = ' 2&gt;&gt; /Users/xxx/sites/shell.log';\n                error_log('开始检测代码是否更新5'.PHP_EOL, 3, '/Users/xxx/sites/es-log.log');\n\n                // 检查Git是否有新代码发布\n                $diffExec = 'cd ' .EASYSWOOLE_ROOT. '; git fetch; git diff --stat master origin/master;';\n                $pullResult = exec($diffExec);\n                error_log(json_encode($pullResult), 3, '/Users/xxx/sites/es-log.log');\n\n                if ($pullResult !== '') {\n                    error_log('有新版本发布'.PHP_EOL, 3, '/Users/xxx/sites/es-log.log');\n\n                    // 新版本项目的目录\n                    $newVersionPath = '/Users/xxx/sites/relase-'.time();\n\n                    // 开始clone, 初始化代码\n                    $cloneExec = \"git clone https://github.com/huizhang-Easyswoole/release.git {$newVersionPath} {$shellLog};cd {$newVersionPath} {$shellLog};composer update {$shellLog}; {$shellLog}\";\n                    $res = exec($cloneExec, $a, $b);\n                    error_log('新版本代码clone'.PHP_EOL, 3, '/Users/xxx/sites/es-log.log');\n\n                    // 判断当前是哪个端口正在服务\n                    $lsofExec = \"lsof -i:9501 {$shellLog}\";\n                    $lsofResult = exec($lsofExec);\n                    $newPort = 9501;\n                    $oldPort = 9502;\n                    if ($lsofResult !== '') {\n                        $newPort = 9502;\n                        $oldPort = 9501;\n                    }\n\n                    // 将另一个闲置的端口，替换到新版本中\n                    error_log('开始替换端口'.$newPort.PHP_EOL, 3, '/Users/xxx/sites/es-log.log');\n\n                    $devConfig = file_get_contents($newVersionPath.'/dev.php');\n                    $devConfig = str_replace($oldPort, $newPort, $devConfig);\n                    file_put_contents($newVersionPath.'/dev.php', $devConfig);\n\n                    // 启动新服务(这一刻新旧服务是同时存在的)\n                    error_log('新服务启动'.PHP_EOL, 3, '/Users/xxx/sites/es-log.log');\n                    $startExec = \"cd {$newVersionPath}; php easyswoole start d {$shellLog}\";\n                    exec($startExec);\n\n                    // 替换nginx配置\n                    error_log('开始替换ng端口'.PHP_EOL, 3, '/Users/xxx/sites/es-log.log');\n                    $ngConfigPath = '/usr/local/etc/nginx/nginx.conf';\n                    $ngConfig  = file_get_contents($ngConfigPath);\n                    $ngConfig = str_replace($oldPort, $newPort, $ngConfig);\n                    file_put_contents($ngConfigPath, $ngConfig);\n\n                    // 重启Nginx\n                    error_log('重启ng'.PHP_EOL, 3, '/Users/xxx/sites/es-log.log');\n                    $reloadNgExec = \"nginx -s reload {$shellLog}\";\n                    exec($reloadNgExec);\n\n                    // 停掉旧服务\n                    error_log('旧服务停掉'.PHP_EOL, 3, '/Users/xxx/sites/es-log.log');\n                    $stopExec = \"cd \".EASYSWOOLE_ROOT.\"; php easyswoole stop {$shellLog}\";\n                    exec($stopExec);\n\n                    // 每30秒同步一次代码\n                    Coroutine::sleep(30);\n                } else {\n                    error_log('无新版本'.PHP_EOL, 3, '/Users/xxx/sites/es-log.log');\n\n                }\n\n            }\n        });\n\n    }\n\n}\n进程注册\n&lt;?php\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse App\\Relase\\Relase;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.1\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // TODO: Implement mainServerCreate() method.\n        $process = new Relase('Es-relase');\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess($process);\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        // TODO: Implement onRequest() method.\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        // TODO: Implement afterAction() method.\n    }\n}\n6. 测试\n绑定host\n127.0.0.1 easyswoole.relase.com\n访问easyswoole.relase.com\n\n查看Nginx配置的端口\n➜  nginx cat nginx.conf | grep 950\n           server    127.0.0.1:9501;\n发布新版本\n\n重新clone一份代码，更改内容提交。\n\n查看Nginx配置的端口\n➜  nginx cat nginx.conf | grep 950\n           server    127.0.0.1:9502;","link":"/Other/deploy.html"},{"id":264,"title":"延迟队列","content":"EasySwoole 基于Redis组件实现延迟队列\n介绍\n在用户要支付订单的时候，如果超过30分钟未支付，会把订单关掉。当然我们可以做一个定时任务，每个一段时间来扫描未支付的订单，如果该订单超过支付时间就关闭，但是在数据量小的时候并没有什么大的问题，但是数据量一大轮训数据库的方式就会变得特别耗资源。当面对千万级、上亿级数据量时，本身写入的IO就比较高，导致长时间查询或者根本就查不出来，更别说分库分表以后了。\n使用延迟队列解决的痛点无非是\n\n实现了数据延迟\n数据摊开(仔细去理解)\n\n知识点\n\nredis有序集合\nEasySwoole Redis协程客户端\n\n案例\n生成订单id ---&gt; 扔到延迟队列 ---&gt; 延迟队列消费进程不停获取30分钟前的订单满足条件的订单 ---&gt; 处理订单\n直接上代码\nEasySwooleEvent.php 注册redis连接池、注册延迟队列消费进程\n&lt;?php\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Process\\Consumer;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\Pool\\Manager;\nuse EasySwoole\\Redis\\Config\\RedisConfig;\nuse App\\RedisPool\\RedisPool;\nuse EasySwoole\\Pool\\Config;\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n        //TODO:: 注册redis连接池\n        $config = new Config();\n        $redisConfig1 = new RedisConfig([\n            'host'      =&gt; '127.0.0.1',\n            'port'      =&gt; '6379'\n        ]);\n\n        // 这里的redis连接池看文档配吧\n        Manager::getInstance()-&gt;register(new RedisPool($config,$redisConfig1),'redis');\n\n        //TODO:: 延迟队列消费进程\n        $processConfig= new \\EasySwoole\\Component\\Process\\Config();\n        $processConfig-&gt;setProcessName('testProcess');\n\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new Consumer($processConfig));\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        // TODO: Implement onRequest() method.\n\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        // TODO: Implement afterAction() method.\n    }\n}\n\n扔到延迟队列\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Pool\\Manager;\n\nclass Index extends Controller\n{\n\n    function index()\n    {\n        /** @var $redis \\EasySwoole\\Redis\\Redis*/\n        $orderId = date('YmdHis', time());\n        $redis = Manager::getInstance()-&gt;get('redis')-&gt;getObj();\n        $res = $redis-&gt;zAdd('delay_queue_test1', time(), $orderId);\n        if ($res) {\n            $this-&gt;writeJson(200, '订单添加成功:'.$orderId);\n        }\n    }\n\n}\n延迟队列消费进程\n&lt;?php\nnamespace App\\Process;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Pool\\Manager;\nuse Swoole\\Coroutine;\n\nclass Consumer extends AbstractProcess {\n    protected function run($arg)\n    {\n        go(function (){\n            while (true) {\n\n                //TODO:: 拿到redis\n                /** @var $redis \\EasySwoole\\Redis\\Redis*/\n                $redis = Manager::getInstance()-&gt;get('redis')-&gt;defer();\n\n                //TODO:: 从有序集合中拿到三秒(模拟30分钟)以前的订单\n                $orderIds = $redis-&gt;zRangeByScore('delay_queue_test1', 0, time()-3, ['withscores' =&gt; TRUE]);\n\n                if (empty($orderIds)) {\n                    Coroutine::sleep(1);\n                    continue;\n                }\n\n                //TODO::拿出后立马删除\n                $redis-&gt;zRem('delay_queue_test1', ...$orderIds);\n\n                foreach ($orderIds as $orderId)\n                {\n                    var_dump($orderId);\n\n                    //TODO::判断此订单30分钟后，是否仍未完成，做相应处理\n                }\n            }\n        });\n    }\n\n}\n测试\n请求index/index 投递订单到延迟队列\n➜  ~ curl 127.0.0.1:9501/index/index\n{\"code\":200,\"result\":\"订单添加成功:20200422004046\",\"msg\":null}%\n等3s看终端是否输出\n➜  easyswoole php easyswoole start\n  ______                          _____                              _\n |  ____|                        / ____|                            | |\n | |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___\n |  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n | |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n |______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                          __/ |\n                         |___/\nmain server                   SWOOLE_WEB\nlisten address                0.0.0.0\nlisten port                   9501\nip@en0                        192.168.43.57\nworker_num                    8\nreload_async                  true\nmax_wait_time                 3\npid_file                      /Users/xx/sites/easyswoole/Temp/pid.pid\nlog_file                      /Users/xx/sites/easyswoole/Log/swoole.log\nuser                          xx\ndaemonize                     false\nswoole version                4.4.15\nphp version                   7.2.18\neasy swoole                   3.3.7\ndevelop/produce               develop\ntemp dir                      /Users/xx/sites/easyswoole/Temp\nlog dir                       /Users/xx/sites/easyswoole/Log\n\nstring(14) \"20200422004046\"\n总结\n这只是一个思路，大家可以根据实际业务做不同调整","link":"/Other/delayQueue.html"},{"id":265,"title":"栏目说明","content":"栏目介绍\n本栏目——开源项目推荐，旨在共同推动开源的氛围，欢迎基于easyswoole的开源项目、或适用于easyswoole环境的开源项目提交。","link":"/OpenSource/explanation.html"},{"id":266,"title":"xlswriter-excel解析项目","content":"xlsWriter-excel解析项目\n  \n为什么使用xlswriter\n请参考下方对比图；由于内存原因，PHPExcel数据量相对较大的情况下无法正常工作，虽然可以通过修改memory_limit配置来解决内存问题，但完成工作的时间可能会更长;\n\nxlswriter是一个 PHP C 扩展，可用于在 Excel 2007+ XLSX 文件中读取数据，插入多个工作表，写入文本、数字、公式、日期、图表、图片和超链接。\n它具备以下特性：\n一、写入\n\n100％兼容的Excel XLSX文件\n完整的Excel格式\n合并单元格\n定义工作表名称\n过滤器\n图表\n数据验证和下拉列表\n工作表PNG/JPEG图像\n用于写入大文件的内存优化模式\n适用于Linux，FreeBSD，OpenBSD，OS X，Windows\n编译为32位和64位\nFreeBSD许可证\n唯一的依赖是zlib\n\n二、读取\n\n完整读取数据\n光标读取数据\n按数据类型读取\n\n从这里开始\n文档|Documents\nPECL 仓库\n\nIDE Helper\ncomposer require viest/php-ext-xlswriter-ide-helper:dev-master\n基准测试\n测试环境: Macbook Pro 13 inch, Intel Core i5, 16GB 2133MHz LPDDR3 Memory, 128GB SSD Storage.\n导出\n\n两种内存模式导出100万行数据（单行27列，数据类型均为字符串，单个字符串长度为19）\n\n\n普通模式：耗时 29S，内存只需 2083MB；\n固定内存模式：仅需 52S，内存仅需 &lt;1MB；\n\n导入\n\n100万行数据（单行1列，数据类型为INT）\n\n\n全量模式：耗时 3S，内存仅 558MB；\n游标模式：耗时 2.8S，内存仅 &lt;1MB；\n","link":"/OpenSource/xlsWriter.html"},{"id":267,"title":"ritaswcipaddress ip地址归属地","content":"IP地址归属地，支持IPv6地址(离线数据库，定期更新)\n为什么建立这个库\n政府在大力推进IPv6建设，作者响应国家号召，整合网络免费数据库，制作成离线版供大家使用\n国家公文链接：关于开展2019年IPv6网络就绪专项行动的通知\n链接\nGithub\nPackagist\nBlog\n使用方法\ncomposer require ritaswc/zx-ip-address\n$result = \\Ritaswc\\ZxIPAddress\\IPv4Tool::query('114.114.114.114');\n/*\n$result = [\n    \"start\" =&gt; \"114.114.114.114\"\n    \"end\" =&gt; \"114.114.114.114\"\n    \"addr\" =&gt; array:2 [\n        0 =&gt; \"江苏省南京市\"\n        1 =&gt; \"南京信风网络科技有限公司GreatbitDNS服务器\"\n    ]\n    \"disp\" =&gt; \"江苏省南京市 南京信风网络科技有限公司GreatbitDNS服务器\"\n]\n */\n$result = \\Ritaswc\\ZxIPAddress\\IPv6Tool::query('240e:e9:8819:0:3::3f9');\n/*\n$result = [\n    \"start\" =&gt; \"240e:e9:8800::\"\n    \"end\" =&gt; \"240e:e9:8fff:ffff::\"\n    \"addr\" =&gt; array:2 [\n        0 =&gt; \"中国江苏省苏州市\"\n        1 =&gt; \"中国电信IDC\"\n    ]\n    \"disp\" =&gt; \"中国江苏省苏州市 中国电信IDC\"\n]\n */","link":"/OpenSource/ritaswcIpAddress.html"},{"id":268,"title":"demo","content":"Demo\nEasySwoole-Chat\n基于EasySwoole V3 实现的聊天室 \n聊天室Demo地址\nEasySwoole-Admin\n基于EasySwoole框架的后台，内使用Policy组件、FastCache组件、mysqli连接池组件等。用于：api开发过程学习、组件使用学习、项目后台。 \nadmin后台模板地址\nEasySwoole-Http-Monitor\n开发工具，可以记录最近的http请求，并且分析参数、复发请求，如微信异步回调调试，支付一单，可以反复模拟推送回调，直到程序走通。 \nhttp监控工具地址\ncurdAutomaticGeneration\n快速根据数据库生成CURD代码，包括全套bean,model,controller。代码分层，快速开发增删改查功能模块。\n自动写代码工具地址\njin-Chat\n是基于EasySwoole V3 并整合ES文档中的mysq/redisl协程连接池、Task异步任务、ceche缓存、chat聊天等功能的完整IM应用（demo）\nim Demo地址\nsocialite (第三方登录集成组件)\n基于 overtrue/socialite改造的,适用于easyswoole的第三方登录组件，现已支持wechat,qq,weibo,github,facebook\n第三方登录集成组件地址","link":"/demo.html"},{"id":269,"title":"docker","content":"Docker部署\nDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux 或 Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。\n使用 Docker 部署前，需要用户自行安装Docker。\n镜像拉取\n请在终端执行以下命令\n\ndocker pull easyswoole/easyswoole3\n\ndocker hub上的环境为 php7.2 + swoole4.4.17 + easyswoole 3.3.x\n框架启动\n\ndocker run -ti -p 9501:9501 easyswoole/easyswoole3\n\n默认工作目录为: /easyswoole\n命令执行完成，自动进入工作目录，执行 php easyswoole start，宿主机浏览器访问 http://127.0.0.1:9501/ 即可看到欢迎页。\n如何开发\n可以利用 Docker 的映射功能，将宿主机目录映射到容器中。在被映射的目录中根据框架安装文档重新安装 easyswoole。在宿主机开发，容器内进行同步测试。\n注意，在部分环境下，例如 Win10 系统的 docker 环境。\n不可把虚拟机共享目录作为 EasySwoole 的 Temp 目录，将会因为权限不足无法创建socket。这将产生报错：listen xxxxxx.sock fail， 为此可以手动在dev.php 配置文件里把 Temp 目录改为其他路径即可,如：'/Tmp'\nDockerfile\nDockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。\nFROM centos:8\n\n#version defined\nENV SWOOLE_VERSION 4.4.17\nENV EASYSWOOLE_VERSION 3.x\n\n#install libs\nRUN yum install -y curl zip unzip  wget openssl-devel gcc-c++ make autoconf git\n#install php\nRUN yum install -y php-devel php-openssl php-mbstring php-json php-simplexml\n# composer\nRUN curl -sS https://getcomposer.org/installer | php \\\n    &amp;&amp; mv composer.phar /usr/bin/composer &amp;&amp; chmod +x /use/bin/composer\n# use aliyun composer\nRUN composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\n\n# swoole ext\nRUN wget https://github.com/swoole/swoole-src/archive/v${SWOOLE_VERSION}.tar.gz -O swoole.tar.gz \\\n    &amp;&amp; mkdir -p swoole \\\n    &amp;&amp; tar -xf swoole.tar.gz -C swoole --strip-components=1 \\\n    &amp;&amp; rm swoole.tar.gz \\\n    &amp;&amp; ( \\\n    cd swoole \\\n    &amp;&amp; phpize \\\n    &amp;&amp; ./configure --enable-openssl \\\n    &amp;&amp; make \\\n    &amp;&amp; make install \\\n    ) \\\n    &amp;&amp; sed -i \"2i extension=swoole.so\" /etc/php.ini \\\n    &amp;&amp; rm -r swoole\n\n# Dir\nWORKDIR /easyswoole\n# install easyswoole\nRUN cd /easyswoole \\\n    &amp;&amp; composer require easyswoole/easyswoole=${EASYSWOOLE_VERSION} \\\n    &amp;&amp; php vendor/easyswoole/easyswoole/bin/easyswoole install\n\nEXPOSE 9501","link":"/Deploy/docker.html"},{"id":270,"title":"nginx","content":"Nginx部署\nNginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。其特点是占有内存少，并发能力强。可以做为EasySwoole的前置服务器，实现负载均衡等。\nhttp代理\n# 配置EasySwoole节点 至少需要一个\nupstream easyswoole {\n    server 127.0.0.1:9501;\n    server 127.0.0.1:9502;\n    server 127.0.0.1:9503;\n}\n\nserver {\n    # nginx所监听端口\n    listen 80; \n    # 域名\n    server_name proxy.easyswoole.com;\n\n    location / {\n        # 将客户端host及ip信息转发到对应节点  \n        proxy_set_header Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n        # 转发Cookie，设置 SameSite\n        proxy_cookie_path / \"/; secure; HttpOnly; SameSite=strict\";\n\n        # 代理访问真实服务器\n        proxy_pass http://easyswoole;\n    }\n}\nwebsocket代理\n# 配置EasySwoole节点 至少需要一个\nupstream easyswoole {\n    # 将负载均衡模式设置为IP hash，作用：不同的客户端每次请求都会与同一节点进行交互。\n    ip_hash;\n    server 127.0.0.1:9501;\n    server 127.0.0.1:9502;\n    server 127.0.0.1:9503;\n}\n\nserver {\n    listen 80;\n    server_name websocket.easyswoole.com;\n\n    location / {\n        # websocket的header\n        proxy_http_version 1.1;\n        # 升级http1.1到websocket协议\n        proxy_set_header Upgrade websocket;\n        proxy_set_header Connection \"Upgrade\";\n\n        # 将客户端host及ip信息转发到对应节点  \n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Host $http_host;\n\n        # 客户端与服务端60s之内无交互，将自动断开连接。\n        proxy_read_timeout 60s ;\n\n        # 代理访问真实服务器\n        proxy_pass http://easyswoole;\n    }\n}","link":"/Deploy/nginx.html"},{"id":271,"title":"supervisor","content":"Supervisor部署\nSupervisor是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，不支持Windows系统。很方便的监听、启动、停止、重启一个或多个进程。用Supervisor管理的进程，当一个进程意外被Kill，会自动将它重新拉起，不需要开发者自己编写shell进行进程管理来维护自己的服务。\n安装Supervisor\n采用Ubuntu系统下的安装方式进行演示：\n\napt-get -y install supervisor\n\n创建配置文件\n\nvim /etc/supervisor/conf.d/easyswoole.conf\n\n文件内容如下：\n# 设置应用名称为easyswoole\n[program:easyswoole]\n# 设置运行目录\ndirectory=/data/wwwroot/EasySwoole3.4.x\n# 项目的启动命令\ncommand=php easyswoole server start\n# 设置用户来运行该进程\nuser=www-data\n# 是否随着supervisor启动时 自动启动该应用\nautostart=true\n# 进程退出 是否自动重启进程\nautorestart=true\n# 进程启动多少秒之后被认为是启动成功 默认1s\nstartsecs=1\n# 失败最大尝试次数 默认3\nstartretries=3\n# stderr\nstderr_logfile=/data/wwwlog/easyswoole-stderr.log\n# stdout\nstdout_logfile=/data/wwwlog/easyswoole-stdout.log\n启动Supervisor\n\nservice supervisor start\n\nSupervisorctl\n启动EasySwoole应用\n\nsupervisorctl start easyswoole\n\n停止EasySwoole应用\n\nsupervisorctl stop easyswoole\n\n重启EasySwoole应用\n\nsupervisorctl restart easyswoole\n\n启动EasySwoole应用\n\nsupervisorctl start easyswoole\n\n查看所有监控的应用\n\nsupervisorctl status\n\n重新加载配置文件\n\nsupervisorctl update\n\n重启所有应用\n\nsupervisorctl reload\n","link":"/Deploy/supervisor.html"},{"id":272,"title":"新手必看","content":"新手入门\n本文适用于那些对Swoole/EasySwoole毫无了解,只用过传统fpm框架的开发者,看完这个教程,你将可以入门Swoole/EasySwoole  \n学习要求\n在观看本教程时,请先确认你的技术基础是否满足:  \n\nphp语法基础(菜鸟教程/慕课网可学)\nphp面对对象基础(菜鸟教程/慕课网可学)\nphp设计模式(http://www.imooc.com/learn/236)\nphp异常,错误处理(http://www.imooc.com/learn/380)\n使用过fpm框架开发或对mvc框架有了解\n能安装linux系统,以及基础使用\n开发经验半年以上\n有着 百度/谷歌 搜索答案的经历\n\n注意事项\n为了您能学会该教程,请注意一下事项:  \n\n教程每个章节都有看完\n不懂的技术语句有去搜索了解\n请不要跳章节学习,每个章节都有存在的必要\n","link":"/NoobCourse/introduction.html"},{"id":273,"title":"运行模式","content":"运行模式\nphp有着5种运行模式,常见的有4种:  \ncgi 协议模式\ncgi模式 通用网关接口（Common Gateway Interface）,它允许web服务器通过特定的协议与应用程序通信,\n调用原理大概为:\n用户请求-&gt;Web服务器接收请求-&gt;fork子进程 调用程序/执行程序-&gt;程序返回内容/程序调用结束-&gt;web服务器接收内容-&gt;返回给用户\n由于每次用户请求,都得fork创建进程调用一次程序,然后销毁进程,所以性能较低\nfast-cgi 协议模式\nfast-cgi是cgi模式的升级版,它像是一个常驻型的cgi,只要开启后,就可一直处理请求,不再需要结束进程,\n调用原理大概为:\nweb服务器fast-cgi进程管理器初始化-&gt;预先fork n个进程\n用户请求-&gt;web服务器接收请求-&gt;交给fast-cgi进程管理器-&gt;fast-cgi进程管理区接收,给其中一个空闲fast-cgi进程处理-&gt;处理完成,fast-cgi进程变为空闲状态,等待下次请求-&gt;web服务器接收内容-&gt;返回给用户\n\n注意,fast-cgi和cgi都是一种协议,开启的进程是单独实现该协议的进程  \n\n模块模式\napache+php运行时,默认使用的是模块模式,它把php作为apache的模块随apache启动而启动,接收到用户请求时则直接通过调用mod_php模块进行处理,详细内容可自行百度\nphp-cli模式\nphp-cli模式属于命令行模式,对于很多刚开始学php就开始wamp,wnmp的开发者来说是最陌生的一种运行模式\n该模式不需要借助其他程序,直接输入php xx.php 就能执行php代码\n命令行模式和常规web模式明显不一样的是:  \n\n没有超时时间\n默认关闭buffer缓冲\nSTDIN和STDOUT标准输入/输出/错误 的使用\necho var_dump,phpinfo等输出直接输出到控制台\n可使用的类/函数 不同\nphp.ini配置的不同\n\n\n想要了解详细内容可查看http://php.net/manual/zh/features.commandline.php \n\n其他\n\n本文将以上除了php-cli的模式,都定义为常规web访问模式  \n","link":"/NoobCourse/RunMode/introduction.html"},{"id":274,"title":"php-fpm","content":"php-fpm\nPHP-FPM（FastCGI 进程管理器）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。\n它的功能包括:\n\n支持平滑停止/启动的高级进程管理功能;\n可以工作于不同的 uid/gid/chroot 环境下，并监听不同的端口和使用不同的 php.ini 配置文件（可取代 safe_mode 的设置）;\nstdout 和 stderr 日志记录;\n在发生意外情况的时候能够重新启动并缓存被破坏的 opcode;\n文件上传优化支持;\n&quot;慢日志&quot; - 记录脚本（不仅记录文件名，还记录 PHP backtrace 信息，可以使用 ptrace或者类似工具读取和分析远程进程的运行数据）运行所导致的异常缓慢;\nfastcgi_finish_request() - 特殊功能：用于在请求完成和刷新数据后，继续在后台执行耗时的工作（录入视频转换、统计处理等）;\n动态／静态子进程产生;\n基本 SAPI 运行状态信息（类似Apache的 mod_status）;\n基于 php.ini 的配置文件。\n\n工作原理:\n它的工作原理大概为:\nphp-fpm启动-&gt;生成n个fast-cgi协议处理进程-&gt;监听一个端口等待任务\n用户请求-&gt;web服务器接收请求-&gt;请求转发给php-fpm-&gt;php-fpm交给一个空闲进程处理\n-&gt;进程处理完成-&gt;php-fpm返回给web服务器-&gt;web服务器接收数据-&gt;返回给用户\n\nnginx+php-fpm 就是用的以上的方法\n","link":"/NoobCourse/RunMode/php-fpm.html"},{"id":275,"title":"基础介绍","content":"php-cli\n在前面的简单介绍中,我们已经了解了有php-cli这个模式,现在我们继续详细了解下php-cli和传统web模式不一样的地方吧  \n超时时间\n在php-cli中,默认超时时间为永久不超时,但是可以通过set_time_limit设置超时时间.\n&lt;?php\nset_time_limit(1);\nwhile (1){\n}\nbuffer缓冲\n在常规web模式中,echo,var_dump,phpinfo等输出语句/函数,默认情况是先进入php缓冲区,等缓冲区到达一定数量,才开始传输给web服务器的,但是在php-cli模式中,默认关闭buffer,直接输出,例如以下代码:  \n&lt;?php\nob_start();//开启buffer缓冲区  php-cli下默认关闭buffer,由于web访问测试较麻烦,该段代码只为了查看以及测试缓冲区的作用,在web模式下,默认开启,无需手动开启,可自行配置\nfor($i=0;$i&lt;1000;$i++){\n    echo $i;\n    sleep(1);\n    if($i%10==0){\n        //当i为10的倍数时,将直接结束并输出缓冲区的数据,然后再次开启缓冲区\n        ob_end_flush();\n        ob_start();\n    }\n}\n\n也可通过ob_get_contents函数获取缓冲区内容,ob缓冲系列函数可自行搜索了解  \n\nbuffer缓冲详细内容可查看:http://www.php20.cn/article/sw/buffer/104 \n标准输入/输出/错误\n执行一个命令行都存在3个标准文件(linux一切皆文件): \n\n标准输入 (stdin,通常对应终端的键盘,进程可通过该文件获取键盘输入的数据)\n标准输出 (stdout,对应终端的屏幕,进程通过写入数据到该文件,将数据显示到屏幕)\n标准错误 (stderr,对应终端的屏幕,进程通过写入数据到该文件,将错误信息显示到屏幕)\n在php-cli命令行下,可通过以上3个文件句柄进行一系列的逻辑操作,比如:\n启动php文件,监听标准输入,获取到输入的网址,php再进行网址的数据请求/接收 等等操作\n而在常规web模式下,标准输出会被拦截 \n\necho var_dump等输出函数其实就是stdout,但是在常规web访问下被重定向到了web服务器,然后由web服务器输出\n\n\n\n了解详细内容可查看http://www.php20.cn/article/156\nphp-cli 专属扩展\nphp有些扩展在常规web下运行时没用/没有意义的 例如: \n\nswoole扩展\nsocket扩展\n等\n","link":"/NoobCourse/RunMode/php-cli/introduction.html"},{"id":276,"title":"网络协议","content":"网络协议\n网络协议为计算机网络中进行数据交换而建立的规则,标准或约定的集合,所有的计算机/手机等网络设备通信都得遵循网络协议.\n网络协议根据通信的步骤,层级划分为7个层级,从上往下为:  \n\n应用层\n表示层\n会话层\n传输层\n网络层\n数据链路层\n物理层\n\n\n作为php应用程序开发者,我们只需要了解网络层以上的协议即可","link":"/NoobCourse/NetworkrPotocol/introduction.html"},{"id":277,"title":"ip","content":"ip协议(网络层)\nip协议是互联网的基础协议,它是目前最流行的一种网络协议\n范围\nIP的责任就是把数据从源传送到目的地。它不负责保证传送可靠性，流控制，包顺序和其它对于主机到主机协议来说很普通的服务。\n接口\n这个协议由主机到主机协议调用，而此协议负责调用本地网络协议将数据包传送以下一个网关或目的主机。例如TCP可以调用IP协议，在调用时传送目的地址和源地址作为参数，IP形成数据包并调用本地网络（协议）接口传送数据包。\n操作\nIP实现两个基本功能：寻址和分段。IP可以根据数据包包头中包括的目的地址将数据包传送到目的地址，在此过程中IP负责选择传送的道路，这种选择道路称为路由功能。如果有些网络内只能传送小数据包，IP可以将数据包重新组装并在报头域内注明。IP模块中包括这些基本功能，这些模块存在于网络中的每台主机和网关上，而且这些模块（特别在网关上）有路由选择和其它服务功能。对IP来说，数据包之间没有什么联系，对IP不好说什么连接或逻辑链路。  \nIP使用四个关键技术提供服务：服务类型，生存时间，选项和报头校验码。服务类型指希望得到的服务质量。服务类型是一个参数集，这些参数是Internet能够提供服务的代表。这种服务类型由网关使用，用于在特定的网络，或是用于下下一个要经过的网络，或是下一个要对这个数据包进行路由的网关上选择实际的传送参数。生存时间是数据包可以生存的时间上限。它由发送者设置，由经过路由的地方处理。如果未到达时生存时间为零，抛弃此数据包。对于控制函数来说选项是重要的，但对于通常的通信来说它没有存在的必要。选项包括时间戳，安全和特殊路由。报头校验码保证数据的正确传输。如果校验出错，抛弃整个数据包。\nip地址\n把数据从源传送到目的地时,需要有ip地址才能传输,现在ip地址分为ipv4和ipv6 两种地址,现在最常见的就是ipv4地址,例如127.0.0.1(本机地址)  119.75.217.109(百度ip)  \nip传输必须要有明确的ip地址,才能进行数据发送\n\n详细内容可自行了解\n","link":"/NoobCourse/NetworkrPotocol/ip.html"},{"id":278,"title":"tcp","content":"tcp(传输层)\nTCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内  另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。  \n应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（ MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体 的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。\n三次握手\nTCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK ，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。\nTCP三次握手的过程如下：\n\n客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。\n服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。\n客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。\n\n连接成功\n连接成功之后双方即可互相传输字节流,并随时可关闭连接,传输的数据有以下特性  \n\n\n传输的数据被tcp分割成了最适合发送的数据块 传递给ip协议,这个发送数据称为 报文段 或 段 \n\n\ntcp作为可靠性连接,每次发送数据段,会启动一个定时器,每次接收数据段,会发送一次确认,如果定时器没有及时收到确认,则会重发数据\n\n\nTCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。\n\n\n两个应用程序通过TCP连接交换8bit字节构成的字节流。TCP不在字节流中插入记录标识符。我们将这称为字节流服务（bytestreamservice）。如果一方的应用程序先传10字节，又传20字节，再传50字节，连接的另一方将无法了解发方每次发送了多少字节。只要自己的接收缓存没有塞满，TCP 接收方将有多少就收多少。一端将字节流放到TCP连接上，同样的字节流将出现在TCP连接的另一端。\n\n\n四次挥手\n建立一个连接需要三次握手，而终止一个连接要经过四次挥手，这是由TCP的半关闭（half-close）造成的。具体过程如下所示。\n\n某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。\n接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。\n注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。\n一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。\n接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。\n既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。\n\n\n“通常”是指，某些情况下，步骤1的FIN随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。\n在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的，这称为“半关闭”（half-close）。\n当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。\n无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。\n\nphp中的tcp\nphp可通过socket函数,swoole扩展,stream流函数进行创建tcp协议的socket,绑定网卡端口,进行tcp服务端/客户端操作\n在php中,我们并不需要了解tcp的握手/挥手,我们只需要知道ip:port能连接/创建 一个tcp服务端/客户端就行了\n使用php的socket,我们可以直接发送字符串,接收的也是字符串,其他一切都是语言,操作系统所需要做的事,\n我们只需要处理好字符串的完整性,例如我们使用php做tcp服务端  \n\n客户端连接成功后,发送了一个&quot;easyswoole是一个非常好的swoole框架&quot;的字符串 \n而服务端每次只接收9个字节,那第一次获取只会接收到&quot;easyswool&quot;的残缺字符串,需要继续获取数据\n\n其他\n\n可自行搜索详细理解\n","link":"/NoobCourse/NetworkrPotocol/Tcp/tcp.html"},{"id":279,"title":"http","content":"http协议\n超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。 \n技术架构\nHTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理（user agent）。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在  \n多个中间层，比如代理，网关，或者隧道（tunnels）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。  \n通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如&quot;HTTP/1.1 200 OK&quot;，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。  \nHTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。  \n通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。  \n\n过程解析\nhttp一次请求的过程大概如下:\n\n用户在浏览器输入www.easyswoole.com\ndns服务器解析/或者本机hosts,路由器hosts对比 获得ip\n浏览器访问默认端口80,则访问的tcp地址为  ip:80\ntcp协议3次握手,建立连接\n发送一个http request请求头\n服务器获得http request请求头,表明该次访问为http访问,解析http请求头,获得请求类型,请求格式,以及请求数据(cookie,get,post数据)\n服务器发送response响应数据,主动断开\n浏览器接收response响应数据,解析响应文本类型,解析数据,断开连接\n\nhttps协议中,在请求以及响应时多了一层tls,ssl加密解密协议,默认端口从80变为了443 \n\n\n\nphper中的http\n由于php大部分时候都是用于web服务器,所以php开发者接触最多的协议也就是基于tcp/ip协议的http协议了\n在php初级程序员中,其实没有详细的了解过http协议,但是可以通过浏览器的f12-&gt;network去查看http协议具体的请求头,以及服务端发送的响应头","link":"/NoobCourse/NetworkrPotocol/Tcp/http.html"},{"id":280,"title":"websocket","content":"WebSocket协议\nWebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。\n产生背景\n在没有WebSocket协议之前,在网页中,实现一个聊天室只能使用ajax 不断轮询,请求服务器是否有数据产生,而这样的实现方法会出现一系列的问题:  \n\n如果轮询时间间隔太短,会导致客户端和服务端在一个时间段内不断的进行http tcp的握手/挥手动作和http 请求头,响应头的传输,大量消耗服务器资源,如果用户量大的情况,会造成服务器的繁忙以至于宕机\n客户端每次只能通过发送http 请求获得服务器是否有数据返回,且数据的及时性无法保证\n\n正因为在这种情况下,所以WebSocket出现了,它只需要一次http握手,就可以保持一个长连接,使得服务器可以主动发送消息给客户端,大大减少了轮询机制的消耗 \n实现原理\n在实现websocket连线过程中，需要通过浏览器发出websocket连线请求，然后服务器发出回应，这个过程通常称为“握手” 。在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处：\n\nHeader: 互相沟通的Header是很小的-大概只有 2 Bytes\nServer Push: 服务器的推送，服务器不再被动的接收到浏览器的请求之后才返回数据，而是在有新数据时就主动推送给浏览器。\n\n握手协议\n  \n首先,浏览器发起一个http协议的websocket握手请求:  \nGET /websocket/HTTP/1.1\n\nHost: localhost\nUpgrade: websocket          #表示希望将http协议升级到Websocket协议。\nConnection: Upgrade         #表示希望将http协议升级到Websocket协议。\nSec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==   #浏览器随机生成的base64 encode的值，用来询问服务器是否是支持WebSocket。\nOrigin: http://服务器地址\nSec-WebSocket-Version: 13\nwebsocket服务器响应:  \nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket                #告诉浏览器已经升级到websocket\nConnection: Upgrade               #告诉浏览器已经升级到websocket\nSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=   #将请求包“Sec-WebSocket-Key”的值，与” 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 ″这个字符串进行拼接，然后对拼接后的字符串进行sha-1运算，再进行base64编码得到的。用来说明自己是WebSocket助理服务器。\n这样就已经是握手成功了,浏览器和服务端已经建立了一个websocket通道,发送数据不再需要tcp握手,也不需要发送http请求头,服务端也可自动下发数据到浏览器\nHTML5 Web Socket API\n在HTML5中内置有一些API，用于响应应用程序发起的请求。基本API语句如下：\nvar ws = new WebSocket(url,name);//创建对象\nws.send(msg);//发送文本消息\nws.onmessage = (function(evt/*服务器发送数据的对象*/){})();//接收消息回调事件\nws.onerror = (function(evt/*错误对象*/){})();//错误处理\nws.close();//关闭连接\n其他\n可自行搜索了解详细内容","link":"/NoobCourse/NetworkrPotocol/Tcp/websocket.html"},{"id":281,"title":"udp","content":"udp(传输层)\nUDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。  \nUDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。UDP协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天UDP仍然不失为一项非常实用和可行的网络传输层协议。   \n与所熟知的TCP（传输控制协议）协议一样，UDP协议直接位于IP（网际协议）协议的顶层。根据OSI（开放系统互连）参考模型，UDP和TCP都属于传输层协议。UDP协议的主要作用是将网络数据流量压缩成数据包的形式。一个典型的数据包就是一个二进制数据的传输单位。每一个数据包的前8个字节用来包含报头信息，剩余字节则用来包含具体的传输数据。\nudp与tcp\nudp和tcp都属于传输层的协议,都位于ip协议的顶层,他们不同之处有:  \n\nudp是无连接协议,不需要进行tcp的握手\nudp每次发送最大长度是65535,而tcp在握手后可以源源不断的发送\nudp协议使用报头中的校验值来保证数据的安全。校验值首先在数据发送方通过特殊的算法计算得出，在传递到接收方之后，还需要再重新计算。如果某个数据报在传输过程中被第三方篡改或者由于线路噪音等原因受到损坏，发送和接收方的校验计算值将不会相符，由此UDP协议可以检测是否出错。这与TCP协议是不同的，后者要求必须具有校验值。  \nudp报文没有可靠性保证、顺序保证和流量控制字段等，可靠性较差。但是正因为udp协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。\n在网络质量令人十分不满意的环境下，UDP协议数据包丢失会比较严重。而tcp会进行确认验证,确保对方接收成功\nudp可实现对网关内的所有主机进行广播\n\nphper的udp\n在php初级开发者中,是很少接触到udp协议的,常见的有DNS协议,\n在我们输入一个域名时,会先请求到一个dns服务器,由dns服务器匹配出一个ip地址,然后通过ip地址去传输数据,\n在这个步骤中,请求dns服务器使用的就是udp协议\n其他\n具体详细内容可自行搜索了解","link":"/NoobCourse/NetworkrPotocol/udp.html"},{"id":282,"title":"port端口","content":"端口\n在网络技术中，端口（Port）包括逻辑端口和物理端口两种类型。物理端口指的是物理存在的端口，如ADSL Modem、集线器、交换机、路由器上用 于连接其他网络设备的接口，如RJ-45端口、SC端口等等。逻辑端口是指逻辑意义上用于区分服务的端口，如TCP/IP协议中的服务端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等。由于物理端口和逻辑端口数量较多，为了对端口进行区分，将每个端口进行了编号，这就是端口号。本文主要讲逻辑端口.\n逻辑端口\n端口有什么用呢？我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区 分不同的服务的。\n服务器一般都是通过知名端口号来识别的。例如，对于每个TCP/IP实现来说，FTP服务器的TCP端口号都是21，每个Telnet服务器的TCP端口号都是23，每个TFTP(简单文件传送协议)服务器的UDP端口号都是69。任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。这些知名端口号由Internet  号分配机构（InternetAssignedNumbersAuthority,IANA）来管理。\n到1992年为止，知名端口号介于1～255之间。256～1023之间的端口号通常都是由Unix系统占用，以提供一些特定的Unix服务—也就是说，提供一些只有Unix系统才有的、而其他操作系统可能不提供的服务，IANA管理1～1023之间所有的端口号。\nInternet扩展服务与Unix特定服务之间的一个差别就是Telnet和Rlogin。它们二者都允许通过计算机网络登录到其他主机上。Telnet是采用端口号为23的TCP/IP标准且几乎可以在所有操作系统上进行实现。Rlogin只是为Unix系统设计的（尽管许多非Unix系统也提供该服务），它的有名端口号为513。\n客户端通常对它所使用的端口号并不关心，只需保证该端口号在本机上是唯一的就可以了。客户端口号又称作临时端口号（即存在时间很短暂）。这是因为它通常只是在用户运行该客户程序时才存在，而服务器则只要主机开着的，其服务就运行。\n大多数TCP/IP实现给临时端口分配1024～5000之间的端口号。大于5000的端口号是为其他服务器预留的（Internet上并不常用的服务)。我们可以在后面看见许多这样的给临时端口分配端口号的例子。\nSolaris2.2是一个很有名的例外。通常TCP和UDP的缺省临时端口号从32768开始。  \nphper中的端口\n在php开发者中,最常见的就是80 http默认端口了,在通常情况下,我们访问  www.easyswoole.com  ,其实是请求的  www.easyswoole.com:80  ,在没有指定端口的情况下,访问网站都是默认为80端口,如果你web服务器监听的是8080端口,访问时就必须  www.easyswoole.com:8080  带上端口才能访问  ","link":"/NoobCourse/NetworkrPotocol/port.html"},{"id":283,"title":"会话管理","content":"会话管理\n在http协议中,我们了解到了,http每次请求都是握手/挥手,第二次和第一次请求时没有任何关联的,属于无状态协议,那么问题来了,既然http是无状态协议,那服务器是怎么区分不同的用户的呢?,这就是会话了  \n基础讲解\n服务器能区分用户的原理主要就是在于会话,每次发起http请求时,都附加上一条身份识别数据,例如下面这个http请求头:   \nGET / HTTP/1.1\nHost: www.easyswoole.com\nConnection: keep-alive\nPragma: no-cache\nCache-Control: no-cache\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 \nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.8\nCookie: Hm_lvt_4c8d895ff3b25bddb6fa4185c8651cc3=1541986142,1542074627,1542158990,1542252497; Hm_lpvt_4c8d895ff3b25bddb6fa4185c8651cc3=1542252498\n抛开http本身需要的数据,我们讲解下:\nUser-Agent: 用户端信息,浏览器的各种信息\nCookie: cookie会话\n服务端可以通过User-Agent获得用户的浏览器信息,可以通过cookie获取自定义的信息\n所以我们可以:  \n\n用户A第一次进入,没有附带cookie\n服务端记录这个用户,响应头增加一个set_cookie:id=1的cookie\n浏览器获得响应头,解析到set_cookie动作,把id=1存进cookie\n第二次请求服务端,带上id=1的cookie,服务端就可以知道:这次请求时用户A请求的\n同理,用户B第一次进入,服务端响应set_cookie:id=2\n...\n\n可以看出,只要用户端每次请求,跟服务端约定好一个参数作为用户标识,服务端就可以通过这个标识区分不同的用户了","link":"/NoobCourse/Conversation/introduction.html"},{"id":284,"title":"cookie","content":"Cookie\nCookie 是在 HTTP 协议下，服务器或脚本可以维护客户工作站上信息的一种方式。  \nCookie 是由 Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息 。  \n目前有些 Cookie 是临时的，有些则是持续的。临时的 Cookie 只在浏览器上保存一段规定的时间，一旦超过规定的时间，该 Cookie 就会被系统清除 。  \n持续的 Cookie 则保存在用户的 Cookie 文件中，下一次用户返回时，仍然可以对它进行调用。在 Cookie 文件中保存 Cookie，有些用户担心 Cookie 中的用户信息被一些别有用心的人窃取，而造成一定的损害。其实，网站以外的用户无法跨过网站来获得 Cookie 信息。如果因为这种担心而屏蔽 Cookie，肯定会因此拒绝访问许多站点页面。因为，当今有许多 Web 站点开发人员使用 Cookie 技术，例如 Session 对象的使用就离不开 Cookie 的支持\n存储\ncookie存储在用户端(通常是浏览器端),可通过JavaScript脚本,服务端response头进行设置/修改/删除操作\n一个cookie,存在以下信息:  \nname   一个唯一确定的cookie名称,通常来讲cookie的名称是不区分大小写的。\n\nvalue  存储在cookie中的字符串值。\n\ndomain  cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域(如：\nyq.aliyun.com)，也可以不包含它(如：.aliyun.com，则对于aliyun.com的所有子域都有效).\n\npath   表示这个cookie影响到的路径，浏览器跟会根据这项配置，像指定域中匹配的路径发送cookie。\n\nexpires  失效时间，表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)。如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有cookie；不过也可以自己设置删除时间。这个值是GMT时间格式，如果客户端和服务器端时间不一致，使用expires就会存在偏差。\n\nmax-age 与expires作用相同，用来告诉浏览器此cookie多久过期（单位是秒），而不是一个固定的时间点。正常情况下，max-age的优先级高于expires。\n\nHttpOnly  告知浏览器不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见。但在http请求张仍然会携带这个cookie。注意这个值虽然在脚本中不可获取，但仍然在浏览器安装目录中以文件形式存在。这项设置通常在服务器端设置。\n\nsecure   安全标志，指定后，只有在使用SSL链接时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放cookie就对了服务器端设置\ncookie不仅仅只作为session会话,也可存储一些不重要的会员个性化设置,例如:  \n\n用户A通过设置cookie type:red \n用户A请求服务端,想获取一个页面\n服务端接收到请求,并解析到type:red,给用户A返回一个红色风格的首页 \n\n安全\n服务端安全\n首先,cookie是存储在用户端的,可以被用户修改,所以服务端不能直接通过一个cookie来确定用户身份,需要用一定的方式加密或者对等存储(cookie作为凭证,在服务端记录对应数据),服务端session就是使用这种方法存储的\n用户端安全\n在通常情况下,用户端的cookie安全的,网站以外的用户无法跨过网站来获取用户的cookie信息,但是有心之人可能会通过ajax方法,让用户访问A网站,却使用B网站的脚本进行敏感操作.(详细内容可自行搜索&quot;跨站点脚本攻击&quot;)\nphper中的cookie\n在php  web网站中,用户端cookie是必不可少的,没有cookie就无法启用session会话,无法识别用户身份,php中的session_start()函数就是向用户端设置一个cookie值用于session会话.","link":"/NoobCourse/Conversation/cookie.html"},{"id":285,"title":"session","content":"Session\n在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。  \n当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。  \n注意 会话状态仅在支持 cookie 的浏览器中保留。  \n会话实现原理\nsession会话的实现原理大概如下所示:\n\n用户A第一次进入,没有附带任何标识信息(通常是cookie)\n服务端接收请求,给与用户A一个会话标识(通常是set_cookie,cookie值将加密)\n服务端根据会话标识,在服务器本地存储用户信息\n用户A端获取到会话标识,存储到用户端本地\n用户A第二次请求,附带会话标识(通常是cookie)\n服务端通过会话标识,找到服务端相应的用户信息\n\nphp中的session\nphp已经内置封装好了一个功能完整的会话管理,基础用法为:\n&lt;?php\nsession_start();//启动新会话或者重用现有会话,发送set-cookie的响应头,告诉浏览器设置一个php_session的cookie 会话,会话id为php随机产生,并在服务器端临时目录产生一个对应的session文件\n$_SESSION['a'] = 1;//存储一个关于该会话id的值\nsession_destroy();//销毁会话数据\n//当在脚本结束时,会将超全局变量$_SESSION中的值存储进对应的session文件\n可自行搜索了解详细内容(如自定义session_id,自定义存储方式,自定义启用会话方式等)","link":"/NoobCourse/Conversation/session.html"},{"id":286,"title":"api/token","content":"api/token\ntoken其实和session原理差不多,服务端通过给用户发送一个token,用户通过该token进行请求服务端,这种会话验证方式一般用于跨平台开发,以及接口开发,大概步骤为:\n\n用户A第一次进入,通过验证机制(账号密码登陆)请求服务端token\n服务端验证成功,给用户发送一个token(针对用户)\n服务端根据token,在服务端存储对应的数据(文件,mysql,redis等)\n用户A端获取到token,存储到用户端本地\n用户A请求某接口,带上token\n服务端通过token,验证用户有效性,返回数据\n\n这种设计理念和session相差不大(无论如何变换,都是需要用户端存储相应的标识,用于给服务端解析) \n\n为了安全,服务端可设定token有效时间,以及加密token,每隔一段时间变动一次token等.\n","link":"/NoobCourse/Conversation/token.html"},{"id":287,"title":"linux基础","content":"Linux\nLinux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\nLinux的发行版\nLinux的发行版说简单点就是将Linux内核与应用软件做一个打包。\n目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。\n\n可自行搜索安装方法,推荐使用虚拟机安装,或docker镜像等\n\n一切皆文件\nlinux 一切皆文件,在linux系统中,所有东西都是用文件来表示的,例如磁盘,内存,鼠标,显示器,socket,都是以文件来标识的,任何设备都是通过操作文件(写入,读取)的方式来操作  \nwindows连接linux\n连接linux终端需要使用ssh协议工具进行连接,linux必须开启ssh连接(默认开启)\nwindows ssh工具推荐:\n\nphpstorm自带ssh,以及sftp\nSecure CRT\nputty\n\n可自行搜索下载\n详细教程可自行搜索了解,建议菜鸟教程","link":"/NoobCourse/Linux/introduction.html"},{"id":288,"title":"lnmp安装","content":"LNMP\nLNMP代表的就是：Linux系统下Nginx+MySQL+PHP这种网站服务器架构。  \nLinux是一类Unix计算机操作系统的统称，是目前最流行的免费操作系统。代表版本有：debian、centos、ubuntu、fedora、gentoo等。  \nNginx是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。  \nMysql是一个小型关系型数据库管理系统。    \nPHP是一种在服务器端执行的嵌入HTML文档的脚本语言。  \n这四种软件均为免费开源软件，组合到一起，成为一个免费、高效、扩展性强的网站服务系统。  \n安装\nlnmp环境安装有以下几种方法:\n\nyum,apt-get 软件包安装\n编译安装\n集成一键安装\n\n由于软件包安装步骤较多,可自行搜索了解详细\n编译安装\n编译安装主要步骤为(需要有编译器):\n\n下载软件源码,cd 目录\n./configure 参数解析,配置安装位置参数,以及其他绑定参数\nmake 一般情况下，只需要直接用make即可，但是有时候，生成的Makefile文件中并没有指定C编译器或者C++编译器，那么就需要手动指定了，不然就有可能出现编译错误。\nmake install \n\n安装php时最为复杂,需要根据需要使用的扩展,预先安装一系列的软件支持,然后在./configure中配置软件目录,配置需要开启的扩展等\n\n\n\n可自行搜索了解详细\n集成一键安装\n集成一键安装是通过预先写好的shell脚本,里面包含了安装lnmp所有的命令(编译或软件包安装命令),以及包含了所需扩展的软件包.\n集成一键安装可使用以下几种:\n\nlnmp集成环境:https://lnmp.org/   \n宝塔:http://www.bt.cn/\n可自行搜索了解详细\n","link":"/NoobCourse/Linux/lnmp.html"},{"id":289,"title":"命令","content":"命令基础\nlinux命令存储以下位置:\n\n/bin(指向/usr/bin)目录,包含基本的用户命令,默认全体用户都可使用,例如curl,ls命令\n/sbin(指向/usr/sbin),/usr/local/sbin,存放需要root权限的命令以及工具,默认root用户使用,例如ip,halt命令\n/usr/local/bin 给用户放置自己的可执行程序的地方,不会被系统升级覆盖\n/usr/local/sbin 给管理员放置自己的可执行程序的地方,不会被系统升级覆盖\n\n如果在每个命令目录都存在某个命令时,通过系统的$PATH变量决定优先级\necho $PATH\n# 每台电脑输出不同,/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/local/protobuf/bin/:/root/bin\n所以,当你输入 ls 命令,点击回车时,系统会以此从各个目录找到这个命令文件,然后执行该文件.\n执行当前目录文件\n如果你的程序命令没有放在以上文件夹,我们也可通过相对路径以及绝对路径启动该命令:\n./php -m #当你在php命令文件目录中时,\n/www/server/php/72/bin/php -m,宝塔php命令目录\n根据这个原理,我们可以安装多个php版本,并启动\n/www/server/php/72/bin/php -m\n/www/server/php/56/bin/php -m","link":"/NoobCourse/Linux/command.html"},{"id":290,"title":"进程管理","content":"进程管理\n我们可以使用ps 查看当前进程(相当于windows的任务管理器)\nps -ef |grep php\n输出:\nroot       8351   8346  0 09:07 ?        00:00:00 /usr/bin/php /www/wwwroot/es3_demo/test.php\nroot      10618   8970  0 14:26 pts/0    00:00:00 grep --color=auto php\n用于筛选出当前运行中,包含php关键字的进程信息\n通过kill -9 PID可杀死某一个进程:\nkill -9 10618\n使用killall 可杀死指定名字的进程:\nkillall -9 php\n杀死所有php进程\n\nkill 和killall其实是给进程发送一个进程信号的命令,-9是SIGKILL 信号,终止进程,可通过kill ,killall命令发送其他信号\n","link":"/NoobCourse/Linux/process.html"},{"id":291,"title":"扩展安装","content":"php扩展安装\n在windows中,只需要将dll文件移动到扩展目录,并在php.ini中引入即可\nlinux中类似,我们需要安装扩展的软件(例如mysql扩展,我们需要先安装mysql),再安装mysql操作扩展(mysqli,pdo)生成.so文件,在php.ini中引入.so文件即可\n编译安装\nswoole扩展,先下载swoole官方源码:https://github.com/swoole/swoole-src\n解压,进入目录\nphpize #当不存在./configure时\n./configure --with-php-config=/usr/local/php/bin/php-config\nmake \nmake install\n这时候.so文件会自动生成到php扩展目录(有些扩展需要自己移动进去),\n在php.ini最后面加上\n extension = swoole.so\n然后php -m查看扩展,就能看到swoole扩展安装好了","link":"/NoobCourse/Linux/extention.html"},{"id":292,"title":"端口监控","content":"端口监控\n在ip章节中,我们知道了,开启一个tcp/udp服务,都得占用一个端口,所有我们可以通过查看端口的方式去判断服务是否开启成功.\nnetstat命令\n使用netstat命令可查看端口占用情况\nnetstat命令各个参数说明如下:\n\n-t : 指明显示TCP端口\n-u : 指明显示UDP端口\n-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)\n-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。\n-n : 不进行DNS轮询，显示IP(可以加速操作)\nnetstat -ntulp |grep 80 \n查看80端口占用情况\n输出:\ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      1036/nginx: master  \n\n\nlsof命令\nlsof命令需要自行安装\nsudo yum install lsof\n使用方法如下:\nlsof  -i tcp #列出所有tcp网络连接\nlsof  -i udp #列出所有udp网络连接信息\nlsof -i :8080 #列出使用8080端口信息","link":"/NoobCourse/Linux/port.html"},{"id":293,"title":"防火墙说明","content":"防火墙\n当你开启一个tcp服务,却发现访问不了,那么你得考虑下是否是防火墙拦截了,\n目前,最常见的拦截有以下几种情况:\n\n服务器本机防火墙拦截\n服务器供应商拦截(阿里云,腾讯云安全组)\n\n服务器本机拦截,可通过防火墙管理软件,开端口,或者直接关闭防火墙进行解决(不建议):\n例如centos 7下,防火墙管理软件为firewalld.\n基础命令为:\nsystemctl start firewalld;#启动\nsystemctl stop firewalld;#停止\nsystemctl status firewalld;#查看状态\nsystemctl disable firewalld;#开机禁用\nsystemctl enable firewalld;#开启启动\nfirewall-cmd --zone=public --add-port=80/tcp --permanent #开放80/tcp端口  （--permanent永久生效，没有此参数重启后失效）;\nfirewall-cmd --reload;#\nfirewall-cmd --zone= public --query-port=80/tcp;#查看80/tcp端口\nfirewall-cmd --zone= public --remove-port=80/tcp --permanent;#删除该端口开放","link":"/NoobCourse/Linux/firewall.html"},{"id":294,"title":"部分新特性","content":"PHP7与php5\nphp在2015年12月03日发布了7.0正式版,带来了许多新的特性，以下是不完全列表:\n\n\n性能提升：PHP7比PHP5.6性能提升了两倍。 Improved performance: PHP 7 is up to twice as fast as PHP 5.6\n\n\n全面一致的64位支持。 Consistent 64-bit support\n\n\n以前的许多致命错误，现在改成抛出异常。Many fatal errors are now Exceptions\n\n\n移除了一些老的不在支持的SAPI（服务器端应用编程端口）和扩展。Removal of old and unsupported SAPIs and extensions\n\n\n新增了空接合操作符。The null coalescing operator (??)\n\n\n新增加了结合比较运算符。Combined comparison Operator (&lt;=&gt;)\n\n\n新增加了函数的返回类型声明。Return Type Declarations\n\n\n新增加了标量类型声明。Scalar Type Declarations\n\n\n新增加匿名类。Anonymous Classes\n\n\n本教程主要讲解swoole将要用到或有相关性的特性\n致命错误将可用异常形式抛出\n在php7之后,大部分错误可通过异常形式抛出,并可使用catch拦截,例如:\ntry {\n   $a-&gt;test();//未定义该对象并没有该方法,抛出一个Throwable类\n    // Code that may throw an Exception or Error.\n} catch (Throwable $t) {\n    var_dump($t-&gt;getMessage());\n    // Executed only in PHP 7, will not match in PHP 5\n} catch (Exception $e) {\n}\n运行之后将打印一条报错语句:\nstring(40) \"Call to a member function test() on null\"\n??  null合并运算符\n由于日常使用中存在大量同时使用三元表达式和 isset()的情况， php7添加了null合并运算符 (??) 这个语法糖。如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。例如:\n$a = $b??0;\n//如果当$b为null,则返回0.如果$b不为null,则返回$b;\n标量类型声明\n标量类型声明 有两种模式: 强制 (默认) 和 严格模式。 现在可以使用下列类型参数（无论用强制模式还是严格模式）： 字符串(string), 整数 (int), 浮点数 (float), 以及布尔值 (bool)。它们扩充了PHP5中引入的其他类型：类名，接口，数组和 回调类型。例如:\n&lt;?php\nfunction a(\n    ?int $a /*参数必须是int或者null*/,\n    string $b/*参数必须string*/,\n    Closure $function /*参数必须是匿名函数*/,\n    array $array/*参数必须是数组*/\n    ){}\n\n类名/接口限定都需要考虑命名空间\n\n返回值类型声明\nPHP 7 增加了对返回类型声明的支持。 类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。例如:\n&lt;?php\nfunction a():int{//必须返回int类型,否则报错\n    return 1;\n}\nfunction b():?int{//必须返回int类型或者null类型,否则报错\n    return 'das';\n}\n太空船操作符&lt;=&gt;（组合比较符）\n太空船操作符用于比较两个表达式。当$a小于、等于或大于$b时它分别返回-1、0或1。 比较的原则是沿用 PHP 的常规比较规则进行的。\n&lt;?php\n// Integers\necho 1 &lt;=&gt; 1; // 0\necho 1 &lt;=&gt; 2; // -1\necho 2 &lt;=&gt; 1; // 1\n// Floats\necho 1.5 &lt;=&gt; 1.5; // 0\necho 1.5 &lt;=&gt; 2.5; // -1\necho 2.5 &lt;=&gt; 1.5; // 1\n// Strings\necho \"a\" &lt;=&gt; \"a\"; // 0\necho \"a\" &lt;=&gt; \"b\"; // -1\necho \"b\" &lt;=&gt; \"a\"; // 1","link":"/NoobCourse/PHP/php7.html"},{"id":295,"title":"回调事件","content":"回调函数\n回调函数就是在主进程执行当中,突然跳转到预先设置好的函数中去执行的函数.\n以下是自知乎作者常溪玲的解说：\n你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。\n以下是一个非常简单的回调函数的例子:\n&lt;?php\n//登记回调函数\nfunction insert(int $i):bool {\n    echo \"插入数据{$i}\\n\";//模拟数据库插入//响应回调事件\n    return true;\n}\n$arr = range(0,1000);//模拟生成1001条数据\nfunction action(array $arr, callable $function)\n{\n    foreach ($arr as $value) {\n        if ($value % 10 == 0) {//当满足条件时,去执行回调函数处理//触发回调\n            call_user_func($function, $value);//调用回调事件\n        }\n    }\n}\naction($arr,'insert');\n\n在这个例子中,首先定义了一个插入数据的函数,定义了一个1001条数据的数组\n然后调用了action函数,当遍历数组满足条件时,则执行设定好的回调函数进行插入数据\n回调函数的几种写法\n函数字符串:\n&lt;?php\nfunction insert(int $i):bool {\n    echo \"插入数据{$i}\\n\";//模拟数据库插入\n    return true;\n}\n$arr = range(0,1000);//模拟生成1001条数据\nfunction action(array $arr, callable $function)\n{\n    foreach ($arr as $value) {\n        if ($value % 10 == 0) {//当满足条件时,去执行回调函数处理\n            call_user_func($function, $value);\n        }\n    }\n}\naction($arr,'insert');\n匿名函数\n&lt;?php\n$arr = range(0,1000);//模拟生成1001条数据\nfunction action(array $arr, callable $function)\n{\n    foreach ($arr as $value) {\n        if ($value % 10 == 0) {//当满足条件时,去执行回调函数处理\n            call_user_func($function, $value);\n        }\n    }\n}\naction($arr,function($i){\n    echo \"插入数据{$i}\\n\";//模拟数据库插入\n    return true;\n});\n类静态方法\n&lt;?php\n$arr = range(0, 1000);//模拟生成1001条数据\nfunction action(array $arr, callable $function)\n{\n    foreach ($arr as $value) {\n        if ($value % 10 == 0) {//当满足条件时,去执行回调函数处理\n            call_user_func($function, $value);\n        }\n    }\n}\nclass A{\n    static function insert(int $i):bool {\n        echo \"插入数据{$i}\\n\";//模拟数据库插入\n        return true;\n    }\n}\naction($arr,'A::insert');\naction($arr,array('A','insert'));\n\n类方法\n&lt;?php\n$arr = range(0, 1000);//模拟生成1001条数据\nfunction action(array $arr, callable $function)\n{\n    foreach ($arr as $value) {\n        if ($value % 10 == 0) {//当满足条件时,去执行回调函数处理\n            call_user_func($function, $value);\n        }\n    }\n}\nclass A{\n    public function insert(int $i):bool {\n        echo \"插入数据{$i}\\n\";//模拟数据库插入\n        return true;\n    }\n}\n$a = new A();\naction($arr,array($a,'insert'));\n","link":"/NoobCourse/PHP/callback.html"},{"id":296,"title":"闭包/匿名函数","content":"闭包函数\n闭包的概念\n闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。\n在php中,闭包函数一般就是匿名函数.\n举例,有一个定时任务,每一秒执行一次,现在我们要开启一个服务,然后准备在30秒的时候关闭这个服务\n&lt;?php\nfunction tick($callback){\n    while (1) {//简单实现的定时器,每秒都去执行一次回调\n        call_user_func($callback);\n        sleep(1);\n    }\n}\nclass Server\n{\n    //模拟退出一个服务\n    public function exitServer()\n    {\n        return true;\n    }\n}\n$server = new Server();\n$time = time();\ntick(function ()use($server) {\n    $server-&gt;exitServer();\n});\n在这里面,使用匿名函数,use了函数外部的$server变量,才使得定时器能回调调用$server-&gt;exitServer();\n匿名函数\n匿名函数 通俗来讲,就是没有名字的函数,例如上面写的function(){},它通常作为闭包函数使用,使用方法如下:\n&lt;?php\n$fun = function($name){\n    printf(\"Hello %s\\r\\n\",$name);\n};\necho $fun('Tioncico');\nfunction a($callback){\n    return $callback();\n}\na(function (){\n    echo \"EasySwoole\\n\";\n    return 1;\n});\nuse\nPHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用use关键字。\n&lt;?php\nfunction a($callback){\n    return $callback();\n}\n$str1 = \"hello,\";\n$str2 = \"Tioncico,\";\na(function ()use($str1,$str2){\n    echo $str1,$str2,\"EasySwoole\\n\";\n    return 1;\n});\n","link":"/NoobCourse/PHP/closures.html"},{"id":297,"title":"php多进程","content":"php多进程\nphp多进程是在开发业务逻辑层面,并行处理多个任务的一种开发方式,例如,需要给10万给会员发送邮件,每个邮件需要处理1秒,如果是一个进程处理,就得10万*1秒才能处理完,但是,如果开启多个进程同时处理,例如:10个进程,那只需要10万*1/10秒就能处理完成,缩短了10倍的时间\n多进程的概念\n前面有讲到,多进程主要是在开发业务逻辑层面,并行处理多个任务的开发方式,什么叫做开发业务逻辑层面呢?\n在上面我们有讲到,php-fpm是fast-cgi的进程管理器,启动之后会启动多个fast-cgi进程,等待任务处理  \n在php-fpm软件层面,fast-cgi的多个进程就属于多进程处理,但是,当用户发起请求,由nginx交给php-fpm处理请求时,在这个层面,每个请求其实只占有一个php fast-cgi进程进行处理逻辑,对于运行业务逻辑的这个php进程,其实是单进程的.\n同理,当我们直接运行一个php文件时,默认是只开启了一个php进程进行运行php的代码\n多进程的开发场景\n在传统web模式下,php一向是单进程处理业务逻辑,只有在php-cli模式下,用于处理异步任务,作为网络服务器时,才可能用到多进程处理,所以,大部分phper都对php多进程的概念不熟悉\n伪多进程\n在上面讲到,在传统web下,一个请求就是一个进程,我们可以通过这个方法,实现理论上的多进程:\n\n在一个php文件中,写消费任务逻辑,比如给队列中的会员id发送邮件(注意超时,注意用户端关闭不终止脚本)\n用网页访问这个php文件,相当于开启了一个进程处理\n再开第二个网页访问这个文件,相当于又开启了一个进程\n如此重复,我们可以得到n个处理邮件的进程\n针对于消费任务逻辑层面,我们已经是开启了多进程在处理了\n","link":"/NoobCourse/PHP/Multiprocess/introduction.html"},{"id":298,"title":"多进程开启","content":"多进程使用\n怎么才能在一个php脚本中,开启多进程处理呢?这里我们可以使用2种方法(注意,本教程只适用于linux,php-cli环境)\npcntl扩展\npcntl是php官方的多进程扩展,只能在linux环境使用,例如:\n&lt;?php\n$num=1;\n$str=\"EasySwoole,Easy学swoole\\n\";\n$pid = pcntl_fork();//新开一个子进程,上面的变量内存将会复制一份到子进程中.这个函数,在主进程中返回子进程进程id,在子进程返回0,开启失败在主进程返回-1\necho $str;//这下面的代码,将会被主进程,子进程共同执行\n\nif($pid&gt;0){//主进程代码\n    echo \"我是主进程,子进程的pid是{$pid}\\n\";\n}elseif($pid==0){\n    echo \"我是子进程,我的pid是\".getmypid().\"\\n\";\n}else{\n    echo \"我是主进程,我现在慌得一批,开启子进程失败了\\n\";\n}\n详细内容可自行搜索了解\nswoole扩展\nswoole扩展是面向生产环境的 PHP 异步网络通信引擎,它也有着进程管理模块\n&lt;?php\n$num = 1;\n$str = \"EasySwoole,Easy学swoole\\n\";\n\n$process = new swoole_process(function () use ($str) {//实例化一个进程类,传入回调函数\n    echo $str;//变量内存照常复制一份,只不过swoole的开启子进程后使用的是回调方法运行\n    echo \"我是子进程,我的pid是\" . getmypid() . \"\\n\";\n});\n$pid = $process-&gt;start();//开启子进程,创建成功返回子进程的PID，创建失败返回false。\necho $str;\nif ($pid &gt; 0) {//主进程代码\n    echo \"我是主进程,子进程的pid是{$pid}\\n\";\n}else{\n    echo \"我是主进程,我现在不慌了,失败就失败吧\\n\";\n}\n详细内容可自行搜索了解","link":"/NoobCourse/PHP/Multiprocess/fork.html"},{"id":299,"title":"进程通信","content":"进程通信\n在各个进程中,内存空间都是不一致的,各个变量都是在不同的内存空间,举个简单的例子  \n\n用户A访问服务端,$_SESSION['user']=1;\n用户B同时访问服务端,读取$_SESSION['user']是读取不到的,因为进程之间内存不是相同的  \n\n同样,在php多进程中,pcntl_fork之后,虽然能读取到之前的变量,但这个变量是复制出来的一份,和原来那份存储位置根本不同,例如:\n&lt;?php\n$str = \"EasySwoole\\n\";\n$pid = pcntl_fork();\nif($pid&gt;0){\n    $str=\"Tioncico\\n\";//在主进程修改了$str,不会影响到子进程的$str变量\n    echo $str;\n}elseif ($pid==0){\n    echo $str;//$str是pcntl_fork复制出来的\n}else{\n\n}\n所以,多进程中根本无法直接通信,那么,该怎么样才能通信呢?可以使用以下几种方式进行通信\n\n管道通信,分为有名管道,无名管道等,可自行搜索了解详细\n消息队列通信,使用linux消息队列,通过sysvmsg扩展,可查看:http://www.php20.cn/article/137\n\n进程信号通信,可查看:http://www.php20.cn/article/134\n\n共享内存通信,映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。\n套接字通信\n第三方通信,使用文件操作,mysql,redis等方法也可实现通信\n\n可自行搜索了解详细内容 ","link":"/NoobCourse/PHP/Multiprocess/processCommunication.html"},{"id":300,"title":"进程信号","content":"进程信号\n信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。一个键盘中断或者一个错误条件（比如进程试图访问它的虚拟内存中不存在的位置等）都有可能产生一个信号。Shell也使用信号向它的子进程发送作业控制信号。  \n信号是在Unix System V中首先引入的，它实现了15种信号，但很不可靠。BSD4.2解决了其中的许多问题，而在BSD4.3中进一步加强和改善了信号机制。但两者的接口不完全兼容。在Posix 1003.1标准中做了一些强行规定，它定义了一个标准的信号接口，但没有规定接口的实现。目前几乎所有的Unix变种都提供了和Posix标准兼容的信号实现机制。\n阶段\n在一个信号的生命周期中有两个阶段：生成和传送。当一个事件发生时，需要通知一个进程，这时生成一个信号。当进程识别出信号的到来，就采取适当的动作来传送或处理信号。在信号到来和进程对信号进行处理之间，信号在进程上挂起（pending）。  \n内核为进程生产信号，来响应不同的事件，这些事件就是信号源。主要的信号源如下：  \n\n异常：进程运行过程中出现异常；  \n其它进程：一个进程可以向另一个或一组进程发送信号；\n终端中断：Ctrl-C，Ctrl-\\等；\n作业控制：前台、后台进程的管理；\n分配额：CPU超时或文件大小突破限制；\n通知：通知进程某事件发生，如I/O就绪等；\n报警：计时器到期。\n\n常见信号\n\n\nSIGHUP： 从终端上发出的结束信号；\n\n\nSIGINT： 来自键盘的中断信号（Ctrl-C）；\n\n\nSIGQUIT：来自键盘的退出信号（Ctrl-\\）；\n\n\nSIGFPE： 浮点异常信号（例如浮点运算溢出）；\n\n\nSIGKILL：该信号结束接收信号的进程；\n\n\nSIGALRM：进程的定时器到期时，发送该信号；\n\n\nSIGTERM：kill 命令发出的信号；\n\n\nSIGCHLD：标识子进程停止或结束的信号；\n每一个信号都有一个缺省动作，它是当进程没有给这个信号指定处理程序时，内核对信号的处理。有5种缺省的动作：\n\n\n异常终止（abort）：在进程的当前目录下，把进程的地址空间内容、寄存器内容保存到一个叫做core的文件中，而后终止进程。  \n\n\n退出（exit）：不产生core文件，直接终止进程。\n\n\n忽略（ignore）：忽略该信号。\n\n\n停止（stop）：挂起该进程。\n\n\n继续（continue）：如果进程被挂起，则恢复进程的运行。否则，忽略信号。\n\n\n进程可以对任何信号指定另一个动作或重载缺省动作，指定的新动作可以是忽略信号。进程也可以暂时地阻塞一个信号。因此进程可以选择对某种信号所采取的特定操作，这些操作包括：\n\n\n忽略信号：进程可忽略产生的信号，但 SIGKILL 和 SIGSTOP 信号不能被忽略,必须处理（由进程自己或由内核处理）。进程可以忽略掉系统产生的大多数信号。\n\n\n阻塞信号：进程可选择阻塞某些信号，即先将到来的某些信号记录下来，等到以后（解除阻塞后）再处理它。\n\n\n由进程处理该信号：进程本身可在系统中注册处理信号的处理程序地址，当发出该信号时，由注册的处理程序处理信号。\n\n\n由内核进行缺省处理：信号由内核的缺省处理程序处理，执行该信号的缺省动作。例如，进程接收到SIGFPE（浮点异常）的缺省动作是产生core并退出。大多数情况下，信号由内核处理。\n\n\n需要指出的是，对信号的任何处理，包括终止进程，都必须由接收到信号的进程来执行。而进程要执行信号处理程序，就必须等到它真正运行时。因此，对信号的处理可能需要延迟一段时间。  \n信号没有固有的优先级。如果为一个进程同时产生了两个信号，这两个信号会以任意顺序出现在进程中并会按任意顺序被处理。另外，也没有机制用于区分同一种类的多个信号。如果进程在处理某个信号之前，又有相同的信号发出，则进程只能接收到一个信号。进程无法知道它接收了1个还是42个SIGCONT信号。\n\n详细内容可查看:http://www.php20.cn/article/134\n","link":"/NoobCourse/PHP/Multiprocess/processSignal.html"},{"id":301,"title":"僵尸进程","content":"僵尸进程\n僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。\n在unix进程管理中,如果你新开的子进程运行结束,父进程将会收到一个SIGCHLD信号,子进程成为僵尸进程(保存了进程的状态等信息),等待父进程的处理,如果父进程一直不处理,该进程将会一直存在,占用系统进程表项,如果僵尸进程过多,导致系统没有可用的进程表项,于是再也无法运行其他的程序\n\n为了更容易理解,本文使用pcntl扩展进行进程管理  \n\n例如:\n&lt;?php\n$num = 1;\n$str = \"EasySwoole,Easy学swoole\\n\";\n$pid = pcntl_fork();\nif ($pid &gt; 0) {//主进程代码\n    echo \"我是主进程,id是\".getmypid().\",子进程的pid是{$pid}\\n\";\n    pcntl_async_signals(true);\n    pcntl_signal(SIGCHLD, function () {\n        echo '子进程退出了,请及时处理' . PHP_EOL;\n    });\n    while (1) {//主进程一直不退出\n        sleep(1);\n    }\n\n} elseif ($pid == 0) {\n    echo \"我是子进程,我的pid是\" . getmypid() . \"\\n\";\n} else {\n    echo \"我是主进程,我慌得一批,开启子进程失败了\\n\";\n}\n\n使用ps查看僵尸进程:\nps -A -ostat,ppid,pid,cmd |grep -e '^[Zz]'\n输出:\nZ+     7136   7137 [php] &lt;defunct&gt;\n\n当主进程退出之后,子进程将会被init接管并处理\n\n回收僵尸进程\n回收僵尸进程\n通过pcntl_wait和pcntl_waitpid等函数等待子进程结束\n&lt;?php\n$pid = pcntl_fork();\n\nif ($pid == -1) {\n    die('fork error');\n} else if ($pid &gt; 0) {\n//父进程阻塞着等待子进程的退出\n//    pcntl_wait($status);\n//    pcntl_waitpid($pid, $status);\n\n//非阻塞方式\n//    pcntl_wait($status, WNOHANG);\n\n//    pcntl_waitpid($pid, $status, WNOHANG);\n\n} else {\n    sleep(3);\n    echo \"child \\r\\n\";\n    exit;\n}\n通过signal函数为SIGCHLD安装handler，因为子进程结束后，父进程会收到该信号，可以在handler中调用pcntl_wait或pcntl_waitpid来回收.\n&lt;?php\npcntl_async_signals(true);\n\npcntl_signal(SIGCHLD, function () {\n    echo \"SIGCHLD \\r\\n\";\n    //阻塞方式\n    pcntl_wait($status);\n    //pcntl_waitpid(-1, $status);\n\n    //非阻塞\n    //pcntl_wait($status, WNOHANG);\n    //pcntl_waitpid(-1, $status, WNOHANG);\n});\n\n$pid = pcntl_fork();\n\nif ($pid == -1) {\n    die('fork error');\n} else if ($pid) {\n    sleep(10);\n} else {\n    sleep(3);\n    echo \"child \\r\\n\";\n    exit;\n}\n忽略掉子进程结束信号,交给init进程管理\n&lt;?php\npcntl_async_signals(true);\n\npcntl_signal(SIGCHLD, SIG_IGN);\n\n$pid = pcntl_fork();\nif ($pid == -1) {\n    die('fork error');\n} else if ($pid&gt;0) {\n    while(1){\n        sleep(1);\n    }\n} else {\n    sleep(3);\n    echo \"child \\r\\n\";\n    exit;\n}","link":"/NoobCourse/PHP/Multiprocess/zombieProcess.html"},{"id":302,"title":"孤儿进程","content":"孤儿进程\n孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程。这些孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。\n孤儿进程没有任何危害,只是需要注意自己的代码逻辑即可.\n例如:\n&lt;?php\n$pid = pcntl_fork();\nif ($pid == -1) {\n    die('fork error');\n} else if ($pid&gt;0) {\n    echo \"爸爸先走了,儿子你好好干活\\n\";\n    exit(0);\n} else {\n    while(1){\n        echo \"1\";\n        sleep(1);\n    }\n}\n运行结果:\n\n孤儿进程和僵尸进程\n僵尸进程：一个子进程在其父进程还没有调用wait()或waitpid()的情况下退出。这个子进程就是僵尸进程。任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。  \n孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害  。","link":"/NoobCourse/PHP/Multiprocess/orphanProcess.html"},{"id":303,"title":"守护进程","content":"守护进程\n守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。 \n用户使守护进程独立于所有终端是因为，在守护进程从一个终端启动的情况下，这同一个终端可能被其他的用户使用。例如，用户从一个终端启动守护进程后退出，然后另外一个人也登录到这个终端。用户不希望后者在使用该终端的过程中，接收到守护进程的任何错误信息。同样，由终端键人的任何信号(例如中断信号)也不应该影响先前在该终端启动的任何守护进程的运行。虽然让服务器后台运行很容易(只要shell命令行以&amp;结尾即可)，但用户还应该做些工作，让程序本身能够自动进入后台，且不依赖于任何终端。\n创建步骤\n\n调用fork(),创建新进程,它会是将来的守护进程.\n在父进程中调用exit,保证子进程不是父进程,成为孤儿进程\n调用setsid()创建新的会话区,让进程摆脱原会话的控制、让进程摆脱原进程组的控制和让进程摆脱原控制终端的控制。(如果不进行这步,孤儿进程将会在控制终端退出后退出)\n将当前目录改成根目录(如果把当前目录作为守护进程的目录,当前目录不能被卸载他作为守护进程的工作目录)\n将标准输入,标注输出,标准错误重定向到/dev/null.(否则会在控制终端中输出)\n重设文件创建掩码,文件创建掩码是指屏蔽掉文件创建时的对应位。由于使用fork函数新建的子进程继承了父进程的文件创建掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件创建掩码设置为0，可以大大增强该守护进程的灵活性。设置文件创建掩码的函数是umask，通常的使用方法为umask(0)。\n关闭文件描述符,用fork新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读或写，但它们一样消耗系统资源，可能导致所在的文件系统无法卸载。\n\n特点\n首先，守护进程最重要的特性是后台运行。其次，守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的文件描述符、控制终端、会话和进程组、工作目录以及文件创建掩码等。这些环境通常是守护进程从执行它的父进程(特别是shell)继承下来的。最后，守护进程的启动方式有其特殊之处。它可以在Linux系统启动时从启动脚本/etc/rc．d中启动，也可以由作业控制进程crond启动，还可以由用户终端(通常是shell)执行。  \n除这些以外，守护进程与普通进程基本上没有什么区别。因此，编写守护进样实际上是把一个普通进程按照上述的守护进程的特性改造成为守护进程。\n分类\n按照服务类型分为如下几个。\n\n系统守护进程：syslogd、login、crond、at等。\n网络守护进程：sendmail、httpd、xinetd、等。\n独立启动的守护进程：httpd、named、xinetd等。\n被动守护进程（由xinetd启动）：telnet、finger、ktalk等。\n","link":"/NoobCourse/PHP/Multiprocess/deamon.html"},{"id":304,"title":"同步/异步","content":"同步\n同步代码主要是指调用某个逻辑时,会等待到该逻辑返回调用结果.\n例如:\n&lt;?php\n$num = 30;\n$result = M('test')-&gt;select();//伪代码,查询数据库\nsleep(3);//伪代码,当成执行了3秒才返回\necho json_encode($result);//返回数据\n只有当select查询到数据时,才会返回数据给$result,这个值一定是数据库操作完毕返回的值\n例如:\n&lt;?php\n$num = -30;\n$result = abs($num);\necho json_encode($result);//返回数据\n\nabs会返回数据给$result,这个值一定是abs正确操作的值\n例如:\n用户请求www.easyswoole.com,页面会一直等待easyswoole响应数据.\n例如:\n&lt;?php\n//模拟发送邮件中\n$status = send();\nsleep(30);//发送邮件花费30秒\n\necho \"发送邮件\".$status?'完成':'失败';\n等待发送邮件的成功/失败,就是同步\n异步\n异步代码主要是指调用某个逻辑时,不会等待该逻辑返回的结果,只会返回是否已经调用的最初结果(或不返回)\n例如:\n调用$.ajax(),默认情况下是异步ajax,它会继续往下执行代码,当有结果返回时通过回调事件进行处理.\n例如:\n&lt;?php\n$pid = pcntl_fork();\nif ($pid == 0) {\n    //子进程\n    //模拟发送邮件\n    sleep(30);//发送邮件花费30秒\n    exit(0);\n}\n\npcntl_waitpid($pid, $status, WNOHANG);\necho \"发送邮件中\";\n通过新开一个进程去处理发送邮件的任务,在当前进程中不关心发送邮件的结果,直接往下执行\n","link":"/NoobCourse/sync.html"},{"id":305,"title":"阻塞/非阻塞","content":"进程阻塞\n正在运行的进程由于提出系统服务请求（如I/O操作），但因为某种原因未得到操作系统的立即响应，或者需要从其他合作进程获得的数据尚未到达等原因，该进程只能调用阻塞原语把自己阻塞，等待相应的事件出现后才被唤醒。\n阻塞状态\n正在进行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，我们把这种暂停状态叫阻塞进程阻塞，有时也成为等待状态或封锁状态。通常这种处于阻塞状态的进程也排成一个队列。有的系统则根据阻塞原因的不同而处于阻塞状态进程排成多个队列。  \n例如:\n用户访问服务端,请求用户的个人的订单信息,由于数据库数据量大,数据库繁忙,sql语句查询了3秒才返回,这个查询数据库的过程,就是可称为是&quot;阻塞的&quot;.(进程调用外部逻辑)   \n\n阻塞这个概念和时间关系不大,就算查了0.1秒,也可以说是阻塞了0.1秒,因为这个并不是进程本身执行所消耗的时间,而是因为查询数据库,等待数据库响应消耗的时间.\n但阻塞的危害性和时间有关,阻塞0.1秒对于用户是没有任何问题的,但是阻塞10秒将会使用户体验下降很多,所以我们需要重视阻塞\n用户访问服务端,由于某个地方调用了死循环或多重循环浪费了许多时间,无法继续往下执行,这个状态也可称为阻塞.(非进程阻塞,可自行避免)\n非进程阻塞 在进程阻塞层面中,并不算是被阻塞了,因为它依旧在执行进程中的代码,没有等待清空\n\n阻塞函数\n如上所说,调用数据库等外部逻辑,造成阻塞的函数,就叫做阻塞函数\nphp中的阻塞\n在php初级开发者中,或许没有听过这个概念,阻塞往往是和&quot;同步&quot;概念一起存在的,例如查询数据库,获取文件数据,请求其他网站,等等,只要需要消耗非进程本身执行时间并需要进程等待(同步)的,都可以说是阻塞.\n\n几乎所有的阻塞,都是与I/O有关.\n阻塞一定是同步代码调用阻塞函数才会阻塞,但同步代码不一定会阻塞(不调用阻塞函数的同步代码)\n&lt;?php\n$num = 30;\n$result = M('test')-&gt;select();//伪代码,sql阻塞\nsleep(3);//伪代码,当成执行了3秒才返回\necho json_encode($result);//返回数据\n\n可自行搜索了解更多\n非阻塞\n非阻塞,顾名思义,就是在进程在运行中,不存在阻塞情况,一直能往下执行.\n\n非阻塞一般是指调用I/O操作时,进程无需等待I/O操作,直接往下执行的情况\n非阻塞通常是和&quot;异步&quot;概念一起存在,只要是异步获取I/O,就一定是非阻塞\n异步调用I/O一定是非阻塞的,但非阻塞不一定需要异步调用才可实现(非阻塞模型)\n\n例如:\n当查询数据库时,马上返回状态(查询到了就返回数据,数据还没到就返回-1),程序可以立即往下执行逻辑.  \n\n这种马上返回结果,无需等待(并不一定有数据)的函数,就叫做非阻塞函数,也可称为是&quot;异步调用&quot;\n\n非阻塞模型\n可以通过非阻塞模型去实现非阻塞(主要针对于server服务端实现).\n详细了解可查看:http://www.php20.cn/article/157\nphp中的非阻塞\nphp初级开发者中,很少有非阻塞这个概念存在,但php是有非阻塞的,例如socket_set_nonblock()函数,将socket改为非阻塞状态\n通过flock($file,LOCK_EX|LOCK_NB),可将文件操作设置为非阻塞状态\n可自行搜索了解详细  \n非阻塞注意事项\n由于非阻塞的返回结果是不确定的,当我们需要关心返回结果的情况时,需要确保返回结果是正确的(例如while(1){}定时查询,当数据正确返回退出循环),或者直接使用阻塞函数\n阻塞和非阻塞的举例\n阻塞:\n小明去电脑店买Mac,问店员现在有没有MacBook Pro版本,有多少台,店员告诉小明,&quot;我得去查一查,你得等等&quot;,小明站在店门口等了2天,店员回来了,告诉小明,现在有10台,然后小明买了一台.\n\n在这个过程中,店员查询是否有mbp的动作,就属于I/O操作,叫小明等等这个操作,就是阻塞情况,小明等了2天,就说明查询mbp时间为2天,阻塞了2天,店员回来告诉小明有10台,就是阻塞函数出现了结果,并返回了数据,小明买了一台,就是继续往下执行了代码\n\n非阻塞:\n小明去电脑店买Mac,问店员现在有没有MacBook Pro版本,有多少台,店员告诉小明,&quot;我得去查一查,你先回去呗&quot;,小明回家,每隔10分钟打电话给店员,但是店员每次都告诉他还没查到,小明每次打完电话就去敲PHP代码,2天后,小明打完一把LOL,又打电话给店员问,店员告诉小明,现在有10台了,然后小明买了一台.\n\n在这个过程中,店员查询是否有mbp的动作,就属于I/O操作,叫小明回家这个操作,就是非阻塞情况,小明不断打电话,这个就是定时轮询查询,店员不断的回复,这个情况就是非阻塞函数没有返回数据,小明去敲PHP,说明非阻塞情况还能执行其他代码,2天后,店员回来告诉小明有10台,就是非阻塞函数通过轮询出现了结果,并返回了数据,小明买了一台,就是退出了循环继续往下执行了代码\n\n","link":"/NoobCourse/block.html"},{"id":306,"title":"协程","content":"协程\n协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。\n一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。\n\n协程执行顺序\n首先,我们来看一个原生php代码:\n&lt;?php\nfunction task1(){\n    for ($i=0;$i&lt;=300;$i++){\n        //写入文件,大概要3000微秒\n        usleep(3000);\n        echo \"写入文件{$i}\\n\";\n    }\n}\nfunction task2(){\n    for ($i=0;$i&lt;=500;$i++){\n        //发送邮件给500名会员,大概3000微秒\n        usleep(3000);\n        echo \"发送邮件{$i}\\n\";\n    }\n}\nfunction task3(){\n    for ($i=0;$i&lt;=100;$i++){\n        //模拟插入100条数据,大概3000微秒\n        usleep(3000);\n        echo \"插入数据{$i}\\n\";\n    }\n}\ntask1();\ntask2();\ntask3();\n在这个代码中,我们主要做了3件事:写入文件,发送邮件,以及插入数据.\n再看下面这段代码:\n&lt;?php\nfunction task1($i)\n{\n    //使用$i标识 写入文件,大概要3000微秒\n    if ($i &gt; 300) {\n        return false;//超过300不用写了\n    }\n    echo \"写入文件{$i}\\n\";\n    usleep(3000);\n    return true;\n}\n\nfunction task2($i)\n{\n    //使用$i标识 发送邮件,大概要3000微秒\n    if ($i &gt; 500) {\n        return false;//超过500不用发送了\n    }\n    echo \"发送邮件{$i}\\n\";\n    usleep(3000);\n    return true;\n}\n\nfunction task3($i)\n{\n    //使用$i标识 插入数据,大概要3000微秒\n    if ($i &gt; 100) {\n        return false;//超过100不用插入\n    }\n    echo \"插入数据{$i}\\n\";\n    usleep(3000);\n    return true;\n}\n\n$i           = 0;\n$task1Result = true;\n$task2Result = true;\n$task3Result = true;\nwhile (true) {\n    $task1Result &amp;&amp; $task1Result = task1($i);\n    $task2Result &amp;&amp; $task2Result = task2($i);\n    $task3Result &amp;&amp; $task3Result = task3($i);\n    if($task1Result===false&amp;&amp;$task2Result===false&amp;&amp;$task3Result===false){\n        break;//全部任务完成,退出循环\n    }\n    $i++;\n}\n这段代码也是做了3件事,写入文件,发送邮件,以及插入数据,但是和上面的不同的是,这段代码将这3件事交叉执行,每个任务执行完一次之后,切换到另一个任务,如此循环.\n类似于这样的执行顺序,就是协程.\n\n协程是指一种用代码实现任务交叉执行的逻辑,协程可以使得代码1中的3个函数交叉运行,在实现了协程的框架中,我们不需要通过代码2的方法实现任务交叉执行.直接可让代码1中的while(1),执行一次后切换\n\n协程的实现\n在php中,实现协程主要使用2种方式: \n\nyield生成器实现 (详细原理可查看http://www.php20.cn/article/148)\nswoole扩展实现\n\nswoole实现协程代码:\n&lt;?php\nfunction task1(){\n    for ($i=0;$i&lt;=300;$i++){\n        //写入文件,大概要3000微秒\n        usleep(3000);\n        echo \"写入文件{$i}\\n\";\n        Co::sleep(0.001);//挂起当前协程,0.001秒后恢复//相当于切换协程\n    }\n}\nfunction task2(){\n    for ($i=0;$i&lt;=500;$i++){\n        //发送邮件给500名会员,大概3000微秒\n        usleep(3000);\n        echo \"发送邮件{$i}\\n\";\n        Co::sleep(0.001);//挂起当前协程,0.001秒后恢复//相当于切换协程\n    }\n}\nfunction task3(){\n    for ($i=0;$i&lt;=100;$i++){\n        //模拟插入100条数据,大概3000微秒\n        usleep(3000);\n        echo \"插入数据{$i}\\n\";\n        Co::sleep(0.001);//挂起当前协程,0.001秒后恢复//相当于切换协程\n    }\n}\n$pid1 = go('task1');//go函数是swoole的开启协程函数,用于开启一个协程\n$pid2 = go('task2');\n$pid3 = go('task3');\n以上代码,即可实现切换函数\n\n为什么要用sleep挂起协程实现切换呢?因为swoole的协程是自动的,当协程内遇上I/O操作(mysql,redis)等时,swoole的协程会自动切换,运行到下一个协程任务中(切换后,I/O继续执行),直到下一个协程任务完成或者被切换(遇上I/O),如此反复,直到所有协程任务完成,则任务完成\n\n协程与进程\n由上面的协程执行顺序中的代码2,我们很容易发现,协程其实只是运行在一个进程中的函数,只是这个函数会被切换到下一个执行,可以这么说:\n\n协程只是一串运行在进程中的任务代码,只是这些任务代码可以交叉运行\n注意,协程并不是多任务并行,属于多任务串行,每个进程在一个时间只执行了一个任务\n\n协程的作用域\n由于协程就是进程中一串任务代码,所以它的全局变量,静态变量等变量都是共享的,包括了php的全局缓冲区.\n所以,在开发之中,需要特别注意协程中的全局变量,静态变量,只要某一个协程内修改了,那将会影响全部的协程,在使用ob缓冲区函数拦截的时候,也得考虑是否会被其他协程的输出给污染.\n用协程执行顺序中的代码2解释,当task1给$_GET['name']赋值为1时,task2读取$_GET['name']也会是1,task2将$_GET['name']赋值为2时,task3读取$_GET['name']也会是2\n协程中的I/O连接\n在协程中,要特别注意不能共用一个I/O连接,否则会造成数据异常.\n用协程执行顺序中的代码2解释,当task1,task2函数共用mysql连接,并都进行查询时,由于协程是交叉运行的,可能会造成task1获取到task1+task2查询出来的数据,也可能会丢失部分数据,被task2获取.\n\n由于协程的交叉运行机制,各个协程的I/O连接都必须是独立的,所以我们需要在每个协程都创建一个连接,但由于mysql,redis的连接数有限,以及连接的开启关闭需要消耗大量资源,所以我们可以使用连接池方案实现共用连接(只要保证每个连接每次只有一个协程在使用即可)\n","link":"/NoobCourse/coroutine.html"},{"id":307,"title":"初识swoole","content":"初识 Swoole\n前言\n\n在之前的教程当中我们已经了解到了php的几种运行模式：\n\n\nCGI   通用网关接口(Common Gateway Interface)\n\nFast-CGI 是 cgi的升级版本，用 PHP-FPM(FastCGI Process Manager) 即 fast-cgi 进程管理器\n\nmod 以模块的形式集成进 Apache 中，接受 Apache 提供的.php文件，并进行解析。\n\nCLI 命令行模式，直接使用 PHP 去执行.php文件时便是此模式。\n\n尽管 CLI 模式可以完成更多有趣和强大的功能，但大多数php程序员很少使用 CLI 模式。\n起源\nSwoole是Rango在2010年底，因为公司业务需要自己实现一个Tcp Socket Server 实现SMT\nP协议接收数据，但是在当时PHP在这个领域几乎是一片空白，所以Rango自己学习，最终完成了需求；随后便开源了此套系统，希望能帮助其他PHPer解决在这个领域的问题，让PHP从单纯的Web开发扩展到更大的空间。\n以下内容来自于Swoole官方文档\n\n项目起源\nSwoole 项目最初的想法是来自于之前所做的一个企业软件项目。当时大概是2010年底，公司产品有一个需求是用户可以任意生成一个 email 地址，然后其他用户可以向这个email发邮件，后台能实时将邮件内容解析成数据，并主动通知用户。当时项目使用PHP开发的，在实现这个需求时遇到了难题，PHP只能依赖其他的STMP服务器，通过pop3协议定时查收新邮件来完成，这样就不是实时的。如果要实现的实时系统必须自己写一个TCP Socket Server实现SMTP协议接收数据。当时PHP在这个领域几乎是空白，没有一套成熟的网络通信框架。为了实现需求，我从socket学起到TCP/IP、IO复用、libevent、多进程，最后终于实现了这套程序。做完这个项目后我就想把这套程序开源出来，希望能帮助其他PHPer解决在这个领域的难题。如果能有这样一个框架，那么PHP就能从单纯地做一个Web网站延伸到更大的空间。\n还有一个重要的原因是PHP程序的性能问题，我最早是学Java出身的，工作后才转行成为一名PHP程序员。在使用PHP开发程序的过程中，我一直在思考的问题 PHP 和 Java 比最大的优势是什么？简单高效， PHP 在请求完成之后会释放所有资源和内存，无须担心内存泄漏。代码的质量无论高低一样运行的很流畅。但同时这也是 PHP 致命的缺点。一旦请求数量上升，并发很高的时候，快速创建资源，又马上释放，使得 PHP 程序运行效率急剧下降。另外一旦项目的功能的越来越复杂，代码增多后，对于 PHP 也会是灾难。这也是 PHP 的框架为什么没有被 PHP 程序员广泛接受，而 Java 不存在这个问题。再好的框架也会被这种低效的方式拖累，导致系统变慢。所以想到了使用 PHP 来开发 PHP 的应用服务器，让 PHP 的代码加载到内存后，拥有更长的生命周期，这样建立的数据库连接和其他大的对象，不被释放。每次请求只需要处理很少的代码，而这些代码只在第一次运行时，被 PHP 解析器编译，驻留内存。另外，之前 PHP 不能实现的，对象持久化、数据库连接池，缓存连接池都可以实现。系统的运行效率会大大提高。\n经过一段时间研究，目前已经初步得到实现。使用 PHP 本身编写出 HTTP 服务器，以独立服务器方式运行，单个程序页面 ( 有对象生成，数据库连接、 smarty 模板操作 ) 的执行时间由原来的 0.0x 秒，下降到 0.00x 秒。使用 Apache AB 并发 100 测试。比传统 LAMP 方式， Request per Second 高出至少 10 倍。在我的测试机上 (Ubuntu10.04 Inter Core E5300 + 2G 内存 ) ， Apache 只跑到 83RPS 。 Swoole Server 可以跑到 1150 多 RPS。\n这个项目就是Swoole的雏形。这个版本一直持续维护了2年多，在这个过程中逐步有了一些经验积累，对这套技术方案的存在问题有了更深入的理解，比如性能差、限制较多无法直接调用操作系统接口、内存管理效率低下。\n入职腾讯\n2011年底我入职腾讯，负责朋友网的PHP平台开发工作。惊奇地发现朋友网的同事不光这样想了，他们直接做到了。朋友网团队已经在生产环境中使用了这套方案。朋友网有三架马车，第一个是PWS，这是一个纯PHP编写的WebServer，朋友网线上有600多台服务器运行在PWS上，完全没有使用Apache、PHP-FPM之类的程序。第二个是SAPS，这是使用纯PHP开发的一个分布式队列，当时大概由150台服务器的集群在跑，很多图片裁剪、头像处理、消息同时、数据同步等逻辑全部使用了SAPS做逻辑异步化。第三个是PSF，这是一个PHP实现的Server框架，朋友网很多逻辑层的服务器都是基于PSF实现的。大概有300台左右的集群在运行PSF服务器程序。在朋友网的这段时间，我学到了很多Linux底层、网络通信的知识，积累了很多大型集群高并发环境的网络通信跟踪、调试经验，为开发Swoole打下了一个很好的基础。\n开发Swoole\n在这期间也学习了解到了Node.js、Golang这些优秀的技术方案，得到了更多灵感。在2012年的时候就有了新的想法，决定使用C语言重新实现一个性能更强、功能更强大的版本。这就是现在的Swoole扩展。\n现在Swoole已经被很多PHP技术团队用于实际项目的开发工作，国内国外都有。国内知名的有百度订单中心、百度地图、腾讯QQ公众号和企业QQ、战旗直播、360、当当网、穷游等。另外还有很多物联网、硬件、游戏项目也在使用Swoole 。另外基于Swoole的开源框架也越来越多，比如TSF、Blink、swPromise 等等，在Github上也能找到很多Swoole相关的项目和代码。\n名字由来\nSwoole这个名字不是一个英文单词，是由我创造的一个音近字。我最早想到的名字是叫做 sword-server，寓意是为广大PHPer创造一把锋利的剑，后来联想到 google 也是凭空创造出来的，所以我就给它命名为 swoole。\n\n现在\n\n随着Swoole进入4.0时代，原2.0时期协程的各种各样的坑，在4.0都得到了解决。\n如今的Swoole可以说是真正好用可靠的PHP异步网络引擎。\n2018年7月Rango辞去工作，组织了全职的研发团队来开发 Swoole 内核、组件和工具链。在文档、测试、社区运营方面也会投入更多资源。本段来源\nSwoole 能做什么\n\n以下内容来源于Swoole官方文档\nSwoole 是使用 C 和 C++ 语言编写的PHP扩展， 内置了异步非阻塞、多线程的网络IO服务器，PHP程序员仅需处理事件回调即可，无需关心底层。\n同时Swoole也提供了许多非常多的内置功能如：\n\nPHP语言的异步多线程服务器\n异步TCP/UDP网络客户端\n异步MySQL\n异步Redis\n数据库连接池\nAsyncTask\n消息队列\n毫秒定时器\n异步文件读写\n异步DNS查询\nHttp/WebSocket服务器端/客户端\nHttp2.0服务器端/客户端\n\n与大家熟知的 Workerman 框架不同，Swoole更像是一个基础库给了开发者一把无比锋利的宝剑，可以按照自己想要的方法去使用。\nSwoole绝大部分功能都只能运行在 CLI 模式下，也正因为此开发者可以完全的掌控Server的一切，与传统的 php-fpm 模式不同，Swoole需要开发者自行接管各种相关事件，和管理变量的生命周期等。\n与传统Web开发的区别\n\n我们知道 php-fpm 是 fast-cgi 运行模式的进程管理器，当启动Server时 php-fpm 会预创建若干个 fast-cgi 处理进程；\n每当请求到达 Nginx 时 Nginx 检查到请求的是.php文件时，就将请求转发给 php-fpm Server 然后由 php-fpm 交给某个空闲的进程处理，当处理完成后由 php-fpm 返回给 Nginx 然后由 Nginx 响应给用户。\n传统PHP开发者几乎无需关注这其中发生的过程甚至根本不了解，正所谓成也萧何败萧何，一方面虽然降低了开发者入门的门槛但另一方面也使得大量的PHP开发者几乎不了解也不懂的真正的服务端开发。\n而 SwooleServer 则是相当于取代了 php-fpm 作为管理器的位置， 由于Swoole 是运行在 CLI 模式下， 所以可以常驻运行和以守护进程运行， 但也正因为如此，也需要开发者自行处理变量的销毁及各种异常和超时的处理。","link":"/NoobCourse/Swoole/start.html"},{"id":308,"title":"运行机制","content":"Swoole 的运行模式\n\n注： 以下内容主要指 SwooleServer 。\nSwoole 做了什么\n\nSwoole 是 php 的一个扩展，但是他又不是普通的扩展，其最明显的特点就是：一但运行后就会接管PHP的控制权，进入事件循环。 当某种IO事件发生时， Swoole 会回调开发者设置的指定PHP函数。\n也就是说 SwooleServer 更像是一个用 C 语言封装好的一个 Tcp/Udp 支持 多线程， EventLoop，事件驱动，异步 等功能的框架。开发者不需要关心底层的各种实现，直接的在业务层面进行开发即可。\n什么是IO事件\n\n很多 php 程序员没有使用过其他语言开发Server，也不太了解除了php-fpm以外运行模式的php程序，初次使用Swoole时总是会有各种摸不到头脑的事情。其实IO我们经常提起如： 磁盘IO ，网络IO 在这里Swoole所指的IO事件实际上是指 网络IO 事件。\n在日常生活中你留下了一个邮箱，当有人给你发送邮件的时候，你就会收到邮件提醒；而对于你而言，你并不关心邮件是如何送达的，你只关心你有没有收到邮件，当你收到邮件之后会根据邮件的内容和发送人去做各种各样的处理。在这个比喻中，Swoole就承担了底层网络事件的监听及各种底层事件处理，当收到邮件(请求)时，会触发收件(接收)提醒，然后将控制权转交给你(预先注册的事件回调函数)，来进行后续的处理。\nSwoole 的运行流程\n\n初始化\n&lt;?php\n\n// new 一个SwoolerServer对象 并指定监听端口 和运行模式 以及Socket类型\n// 此时的一切一切 都是开发者进行配置的时间，没有任何其他事情发生\n$server = new Swoole\\Server('0.0.0.0', 9501, SWOOLE_PROCESS, SWOOLE_SOCK_TCP);\n\n// 设置运行参数， 就像你平时做的那样，给$server 对象配置相关的参数\n$server-&gt;set([\n    'worker_num' =&gt; 4,    // 工作进程数量\n    'daemonize' =&gt; true,  // 是否以守护进程模式运行\n    'backlog' =&gt; 128,     // Listen队列长度\n]);\n\n// 注册事件回调函数\n// 这里指 当底层Tcp新连接进入事件时 交给Tcp 类的 onConnect 静态方法处理\n$server-&gt;on('Connect', [Tcp::class, 'onConnect']);\n// 这里指 当收到数据时 交给Tcp 类的 onReceive 静态方法处理\n$server-&gt;on('Receive', [Tcp::class, 'onReceive']);\n// 这里指 当Tcp客户端连接关闭时 交给Tcp 类的 onClose 静态方法处理\n$server-&gt;on('Close', [Tcp::class, 'onClose']);\n在上面的示例当中，实际上Swoole还尚未启动，但是我们已经预先配置了许多必要的配置条件。鉴于有的新人还尚不了解什么叫做 回调函数，在这里我简单的讲解一下:\n\n所谓的回调函数(CallBack) 就好比是张开了夹子的捕鼠器，我们设定当有老鼠踩到捕鼠器的时候，他会关闭夹子然后捉住老鼠，我们放置捕鼠器的时候，捕鼠器并没有真的抓老鼠。这个设定就是回调，他不立刻执行，会在遇到触发条件(事件)时执行，在上面的示例当中我们放置了3个捕鼠器(回调函数)，我们只需要知道他会在特定老鼠(事件)踩到的时候(发生的时候)去执行我们期望的功能就好。\n\nServer Start\n// 启动Swole Server 将由 Swoole 接管php运行\n$server-&gt;start();\n至此Swoole 完全的接管了php的运行，并且监听相应端口并当发生事件时去执行开发者自定义的事件回调。\n仅仅如此吗？\n事实上Swoole 在启动的时候做了非常多的事情:  \n\nSwoole 运行流程图：\n  \nSwoole 进程关系图：\n\n\n上图中我们可以了解，Swoole 会创建一个 Manager 进程专门 管理 Work 和 Task 进程。 而 Work 进程则直接通过 Unix Socket 和 Master 进程通讯。\n待续","link":"/NoobCourse/Swoole/runningMode.html"},{"id":309,"title":"生命周期","content":"Swoole的生命周期\n\nphp-fpm中的生命周期\n\n传统基于php-fpm的web开发通常淡化了全局期变量的影响，这对于开发者而言，显然是降低了许多上手难度的；但也导致了许多新人对全局期变量会产生的影响没有深刻理解。\n我们知道，php-fpm收到请求后会分配一个work进程去处理这条请求，而work会去读取并执行.php文件(在通常情基于框架的开发中，这个.php文件可能是index.php)。也就是说在传统模式中，每个请求都是独立在自己的进程中执行的，因为进程是隔离的而php-fpm又是同步阻塞的，所以我们可以很好的清楚和了解是谁在什么时候创建了变量、修改了变量、销毁了变量。\n简单举个例子\n可可酱是商店的一名售货员，这个店只有他一个人。当客户来了之后需要购买一瓶可乐，可可酱检查了货架确认有可乐，随后告诉客户这瓶可乐价格是￥3.5元，客户付钱给可可酱，可可酱收到钱后把可乐交给了客户。\n后来发现客人太多，只有可可酱一个人的时候后面的客户需要排队很久，于是老板决定再雇一名售货员，于是加入了小明。\n还是上面的场景，但是由于小明的加入，小明和可可酱同时接待了2名客户，可可酱检查了货架确认还有一箱可乐的时候，和客人沟通可乐的价格时，小明的客户需要购买一箱可乐，于是小明就取走了一箱可乐，当可可酱收了钱准备拿可乐的时候，发现没有可乐了，然后被客户打了一顿。\n在上面的场景中，就是一个变量被修改而导致后续逻辑混乱的场景，在传统的fpm开发中，往往只会在访问数据库的时候出现这种场景。但是如果假设一个fpm进程可以同时处理多条请求的时候，你如果将用户信息存放在全局变量中，那么你就无法再可靠的判断当前用户是谁了。\nswoole_server中对象的4层生命周期\n\n以下内容摘自swoole文档\n开发swoole程序与普通LAMP下编程有本质区别。在传统的Web编程中，PHP程序员只需要关注request到达，request结束即可。而在swoole程序中程序员可以操控更大范围，变量/对象可以有四种生存周期。\n\n变量、对象、资源、require/include的文件等下面统称为对象\n\n程序全局期\n在swoole_server-&gt;start之前就创建好的对象，我们称之为程序全局生命周期。这些变量在程序启动后就会一直存在，直到整个程序结束运行才会销毁。\n有一些服务器程序可能会连续运行数月甚至数年才会关闭/重启，那么程序全局期的对象在这段时间持续驻留在内存中的。程序全局对象所占用的内存是Worker进程间共享的，不会额外占用内存。\n这部分内存会在写时分离（COW），在Worker进程内对这些对象进行写操作时，会自动从共享内存中分离，变为进程全局对象。\n\n程序全局期include/require的代码，必须在整个程序shutdown时才会释放，reload无效\n\n进程全局期\nswoole拥有进程生命周期控制的机制，一个Worker子进程处理的请求数超过max_request配置后，就会自动销毁。Worker进程启动后创建的对象（onWorkerStart中创建的对象），在这个子进程存活周期之内，是常驻内存的。onConnect/onReceive/onClose 中都可以去访问它。\n\n进程全局对象所占用的内存是在当前子进程内存堆的，并非共享内存。对此对象的修改仅在当前Worker进程中有效\n进程期include/require的文件，在reload后就会重新加载  \n\n会话期\nonConnect到onClose是一次TCP的会话周期，http keep-alive时，一个连接可能会有多个request。\nhttp是无状态的，一个用户可能也不止一个连接，可以通过创建一个session来关联同一个用户的不同请求。\n请求期\n请求期就是指一个完整的请求发来，也就是onReceive收到请求开始处理，直到返回结果发送response。这个周期所创建的对象，会在请求完成后销毁。\nswoole中请求期对象与普通PHP程序中的对象就是一样的。请求到来时创建，请求结束后销毁。\n总结\n\n在Swoole中，一个work进程处理完请求后并不会销毁(甚至可能同时处理多个请求)，所以务必要明确你创建的变量的生命周期，以防止出现逻辑上的问题。","link":"/NoobCourse/Swoole/lifecycle.html"},{"id":311,"title":"composer使用","content":"Composer\nComposer 是 PHP5.3以上 的一个依赖管理工具。它允许你声明项目所依赖的代码库，它会在你的项目中为你安装他们。Composer 不是一个包管理器。是的，它涉及 &quot;packages&quot; 和 &quot;libraries&quot;，但它在每个项目的基础上进行管理，在你项目的某个目录中（例如 vendor）进行安装。默认情况下它不会在全局安装任何东西。因此，这仅仅是一个依赖管理。\n\n可以这么理解,composer是一个实现了自动加载的框架,它可以通过配置的声明,下载相应的依赖,代码库,并通过配置,使其能psr-4规范被正确的自动引入\n详细文档可查看composer文档:https://github.com/5-say/composer-doc-cn\n\ncomposer使用步骤\n\n安装composer\n创建composer项目,自动生成composer.json\n通过composer.json配置需要加载的代码库\n通过composer install下载代码库,依赖\n框架引入composer的autoload.php\n即可实现自动加载代码\n\n常用命令\ncomposer install;  #安装包,根据composer.json\ncomposer update;   #更新包,升级composer.json的所有代码库(如果能升级的话)\ncomposer search 关键字; #搜索包,搜索composer可用的包\ncomposer require 包名称; #引入包,会在composer.json新增一条包配置,并下载该代码包 \ncomposer remove 包名称; #删除包\ncomposer dump-autoload;#生成当前命名空间与类库文件路径的一个映射，运行时加载会直接读取这个映射，加快文件的加载速度。","link":"/NoobCourse/composer.html"},{"id":312,"title":"easyswoole","content":"EasySwoole\nEasySwoole 是一款基于Swoole Server 开发的常驻内存型的分布式PHP框架，专为API而生，摆脱传统PHP运行模式在进程唤起和文件加载上带来的性能损失。EasySwoole 高度封装了 Swoole Server 而依旧维持 Swoole Server 原有特性，支持同时混合监听HTTP、自定义TCP、UDP协议，让开发者以最低的学习成本和精力编写出多进程，可异步，高可用的应用服务。","link":"/NoobCourse/EasySwoole/introduction.html"},{"id":313,"title":"设计理念","content":"设计理念\n以下是作者原话:\n最早接触Swoole，是2015年年初，为实现一个可以实时控制的多进程爬虫而接触的Swoole，进而为Swoole的各种便捷、高效所着迷。   \n为此，做了综合技术评审之后，公司决定开始全线推展Swoole，并利用Swoole实现承载每天对外过亿的任务爬取与投递服务。2017年年初，在[Rango](http://rango.swoole.com/)的鼓励下,我决定将框架进行开源，并在Rango的建议下，命名为EasySwoole。\n目前为止,EasySwoole框架文档越来越完善,秉承着Easy学swoole,编写了这次的新手入门教程,让更多的phper能够更好,更快,更加容易的入门swoole,拥抱swoole的怀抱","link":"/NoobCourse/EasySwoole/designIdea.html"},{"id":314,"title":"组件说明","content":"组件设计\nEasySwoole3.x版本采用组件分离设计,可自行选择需要的组件进行添加使用,框架本身只实现了基础的封装,框架变的更加简洁,轻便\n组件列表\n目前EasySwoole3.x开源组件如下:\n\nvalidate 验证组件\nhttp   http组件,实现了对http控制器的调度封装等\nmysqli 协程版mysqli组件\nrpc    rpc组件,可实现rpc分布式\nsocket  socket组件,实现了对tcp/udp的控制器调度\ntrace   trace组件,代码追踪\ncomponent  基础组件库\nutility  工具类库\nverifyCode  验证码生成组件\nspl   spl组件\ncurl  curl组件\n","link":"/NoobCourse/EasySwoole/section.html"},{"id":315,"title":"运行过程","content":"EasySwoole运行步骤\nEasySwoole的框架运行步骤大概为以下几步:\n\n从php easyswoole start开始,首先进行了目录常量定义,临时目录,日志目录定义,\n触发initialize,这个事件你可以进行一些服务注册,修改临时目录,日志目录等\n获取框架配置,监听ip,端口,worker进程数,子服务配置,回调等,准备开启swoole服务\n触发mainServerCreate,这个事件你可以自行重新配置监听ip,端口,回调事件,框架异常,等等\n框架根据配置,启动swoole服务,附带子服务(如果有配置的话)\n\n到这个时候,框架已经是启动成功了,由于swoole_server的特性,开启之后会常驻内存(进程会一直运行,可以理解成一直在while(1){}),等待请求进入然后回调.\n用户请求步骤:\n\n用户请求\nswoole_server触发回调事件,经过框架解析\n触发 onRequest(http服务时),onReceive(tcp服务时)\n经过http组件的调度,调用控制器方法完毕\n触发 afterRequest 事件,表明这次请求已经要结束\nes将响应数据交回给swoole_server,给客户端响应数据\n","link":"/NoobCourse/EasySwoole/runSteps.html"},{"id":316,"title":"demo","content":"Demo\n目前EasySwoole文档相当完善,并且每个功能点都有代码示例,可通过下载demo,与文档对比学习EasySwoole框架:\nhttps://github.com/easy-swoole/demo","link":"/NoobCourse/EasySwoole/demo.html"},{"id":317,"title":"提问的艺术","content":"提问的艺术\n在开发过程当中,难免会遇到一些问题,而提问是最不费脑并且可能是最快的一种方式,但是,你的问题不一定会被人家所理解,但是你应该学会怎么提问\n提问之前\n在提问之前,首先要确保以下几个点:\n\n有做好可能解决不了的心理准备\n或许应该准备好付费的情况\n确定这个问题是因为实现什么而出现的,是否可以换种实现方式\n有认真思考过该问题的解决方案\n有尝试过搜索该问题的解决方案\n确定 开发手册/文档中 没有该问题的解决方案\n确定你有该问题的基础知识\n有做一系列的排查,并将问题确定在一个范围内\n\n解决不了\n当你的问题难度太大时,可能没有人能回答你的问题,你得做好解决不了的准备,解决不了请不要恼羞成怒,做出一些不理智的事情,或许可以尝试下付费解决,也或许可以换一种解决的方式(放弃问题的源头,用另一种方式实现你的逻辑)\n认真思考问题的解决方案\n当问题特别明显,只要有动脑就能解决这个问题时,没有人会喜欢回答这种基础问题,\n例如:\n当你知道echo &quot;hello world&quot;语句,却不知道怎么输出&quot;EasySwoole天下第一&quot;时\n当你知道如何移动文件到/tmp目录,却不知道移动到指定日期的目录时\n当你知道mysql有解释器可以查看是否有使用到索引,却不知道如何看组合索引是否有效时\n当报错信息出现的情况,却不知道去搜索时\n搜索问题的解决方案\n同样,当一个问题直接搜索就能出现答案,却一直拿出来问时,没有人会给伸嘴党喂饭,这是对回答者的一种侮辱\n请在提问的时候,先尝试在搜索引擎中搜索,或许答案就在第一页\n开发手册\n当你在搜索引擎没有找到一些 生僻/不知名/不公开 的一些问题时,或许你得考虑下是否有一份文档还没有看完\n既然搜索引擎都找不到的问题,那你问对该项目毫不知情的人有什么用呢?\n既然有开发文档,那你为什么不尝试下在开发文档中发现这个问题的解决方案呢?\n问题的基础\n千万不要问你对该问题一无所知的问题,当你没学过php时,请不要问为什么if(){}括号里不加条件就会报错的问题\n当你提出一个问题的,该问题相应的基础你应该要会,否则你会被人耻笑.\n例如:\n当你没看完新手教程,问swoole为什么运行之后改代码要重启\n当你没看完面对对象,问为什么不use命名空间就会报错\n当你连接websocket时,问为什么会发起一个http请求  \n排查问题\n在提问之前,首先你得学会排查这个问题,确定问题的一个大致范围.否则会让人无从回答.\n例如:\n当你上传文件这个逻辑出现问题时,你问:&quot;为什么我没法上传文件&quot;,是没有人能回答的了你的,你得自行排查,直到一个小范围.\n例如:  \n\n上传文件,选择文件之后,发生错误.  \n选择文件成功,发起http请求时出错.  \n发起http请求成功,到后端接收不到文件信息.  \n接收文件信息成功,无法保存上传文件.\n将一个大问题分解成一个个步骤,自行测试每个步骤.直到某个步骤出错(如果每个步骤都有错,那就一个个步骤慢慢解决)\n\n提问  (首先确保你看完了上面的 提问之前 小节)\n在提问时,我们应该避免以下几种问法:\n\n在吗?\n大神救我\n你好\n大佬求带\n有没有人用过xxx(说一个框架,或者一个不知名的项目)\n大神这个是怎么做的(直接要代码)\n可以问个问题吗?(不说问题,等别人回答可不可以)\n这个代码有什么错?(发出一串代码,不说问题)\n这个代码怎么改?(发出一串代码,不说怎么改,不说问题)\n为什么我这个有问题?(截图一段&quot;xxxxx&quot;自行判断输出的错误信息不截图代码)\n能不能咨询一下(某种语言,某种框架,某种项目 一个大范围的概念)\n\n当然,没有人会跟钱过不去,只要给钱,可无视一切\n\n\n\n正确的提问包含以下几点:  \n\n描述准确,准确描述你要实现的功能,问题出现之前以及出现之后的现象\n截图准确,不要截一些和问题无关,或者对解决问题没有任何帮助的图\n态度端正,虚心请教,没有人有义务帮你.\n\n问题可分为以下几种:\n\n概念问题,某种抽象概念的不理解\n代码问题,代码出现非预期的情况,报错等\n框架问题,出现框架报错,运行出错,运行逻辑不理解等问题\n逻辑问题,对某种功能实现的逻辑不理解\n性能优化问题\n\n每种问题的提问方式如下:\n概念问题\n概念问题,我们必须要描述准确,并且有自行了解过概念的基础,例如:\n\n我不太清楚为什么要用面对对象,直接函数封装不行吗?\n为什么协程要是用mysql连接池\n等\n\n代码问题\n代码问题,我们需要截图代码,以及报错信息,并且说明自己要实现什么功能,例如:\n\n我想要实现文件上传,我已经尝试了修改权限,但是不知道为什么代码会报错(附上错误信息,以及代码)\n等\n\n框架问题\n框架问题,我们需要详细的说明框架的哪个部分,以及发生了什么问题,例如:\n\n使用EasySwoole时,发现在生产模式下,调用配置文件错误\n使用tp3.2时,上传文件总是报文件夹不存在,但是文件夹存在\n使用tp3.2时,session生存时间无法配置\n\n逻辑问题\n逻辑问题,我们需要详细描述某个功能的哪部分逻辑,例如:\n\n请问session过期是怎么实现的?\n请问mysql连接池是怎么实现的?\n\n性能优化问题\n性能优化问题,需要先确认慢的地方,然后截图,例如:\n\n我发现这段代码执行特别慢,有什么错误吗?(附上代码截图)\n这段sql我想实现xxxxx查询,但是非常慢,能优化吗?(附上sql语句,表结构,解释器截图)\n\n\n可查看https://github.com/tioncico/How-To-Ask-Questions-The-Smart-Way\n","link":"/NoobCourse/artOfAskingQuestions.html"}]