[{"id":1,"title":"project introduction","content":"  ______                          _____                              _        \n |  ____|                        / ____|                            | |       \n | |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___ \n |  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n | |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n |______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                          __/ |                                               \n                         |___/                                                \nEasySwoole\n\n\n\n\n\nEasySwoole is a resident memory-based distributed PHP framework based on Swoole Server. It is designed for APIs and gets rid of the performance loss caused by process evoke and file loading in traditional PHP running mode.\nEasySwoole highly encapsulates the Swoole Server and still maintains the original features of the Swoole Server. It supports simultaneous mixing of HTTP, custom TCP, and UDP protocols, allowing developers to write multi-process, asynchronous, and highly available applications with minimal learning cost and effort. service. In development, we have prepared the following common components for you:\n\nHTTP WEB component\nTCP, UDP, WEB_SOCKET components\nredis connection pool\nmysql connection pool\nCustom process\nDistributed cross-platform RPC components\nWeChat public number and applet SDK\nCorrespondence version WeChat, Alipay payment SDK\nTemplate rendering engine\nTracker link tracking\nCurrent limiter\nmessage queue\nCoroutine HTTP client component\napollo configuration center\nvalidate validator\nVerification code\nfast-cache component\nPolicy permission component\nIOC, coroutine context manager\n\nThe above components are common components, and more components can be found in the component library documentation.\nProduction available\nFrom the earliest predecessor EasyPHP-Swoole, to the name Easyswoole, and now to the EasySwoole 3.x version, EasySwoole has experienced many stable and reliable companies under the joint efforts of many community partners.\nE.g:\n\nTencent's IEG department\nWEGAME department\nNets Technology (domestic CDN manufacturers)\n360 Finance\n360 games (Actor)\n9377 games\nXiamen Meitu Net\nChan Dashi\n\nThese companies are using EasySwoole.\nFeatures\n\nPowerful TCP/UDP Server framework, multithreading, EventLoop, event driven, asynchronous, Worker process group, Task asynchronous task, millisecond timer, SSL/TLS tunnel encryption\nThe EventLoop API allows users to directly manipulate the underlying event loop and add Linux files such as sockets, streams, and pipes to the event loop.\nTimer, coroutine object pool, HTTP\\SOCK controller, distributed microservice, RPC support\n\nAdvantage\n\nEasy to use and high development efficiency\nConcurrent million TCP connections\nTCP/UDP/UnixSock\nSupport for asynchronous / synchronous / coroutine\nSupport multi-process / multi-threading\nCPU affinity / daemon\n\nMaintenance Team\n\nAuthor\n\n如果的如果 admin@fosuss.com\n\n\nteam member\n\n阿正 1589789807@qq.com\n不忘初心 2788828128@qq.com\n北溟有鱼 1769360227@qq.com\n机器人 694050314@qq.com\nManlin 476295133@qq.com\nSiam(宣言) 59419979@qq.com\n小菜瓜 1276407988@qq.com\n仙士可 1067197739@qq.com\n\n\n\nThe above rankings are in no particular order        \nOther\n\n\nGitHub  Leave a star if you like\n\n\nGitHub for Doc  Contribute document\n\n\nDEMO  At present, the demo is not fully adapted to the new version of the EasySwoole framework. See the documentation for details.\n\n\nQQ exchange group\n\nVIP group 579434607 (this group needs to pay 599 RMB)\nEasySwoole official group 633921431 (full)\nEasySwoole official two groups 709134628 (full)\nEasySwoole official three groups 932625047 (full)\nEasySwoole official four groups 779897753 (full)\nEasySwoole official five groups 853946743 \n\n\n\nBusiness support:\n\nQQ 291323003\nEMAIL admin@fosuss.com   \n\n\n\nAuthor WeChat\n    \n\n\nDonation\nYour donation is the greatest encouragement and support for the Swoole project development team. We will insist on development and maintenance. Your donation will be used to:\n\nContinuous and in-depth development\nDocument and community construction and maintenance\n\n\n","link":"/Preface/intro.html"},{"id":2,"title":"contact author","content":"Contact author\n\n\nAuthor WeChat\n\n\n\nCommercial support：\n\nQQ 291323003\nEMAIL admin@fosuss.com  \n\n\n\nQQ exchange group\n\nVIP group 579434607 (this group needs to pay 599 RMB)\nEasySwoole official group 633921431 (full)\nEasySwoole official two groups 709134628 (full)\nEasySwoole official three groups 932625047 (full)\nEasySwoole official four groups 779897753 (full)\nEasySwoole official five groups 853946743\n\n\n","link":"/Preface/contact.html"},{"id":3,"title":"donation","content":"Donation\nDonating your donation is the greatest encouragement and support for the EasySwoole project development team. We will insist on development and maintenance. Your donation will be used for:\n\nContinuous and in-depth development\nDocument and community building and maintenance\nAlipay\n\n\n\nAlipay QR code supports flower card, credit card installment payment\nWeChat\n\nIf you donate through WeChat, please leave your message when you donate, otherwise you will not know your name.\nDonor list\n\n*章进\n*晓博\n*振宇\n*高明\n*东东\n*佳明\n*亮亮\n*凯峰\n*进国\n*海旋\n*志军\n*成龙\n*玲杰\n*东杰\n*鹏\n*力\n*宾\n*海伟\n*勇辉\n*思杰\n*龙翔\n*洋\n*伟平\n*坤平\n*勇城\n*锐\n*昆标\n*浩斌\n*博文\n*苏维\n*海涛\n*志成\n*磊\n*凯\n*建军\n*浩\n*永健\n*志强\n*少峰\n*坤磊\n*国锴\n*祖兴\n*宇翔\n*慧锋\n*萍萍\n*经国\n*超\n*达庆\n*瑾\n*强\n*民\n*振生\n*张虎\n*西湖\n*洪鐾\n*金发\n*洋\n*成永\n*俊德\n*涛\n*志银\n*科志\n*诚\n*杰\n*洪福\n*星\n*海弟\n*成龙\n*干\n*昌盛\n*坤磊\n*奇峰\n*远东\n*宾干\n*伟东\n*明磊\n*国恒\n*泉\n*进国\n*子华\n*刚\n*鹏亮\n*礼森\n*兵帅\n*旭\n*志超\n*以达\n*鹏鸿\n*航\n*亮\n*向荣\n*胜\n*艺轩\n*诸亮\n*志林\n*少峰\n*伟良\n*恒\n*钢筋\n*银\n*永欢\n*雏清\n*俊\n*凯\n*浩伟\n*亮亮\n*鹏辉\n*强\n*兵\n*金蓉\n*兴龙\n*龙辉\n*武益\n\nThe above list is sorted by time and has nothing to do with the donation amount (multiple donors do not avoid repeating and only write once). If you do not wish to appear on the list or are omitted, please contact 291323003@qq.com.","link":"/Preface/donate.html"},{"id":4,"title":"framework update record","content":"EasySwoole Framework version update record\n\nThe latest update record of the EasySwoole framework only describes the update record after October 24th, 2020. For details of the previous update record, please refer to the document of the old version or github record.\n\nVersion 3.4.2 - December 24th, 2020\nOptimized\n\nOptimized the task component, more flexible configuration can be used.\nOptimized the crontab component, it can avoid the task not being executed in extreme situations.\nOptimized the http-dispatcher component, you can register routes more flexibly.\n\nVersion 3.4.1 - November 18th, 2020\nAdded\n\nAdded constant SysConst::EXECUTE_COMMAND, the constant can get the executed command inside the main frame.\nAdded check that the install command check whether the symlink and readlink functions are disabled.\n\nFixed\n\nFixed bug that the table information is not cleaned up when worker exits abnormally.\n\nRemoved\n\nRemoved the config function in the command and bridge component, because the configuration does not use swoole-table.\n\nVersion 3.4.0 - October 24th, 2020\nv3.4.x is not compatible with v3.3.x, 3.4.x has made relatively large adjustments.\nTo upgrade from v3.3.x to v3.4.x, you need to re-execute the php vendor/bin/easyswoole install command to complete the upgrade.\nAdded\n\nAdded method Core::getInstance()-&gt;runMode();. You can use the method to modify the configuration file used when the framework is running. The default configuration file used when the framework is running is dev.php. You can also dynamically modify this configuration file in the startup command.\n\nChanged\n\n\nThe basic management command of the framework has been changed.\n\n\nWhen upgrading the framework to v3.4.x, the user-defined command needs to be adjusted. (For versions lower than v3.4.x)\n\n\nconfig is changed from the previously used swoole-table to splArray, users can adjust config by themselves.\n\n\nThe use of onRequest and afterRequest global events is changed, it needs to be registered in the initialize event and use, and the usage is as follows:\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, callback);\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_AFTER_REQUEST, callback);\nThe callback parameter in the above function is the callback function, and the parameters that need to be injected in the callback function are as follows:\nfunction (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response){}\nThe onRequest event needs to return bool to determine whether the program continues with the dispatcher.\n\n\nRemoved\n\n\nRemoved global events onRequest and afterRequest in EasySwooleEvent.\n\n\nRemoved method Core::getInstance()-&gt;isDev();.\n\n\nRemoved  Core::getInstance()-&gt;globalInitialize();, you can call EasySwooleEvent::initialize() by yourself.\n\n","link":"/Update/main.html"},{"id":5,"title":"component update record","content":"组件更新记录\n\n框架更新记录仅仅整理自2020年10-24后的记录，其余记录以老版本文档或github记录为准。\n\npool组件\n1.0.12 - 2021-01-07\n优化\n\n优化 pool 组件的负载阀值，在并发峰值非持续性情况下，对池内连接进行负载，自动调控池内连接，让 pool 组件并发处理能力更强，详见 pool组件 loadAverageTime参数\n\n\nSnowFlake(雪花算法)\n1.2.0 - 2021-01-05\n优化\n\n缩短数据中心位至 5 bit: 0 ~ 31\n\n增长进程编号位至 7 bit: 0 ~ 127\n\n同毫秒序号为 11 bit: 0 ~ 2047\n\n理论上，当使用一秒一个数据中心，128 进程时，可以允许产生 1 * 128 * 1000 * 2047 = 26201600 个唯一 ID\n\n\nOrm\n1.4.31 - 2020-12-22\n新增\n\n\nduplicate key支持.\n\ncollection增加toRawArray.\n\nwhere方法支持闭包函数.\n\n变更\n\n\ngetClientPool()方法调整为__getClientPool().\n\nupdate取消预算inc dec,直接为field = filed + 1.\n\n修复\n\n修复字段预定义属性不生效.\n屏蔽KeepMin异常导致进程退出.\n修复循环执行事务不生效问题.\n\n1.4.30 - 2020-11-2\n新增\n\n\nEasySwoole\\ORM\\Exception增加lastQueryResult.\n\n1.4.29 - 2020-10-29\n修复\n\n修复with关联调用setter问题.\n\nRedis-Pool\n2.2.1 - 2020-12-29\n2.1.x -&gt; 2.2.x不兼容,谨慎更新.\n变更\n\n\nclass名字进行合理化修改.\n\nclass参数顺序调整,调用更加合理化.\n调整invoke使用.\n\nRedis\n1.3.7 - 2020-12-24\n修复\n\n\nredis-cluster中,单个节点存在多个slot区间,无法识别问题.\n\n1.3.6 - 2020-12-14\n新增\n\nBZPopMax\nBZPopMin\nZPopMax\nZPopMin\n\n优化\n\nSPop\n\nHttp-Annotation\n1.4.6 - 2021-01-05\n优化\n\n优化scanner非php文件.\n\n1.4.5 - 2021-01-02\n新增\n\n\nInject注解,支持注入class且参数传入.\n\n1.4.4 - 2020-12-23\n修复\n\n修复生成注解文档左侧栏标题错误问题.\n\nRpc\n5.0.3 - 2020-12-23\n增加\n\n可设置client中success及fail回调.\n可设置client调用参数.\n\nreqeuest及response中uuid\n\n\nresponse中status2msg.\n\n优化\n\n带权获取节点.\n\n5.0.1 - 2020-12-18\n修复\n\n局域网内udp-broadcast问题.\n\n5.0.0 - 2020-12-17\nrpc组件5.x版本发布.\n\n完善的节点管理机制.\n无主化服务发现.\n允许节点主动上下线.\n调用流程改为Service-Module-Action模式.\n开放全局onRequest.\n优化数据包结构,缩减通讯宽带.\n\nTemplate\n1.1.0 - 2020-12-29\n1.0.x -&gt; 1.1.x不兼容.\n\n数据包结构变更\n\ninterface变更.\n","link":"/Update/component.html"},{"id":6,"title":"documentation contribution","content":"文档编写规范事项\n文档风格\n为了保障EasySwoole文档的风格基本统一，方便使用者阅读，请使用下面提供的示例风格编写文档内容。\n多版本\n每个章节文档默认显示最新版本对应的文档。如果组件错在多个版本，或者需要特殊说明。则请在对应章节文档开头处写上对应的版本连接。\n效果如：说明2或者如说明2\n风格1：\n[说明2](/Update/doc2.md)\n风格2：\n&lt;layerOpen href=\"/Update/doc2.md\"&gt;说明2&lt;/layerOpen&gt;\n层级风格\nEasySwoole 文档采用三级目录风格，语言-&gt;模块-&gt;章节 的形式进行组织内容，如某内容并不具体属于某模块，可以省略，具体组织方式如下：\n└── 语言\n    ├── 模块-1\n    │   └── 章节.md\n    ├── 模块-2\n    └── 章节.md\n分层原则\n\n\n语言 毫无争议，目前仅支持zh-cn和en\n\n\n模块 通常为相似功能的集合，或某个较为复杂的组件，新增一个模块应当谨慎\n\n章节 应当强调阅读顺序，从上到下渐进，非模块的章节可以长一些，相反模块的章节不应当过长\n\n关键词风格\n文档系统会对 .md 格式的特定语法进行美化，为了方便大家统一风格，请使用以下语法进行关键词修饰。\n希望用户在终端执行命令\n如果希望用户在终端执行某命令，可以使用 引用 语法。\n&gt; composer require easyswoole/easyswoole=3.x\n效果如下：\n\ncomposer require easyswoole/easyswoole=3.x\n\n如果希望用户在特定的地方执行命令，最好使用 重点 注释说明\n*请在终端执行以下命令*\n&gt; composer require easyswoole/easyswoole=3.x\n效果如下：\n请在终端执行以下命令\n\ncomposer require easyswoole/easyswoole=3.x\n\n高亮关键名词\n如果希望在描述中高亮某些名词，可以使用 反引号 进行修饰\n强大的 `TCP/UDP Server` 框架，`多线程`，`EventLoop`，`事件驱动`，`异步`，`Worker进程组`，`Task异步任务`，`毫秒定时器`，`SSL/TLS隧道加密`\n效果如下：\n强大的 TCP/UDP Server 框架，多线程，EventLoop，事件驱动，异步，Worker进程组，Task异步任务，毫秒定时器，SSL/TLS隧道加密\n描述函数或者 function\n\n描述函数和 function 必须简述其作用和输入输出参数，使用 代码块 指令最方便\n```php\nDbManager::getInstance()-&gt;invoke(callable function(MysqlClient $client));\n希望用户注意或警告用户\n如果希望提醒用户或者警告用户，可以使用扩展语法[^非md语法] tip warning 进行描述\n::: tip\n旧版本的invoke没有return值，请更新orm版本。\n:::\n\n::: warning  \n    注意EasySwoole的Temp目录不在虚拟机与宿主机共享目录下，否则会导致没有权限创建UnixSocket链接\n:::\n效果如下：\n旧版本的invoke没有return值，请更新orm版本。\n注意EasySwoole的Temp目录不在虚拟机与宿主机共享目录下，否则会导致没有权限创建UnixSocket链接\n章节案例\n组件库基本结构\n组件库的章节主要围绕如何让用户快速上手组件，和如果遇到问题如何解决构成的；优秀的文档应该是站在用户的角度进行编写的，提供可运行的代码片段非常重要。\n# 组件名称\n\n在章节开头描述组件的作用和用途，以及依赖的其他组件或者注意事项；以及组件主要是用来做什么的。\n\n## 组件要求\n\n最好在这里说明组件要求，防止用户在安装时遭遇失败。\n\n- php &gt;= 7.1\n- swoole &gt;= 4.4\n\n## 安装方法\n\n&gt; composer require 组件名称\n\n## 仓库地址\n\n在这里给出GitHub的仓库地址 使用[仓库名称](https://github.com/easy-swoole) 来创建一个超链接\n\n## 基本使用\n\n在这里描述组件的常用方法，以及用来做什么，具体怎么使用；给出代码。\n\n## 进阶使用\n\n在这里描述组件的进阶使用方法，比如可以用作其他相关业务，给出示例。\n\n## 相关仓库\n\n在这里给出组件的demo仓库，或基于此组件的开源项目。\n非组件库案例\n非组件案例一般是指常用的核心功能，或者是某个经典案例示例。\n# 功能名称\n\n## 功能介绍\n\n在这里介绍功能的主要用途，和通常适用于什么场景。\n\n## 相关Class位置\n\n在这里给出Class的Github地址，或是完整的`namespace`\n\n- HttpController\n    - [GitHub](https://github.com/easy-swoole/http/blob/master/src/AbstractInterface/Controller.php)\n    - `namespace`: `EasySwoole\\Http\\AbstractInterface`\n\n## 核心方法\n\n在这里给出核心或常用方法的原型；\n\n## 注意事项\n\n在这里给出常见的注意事项\n\n版本痕迹\n如果某个方法是特定版本增加，应当使用 重点 或 tip 语法进行描述。\n*3.3.4新增*\n\n::: tip\n3.3.4新增\n:::\n效果如下：\n3.3.4新增\n3.3.4新增","link":"/Update/doc.html"},{"id":7,"title":"development environment","content":"Environmental requirements 1\nThe basic environment requirements are met to run the framework. The EasySwoole framework is very simple to the environment. It only needs to meet the conditions for running Swoole extension, and the PHP version is above 7.1.\n\n\nGitHub  Leave a star if you like\n\nGitHub for Doc  Contribute document\n\nBasic operating environment\n\nGuaranteed PHP version is greater than or equal to 7.1\n\nGuaranteed Swoole extended version is greater than or equal to 4.4.12\nNeed any version of pcntl extension\nUse Linux / FreeBSD / MacOS These three types of operating systems\nUse Composer as a dependency management tool\n\nRefer to the suggestions below, they are not required, but help to use the framework and develop more efficiently.\n\nUse Ubuntu14 / CentOS 7.0 or higher operating system\n\nother\n\n\nQQ exchange group\n\nVIP group 579434607 (this group needs to pay 599 RMB)\nEasySwoole official group 633921431 (full)\nEasySwoole official two groups 709134628 (full)\nEasySwoole official three groups 932625047 (full)\nEasySwoole official four groups 779897753 (full)\nEasySwoole official five groups 853946743\n\n\n\nBusiness support:\n\nQQ 291323003\nEMAIL admin@fosuss.com   \n\n\n\nAuthor WeChat\n\n\n\nDonation\nYour donation is the greatest encouragement and support for the Swoole project development team. We will insist on development and maintenance. Your donation will be used to:\n\nContinuous and in-depth development\nDocument and community construction and maintenance\n\n\n\nEasySwoole The document uses GitBook as the document writing tool. If you find that the document needs to be corrected or supplemented during use, please fork project document warehouse, modify and supplement, submit Pull Request and contact us\n\n","link":"/Introduction/environment.html"},{"id":8,"title":"install","content":"Frame installation\n\n\nGitHub  Leave a star if you like\n\nGitHub for Doc  Contribute document\n\nPlease pay attention to the installation.\n\nThe framework uses Composer as the dependency management tool. Before you start installing the framework, make sure you have configured the environment and installed the Composer tool as described in the previous section.\nFor the installation of Composer, please refer to the [Composer China Full Mirror] (https://pkg.phpcomposer.com/#how-to-install-composer) installation tutorial.\nThe currently recommended image is Alibaba Cloud or Source Station.\nDuring the installation process, the files of the framework will be released to the project directory, please ensure that the project directory has writeable permissions.\nAfter the installation is complete, the App directory will not be automatically generated. Please configure it according to the Hello World section.\nDo not use the virtual machine shared directory as the installation directory. Otherwise, the socket cannot be created because of insufficient permissions, and an error is reported: listen xxxxxx.sock fail\n\nThe shared directory generates the above error, manually change the Temp directory to another path in the dev.php configuration file.\n\nSwitch Ali cloud image\ncomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\nComposer installation\nFollow the steps below to manually install\n(Recommended)\ncomposer require easyswoole/easyswoole=3.x\nphp vendor/easyswoole/easyswoole/bin/easyswoole install\nOr (may be wrong)\ncomposer require easyswoole/easyswoole=3.x\nphp vendor/bin/easyswoole install\n  php vendor/easyswoole/easyswoole/bin/easyswoole install\n  ______                          _____                              _        \n |  ____|                        / ____|                            | |       \n | |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___ \n |  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n | |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n |______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                          __/ |                                                \n                         |___/                                                \n  EasySwooleEvent.php has already existed. do you want to replace it? [ Y/N (default) ] : n\n  index.php has already existed. do you want to replace it? [ Y/N (default) ] : n\n  dev.php has already existed. do you want to replace it? [ Y/N (default) ] : n\n  produce.php has already existed. do you want to replace it? [ Y/N (default) ] : n\n新版安装注意事项\n\n新版的easyswoole安装会默认提供App命名空间，还有index控制器\n在这里面需要填写n，不需要覆盖，已经有的 EasySwooleEvent.php，index.php dev.php produce.php\n\nStart frame\nIf there is no error in the middle, you can execute:\n# Start frame\nphp easyswoole start\nAt this point you can visit http://localhost:9501 to see the welcome page of the framework, indicating that the framework has been successfully installed.\nDocker\nEasyswoole official docker\nDocker knowledge, please learn by yourself\nother\n\n\nQQ exchange group\n\nVIP group 579434607 (this group needs to pay 599 RMB)\nEasySwoole official group 633921431 (full)\nEasySwoole official two groups 709134628 (full)\nEasySwoole official three groups 932625047 (full)\nEasySwoole official four groups 779897753 (full)\nEasySwoole official five groups 853946743\n\n\n\nBusiness support:\n\nQQ 291323003\nEMAIL admin@fosuss.com   \n\n\n\nAuthor WeChat\n    \n\n\nDonation\nYour donation is the greatest encouragement and support for the Swoole project development team. We will insist on development and maintenance. Your donation will be used to:\n\nContinuous and in-depth development\nDocument and community construction and maintenance\n\n\n\n\n  export default {\n    mounted () {\n        if(localStorage.getItem('isNew') != 1){\n            localStorage.setItem('isNew',1);\n            layer.confirm('Do you like the EasySwoole?',function (index) {\n                 layer.msg('thank you for your support');\n                     setTimeout(function () {\n                         window.open('https://github.com/easy-swoole/easyswoole');\n                  },1500);\n             });              \n        }\n    }\n  }\n","link":"/Introduction/install.html"},{"id":9,"title":"hello world","content":"Hello World\nCreate the following directory structure in the project root directory. This directory is the application directory for writing business logic. Edit the Index.php file and add the code of the base controller.\nNote that the directory will not be automatically generated after installation (this is different from the traditional framework), you need to create and add composer to load the configuration to take effect. Please read this content patiently.\nproject                 Project deployment directory\n----------------------------------\n├─App                   Application directory\n│  └─HttpController     Application controller directory\n│     └─Index.php       Default controller file\n----------------------------------\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n\n    function index()\n    {\n        // TODO: Implement index() method.\n        $this-&gt;response()-&gt;write('hello world');\n    }\n}\nThen edit the composer.json file in the root directory to register the application's namespace.\n{\n    \"autoload\": {\n        \"psr-4\": {\n            \"App\\\\\": \"App/\"\n        }\n    },\n    \"require\": {\n        \"easyswoole/easyswoole\": \"3.x\"\n    }\n}\nIn fact, it is the name space of the registered app.\nFinally, the composer dumpautoload command is executed to update the namespace. The framework can automatically load the files in the App directory. At this point, the framework has been installed and you can start writing business logic.\n# Update namespace mapping\ncomposer dumpautoload\n# Start frame\nphp easyswoole start\nAfter launching the framework, visit http://localhost:9501 to see Hello World.\nAbout IDE Assistant\nSince the function of Swoole is not a PHP standard function, the IDE cannot perform auto-completion. In order to facilitate development, you can execute the following command to introduce the IDE assistant, and the Swoole-related functions can be automatically completed under the IDE.\ncomposer require easyswoole/swoole-ide-helper\nDirectory Structure\nEasySwoole's directory structure is very flexible, basically can be customized, there are not many constraints, but for the convenience of development, it is still recommended to follow the following directory structure.\nproject                   Project deployment directory\n├─App                     Application directory (can have multiple)\n│  ├─HttpController       Controller directory\n│  │  └─Index.php         Default controller\n│  └─Model                Model file directory\n├─Log                     Log file directory\n├─Temp                    Temporary file directory\n├─vendor                  Third-party class library directory\n├─composer.json           Composer architecture\n├─composer.lock           Composer lock\n├─EasySwooleEvent.php     Framework global event\n├─easyswoole              Framework management script\n├─dev.php                 Development configuration file\n├─produce.php             Production profile\nIf the project also needs to use other static resource files, it is recommended to use Nginx / Apache as the front-end web service, forward the request to easySwoole for processing, and add a Public directory as the root directory of the web server.\nNote! Please do not use the framework home directory as the root directory of the web server, otherwise the root directory file configuration such as dev.php,produce.php will be accessible, or you can exclude important files by yourself.","link":"/Introduction/helloWorld.html"},{"id":10,"title":"docker","content":"Docker\n\n\nGitHub  Leave a star if you like\n\nGitHub for Doc  Contribute document\n\ndocker pull\ndocker pull easyswoole/easyswoole3\nThe environment on the docker hub is php7.1.30 + swoole4.4.3\nStart up\ndocker run -ti -p 9501:9501 easyswoole/easyswoole3\nThe default working directory is: /easyswoole. When the above command is started, it automatically enters the working directory, executes php easyswoole start, and the browser accesses http://127.0.0.1:9501/\nYou can see the easyswoole welcome page.\nDocker File\nYou can also use Docker file for automatic builds.\n\nFROM centos:latest\n\n#version defined\nENV SWOOLE_VERSION 4.4.3\nENV EASYSWOOLE_VERSION 3.x-dev\n\n#update core\nRUN yum update -y\n\n#install libs\nRUN yum install -y curl zip unzip  wget openssl-devel gcc-c++ make autoconf\n\n#install php\nRUN yum install -y epel-release\nRUN rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm\nRUN yum clean all\nRUN yum update -y\nRUN yum install -y php71w-devel php71w-openssl php71w-gd php71w-mbstring php71w-mysqli\n\n# composer\nRUN curl -sS https://getcomposer.org/installer | php \\\n    &amp;&amp; mv composer.phar /usr/bin/composer \\\n    &amp;&amp; composer self-update --clean-backups\n\n# use aliyun composer\nRUN composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\n\n# swoole ext\nRUN wget https://github.com/swoole/swoole-src/archive/v${SWOOLE_VERSION}.tar.gz -O swoole.tar.gz \\\n    &amp;&amp; mkdir -p swoole \\\n    &amp;&amp; tar -xf swoole.tar.gz -C swoole --strip-components=1 \\\n    &amp;&amp; rm swoole.tar.gz \\\n    &amp;&amp; ( \\\n    cd swoole \\\n    &amp;&amp; phpize \\\n    &amp;&amp; ./configure --enable-openssl \\\n    &amp;&amp; make \\\n    &amp;&amp; make install \\\n    ) \\\n    &amp;&amp; sed -i \"2i extension=swoole.so\" /etc/php.ini \\\n    &amp;&amp; rm -r swoole\n\n# Dir\nWORKDIR /easyswoole\n\n# install easyswoole\n\nRUN cd /easyswoole \\\n    &amp;&amp; composer require easyswoole/easyswoole=${EASYSWOOLE_VERSION} \\\n    &amp;&amp; php vendor/bin/easyswoole install\n\nEXPOSE 9501\n","link":"/Introduction/docker.html"},{"id":11,"title":"configuration file","content":"Configuration file\nThe EasySwoole framework provides a very flexible and free global configuration function. The configuration file is defined by PHP return array. For some simple applications, no configuration needs to be modified. For complex requirements, you can also extend your own independent configuration files and dynamically configure. . After the framework is installed, the default global configuration file is the produce.php, dev.php file in the project root directory (before version 3.1.2 is dev.env, produce.env)\nThe file contents are as follows:\n&lt;?php\n\n      return [\n          'SERVER_NAME'   =&gt; \"EasySwoole\",//Service Name\n          'MAIN_SERVER'   =&gt; [\n              'LISTEN_ADDRESS' =&gt; '0.0.0.0',//Listening address\n              'PORT'           =&gt; 9501,//Listening port\n              'SERVER_TYPE'    =&gt; EASYSWOOLE_WEB_SERVER, //Optional EASYSWOOLE_SERVER  EASYSWOOLE_WEB_SERVER EASYSWOOLE_WEB_SOCKET_SERVER\n              'SOCK_TYPE'      =&gt; SWOOLE_TCP,//This configuration item is valid when the SERVER_TYPE value is TYPE_SERVER.\n              'RUN_MODEL'      =&gt; SWOOLE_PROCESS,// Default Server operating mode\n              'SETTING'        =&gt; [// Run configuration of Swoole Server (full configuration visible [Swoole documentation] (https://wiki.swoole.com/wiki/page/274.html))\n                  'worker_num'       =&gt; 8, // Number of worker processes running\n                  'reload_async' =&gt; true, // Set the asynchronous restart switch. When set to true, the asynchronous secure restart feature is enabled and the worker process waits for the asynchronous event to complete before exiting.\n                  'task_enable_coroutine' =&gt; true, //Automatically create coroutines in the onTask callback after opening\n                  'max_wait_time'=&gt;3\n              ],\n              'TASK'=&gt;[\n                  'workerNum'=&gt;4,\n                  'maxRunningNum'=&gt;128,\n                  'timeout'=&gt;15\n              ]\n          ],\n          'TEMP_DIR'      =&gt; null,//Temporary file storage directory\n          'LOG_DIR'       =&gt; null,//Directory where log files are stored\n      ];\nEASYSWOOLE_SERVER, EASYSWOOLE_WEB_SOCKET_SERVER type, you need to set the callback (receive or message) in EasySwooleEvent.php mainServerCreate, otherwise it will be wrong\nConfiguration operation class\nThe configuration operation class is EasySwoole\\Config, which is very simple to use. See the code example below. The operation class also provides the toArray method to get all the configuration. The load method overrides all configurations. Based on these two methods, you can Customize more advanced operations yourself\nSetting and getting configuration items support dot syntax separation. See the code example for getting the configuration below.\n&lt;?php\n\n$instance = \\EasySwoole\\EasySwoole\\Config::getInstance();\n\n// Get configuration separated by level with level\n$instance-&gt;getConf('MAIN_SERVER.SETTING.task_worker_num');\n\n// Set configuration by level with a dot\n$instance-&gt;setConf('DATABASE.host', 'localhost');\n\n// Get all configurations\n$conf = $instance-&gt;getConf();\n\n// Overwrite the current configuration item with an array\n$conf['DATABASE'] = [\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 13306\n];\n$instance-&gt;load($conf);\nAfter the server is started, the newly added configuration items are valid only for the process that performs the operation. If you need to share the configuration globally, you need to expand the configuration.\nAdd a user profile\nEach application has its own configuration items. Adding your own configuration items is very simple. One of the methods is to add them directly to the configuration file, as in the following example.\n/*################ MYSQL CONFIG ##################*/\n\n'MYSQL' =&gt; [\n    'host'          =&gt; '192.168.75.1',\n    'port'          =&gt; '3306',\n    'user'          =&gt; 'root',\n    'timeout'       =&gt; '5',\n    'charset'       =&gt; 'utf8mb4',\n    'password'      =&gt; 'root',\n    'database'      =&gt; 'cry',\n    'POOL_MAX_NUM'  =&gt; '20',\n    'POOL_TIME_OUT' =&gt; '0.1',\n],\n/*################ REDIS CONFIG ##################*/\n'REDIS' =&gt; [\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; '6379',\n    'auth'          =&gt; '',\n    'POOL_MAX_NUM'  =&gt; '20',\n    'POOL_MIN_NUM'  =&gt; '5',\n    'POOL_TIME_OUT' =&gt; '0.1',\n],\nProduction and development configuration separation\nUnder the php easyswoole start command, the default is development mode, loading dev.php (previous to 3.dev.envbefore 3.1.2) When running the php easyswoole start produce command, loadproduce.phpfor production mode (previouslyproduce.env` before 3.1.2)\nDI injection configuration\nEs3.x provides several Di parameter configurations, custom configuration script error exception handling callbacks, controller namespace, maximum resolution level, etc.\n&lt;?php\nDi::getInstance()-&gt;set(SysConst::ERROR_HANDLER,function (){});//Configuration error handling callback\nDi::getInstance()-&gt;set(SysConst::SHUTDOWN_FUNCTION,function (){});//Configuration script end callback\nDi::getInstance()-&gt;set(SysConst::HTTP_CONTROLLER_NAMESPACE,'App\\\\HttpController\\\\');//Configuring the controller namespace\nDi::getInstance()-&gt;set(SysConst::HTTP_CONTROLLER_MAX_DEPTH,5);//Configure the maximum resolution level of the http controller.\nDi::getInstance()-&gt;set(SysConst::HTTP_EXCEPTION_HANDLER,function (){});//Configure http controller exception callback\nDi::getInstance()-&gt;set(SysConst::HTTP_CONTROLLER_POOL_MAX_NUM,15);//The maximum number of http controller object pools\nDynamic configuration\nAfter the 3.2.5 version of EasySwoole, the default config storage driver was changed to swoole_table. As long as the configuration is modified, other processes are also effective.\nConfig driver\nAfter EasySwoole is released in version 3.2.5, the default configuration of the driver storage is changed from SplArray to swoole_table. After the configuration is modified, all processes take effect at the same time.\n\\EasySwoole\\Config\\AbstractConfig\nThe AbstractConfig abstract class provides the following methods for driving inheritance to other config drivers.\n\n__construct(bool $isDev = true)\nPass in the parameters of the development environment, according to the parameter to load dev.php or produce.php\nisDev()\nThis method can be used to obtain whether the current operating environment is a development environment.\nabstract function getConf($key = null);\nGet a configuration\nabstract function setConf($key,$val):bool ;\nSet a parameter\nabstract function load(array $array):bool ;\nReload configuration item\nabstract function merge(array $array):bool ;\nMerge configuration item\nabstract function clear():bool ;\nClear all configuration items\n\nCustom configuration\nIn EasySwoole, it comes with SplArray and swoole_table driver implementation, you can check the source code to understand.\nThe default driver is swoole_table\nIf you need to modify the storage driver, the steps are as follows:\n\nInherit AbstractConfig to implement each method\n在\n&lt;?php\npublic static function initialize()\n{\n//Obtain the original config configuration item and load it into the new configuration item.\n$config = Config::getInstance()-&gt;getConf();\nConfig::getInstance()-&gt;storageHandler(new SplArrayConfig())-&gt;load($config);\n// TODO: Implement initialize() method.\ndate_default_timezone_set('Asia/Shanghai');\n}\n\n\nDynamic configuration problem\nSince swoole is multi-process, if you use SplArray to store, after a single process modifies the configuration, other processes will not take effect. If you use the swoole_table method, all of them will take effect.\nother\n\n\nQQ exchange group\n\nVIP group 579434607 (this group needs to pay 599 RMB)\nEasySwoole official group 633921431 (full)\nEasySwoole official two groups 709134628 (full)\nEasySwoole official three groups 932625047 (full)\nEasySwoole official four groups 779897753 (full)\nEasySwoole official five groups 853946743\n\n\n\nBusiness support:\n\nQQ 291323003\nEMAIL admin@fosuss.com   \n\n\n\nAuthor WeChat\n\n\n\nDonation\nYour donation is the greatest encouragement and support for the Swoole project development team. We will insist on development and maintenance. Your donation will be used to:\n\nContinuous and in-depth development\nDocument and community construction and maintenance\n\n\n\neasySwoole's documentation uses GitBook as a document writing tool. If you find that the document needs to be corrected/supplemented during use, please fork project's document repository, modify and supplement it. Submit Pull Request and contact us\n\n","link":"/Introduction/config.html"},{"id":12,"title":"service management","content":"Service management script\nAfter performing the framework installation, you can see one more easywool file in your project root directory.\nExecute the following command:\nphp easyswoole\nvisible：\n ______                          _____                              _\n |  ____|                        / ____|                            | |\n | |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___\n |  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n | |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n |______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                          __/ |\n                         |___/\n\nWelcome to the easySwoole framework for the API. Current version: 3.x\n\nUse:\n  easyswoole [Operation] [Options]\n\noperating:\n  install       Install EasySwoole\n  start         Start EasySwoole\n  stop          Stop EasySwoole (used in daemon mode)\n  reload        Hot restart EasySwoole (used in daemon mode)\n  restart       Restart EasySwoole (used in daemon mode)\n  help          View help information for the command\n\nFor more information on an operation, use the HELP command to view\nFor details on the start operation, please enter easyswoole help -start\nService start\nDevelopment model： \nphp easyswoole start\nDaemon mode starts\nphp easyswoole start d\nProduction environment (the default configuration is to load dev.php, use this command to load produce.php 3.1.2 before dev.env, produce.env)\nphp easyswoole start produce\nThe service stops (the default configuration loads dev.php, using this command to load produce.php 3.1.2 before dev.env, produce.env)\nphp easyswoole stop produce\nNote that stop is required in the daemon mode, otherwise control+c or the terminal disconnects to exit the process.\nNote that after the command is added, other related stop, reload, and restart commands need to increase the produce parameter, otherwise it may be wrong.\nHot restart service\nphp easyswoole reload   (Hot restart)\nNote that reload is required only in the daemon mode, otherwise control+c or the terminal disconnects to exit the process. Here is a hot restart, which can be used to update the file (business logic) that is loaded after the worker start, the main process (such as configuration File) will not be restarted. The http custom routing configuration will not be updated and needs to be restarted;\nRestart service\nphp easyswoole restart (Force stop service and restart)\nrestart is to force the service to stop and restart, so it is disabled in production mode, otherwise the process interruption may have unexpected loss.\nFile hot loading\nDue to the characteristics of swoole resident memory, after modifying the file, you need to restart the worker process to reload the modified file into memory. We can customize the process to implement file change and automatically perform service overloading.\nSee related examples\n\nHot overload implementation principle\n\nother\n\n\nQQ exchange group\n\nVIP group 579434607 (this group needs to pay 599 RMB)\nEasySwoole official group 633921431 (full)\nEasySwoole official two groups 709134628 (full)\nEasySwoole official three groups 932625047 (full)\nEasySwoole official four groups 779897753 (full)\nEasySwoole official five groups 853946743\n\n\n\nBusiness support:\n\nQQ 291323003\nEMAIL admin@fosuss.com   \n\n\n\nAuthor WeChat\n\n\n\nDonation\nYour donation is the greatest encouragement and support for the Swoole project development team. We will insist on development and maintenance. Your donation will be used to:\n\nContinuous and in-depth development\nDocument and community construction and maintenance\n\n\n\neasySwoole's documentation uses GitBook as a document writing tool. If you find that the document needs to be corrected/supplemented during use, please fork project's document repository, modify and supplement it. Submit Pull Request and contact us\n\n","link":"/Introduction/server.html"},{"id":13,"title":"reverse proxy","content":"Proxy\nSince Swoole Server does not support HTTP protocol, it is recommended to use EasySwoole as a backend service and add NGINX or APACHE as a proxy on the front end. Add forwarding rules by referring to the following example.\nNginx\nserver {\n    root /data/wwwroot/;\n    server_name local.swoole.com;\n    location / {\n        proxy_http_version 1.1;\n        proxy_set_header Connection \"keep-alive\";\n        proxy_set_header X-Real-IP $remote_addr;\n        if (!-f $request_filename) {\n             proxy_pass http://127.0.0.1:9501;\n        }\n    }\n}\nAfter the proxy, you can get the real ip of the client through $request->getHeader('x-real-ip')[0]\nApache\n&lt;IfModule mod_rewrite.c&gt;\n  Options +FollowSymlinks\n  RewriteEngine On\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteCond %{REQUEST_FILENAME} !-f\n  #RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]  fcgi下无效\n  RewriteRule ^(.*)$  http://127.0.0.1:9501/$1 [QSA,P,L]\n   #请开启 proxy_mod proxy_http_mod request_mod\n&lt;/IfModule&gt;\nother\n\n\nProject document repository\n\n\nDEMO\n\n\nQQ exchange group\n\nVIP group 579434607 (this group needs to pay 599 RMB)\nEasySwoole official group 633921431 (full)\nEasySwoole official two groups 709134628 (full)\nEasySwoole official three groups 932625047 (full)\nEasySwoole official four groups 779897753 (full)\nEasySwoole official five groups 853946743\n\n\n\nBusiness support:\n\nQQ 291323003\nEMAIL admin@fosuss.com   \n\n\n\nAuthor WeChat\n\n\n\nDonation\nYour donation is the greatest encouragement and support for the Swoole project development team. We will insist on development and maintenance. Your donation will be used to:\n\nContinuous and in-depth development\nDocument and community construction and maintenance\n\n\n\neasySwoole's documentation uses GitBook as a document writing tool. If you find that the document needs to be corrected/supplemented during use, please fork project's document repository, modify and supplement it. Submit Pull Request and contact us\n\n","link":"/Introduction/proxy.html"},{"id":14,"title":"development example","content":"Basic development example\nDemo address\nThe base development example is open source, address: https://github.com/easy-swoole/demo/tree/3.x\nInstallation\nFrame installation\n\nWe first install the swoole extension, execute php --ri swoole to make sure you can see the swoole extension version is 4.4.8.\nCreate a directory called Test and execute composer require easyswoole/easyswoole=3.x to introduce easyswoole\n\nExecute php vendor/bin/easyswoole install to install\n\n\n\nNamespace registration\nEdit the composer.json file in the Test root directory and add \"App\\\\\": \"App/\". The general structure is as follows:\n{\n    \"autoload\": {\n        \"psr-4\": {\n            \"App\\\\\": \"App/\"\n        }\n    },\n    \"require\": {\n        \"easyswoole/easyswoole\": \"3.x\"\n    }\n}\nPost-installation directory structure\nTest                   Project deployment directory\n├─App                     Application directory\n│  ├─HttpController       Controller directory (need to create it yourself)\n├─Log                     Log file directory (created after startup)\n├─Temp                    Temporary file directory (created after startup)\n├─vendor                  Third-party class library directory\n├─composer.json           Composer architecture\n├─composer.lock           Composer lock\n├─EasySwooleEvent.php     Framework global event\n├─easyswoole              Framework management script\n├─easyswoole.install      Frame installation lock file\n├─dev.php                 Development configuration file\n├─produce.php             Production profile\nExecute the following command to update the namespace：\ncomposer dumpautoload \nConnection pool implementation\nConfiguration item\nIn the dev.php configuration file, add the following configuration information, note:  Please follow your own mysql server information to fill in the account password .\n 'MYSQL'  =&gt; [\n        'host'          =&gt; '',\n        'port'          =&gt; 3300,\n        'user'          =&gt; '',\n        'password'      =&gt; '',\n        'database'      =&gt; '',\n        'timeout'       =&gt; 5,\n        'charset'       =&gt; 'utf8mb4',\n ]\nIntroducing the ORM library\nExecute the following command to implement the introduction of the ORM library.\ncomposer require easyswoole/orm\nEvent registration\nWe edit the EasySwooleEvent.php file in the root directory and register the ORM connection in the `mainServerCreate event. The general structure is as follows:\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/5/28\n * Time: 下午6:33\n */\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\ORM\\Db\\Connection;\nuse EasySwoole\\ORM\\DbManager;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Time zone configuration\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        $config = new \\EasySwoole\\ORM\\Db\\Config(Config::getInstance()-&gt;getConf('MYSQL'));\n        DbManager::getInstance()-&gt;addConnection(new Connection($config));\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        // TODO: Implement onRequest() method.\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        // TODO: Implement afterAction() method.\n    }\n}\n\nRegister the database connection pool in the initialize event, this $config can configure the connection pool size, etc.\nModel definition\nAdministrator model\nAdd administrator user table:\nCREATE TABLE  if not exists  `admin_list` (\n  `adminId` int(11) NOT NULL AUTO_INCREMENT,\n  `adminName` varchar(15) DEFAULT NULL,\n  `adminAccount` varchar(18) DEFAULT NULL,\n  `adminPassword` varchar(32) DEFAULT NULL,\n  `adminSession` varchar(32) DEFAULT NULL,\n  `adminLastLoginTime` int(11) DEFAULT NULL,\n  `adminLastLoginIp` varchar(20) DEFAULT NULL,\n  PRIMARY KEY (`adminId`),\n  UNIQUE KEY `adminAccount` (`adminAccount`),\n  KEY `adminSession` (`adminSession`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8;\n\nINSERT INTO `admin_list` VALUES ('1', 'Alan', 'xsk', 'e10adc3949ba59abbe56e057f20f883e', '', '1566279458', '192.168.159.1');\n\nAdd a model file\nAdd the App/Model/Admin/AdminModel.php file: \n&lt;?php\n\nnamespace App\\Model\\Admin;\n\nuse EasySwoole\\ORM\\AbstractModel;\n\n/**\n * Class AdminModel\n * Create With Automatic Generator\n * @property $adminId\n * @property $adminName\n * @property $adminAccount\n * @property $adminPassword\n * @property $adminSession\n * @property $adminLastLoginTime\n * @property $adminLastLoginIp\n */\nclass AdminModel extends AbstractModel\n{\n    protected $tableName = 'admin_list';\n\n    protected $primaryKey = 'adminId';\n\n    /**\n     * @getAll\n     * @keyword adminName\n     * @param  int  page  1\n     * @param  string  keyword\n     * @param  int  pageSize  10\n     * @return array[total,list]\n     */\n    public function getAll(int $page = 1, string $keyword = null, int $pageSize = 10): array\n    {\n        $where = [];\n        if (!empty($keyword)) {\n            $where['adminAccount'] = ['%' . $keyword . '%','like'];\n        }\n        $list = $this-&gt;limit($pageSize * ($page - 1), $pageSize)-&gt;order($this-&gt;primaryKey, 'DESC')-&gt;withTotalCount()-&gt;all($where);\n        $total = $this-&gt;lastQueryResult()-&gt;getTotalCount();\n        return ['total' =&gt; $total, 'list' =&gt; $list];\n    }\n\n    /*\n     * After the login is successful, please return to the updated bean.\n     */\n    function login():?AdminModel\n    {\n        $info = $this-&gt;get(['adminAccount'=&gt;$this-&gt;adminAccount,'adminPassword'=&gt;$this-&gt;adminPassword]);\n        return $info;\n    }\n\n    /*\n     * Query by account\n     */\n    function accountExist($field='*'):?AdminModel\n    {\n        $info = $this-&gt;field($field)-&gt;get(['adminAccount'=&gt;$this-&gt;adminAccount]);\n        return $info;\n    }\n\n    function getOneBySession($field='*'):?AdminModel\n    {\n        $info = $this-&gt;field($field)-&gt;get(['adminSession'=&gt;$this-&gt;adminSession]);\n        return $info;\n    }\n\n    function logout()\n    {\n        return $this-&gt;update(['adminSession'=&gt;'']);\n    }\n\n}\nThe definition of model can be viewed in the orm chapter\nRegarding the ide automatic prompt, as long as you add @property $adminId ide to the class comment above, you can automatically prompt this property of the class.\nOrdinary user model\nCommon user model and administrator model are the same\nBuilding a table\nCREATE  TABLE if not exists `user_list` (\n                           `userId` int(11) NOT NULL AUTO_INCREMENT,\n                           `userName` varchar(32) NOT NULL,\n                           `userAccount` varchar(18) NOT NULL,\n                           `userPassword` varchar(32) NOT NULL,\n                           `phone` varchar(18) NOT NULL,\n                           `addTime` int(11) DEFAULT NULL,\n                           `lastLoginIp` varchar(20) DEFAULT NULL,\n                           `lastLoginTime` int(10) DEFAULT NULL,\n                           `userSession` varchar(32) DEFAULT NULL,\n                           `state` tinyint(2) DEFAULT NULL,\n                           `money` int(10) NOT NULL DEFAULT '0' COMMENT 'User balance',\n                           `frozenMoney` int(10) NOT NULL DEFAULT '0' COMMENT 'Freeze balance',\n                           PRIMARY KEY (`userId`),\n                           UNIQUE KEY `pk_userAccount` (`userAccount`),\n                           KEY `userSession` (`userSession`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8;\n\nINSERT INTO `user_list` VALUES ('1', 'Alan', 'xsk', 'e10adc3949ba59abbe56e057f20f883e', '', '1566279458', '192.168.159.1','1566279458','',1,'1','1');\n\nAdd a model file\nAdd the App/Model/User/UserModel.php file:\n&lt;?php\n\nnamespace App\\Model\\User;\n\nuse EasySwoole\\ORM\\AbstractModel;\n\n/**\n * Class UserModel\n * Create With Automatic Generator\n * @property $userId\n * @property $userName\n * @property $userAccount\n * @property $userPassword\n * @property $phone\n * @property $money\n * @property $addTime\n * @property $lastLoginIp\n * @property $lastLoginTime\n * @property $userSession\n * @property $state\n */\nclass UserModel extends AbstractModel\n{\n    protected $tableName = 'user_list';\n\n    protected $primaryKey = 'userId';\n\n    const STATE_PROHIBIT = 0;//Disabled state\n    const STATE_NORMAL = 1;//normal status\n\n    /**\n     * @getAll\n     * @keyword userName\n     * @param  int  page  1\n     * @param  string  keyword\n     * @param  int  pageSize  10\n     * @return array[total,list]\n     */\n    public function getAll(int $page = 1, string $keyword = null, int $pageSize = 10): array\n    {\n        $where = [];\n        if (!empty($keyword)) {\n            $where['userAccount'] = ['%' . $keyword . '%','like'];\n        }\n        $list = $this-&gt;limit($pageSize * ($page - 1), $pageSize)-&gt;order($this-&gt;primaryKey, 'DESC')-&gt;withTotalCount()-&gt;all($where);\n        $total = $this-&gt;lastQueryResult()-&gt;getTotalCount();\n        return ['total' =&gt; $total, 'list' =&gt; $list];\n    }\n\n    public function getOneByPhone($field='*'): ?UserModel\n    {\n        $info = $this-&gt;field($field)-&gt;get(['phone'=&gt;$this-&gt;phone]);\n        return $info;\n    }\n\n    /*\n     * After the login is successful, please return to the updated bean.\n     */\n    function login():?UserModel\n    {\n        $info = $this-&gt;get(['userAccount'=&gt;$this-&gt;userAccount,'userPassword'=&gt;$this-&gt;userPassword]);\n        return $info;\n    }\n\n    function getOneBySession($field='*'):?UserModel\n    {\n        $info = $this-&gt;field($field)-&gt;get(['userSession'=&gt;$this-&gt;userSession]);\n        return $info;\n    }\n\n    function logout(){\n        return $this-&gt;update(['userSession'=&gt;'']);\n    }\n\n}\n\nBanner model\nBuilding a table\nCREATE TABLE if not exists `banner_list` (\n                             `bannerId` int(11) NOT NULL AUTO_INCREMENT,\n                             `bannerName` varchar(32) DEFAULT NULL,\n                             `bannerImg` varchar(255) NOT NULL COMMENT 'Banner image',\n                             `bannerDescription` varchar(255) DEFAULT NULL,\n                             `bannerUrl` varchar(255) DEFAULT NULL COMMENT 'Jump address',\n                             `state` tinyint(3) DEFAULT NULL COMMENT 'State 0 hidden 1 normal',\n                             PRIMARY KEY (`bannerId`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8;\n\nINSERT INTO `banner_list` VALUES ('1', 'Test banner', 'asdadsasdasd.jpg', 'Tested banner data', 'www.php20.cn',1);\nAdd a model file\nAdded App/Model/Admin/BannerModel.php file:  \n&lt;?php\n\nnamespace App\\Model\\Admin;\n\nuse EasySwoole\\ORM\\AbstractModel;\n\n/**\n * Class BannerModel\n * Create With Automatic Generator\n * @property $bannerId\n * @property $bannerImg\n * @property $bannerUrl\n * @property $state\n */\nclass BannerModel extends AbstractModel\n{\n    protected $tableName = 'banner_list';\n\n    protected $primaryKey = 'bannerId';\n\n    public function getAll(int $page = 1,int $state=1, string $keyword = null, int $pageSize = 10): array\n    {\n        $where = [];\n        if (!empty($keyword)) {\n            $where['bannerUrl'] = ['%' . $keyword . '%','like'];\n        }\n        $where['state'] = $state;\n        $list = $this-&gt;limit($pageSize * ($page - 1), $pageSize)-&gt;order($this-&gt;primaryKey, 'DESC')-&gt;withTotalCount()-&gt;all($where);\n        $total = $this-&gt;lastQueryResult()-&gt;getTotalCount();\n        return ['total' =&gt; $total, 'list' =&gt; $list];\n    }\n}\nController definition\nGlobal base controller definition\nAdd the App/Httpcontroller/BaseController file:\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\EasySwoole\\ServerManager;\nuse EasySwoole\\Http\\AbstractInterface\\AnnotationController;\n\nclass BaseController extends AnnotationController\n{\n\n    function index()\n    {\n        $this-&gt;actionNotFound('index');\n    }\n\n    /**\n     * Get the user's real IP\n     * @param string $headerName The header name passed by the proxy server\n     * @return string\n     */\n    protected function clientRealIP($headerName = 'x-real-ip')\n    {\n        $server = ServerManager::getInstance()-&gt;getSwooleServer();\n        $client = $server-&gt;getClientInfo($this-&gt;request()-&gt;getSwooleRequest()-&gt;fd);\n        $clientAddress = $client['remote_ip'];\n        $xri = $this-&gt;request()-&gt;getHeader($headerName);\n        $xff = $this-&gt;request()-&gt;getHeader('x-forwarded-for');\n        if ($clientAddress === '127.0.0.1') {\n            if (!empty($xri)) {  // If there is xri, it is judged that the front end has an agent such as NGINX.\n                $clientAddress = $xri[0];\n            } elseif (!empty($xff)) {  // If there is no xri, continue to judge xff\n                $list = explode(',', $xff[0]);\n                if (isset($list[0])) $clientAddress = $list[0];\n            }\n        }\n        return $clientAddress;\n    }\n\n    protected function input($name, $default = null) {\n        $value = $this-&gt;request()-&gt;getRequestParam($name);\n        return $value ?? $default;\n    }\n}\nNew base controller, the method inside is used to get user ip, and get api parameters  \nThe base controller inherits EasySwoole\\Http\\AbstractInterface\\AnnotationController, this is an annotation support controller, which can be viewed in the annotation section.\nApi base controller definition\nAdded App/Httpcontroller/Api/ApiBase.php file:\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/3/29 0029\n * Time: 10:45\n */\n\nnamespace App\\HttpController\\Api;\n\nuse App\\HttpController\\BaseController;\nuse EasySwoole\\EasySwoole\\Core;\nuse EasySwoole\\EasySwoole\\Trigger;\nuse EasySwoole\\Http\\Exception\\ParamAnnotationValidateError;\nuse EasySwoole\\Http\\Message\\Status;\n\nabstract class ApiBase extends BaseController\n{\n    function index()\n    {\n        // TODO: Implement index() method.\n        $this-&gt;actionNotFound('index');\n    }\n\n    protected function actionNotFound(?string $action): void\n    {\n        $this-&gt;writeJson(Status::CODE_NOT_FOUND);\n    }\n\n    function onRequest(?string $action): ?bool\n    {\n        if (!parent::onRequest($action)) {\n            return false;\n        };\n        return true;\n    }\n\n    protected function onException(\\Throwable $throwable): void\n    {\n        if ($throwable instanceof ParamAnnotationValidateError) {\n            $msg = $throwable-&gt;getValidate()-&gt;getError()-&gt;getErrorRuleMsg();\n            $this-&gt;writeJson(400, null, \"{$msg}\");\n        } else {\n            if (Core::getInstance()-&gt;isDev()) {\n                $this-&gt;writeJson(500, null, $throwable-&gt;getMessage());\n            } else {\n                Trigger::getInstance()-&gt;throwable($throwable);\n                $this-&gt;writeJson(500, null, 'Internal system error, please try again later');\n            }\n        }\n    }\n}\nApi base class controller for intercepting annotation exceptions and api exceptions, returning a json format error message to the user\nCommon base controller definition\nAdded App/Httpcontroller/Api/Common/CommonBase.php file: \n&lt;?php\nnamespace App\\HttpController\\Api\\Common;\n\nuse App\\HttpController\\Api\\ApiBase;\n\nclass CommonBase extends ApiBase\n{\n}\nPublic controller\nThe public controller puts the controller that can be viewed without logging in, such as the banner list view: \nAdded App/HttpController/Api/Common/Banner.php file:\n&lt;?php\n\nnamespace App\\HttpController\\Api\\Common;\n\nuse App\\Model\\Admin\\BannerBean;\nuse App\\Model\\Admin\\BannerModel;\nuse EasySwoole\\Http\\Annotation\\Param;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\MysqliPool\\Mysql;\nuse EasySwoole\\Validate\\Validate;\n\n/**\n * Class Banner\n * Create With Automatic Generator\n */\nclass Banner extends CommonBase\n{\n\n    /**\n     * getOne\n     * @Param(name=\"bannerId\", alias=\"Primary key id\", required=\"\", integer=\"\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @throws \\Throwable\n     * @author Tioncico\n     * Time: 14:03\n     */\n    public function getOne()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $model = new BannerModel();\n        $model-&gt;bannerId = $param['bannerId'];\n        $bean = $model-&gt;get();\n        if ($bean) {\n            $this-&gt;writeJson(Status::CODE_OK, $bean, \"success\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, [], 'fail');\n        }\n    }\n\n    /**\n     * getAll\n     * @Param(name=\"page\", alias=\"Number of pages\", optional=\"\", integer=\"\")\n     * @Param(name=\"limit\", alias=\"Total number of pages\", optional=\"\", integer=\"\")\n     * @Param(name=\"keyword\", alias=\"Keyword\", optional=\"\", lengthMax=\"32\")\n     * @author Tioncico\n     * Time: 14:02\n     */\n    public function getAll()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $page = $param['page']??1;\n        $limit = $param['limit']??20;\n        $model = new BannerModel();\n        $data = $model-&gt;getAll($page, 1,$param['keyword']??null, $limit);\n        $this-&gt;writeJson(Status::CODE_OK, $data, 'success');\n    }\n}\nIt can be seen that in the getAll method, there is a comment of @Param(name=\"page\", alias=\"page number\", optional=\"\", integer=\"\"), this is an annotation support writing method, and can be written. Can not write, after writing this comment, will constrain the page parameter must be int, the specific verification mechanism can be viewed validate validator\nTest link: 127.0.0.1:9501/api/common/banner/getAll\nNeed to have data to see the specific output\nAdministrator base controller definition\nAdd the App/HttpController/Api/Admin/AdminBase.php file: \n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/10/26\n * Time: 5:39 PM\n */\n\nnamespace App\\HttpController\\Api\\Admin;\n\nuse App\\HttpController\\Api\\ApiBase;\nuse App\\Model\\Admin\\AdminModel;\nuse EasySwoole\\Http\\Message\\Status;\n\nclass AdminBase extends ApiBase\n{\n    //Public will be cleared according to the coroutine\n    public $who;\n    //Session cookie header\n    protected $sessionKey = 'adminSession';\n    //whitelist\n    protected $whiteList = [];\n\n    /**\n     * onRequest\n     * @param null|string $action\n     * @return bool|null\n     * @throws \\Throwable\n     * @author yangzhenyu\n     * Time: 13:49\n     */\n    function onRequest(?string $action): ?bool\n    {\n        if (parent::onRequest($action)) {\n            //White list judgment\n            if (in_array($action, $this-&gt;whiteList)) {\n                return true;\n            }\n            //Get login information\n            if (!$this-&gt;getWho()) {\n                $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', 'Login has expired');\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * getWho\n     * @return null|AdminModel\n     * @author yangzhenyu\n     * Time: 13:51\n     */\n    function getWho(): ?AdminModel\n    {\n        if ($this-&gt;who instanceof AdminModel) {\n            return $this-&gt;who;\n        }\n        $sessionKey = $this-&gt;request()-&gt;getRequestParam($this-&gt;sessionKey);\n        if (empty($sessionKey)) {\n            $sessionKey = $this-&gt;request()-&gt;getCookieParams($this-&gt;sessionKey);\n        }\n        if (empty($sessionKey)) {\n            return null;\n        }\n        $adminModel = new AdminModel();\n        $adminModel-&gt;adminSession = $sessionKey;\n        $this-&gt;who = $adminModel-&gt;getOneBySession();\n        return $this-&gt;who;\n    }\n}\n\nAdministrator login controller\nAdded App/HttpController/Api/Admin/Auth.php file:   \n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/10/26\n * Time: 5:39 PM\n */\n\nnamespace App\\HttpController\\Api\\Admin;\n\nuse App\\Model\\Admin\\AdminModel;\nuse EasySwoole\\Http\\Annotation\\Param;\nuse EasySwoole\\Http\\Message\\Status;\n\nclass Auth extends AdminBase\n{\n    protected $whiteList=['login'];\n\n    /**\n     * login\n     * Login, parameter verification annotation\n     * @Param(name=\"account\", alias=\"account number\", required=\"\", lengthMax=\"20\")\n     * @Param(name=\"password\", alias=\"password\", required=\"\", lengthMin=\"6\", lengthMax=\"16\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @throws \\Throwable\n     * @author Tioncico\n     * Time: 10:18\n     */\n    function login()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $model = new AdminModel();\n        $model-&gt;adminAccount = $param['account'];\n        $model-&gt;adminPassword = md5($param['password']);\n\n        if ($user = $model-&gt;login()) {\n            $sessionHash = md5(time() . $user-&gt;adminId);\n            $user-&gt;update([\n                'adminLastLoginTime' =&gt; time(),\n                'adminLastLoginIp'   =&gt; $this-&gt;clientRealIP(),\n                'adminSession'       =&gt; $sessionHash\n            ]);\n\n            $rs = $user-&gt;toArray();\n            unset($rs['adminPassword']);\n            $rs['adminSession'] = $sessionHash;\n            $this-&gt;response()-&gt;setCookie('adminSession', $sessionHash, time() + 3600, '/');\n            $this-&gt;writeJson(Status::CODE_OK, $rs);\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, '', 'wrong password');\n        }\n\n    }\n\n    /**\n     * logout\n     * Logout, parameter annotation\n     * @Param(name=\"adminSession\", from={COOKIE}, required=\"\")\n     * @return bool\n     * @author Tioncico\n     * Time: 10:23\n     */\n    function logout()\n    {\n        $sessionKey = $this-&gt;request()-&gt;getRequestParam($this-&gt;sessionKey);\n        if (empty($sessionKey)) {\n            $sessionKey = $this-&gt;request()-&gt;getCookieParams('adminSession');\n        }\n        if (empty($sessionKey)) {\n            $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', 'Not logged in');\n            return false;\n        }\n        $result = $this-&gt;getWho()-&gt;logout();\n        if ($result) {\n            $this-&gt;writeJson(Status::CODE_OK, '', \"exit successfully\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', 'fail');\n        }\n    }\n\n    function getInfo()\n    {\n        $this-&gt;writeJson(200, $this-&gt;getWho()-&gt;toArray(), 'success');\n    }\n}\nIt can be seen that in the getAll method, there is a comment of @Param(name=\"account\", alias=\"account\", required=\"\", lengthMax=\"20\"), this is an annotation support writing method, and can be written as well. Can not write, after writing this comment, will constrain the page parameter must be int, the specific verification mechanism can be viewed validate validator\nRequest 127.0.0.1:9501/Api/Admin/Auth/login?account=xsk&password=123456 to return:\n{\n    \"code\": 200,\n    \"result\": {\n        \"adminId\": 1,\n        \"adminName\": \"Alan\",\n        \"adminAccount\": \"xsk\",\n        \"adminSession\": \"d45de0cd6dd91122db4bd7e976c7deb8\",\n        \"adminLastLoginTime\": 1566279458,\n        \"adminLastLoginIp\": \"192.168.159.1\"\n    },\n    \"msg\": null\n}\nAdministrator user management controller\nAdd the App/httpController/Api/Admin/User.php file:\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/10/26\n * Time: 5:39 PM\n */\n\nnamespace App\\HttpController\\Api\\Admin;\n\nuse App\\Model\\User\\UserBean;\nuse App\\Model\\User\\UserModel;\nuse EasySwoole\\Http\\Annotation\\Param;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\Validate\\Validate;\n\nclass User extends AdminBase\n{\n    /**\n     * getAll\n     * @Param(name=\"page\", alias=\"Number of pages\", optional=\"\", integer=\"\")\n     * @Param(name=\"limit\", alias=\"Total number of pages\", optional=\"\", integer=\"\")\n     * @Param(name=\"keyword\", alias=\"Keyword\", optional=\"\", lengthMax=\"32\")\n     * @author Tioncico\n     * Time: 14:01\n     */\n    function getAll()\n    {\n        $page = (int)$this-&gt;input('page', 1);\n        $limit = (int)$this-&gt;input('limit', 20);\n        $model = new UserModel();\n        $data = $model-&gt;getAll($page, $this-&gt;input('keyword'), $limit);\n        $this-&gt;writeJson(Status::CODE_OK, $data, 'success');\n    }\n\n    /**\n     * getOne\n     * @Param(name=\"userId\", alias=\"User id\", required=\"\", integer=\"\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @throws \\Throwable\n     * @author Tioncico\n     * Time: 11:48\n     */\n    function getOne()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $model = new UserModel();\n        $model-&gt;userId = $param['userId'];\n        $rs = $model-&gt;get();\n        if ($rs) {\n            $this-&gt;writeJson(Status::CODE_OK, $rs, \"success\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, [], 'fail');\n        }\n\n    }\n\n    /**\n     * add\n     * @Param(name=\"userName\", alias=\"User's Nickname\", optional=\"\", lengthMax=\"32\")\n     * @Param(name=\"userAccount\", alias=\"username\", required=\"\", lengthMax=\"32\")\n     * @Param(name=\"userPassword\", alias=\"user password\", required=\"\", lengthMin=\"6\",lengthMax=\"18\")\n     * @Param(name=\"phone\", alias=\"cellphone number\", optional=\"\", lengthMax=\"18\",numeric=\"\")\n     * @Param(name=\"state\", alias=\"user status\", optional=\"\", inArray=\"{0,1}\")\n     * @author Tioncico\n     * Time: 11:48\n     */\n    function add()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $model = new UserModel($param);\n        $model-&gt;userPassword = md5($param['userPassword']);\n        $rs = $model-&gt;save();\n        if ($rs) {\n            $this-&gt;writeJson(Status::CODE_OK, $rs, \"success\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, [], $model-&gt;lastQueryResult()-&gt;getLastError());\n        }\n    }\n\n    /**\n     * update\n     * @Param(name=\"userId\", alias=\"User id\", required=\"\", integer=\"\")\n     * @Param(name=\"userPassword\", alias=\"member password\", optional=\"\", lengthMin=\"6\",lengthMax=\"18\")\n     * @Param(name=\"userName\", alias=\"Member name\", optional=\"\",  lengthMax=\"32\")\n     * @Param(name=\"state\", alias=\"status\", optional=\"\", inArray=\"{0,1}\")\n     * @Param(name=\"phone\", alias=\"phone number\", optional=\"\",  lengthMax=\"18\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @throws \\Throwable\n     * @author Tioncico\n     * Time: 11:54\n     */\n    function update()\n    {\n        $model = new UserModel();\n        $model-&gt;userId = $this-&gt;input('userId');\n        /**\n         * @var $userInfo UserModel\n         */\n        $userInfo = $model-&gt;get();\n        if (!$userInfo) {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, [], 'This member was not found');\n        }\n        $password = $this-&gt;input('userPassword');\n        $update = [\n          'userName'=&gt;$this-&gt;input('userName', $userInfo-&gt;userName),\n          'userPassword'=&gt;$password ? md5($password) : $userInfo-&gt;userPassword,\n          'state'=&gt;$this-&gt;input('state', $userInfo-&gt;state),\n          'phone'=&gt;$this-&gt;input('phone', $userInfo-&gt;phone),\n        ];\n\n        $rs = $model-&gt;update($update);\n        if ($rs) {\n            $this-&gt;writeJson(Status::CODE_OK, $rs, \"success\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, [], $model-&gt;lastQueryResult()-&gt;getLastError());\n        }\n\n    }\n\n    /**\n     * delete\n     * @Param(name=\"userId\", alias=\"User id\", required=\"\", integer=\"\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @throws \\Throwable\n     * @author Tioncico\n     * Time: 14:02\n     */\n    function delete()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $model = new UserModel();\n        $model-&gt;userId = $param['userId'];\n        $rs = $model-&gt;destroy();\n        if ($rs) {\n            $this-&gt;writeJson(Status::CODE_OK, $rs, \"success\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, [], 'failed to delete');\n        }\n\n    }\n}\nAfter the background administrator logs in, you can use the interface of this file to perform the curd member.  \nThe request address is: 127.0.0.1:9501/Api/Admin/User/getAll (etc.)  \nNormal user base controller definition\nAdded App/HttpController/Api/User/UserBase.php file:  \n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/10/26\n * Time: 5:39 PM\n */\n\nnamespace App\\HttpController\\Api\\User;\n\nuse App\\HttpController\\Api\\ApiBase;\nuse App\\Model\\User\\UserBean;\nuse App\\Model\\User\\UserModel;\nuse App\\Utility\\Pool\\MysqlPool;\nuse App\\Utility\\Pool\\RedisPool;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\MysqliPool\\Mysql;\nuse EasySwoole\\Spl\\SplBean;\nuse EasySwoole\\Validate\\Validate;\n\nclass UserBase extends ApiBase\n{\n    protected $who;\n    //Session cookie header\n    protected $sessionKey = 'userSession';\n    //whitelist\n    protected $whiteList = ['login', 'register'];\n\n    /**\n     * onRequest\n     * @param null|string $action\n     * @return bool|null\n     * @throws \\Throwable\n     * @author yangzhenyu\n     * Time: 13:49\n     */\n    function onRequest(?string $action): ?bool\n    {\n        if (parent::onRequest($action)) {\n            //White list judgment\n            if (in_array($action, $this-&gt;whiteList)) {\n                return true;\n            }\n            //Get login information\n            if (!$data = $this-&gt;getWho()) {\n                $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', 'Login has expired');\n                return false;\n            }\n            //Refresh cookie survival\n            $this-&gt;response()-&gt;setCookie($this-&gt;sessionKey, $data-&gt;getUserSession(), time() + 3600, '/');\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * getWho\n     * @author yangzhenyu\n     * Time: 13:51\n     */\n    function getWho(): ?UserModel\n    {\n        if ($this-&gt;who instanceof UserModel) {\n            return $this-&gt;who;\n        }\n        $sessionKey = $this-&gt;request()-&gt;getRequestParam($this-&gt;sessionKey);\n        if (empty($sessionKey)) {\n            $sessionKey = $this-&gt;request()-&gt;getCookieParams($this-&gt;sessionKey);\n        }\n        if (empty($sessionKey)) {\n            return null;\n        }\n        $userModel = new UserModel();\n        $userModel-&gt;userSession = $sessionKey;\n        $this-&gt;who = $userModel-&gt;getOneBySession();\n        return $this-&gt;who;\n    }\n}\nOrdinary user login controller\nAdded App/HttpController/Api/User/Auth.php file:   \n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2019-04-02\n * Time: 13:03\n */\n\nnamespace App\\HttpController\\Api\\User;\n\nuse App\\Model\\User\\UserBean;\nuse App\\Model\\User\\UserModel;\nuse App\\Service\\Common\\VerifyService;\nuse App\\Utility\\Pool\\MysqlPool;\nuse App\\Utility\\SwooleApi\\User\\Login;\nuse EasySwoole\\Http\\Annotation\\Param;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\MysqliPool\\Mysql;\nuse EasySwoole\\Spl\\SplBean;\nuse EasySwoole\\Validate\\Validate;\n\nclass Auth extends UserBase\n{\n    protected $whiteList = ['login', 'register'];\n\n    /**\n     * login\n     * @Param(name=\"userAccount\", alias=\"username\", required=\"\", lengthMax=\"32\")\n     * @Param(name=\"userPassword\", alias=\"password\", required=\"\", lengthMin=\"6\",lengthMax=\"18\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @throws \\Throwable\n     * @author Tioncico\n     * Time: 15:06\n     */\n    function login()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $model = new UserModel();\n        $model-&gt;userAccount = $param['userAccount'];\n        $model-&gt;userPassword = md5($param['userPassword']);\n\n        if ($userInfo = $model-&gt;login()) {\n            $sessionHash = md5(time() . $userInfo-&gt;userId);\n            $userInfo-&gt;update([\n                'lastLoginIp'   =&gt; $this-&gt;clientRealIP(),\n                'lastLoginTime' =&gt; time(),\n                'userSession'   =&gt; $sessionHash\n            ]);\n            $rs = $userInfo-&gt;toArray();\n            unset($rs['userPassword']);\n            $rs['userSession'] = $sessionHash;\n            $this-&gt;response()-&gt;setCookie('userSession', $sessionHash, time() + 3600, '/');\n            $this-&gt;writeJson(Status::CODE_OK, $rs);\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, '', 'wrong password');\n        }\n    }\n\n    function logout()\n    {\n        $sessionKey = $this-&gt;request()-&gt;getRequestParam('userSession');\n        if (empty($sessionKey)) {\n            $sessionKey = $this-&gt;request()-&gt;getCookieParams('userSession');\n        }\n        if (empty($sessionKey)) {\n            $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', 'Not signed');\n            return false;\n        }\n        $result = $this-&gt;getWho()-&gt;logout();\n        if ($result) {\n            $this-&gt;writeJson(Status::CODE_OK, '', \"Logout success\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', 'fail');\n        }\n    }\n\n    function getInfo()\n    {\n        $this-&gt;writeJson(200, $this-&gt;getWho(), 'success');\n    }\n}\nYou can log in successfully by accessing 127.0.0.1:9501/Api/User/Auth/login?userAccount=xsk&amp;userPassword=123456\nAdministrator login: 127.0.0.1:9501/Api/Admin/Auth/login?account=xsk&password=123456\nPublic request banner:127.0.0.1:9501/Api/Common/Banner/getAll\nMember login: 127.0.0.1:9501/Api/User/Auth/login?userAccount=xsk&userPassword=123456","link":"/Introduction/example.html"},{"id":15,"title":"demo","content":"Demo\nEasySwoole-Chat\nChat room based on EasySwoole V3\nChat Room Demo Address\nEasySwoole-Admin\nBased on the background of the EasySwoole framework, the Policy component, the FastCache component, and the mysqli connection pool component are used. Used for: api development process learning, component usage learning, project background. \nAdmin background template address\nEasySwoole-Http-Monitor\nDevelopment tools, can record the most recent http request, and analyze parameters, recurrence requests, such as WeChat asynchronous callback debugging, pay a single, you can repeatedly simulate push callback until the program goes through. \nHttp monitoring tool address\ncurdAutomaticGeneration\nQuickly generate CURD code from the database, including a full set of beans, models, controllers. Code layering, rapid development of additions, deletions and changes to the function module.\nAutomatic code tool address\njin-Chat\nComplete IM application based on EasySwoole V3 and integrated mysq/redisl coroutine connection pool, Task asynchronous task, ceche cache, chat chat and other functions in ES document (demo)\nim Demo address\nsocialite (Third-party login integration component)\nThird-party login component for easyswoole based on overtrue/socialite transformation, now supports wechat, qq, weibo, github, facebook\nThird-party login integration component address","link":"/Introduction/demo.html"},{"id":16,"title":"life cycle","content":"框架生命周期\n)","link":"/Core/lifecycle.html"},{"id":17,"title":"bootstrap","content":"bootstrapEvent\nBootstrap allows other businesses to be initialized before the framework is initialized\nThis event was added after version 3.2.5\nIn the easyswoole startup script file that is generated after installation:\nThe bootstrap.php file in the application root directory will be automatically determined，If there is，Load。\nSo we can create this file in the application root directory and execute the initialization business code we want：Such as register command line support, global general functions and other functions。\n&lt;?php\n\nuse EasySwoole\\EasySwoole\\Command\\CommandRunner;\n\ndefined('IN_PHAR') or define('IN_PHAR', boolval(\\Phar::running(false)));\ndefined('RUNNING_ROOT') or define('RUNNING_ROOT', realpath(getcwd()));\ndefined('EASYSWOOLE_ROOT') or define('EASYSWOOLE_ROOT', IN_PHAR ? \\Phar::running() : realpath(getcwd()));\n\n$file = EASYSWOOLE_ROOT.'/vendor/autoload.php';\nif (file_exists($file)) {\n    require $file;\n}else{\n    die(\"include composer autoload.php fail\\n\");\n}\n\nif(file_exists(EASYSWOOLE_ROOT.'/bootstrap.php')){\n    require_once EASYSWOOLE_ROOT.'/bootstrap.php';\n}\n\n$args = $argv;\n//trim first command\narray_shift($args);\n$ret = CommandRunner::getInstance()-&gt;run($args);\nif(!empty($ret)){\n    echo $ret.\"\\n\";\n}\n\nf you are an old swoole upgrade, you will need to delete the '/easyswoole' file.\nThen again PHP/vendor/easyswoole/easyswoole/bin/easyswoole install installation(Report errors or other reasons.Please review the framework installation section to perform the installation steps)\ncan use the bootstrap event\n\nCall the coroutine API before starting\nuse Swoole\\Coroutine\\Scheduler;\n$scheduler = new Scheduler();\n$scheduler-&gt;add(function() {\n    /*  Call the coroutine API */\n});\n$scheduler-&gt;start();\n//Clear all timers\n\\Swoole\\Timer::clearAll();","link":"/Core/event/bootstrap.html"},{"id":18,"title":"initialize","content":"Framework initializes Events\nThe function prototype\npublic static function initialize(): void\n{\n}\nFinished work\nEasySwoole has done the following when executing the framework initialization event: \n\nThe definition of the global constant EASYSWOOLE_ROOT\nSystem default Log/Temp directory definition\n\nProcessable content\nIn this event, some system constant changes and global configuration can be made, for example：\n\nModify and create the system default Log/Temp directory。\nIntroduce user-defined configurations\nRegister database,redis connection pool\ntrace registration\n\nCall the coroutine API before starting\nuse Swoole\\Coroutine\\Scheduler;\n$scheduler = new Scheduler();\n$scheduler-&gt;add(function() {\n    /*  Call the coroutine API */\n});\n$scheduler-&gt;start();\n//Clear all timers\n\\Swoole\\Timer::clearAll();","link":"/Core/event/initialize.html"},{"id":19,"title":"mainservercreate","content":"mainServerCreateEvent\nThe function prototype\n@param \\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register\npublic static function mainServerCreate(EventRegister $register)\n{\n}\nFinished work\nAt the time of executing the event, the following work has been completed:\n\nFramework initializes events\nThe configuration file is loaded\nThe main Swoole Server is created successfully\nMain Swoole Server registered its default onRequest, onTask, onFinish events.。\n\nProcessable content\nRegister the main service callback event\nFor example, register the onWorkerStart event for the main service\n$register-&gt;add($register::onWorkerStart,function (\\swoole_server $server,int $workerId){\n     var_dump($workerId.'start');\n});\nFor example, add an onMessage event to the main service\n  // In WebSocket mode message events must be registered and handed in \n$register-&gt;set(EventRegister::onMessage, function (\\swoole_websocket_server $server, \\swoole_websocket_frame $frame) {\n    var_dump($frame);\n});\nThe set method is different from the add method. The set method overrides the previously configured event callback, while the add method adds a new callback\nAdd a custom process\nDetailed operations can be viewed in the basic use -> custom process\n\\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new Test('test_process'));\nTest is a subclass of the EasySwoole\\Component\\Process\\AbstractProcess'abstract class\nAdd a subservice listener\n$subPort = ServerManager::getInstance()-&gt;getSwooleServer()-&gt;addListener('0.0.0.0',9503,SWOOLE_TCP);\n$subPort-&gt;on('receive',function (\\swoole_server $server, int $fd, int $reactor_id, string $data){\n    var_dump($data);\n});\nRefer to different ways of writing Demo branches event: The demo branch\nCall the coroutine API before starting\nuse Swoole\\Coroutine\\Scheduler;\n$scheduler = new Scheduler();\n$scheduler-&gt;add(function() {\n    /*  Call the coroutine API */\n});\n$scheduler-&gt;start();\n//Clear all timers\n\\Swoole\\Timer::clearAll();","link":"/Core/event/mainServerCreate.html"},{"id":20,"title":"onrequest","content":"onRequestEvent\n public static function onRequest(Request $request, Response $response): bool\nEasySwoole executes this event when it receives any HTTP request. This event can intercept HTTP requests globally。\n&lt;?php\n public static function onRequest(Request $request, Response $response): bool\n    {\n        //It is not recommended to intercept requests here, but to add a controller base class for interception\n        //If you want to intercept, return false\n        $code = $request-&gt;getRequestParam('code');\n        if (0/*empty($code)Validation fails*/){\n            $data = Array(\n                \"code\" =&gt; Status::CODE_BAD_REQUEST,\n                \"result\" =&gt; [],\n                \"msg\" =&gt; 'Validation fails'\n            );\n            $response-&gt;write(json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES));\n            $response-&gt;withHeader('Content-type', 'application/json;charset=utf-8');\n            $response-&gt;withStatus(Status::CODE_BAD_REQUEST);\n            return false;\n        }\n\n        return true;\n    }\nIf $response->end() is executed in this event, the request will not enter the route matching phase.","link":"/Core/event/onRequest.html"},{"id":21,"title":"afterrequest","content":"afterRequest\nThe function prototype\npublic static function afterRequest(Request $request, Response $response): void\n{\n}\nThe sample\nYou can trace the event to monitor the request and get the content of the response\npublic static function afterRequest(Request $request, Response $response): void\n{\n    TrackerManager::getInstance()-&gt;getTracker()-&gt;endPoint('request');\n\n    $responseMsg = $response-&gt;getBody()-&gt;__toString();\n    Logger::getInstance()-&gt;console(\"Response content:\".$responseMsg);\n    // Response status code:\n    // var_dump($response-&gt;getStatusCode());\n\n    // tracker end,After the end, you can see halfway set parameters, call stack running\n    TrackerManager::getInstance()-&gt;closeTracker();\n    // TODO: Implement afterAction() method.\n}","link":"/Core/event/afterRequest.html"},{"id":22,"title":"annotation","content":"Annotation\nEasyswoole provides a lightweight annotation resolution tool.\nThe installation\ncomposer require easyswoole/annotation\nImplementation principle\n\nconvention\n\nEach annotation behavior starts with the @ character and is formatted as\n@METHOD(ARGS)\n\n\n\nThe execution process is as follows：\n\nUse PHP reflection to get comment information\nExplode and explode each line with PHP_EOL\nParse the data of each line. If the corresponding METHOD AnnotationTagInterface exists, pass the parsed ARGS to the assetValue METHOD in the AnnotationTagInterface.\nThe user can perform custom parsing of the parsed values in this method.\nIn strict mode, an error is reported if the correct value cannot be resolved.\n\n\n\nexample\n&lt;?php\nuse EasySwoole\\Annotation\\Annotation;\nuse EasySwoole\\Annotation\\AbstractAnnotationTag;\n\n/*\n * Define the param rendering method\n */\n\nclass param extends AbstractAnnotationTag\n{\n\n    public function tagName(): string\n    {\n        return 'param';\n    }\n\n    public function assetValue(?string $raw)\n    {\n        $list = explode(',',$raw);\n        foreach ($list as $item){\n            parse_str($item,$ret);\n            foreach ($ret as $key =&gt; $value){\n                $this-&gt;$key = trim($value,\" \\t\\n\\r\\0\\x0B\\\"\\'\");\n            }\n        }\n    }\n}\n\n/*\n * Define the timeout rendering method\n */\n\nclass timeout extends AbstractAnnotationTag\n{\n    public $timeout;\n\n    public function tagName(): string\n    {\n        return 'timeout';\n    }\n\n    public function assetValue(?string $raw)\n    {\n        $this-&gt;timeout = floatval($raw);\n    }\n\n    public function aliasMap(): array\n    {\n        return [\n            static::class,\n            \"timeout_alias\"\n        ];\n    }\n}\n\nclass A\n{\n    protected $a;\n\n    /**\n     * @param(name=a,type=string,value=2)\n     * @param(name=b)\n     * @timeout_Alias(0.5)\n     * @fuck(easyswoole)\n     * 这是我的其他说明啊啊啊啊啊\n     */\n    function test()\n    {\n\n    }\n}\n\n/**\n * Instantiate the renderer and register the rendering method to parse\n */\n$annotation = new Annotation();\n$ref = new \\ReflectionClass(A::class);\n//Do not register fuck parsing\n$annotation-&gt;addParserTag(new param());\n$annotation-&gt;addParserTag(new timeout());\n\n$list = $annotation-&gt;getClassMethodAnnotation($ref-&gt;getMethod('test'));\n\nforeach ($list['param'] as $item){\n    var_dump((array)$item);\n}\n\nforeach ($list['timeout'] as $item){\n    var_dump((array)$item);\n}\nIf @ exists in the first three characters of each comment line, it means that this behavior needs to parse the comment line. By default, it is in non-strict mode. Unregistered tag information will not be parsed.\nDefault annotation parsing tool\nEasyswoole comes with a string parsing tool calledEasyswoole \\Annotation\\ValueParser, which supports unit testing in the following format\nThe code is shown in：\nnamespace EasySwoole\\Annotation\\Tests;\n\nuse EasySwoole\\Annotation\\ValueParser;\nuse PHPUnit\\Framework\\TestCase;\n\nclass ValueParserTest extends TestCase\n{\n    function testNormal()\n    {\n        $str = \"int=1\";\n        $this-&gt;assertEquals([\n            'int'=&gt;\"1\"\n        ],ValueParser::parser($str));\n\n        $str = \"int=1,int2=2\";\n        $this-&gt;assertEquals([\n            'int'=&gt;\"1\",\n            'int2'=&gt;\"2\"\n        ],ValueParser::parser($str));\n\n        $str = \"int=1,int2='2'\";\n        $this-&gt;assertEquals([\n            'int'=&gt;\"1\",\n            'int2'=&gt;\"2\"\n        ],ValueParser::parser($str));\n    }\n\n    function testArray()\n    {\n        $str = \"array={1,2,3}\";\n        $this-&gt;assertEquals([\n            'array'=&gt;['1','2','3']\n        ],ValueParser::parser($str));\n\n        $str = \"array={'1','2','3'}\";\n        $this-&gt;assertEquals([\n            'array'=&gt;['1','2','3']\n        ],ValueParser::parser($str));\n\n        $str = \"array={'1','2 , 3'}\";\n        $this-&gt;assertEquals([\n            'array'=&gt;['1','2 , 3']\n        ],ValueParser::parser($str));\n\n        $str = 'array={\"1\",\"2\",\"3\"}';\n        $this-&gt;assertEquals([\n            'array'=&gt;['1','2','3']\n        ],ValueParser::parser($str));\n\n        $str = \"array={1,2,3} ,array2={4,5,6}\";\n        $this-&gt;assertEquals([\n            'array'=&gt;['1','2','3'],\n            'array2'=&gt;['4','5','6']\n        ],ValueParser::parser($str));\n\n    }\n\n    function testEval()\n    {\n        $str = 'time=\"eval(time() + 30)\"';\n        $this-&gt;assertEquals([\n            'time'=&gt;time() + 30,\n        ],ValueParser::parser($str));\n\n        $str = 'time=\"eval(time() + 30)\" , time2=\"eval(time() + 31)';\n        $this-&gt;assertEquals([\n            'time'=&gt;time() + 30,\n            'time2'=&gt;time() + 31\n        ],ValueParser::parser($str));\n\n        $str = 'list=\"eval([1,2,3,4])\"';\n        $this-&gt;assertEquals([\n            'list'=&gt;[1,2,3,4]\n        ],ValueParser::parser($str));\n    }\n\n    function testArrayAndEval()\n    {\n        $str = 'array=\"{\"1\",\"2\",eval(time() + 30)}\"';\n        $this-&gt;assertEquals([\n            'array'=&gt;['1','2',time() + 30]\n        ],ValueParser::parser($str));\n\n        $str = 'array={\"1\",\"2\",eval(time() + 30)},str=\"222\"';\n        $this-&gt;assertEquals([\n            'array'=&gt;['1','2',time() + 30],\n            \"str\"=&gt;'222'\n        ],ValueParser::parser($str));\n\n        $str = \"array={1,2,3},time=eval(time())\";\n        $this-&gt;assertEquals([\n            'array'=&gt;['1','2','3'],\n            'time'=&gt;time()\n        ],ValueParser::parser($str));\n    }\n\n    function testStrMulti()\n    {\n        $str = 'mix=\"first|{1,2,3}|eval(time() + 3)\"';\n        $this-&gt;assertEquals([\n            'mix'=&gt;['first',['1','2','3'],time() + 3]\n        ],ValueParser::parser($str));\n    }\n}\nIDE support\nPHPStorm needs to install the &quot;PHP Annotation&quot; plug-in to provide Annotation autoprompt capability. The plug-in can be searched and installed directly in PHPStorm or downloaded and installed on Github\nhttps://github.com/Haehnchen/idea-php-annotation-plugin\nThen write one of the following Annotation prompt classes yourself, the focus is to use the @annotation class Annotation, mark this is an Annotation prompt class, PHPStorm index to this file, you can annotate the class name and class members\n\n&lt;?php\n\nnamespace EasySwoole\\Validate;\n\n/**\n * Annotated document\n * @Annotation\n * You need to use the Annotation tag up here which is an Annotation prompt class\n */\nfinal class ValidateRule\n{\n    /**\n     * These fields are prompted in parentheses\n     * @var string\n     */\n    protected $name;\n\n    /**\n     * These fields are prompted in parentheses\n     * @var string\n     */\n    protected $column;\n\n    /**\n     * These fields are prompted in parentheses\n     * @var string\n     */\n    protected $alias;\n}\n\nYou can implement the following aaa method automatic annotation prompt\n&lt;?php\n\nuse EasySwoole\\Validate as Validate;\n\nclass a\n{\n    /**\n     * @Validate\\ValidateRule(column=\"name\",alias=\"The name of the account\")\n     */\n    function aaa(){\n\n    }\n}","link":"/Components/annotation.html"},{"id":23,"title":"other architecture systems","content":"Others to be added","link":"/Core/other.html"},{"id":24,"title":"swoole example","content":"ServerManager\nServerManagerClass: EasySwoole\\EasySwoole\\ServerManager\nServerManager It is a singleton class (use EasySwoole\\Component\\Singleton)\nCreate main service\nIn the mainServerCreate event of EasySwooleEvent the subservice can be listened on by createSwooleServer.\nThis method is automatically invoked at the bottom of the framework, which will create a swoole main service (not opened), which can be obtained through the getSwooleServer method, and set event callback, calling the original swoole service method to create sub-services, and so on\nCreate subservices\nIn the mainServerCreate event of EasySwooleEvent, a subservice can be listened on through addServer.\n&lt;?php\npublic static function mainServerCreate(EventRegister $register)\n{\n    ################# tcp Server 1 did not handle sticky packets #####################\n    $tcp1ventRegister = $subPort1 = ServerManager::getInstance()-&gt;addServer('tcp1', 9502, SWOOLE_TCP, '0.0.0.0', [\n        'open_length_check' =&gt; false,//Unauthenticated packet\n    ]);\n    $tcp1ventRegister-&gt;set(EventRegister::onConnect,function (\\swoole_server $server, int $fd, int $reactor_id) {\n        echo \"tcpServer 1  fd:{$fd} The connected\\n\";\n        $str = 'Congratulations on connecting to server 1';\n        $server-&gt;send($fd, $str);\n    });\n    $tcp1ventRegister-&gt;set(EventRegister::onClose,function (\\swoole_server $server, int $fd, int $reactor_id) {\n        echo \"tcpServer 1  fd:{$fd} closed\\n\";\n    });\n    $tcp1ventRegister-&gt;set(EventRegister::onReceive,function (\\swoole_server $server, int $fd, int $reactor_id, string $data) {\n        echo \"tcpServer 1  fd:{$fd} Send a message:{$data}\\n\";\n    });\n}\nThe addServer method returns the EventRegister method registration class, which is used to register/set up event callbacks for the service.\ngetSwooleServer\nThe swoole service you are currently creating and the child service you are listening to can be retrieved through getSwooleServer.\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Apple\n * Date: 2018/11/1 0001\n * Time: 11:10\n */\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\EasySwoole\\ServerManager;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    function index()\n    {\n        // TODO: Implement index() method.\n    }\n\n    function push(){\n        $fd = intval($this-&gt;request()-&gt;getRequestParam('fd'));\n        $info = ServerManager::getInstance()-&gt;getSwooleServer()-&gt;connection_info($fd);\n        if(is_array($info)){\n            ServerManager::getInstance()-&gt;getSwooleServer()-&gt;send($fd,'push in http at '.time());\n        }else{\n            $this-&gt;response()-&gt;write(\"fd {$fd} not exist\");\n        }\n    }\n}\nSimilarly, it is possible to add a custom process after the mainServerCreate event of EasySwooleEvent is fetched through this to the primary service.\n\\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new Test('test_process'));\nYou get Swoole services,All methods of the Swoole service are available.\ngetMainEventRegister\ngetMainEventRegisterMethod gets the event registration class for the master service, which registers event callbacks for the master service\nThe method framework is automatically invoked at the bottom,In the mainServerCreate event, themainServerCreate method passed in to EasySwooleEvent is used as an argument, such as registering the onWorkerStart event for the primary service.\n&lt;?php\npublic static function mainServerCreate(EventRegister $register)\n{\n    $register-&gt;add($register::onWorkerStart,function (\\swoole_server $server,int $workerId){\n        var_dump($workerId.'start');\n    });\n}\nstart And isStart\nThe start method will handle the configured swoole main service, sub-service, and callback events, and will open the service. The method is called from within the framework, and the successful invocation indicates that the service has been started successfully..\nThe 'isStart' method returns a bool variable that indicates whether the service started successfully.\ngetSubServerRegister\n'getSubServerRegister' gets all the event callbacks created by the subservice.","link":"/BaseUsage/serverManager.html"},{"id":25,"title":"base command","content":"Basic Command\nEasyswoole comes with a series of commands, as follows:\n\ninstall       install easySwoole\nstart         start easySwoole\nstop          stop easySwoole(Using in a daemon)\nreload        hotreload easySwoole(Using in a daemon)\nrestart       restart easySwoole(Using in a daemon)\nhelp          help information\nphpunit       Start the process unit test\nconfig        easyswoole configuration management\nprocess       easyswoole custom process/task process management\nstatus        easyswole service running status\ntask          easyswoole task process status\ncrontab       easyswoole crontab management\n\ninstall\neasyswoole install command,The command is automatically createdApp/HttpController/Index.php,And automaticallycomposer dump-autoload(If exec function is disabled, execution will fail, and manual execution is required)\nstart\nstart easyswoole service\nphp easyswoole start d  Daemons start\nphp easyswoole start d produce  Production environment, the daemons start, and the production environment will introduce the product.php configuration file,\nstop\nstop easyswoole service\nThe command will get /Temp/pid.pid PID,For closingeasyswoleprocess,Service cannot be stopped by this command when the file is expired / deleted / expired.\nphp easyswoole stop Stop the `easyswoole` service (running tasks will wait for the end of running before stopping)\nphp easyswoole stop force  Force stop of `easyswoole` service (kill process directly)\nphp easyswoole stop produce Stop production environment `easyswoole` service\nreload\nHot restart easyswoole service\nNote that reload is required in the daemons mode, otherwise control + C or the terminal will exit the process when it is disconnected. This is a hot restart, which can be used to update the files (business logic) loaded after the worker starts. The main process (such as configuration files) will not be restarted. HTTP custom routing configuration will not be updated, restart is required;\nrestart\nForce restart of the 'easyswoole' service\nThe command php easyswoole stop force+ php easyswoole start dcombination\nhelp\nHelp command.\nphp easyswoole help stop  View stop command help\nphpunit\nStart the unit test of 'easyswoole', which will bring the collaboration environment:\nphp easyswoole phpunit ./Tests\nconfig\nDynamic management config command.\nphp easyswoole config show [key]  View configuration item information, key support. Separator\nphp easyswoole config set key value Set a configuration dynamically. Key supports. Separator\nprocess\nView / manage custom processes (including task processes)\nphp easyswoole process kill PID [-p] [-d]  -pThe delegate kills the process and restarts it through the process ID\nphp easyswoole process kill PID [-f] [-p] [-d] -f On behalf of force kill process and restart\nphp easyswoole process kill GroupName [-f] [-d]  Without -p, it means to kill a process group and restart it\nphp easyswoole process killAll [-d] Kill all processes and restart\nphp easyswoole process killAll -f [-d] Force kill all processes and restart\nphp easyswoole process show Show current process list\nphp easyswoole process show -d -d stands for personalized display of memory information\nstatus\nView service running status\n[root@localhost easyswoole-git]# php easyswoole status\nstart_time                    2020-04-04 11:08:39\nconnection_num                0\naccept_count                  0\nclose_count                   0\nworker_num                    8\nidle_worker_num               8\ntasking_num                   0\nrequest_count                 0\nworker_request_count          0\nworker_dispatch_count         0\ncoroutine_num                 2\ntask\nView task process status\n[root@localhost easyswoole-git]# php easyswoole task status\n#┌─────────┬─────────┬──────┬───────┬─────────────┐\n#│ running │ success │ fail │  pid  │ workerIndex │\n#├─────────┼─────────┼──────┼───────┼─────────────┤\n#│ 0       │ 4       │ 0    │ 28241 │ 0           │\n#│ 0       │ 3       │ 0    │ 28242 │ 1           │\n#│ 0       │ 3       │ 0    │ 28243 │ 2           │\n#│ 0       │ 2       │ 0    │ 28244 │ 3           │\n#└─────────┴─────────┴──────┴───────┴─────────────┘\n\ncrontab\nphp easyswoole crontab show  View the current scheduled task list\nphp easyswoole crontab stop taskName Pause a scheduled task\nphp easyswoole crontab resume taskName  Continue running a scheduled task\nphp easyswoole crontab run taskName  Perform a scheduled task immediately\n","link":"/BaseUsage/baseCommand.html"},{"id":26,"title":"custom command","content":"Custom command\nEasySwoole has five default commands:  \nphp easyswoole help  Command assistance\nphp easyswoole install (Need to be in./vendor/easyswoole/easyswoole/bin/easyswoole file calls)\nphp easyswoole start  \nphp easyswoole stop   (need daemons)\nphp easyswoole reload  warm restart(need daemons)\nDefault command details can be viewedservice management\nDefine the command\nThrough the implementation of EasySwoole EasySwoole\\Command\\CommandInterfaceinterface, you can customize the Command:\n&lt;?php\npublic function commandName():string;\npublic function exec(array $args):?string ;\npublic function help(array $args):?string ;\nCreate new file App/Command/Test.php:\n&lt;?php\nnamespace App\\Command;\n\nuse EasySwoole\\EasySwoole\\Command\\CommandInterface;\nuse EasySwoole\\EasySwoole\\Command\\Utility;\n\nclass Test implements CommandInterface\n{\n    public function commandName(): string\n    {\n        return 'test';\n    }\n\n    public function exec(array $args): ?string\n    {\n        //Print parameters and test values\n        var_dump($args);\n        echo 'test'.PHP_EOL;\n        return null;\n    }\n\n    public function help(array $args): ?string\n    {\n        //return logo\n        $logo = Utility::easySwooleLog();\n        return $logo.\"this is test\";\n    }\n}\nInjection the command\ncheck boostrap event\nAdded/bootstrap.php File:\n&lt;?php\n\n\\EasySwoole\\EasySwoole\\Command\\CommandContainer::getInstance()-&gt;set(new \\App\\Command\\Test());\nBootstrap is a new 3.2.5 event that allows users to execute custom events before the framework is initialized.\nExecute the command\n\nphp easyswoole test\narray(0) {\n}\ntest\n\nphp easyswoole test 123 456\narray(2) {\n  [0]=&gt;\n  string(3) \"123\"\n  [1]=&gt;\n  string(3) \"456\"\n}\ntest\n[root@localhost easyswoole-test]# php easyswoole help test\n  ______                          _____                              _\n |  ____|                        / ____|                            | |\n | |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___\n |  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n | |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n |______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                          __/ |\n                         |___/\nthis is test\n","link":"/BaseUsage/customCommand.html"},{"id":27,"title":"easyswoole bridge","content":"Bridge\nAfter version 3.3.5, easysoole added a new 'bridge' module. The 'bridge' module starts after the 'mainservercreate' event, and a user-defined process will be created. Listening to 'socket' is used to process external data interaction\nonStart\nWhen the bridge process starts, OnStart event registration is provided:\npublic static function mainServerCreate(EventRegister $register)\n{\n    Bridge::getInstance()-&gt;setOnStart(function () {\n        echo \"process id:\" . getmypid();\n    });\n    // TODO: Implement mainServerCreate() method.\n}\nThis event can only be registered in the 'mainservercreate' event\nBridge data interaction\nAfter your 'easyswoole' service has been started, when you need to obtain the internal running data of 'easyswoole', such as' custom process / task information ',' connection pool information ', the created' swoole table 'cannot be obtained directly outside. We can use the bridge to conduct' unixsock 'data interaction, send the corresponding commands and implement the interaction interface, You can obtain the 'easyswole' internal running data externally\nFor example, easyswoole config is configured as swoole table by default. We can dynamically obtain the configuration of easyswoole service and dynamic configuration through external commands:\nImplement config interaction class\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2020/4/11 0011\n * Time: 10:35\n */\n\nnamespace App\\Bridge;\n\nuse EasySwoole\\EasySwoole\\Bridge\\BridgeCommand;\nuse EasySwoole\\EasySwoole\\Bridge\\Package;\nuse EasySwoole\\EasySwoole\\Config as GlobalConfig;\nuse EasySwoole\\EasySwoole\\Core;\n\nclass Config\n{\n    /**\n     * Register the command callback. Note that it cannot be consistent with the default command of bridgecommand. Otherwise, the original callback of the system will be overwritten\n     * initCommand\n     * @param BridgeCommand $command\n     * @author Tioncico\n     * Time: 10:36\n     */\n    static function initCommand(BridgeCommand $command)\n    {\n        $command-&gt;set(401, [Config::class, 'info']);\n        $command-&gt;set(402, [Config::class, 'set']);\n    }\n\n    /**\n     * Get config configuration information\n     * info\n     * @param Package $package\n     * @param Package $response\n     * @return bool\n     * @author Tioncico\n     * Time: 10:39\n     */\n    static function info(Package $package,Package $response)\n    {\n        $data = $package-&gt;getArgs();\n        if (empty($data['key'])){\n            $configArray =GlobalConfig::getInstance()-&gt;toArray();\n            $configArray['mode'] = Core::getInstance()-&gt;isDev() ? 'develop' : 'produce';\n        }else{\n            $configArray = GlobalConfig::getInstance()-&gt;getConf($data['key']);\n            $configArray = [$data['key']=&gt;$configArray];\n        }\n        $response-&gt;setArgs($configArray);\n        return true;\n    }\n\n    /**\n     * Set config configuration information\n     * set\n     * @param Package $package\n     * @param Package $response\n     * @return bool\n     * @author Tioncico\n     * Time: 10:39\n     */\n    static function set(Package $package,Package $response){\n        $data = $package-&gt;getArgs();\n        if (empty($data['key'])){\n            $response-&gt;setArgs( \"config key can not be null\");\n            return false;\n        }\n        $key = $data['key'];\n        $value = $data['value']??null;\n        GlobalConfig::getInstance()-&gt;setConf($key,$value);\n        $response-&gt;setArgs([$key=&gt;$value]);\n        return true;\n    }\n}\nRegister interaction class to bridge:\npublic static function mainServerCreate(EventRegister $register)\n{\n    \\App\\Bridge\\Config::initCommand(Bridge::getInstance()-&gt;onCommand());\n    // TODO: Implement mainServerCreate() method.\n}\nYou can only register in the mainservercreate event \nExternal script interaction\nAfter starting easyswoole, run the following code to dynamically add the configuration item 'a = &gt; 2' in the easyswoole service, and obtain the current configuration through the '401' command\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2020/4/11 0011\n * Time: 10:53\n */\n\ninclude \"./vendor/autoload.php\";\n//Initialize easyswoole framework service\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n\n//::: warning \n//After version 3.3.7, the initialize event call changes to:`EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()-&gt;globalInitialize();`\n//:::\n\n//Start a scheduler\n$run = new \\Swoole\\Coroutine\\Scheduler();\n$run-&gt;add(function (){\n    $package = new \\EasySwoole\\EasySwoole\\Bridge\\Package();\n    $package-&gt;setCommand(402);\n    $package-&gt;setArgs(['key' =&gt; 'a','value'=&gt;2]);\n    $package = \\EasySwoole\\EasySwoole\\Bridge\\Bridge::getInstance()-&gt;send($package);\n    var_dump($package);\n    $package = new \\EasySwoole\\EasySwoole\\Bridge\\Package();\n    $package-&gt;setCommand(401);\n    $package-&gt;setArgs(['key' =&gt; 'a']);\n    $package = \\EasySwoole\\EasySwoole\\Bridge\\Bridge::getInstance()-&gt;send($package);\n    var_dump($package);\n});\n//Execution scheduler\n$run-&gt;start();\nThis script can be put into the custom command to realize interaction with easyswoole service through the custom command. The specific code can be viewed in the source code: https://github.com/easy-swoole/easyswoole/blob/3.x/src/Command/DefaultCommand/Config.php","link":"/BaseUsage/bridge.html"},{"id":28,"title":"custom process","content":"Process\nUseage\nProcessing time-consuming tasks, such as looping through queue messages, clearing token data from redundant redis, and so on.\nExample\nDefine a process class\nuse EasySwoole\\Component\\Process\\AbstractProcess;\n\nclass Process extends AbstractProcess\n{\n\n    protected function run($arg)\n    {\n        //The callback that is executed when the process starts\n        var_dump($this-&gt;getProcessName().\" run\");\n        var_dump($arg);\n    }\n\n    protected function onPipeReadable(\\Swoole\\Process $process)\n    {\n        /*\n         * This callback is optional\n         * Be sure to use the callback that is triggered when a primary process sends a message to a child process\n         * $process-&gt;read() Read the message\n         */\n    }\n\n    protected function onShutDown()\n    {\n        /*\n         * This callback is optional\n         * The callback is executed when the process exits\n         */\n    }\n\n    protected function onException(\\Throwable $throwable, ...$args)\n    {\n        /*\n         * This callback is optional\n         * This callback is executed when an exception occurs in the process\n         */\n    }\n}\nRegistration process\nWe register the process in the EasySwoole global mainServerCreate event\nuse App\\Process;\nuse EasySwoole\\Component\\Process\\Config;\n\n$processConfig = new Config();\n$processConfig-&gt;setProcessName('testProcess');\n/*\n * Parameters passed to the process\n*/\n$processConfig-&gt;setArg([\n    'arg1'=&gt;time()\n]);\n\\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new Process($processConfig));\nNote that a process model can be registered N times, that is, N processes of the same type can be created\nCustom process warm restart\nIn the Swoole document, it is explicitly mentioned that custom processes cannot reload like workers. But there's a way to do that, we just need to know the pid of a process, send it the SIGTERM command,\nThe process will push itself out. And Swoole Manager will pull up the feature of the process again, all the way around to allow a warm restart of the process.\nThe sample code\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n\n    function index()\n    {\n        $pid = $this-&gt;request()-&gt;getRequestParam('pid');\n        \\Swoole\\Process::kill($pid,SIGTERM);\n        $this-&gt;writeJson(200,null,'send reboot signal');\n    }\n}\n\nDefine a controller that sends signals, and of course, this logic can be used in other ways\n\nnamespace App\\ProcessReload;\n\nuse EasySwoole\\Component\\Timer;\nuse EasySwoole\\EasySwoole\\Logger;\n\nclass Work\n{\n    static function run()\n    {\n        Timer::getInstance()-&gt;loop(3000,function (){\n            $pid = getmypid();\n            Logger::getInstance()-&gt;info(\"asassdaasd\");\n        });\n    }\n}\n\nDefine a task class and note that the run method is static\n\nnamespace App\\ProcessReload;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\EasySwoole\\Logger;\n\nclass Process extends AbstractProcess\n{\n\n    protected function run($arg)\n    {\n        $pid = getmypid();\n        Logger::getInstance()-&gt;info(\"process for pid {$pid} start\");\n        Work::run();\n    }\n\n    function onShutDown()\n    {\n        $pid = getmypid();\n        Logger::getInstance()-&gt;info(\"process for pid {$pid} shutdown\");\n        parent::onShutDown();\n    }\n}\n\nDefine a process class whose run method statically calls the static method of the task class.\n\nThe principle of interpretation\nThe main problem is that the custom process class needs to call a task class。A lot of people might be confused。In fact, the principle is that.\nWhen I need to register a process, I need to new a custom process class, so the custom process code is required in the main process, so no matter how I change it later.\nThe manager process reclones the process from the previous code. This is a clever use of the new class. Since PHP is an interpreted language, the run method is not executed immediately。\nOnly when I do have a process clone, after process start, will I actually execute run().\nHowever, the contents in my process class run method will actually load the code of worker class when the Work::run () is executed. Therefore, every time I kill this custom process, the process will\nWhen cloned by the main process, the Work class code is reloaded.\nPid management\nIn many ways, you can do it yourself in swoole table, redis, files, etc.","link":"/Components/Component/process.html"},{"id":29,"title":"custom events","content":"Custom Events\nIn easyswoole, custom events can be implemented through the Container\nAdd 'App/Event/Event.php' file\n&lt;?php\nnamespace App\\Event;\n\nuse EasySwoole\\Component\\Container;\nuse EasySwoole\\Component\\Singleton;\n\nclass Event extends Container\n{\n    use Singleton;\n    function set($key, $item)\n    {\n        if (is_callable($item)){\n            return parent::set($key, $item);\n        }else{\n            return false;\n        }\n    }\n\n    function hook($event,...$arg){\n        $call = $this-&gt;get($event);\n        if (is_callable($call)){\n            return call_user_func($call,...$arg);\n        }else{\n            return null;\n        }\n    }\n}\nRegister events in the initialize event of the framework:\n public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n        \\App\\Event\\Event::getInstance()-&gt;set('test', function () {\n            echo 'test event';\n        });\n    }\nCall anywhere else:\nEvent::getInstance()-&gt;hook('test');\nCan trigger events","link":"/BaseUsage/event.html"},{"id":30,"title":"task asynctask","content":"Installation\ncomposer require easyswoole/task\nStandalone use example\nuse EasySwoole\\Task\\Config;\nuse EasySwoole\\Task\\Task;\n\n/*\n    The number of worker processes, temporary directory, process name, maximum number of concurrent tasks, exception callbacks and so on can be modified in the configuration item\n*/\n$config = new Config();\n$task = new Task($config);\n\n$http = new swoole_http_server(\"127.0.0.1\", 9501);\n/*\nAdd the service\n*/\n$task-&gt;attachToServer($http);\n\n$http-&gt;on(\"request\", function ($request, $response)use($task){\n    if(isset($request-&gt;get['sync'])){\n        $ret = $task-&gt;sync(function ($taskId,$workerIndex){\n            return \"{$taskId}.{$workerIndex}\";\n        });\n        $response-&gt;end(\"sync result \".$ret);\n    }else if(isset($request-&gt;get['status'])) {\n        var_dump($task-&gt;status());\n    }else{\n        $id = $task-&gt;async(function ($taskId,$workerIndex){\n            \\co::sleep(1);\n            var_dump(\"async id {$taskId} task run\");\n        });\n        $response-&gt;end(\"async id {$id} \");\n    }\n});\n\n$http-&gt;start();\nUsed in the framework\nThe 3.3.0 version of EasySwoole asynchronous tasks is implemented as a separate component to implement and resolve asynchronous tasks：\n\nUndeliverable closure task\nUnable to continue delivering tasks in other custom processes such as TaskWorker\nRealize task flow limitation and state monitoring  \n\nFor the old version, please do the following :\n\nConfiguration item deletion ：  MAIN_SERVER.SETTING.task_worker_num 与 MAIN_SERVER.SETTING.task_enable_coroutine\nConfiguration item added： MAIN_SERVER.TASK ,The default value is ['workerNum'=&gt;4,'maxRunningNum'=&gt;128,'timeout'=&gt;15]\n\nNote that EasySwoole's Temp directory cannot be in a Shared directory between the virtual machine and the host, which will result in a UnixSocket link being created without permission\n\nTask manager\nEasySwoole defines a task manager with a full namespace of：\nEasySwoole\\EasySwoole\\Task\\TaskManager\nIt is a singleton that inherits an 'EasySwoole\\Task\\Task' object and is instantiated in the main service creation event of 'core.php'. Can be invoked anywhere after the service is started.\nPost closure tasks\nTaskManager::getInstance()-&gt;async(function (){\n    var_dump('r');\n});\nSince PHP itself cannot serialize closures, the closure post is done by reflecting the closure function, getting PHP code to serialize PHP code directly, and then eval code directly, so the post closure cannot use external object references and resource handles. For complex tasks, use task template methods.  \nDelivery callable\nTaskManager::getInstance()-&gt;async(callable);\nDelivery template task\nuse EasySwoole\\Task\\AbstractInterface\\TaskInterface;\n\nclass Task implements TaskInterface\n{\n    function run(int $taskId, int $workerIndex)\n    {\n        var_dump('c');\n        TaskManager::getInstance()-&gt;async(function (){\n           var_dump('r');\n        });\n    }\n\n    function onException(\\Throwable $throwable, int $taskId, int $workerIndex)\n    {\n        echo $throwable-&gt;getMessage();\n    }\n}\n\nTaskManager::getInstance()-&gt;async(Task::class);\n//or\nTaskManager::getInstance()-&gt;async(new Task());\nAsynchronous tasks - below version 3.3.0\nRefer to the Demo: Asynchronous task handling demo\nAsynchronous task manager class：EasySwoole\\EasySwoole\\Swoole\\Task\\TaskManager\nAsynchronous task delivery can occur anywhere after the service is started. To simplify asynchronous task delivery, the framework encapsulates the task manager for synchronous/asynchronous task delivery，There are two ways to post a Task: directly post a closure and directly post a job template class\nDrop the closure directly\nWhen the task is relatively simple, the closure can be directly posted anywhere including in various callbacks after the controller/timer/service starts\n// Post in the controller example\nfunction index()\n{\n    \\EasySwoole\\EasySwoole\\Swoole\\Task\\TaskManager::async(function () {\n        echo \"Perform asynchronous tasks...\\n\";\n        return true;\n    }, function () {\n        echo \"Asynchronous task finished...\\n\";\n    });\n}\n\n// An example of delivery in a timer\n\\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(1000, function () {\n    \\EasySwoole\\EasySwoole\\Swoole\\Task\\TaskManager::async(function () {\n        echo \"Perform asynchronous tasks...\\n\";\n    });\n});\nSince PHP itself cannot serialize closures, the closure post is done by reflecting the closure function, getting PHP code to serialize PHP code directly, and then eval code directly, so the post closure cannot use external object references and resource handles. For complex tasks, use task template methods.\nThe following usage is incorrect:\n$image = fopen('test.php', 'a');//Serializing data using an external resource handle will not exist\n$a=1;//Using external variables will not exist\nTaskManager::async(function ($image,$a) {\n    var_dump($image);\n    var_dump($a);\n    $this-&gt;testFunction();//Using a reference to an external object will cause an error\n    return true;\n},function () {});\nPost the task template class\nWhen the task is complex, logical and fixed, you can create a task template in advance and post the task template directly to simplify the operation and facilitate the delivery of the same task in multiple different places. First, you need to create a task template\nAsynchronous task template class：EasySwoole\\EasySwoole\\Swoole\\Task\\AbstractAsyncTask\nclass Task extends \\EasySwoole\\EasySwoole\\Swoole\\Task\\AbstractAsyncTask\n{\n\n    /**\n     * Execute the content of the task\n     * @param mixed $taskData     taskData\n     * @param int   $taskId       The task number of the execution task\n     * @param int   $fromWorkerId Assign the worker process number of the task\n     * @author : evalor &lt;master@evalor.cn&gt;\n     */\n    function run($taskData, $taskId, $fromWorkerId,$flags = null)\n    {\n        // Note that the task number is not absolutely unique\n        // Each worker process is numbered from 0\n        // So $fromWorkerId + $taskId is the absolutely unique number\n        // !!! The return result is needed to complete the task\n    }\n\n    /**\n     * A callback to the completion of a task\n     * @param mixed $result  The result returned when the task is completed\n     * @param int   $task_id The task number of the execution task\n     * @author : evalor &lt;master@evalor.cn&gt;\n     */\n    function finish($result, $task_id)\n    {\n        // The processing of the end of task execution\n    }\n}\nThen, as in the previous example, you can post anywhere after the service is started, just replace the closure with an instance of the task template class\n// Post in the controller example\nfunction index()\n{\n    // Instantiate the task template class and bring in the data to get the data in the task class $taskData parameter\n    $taskClass = new Task('taskData');\n    \\EasySwoole\\EasySwoole\\Swoole\\Task\\TaskManager::async($taskClass);\n}\n\n// An example of delivery in a timer\n\\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(1000, function () {\n    \\EasySwoole\\EasySwoole\\Swoole\\Task\\TaskManager::async($taskClass);\n});\nUse a quick task template\nBy inheriting 'EasySwoole, EasySwoole, Swoole, Task, QuickTaskInterface', add the run method, you can achieve a Task template, through the direct post class name to run the Task:\n&lt;?php\nnamespace App\\Task;\nuse EasySwoole\\EasySwoole\\Swoole\\Task\\QuickTaskInterface;\n\nclass QuickTaskTest implements QuickTaskInterface\n{\n    static function run(\\swoole_server $server, int $taskId, int $fromWorkerId,$flags = null)\n    {\n        echo \"Quick task template\";\n\n        // TODO: Implement run() method.\n    }\n}\nController call:\n$result = TaskManager::async(\\App\\Task\\QuickTaskTest::class);\nDeliver asynchronous tasks in a custom process\nDue to the particularity of custom process, it is not possible to directly call Swoole's asynchronous task-related method for asynchronous task delivery. The framework has encapsulated the relevant method to facilitate asynchronous task delivery, please see the following example\nCustom process post asynchronous task without finish callback  \n    public function run(Process $process)\n    {\n        // Delivery the closure directly\n        TaskManager::processAsync(function () {\n            echo \"process async task run on closure!\\n\";\n        });\n\n        // Delivery task class\n        $taskClass = new TaskClass('task data');\n        TaskManager::processAsync($taskClass);\n    }\nConcurrent execution of tasks\nSometimes it is necessary to execute multiple asynchronous tasks at the same time. The most typical example is data collection. After collecting and processing multiple data, concurrent task delivery can be carried out，A result set is returned after all tasks are executed\n// multitasking\n$tasks[] = function () { sleep(50000);return 'this is 1'; }; // task1\n$tasks[] = function () { sleep(2);return 'this is 2'; };     // task2\n$tasks[] = function () { sleep(50000);return 'this is 3'; }; // task3\n\n$results = \\EasySwoole\\EasySwoole\\Swoole\\Task\\TaskManager::barrier($tasks, 3);\n\nvar_dump($results);\nNote: the Barrier is a block waiting for execution, and all tasks will be distributed to different Task processes (there should be enough Task processes, or they will also be blocked) to execute synchronously, and all results will not be returned until all tasks finish execution or timeout. The default Task timeout is 0.5 seconds，Only task 2 in the example above can execute properly and return results。\nClass function reference\n/**\n * Deliver an asynchronous task\n * @param mixed $task           Asynchronous tasks that need to be delivered\n * @param mixed $finishCallback The callback function after the task executes\n * @param int   $taskWorkerId   Specify the Task process number to post (randomly post to idle process by default)\n * @return bool Successful delivery returns the integer $task_id, Return false on delivery failure\n */\nstatic function async($task,$finishCallback = null,$taskWorkerId = -1)\n/**\n * Deliver an asynchronous task\n * @param mixed $task         Asynchronous tasks that need to be delivered\n * @param float $timeout      Task timeout\n * @param int   $taskWorkerId Specify the Task process number to post (randomly post to idle process by default)\n * @return bool|string Successful delivery returns the integer $task_id, Return false on delivery failure\n */\nstatic function sync($task, $timeout = 0.5, $taskWorkerId = -1)\n/**\n * Deliver tasks in asynchronous processes\n * @param array $taskList List of tasks to perform\n * @param float $timeout  Task timeout\n * @return array|bool The execution result of each task\n */\nstatic function barrier(array $taskList, $timeout = 0.5)","link":"/Components/task.html"},{"id":31,"title":"timer timer","content":"timer\nThe framework encapsulates the native millisecond timer so that developers can quickly call the native timer of swoole. The namespace of timer class is EasySwoole\\Component\\Timer\nNote: the time parameter unit passed in by the timer is milliseconds and executed in seconds. Do not forget to multiply by 1000. If the reload ﹣ async configuration is enabled, please move the timer to the custom process, otherwise the worker process will not reload\nLoop execution\nSet an interval clock timer, which will be triggered at regular intervals until the 'clear' operation is performed. The corresponding native timer function of swoole is swoole_timer_tick\nFunction prototype\n/**\n* Cyclic invocation\n* @param int      $microSeconds The number of milliseconds between loop execution passed into integer type\n* @param \\Closure $func The timer needs to perform an operation passed in a closure the timer needs to perform an operation passed in a closure\n* @param string    $name Timer name, used to cancel the timer\n* @return int Return the timer number of integer type to stop the timer\n*/\npublic function loop($microSeconds, \\Closure $func, $args = null)\nSample code\n// Every 10 seconds\n\\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(10 * 1000, function () {\n    echo \"this timer runs at intervals of 10 seconds\\n\";\n});\nDelayed execution\nSet a delay timer to trigger the corresponding operation after delaying the specified time. Only one operation will be performed. The corresponding native timer function of swoole is swoole_timer_after\nFunction prototype\n/**\n* Delayed call\n* @param int      $microSeconds Time to delay execution\n* @param \\Closure $func The timer needs to perform an operation to pass a closure\n* @return int Returns the timer number of the integer type\n*/\npublic function after($microSeconds, \\Closure $func)\nSample code\n// Once in 10 seconds\n\\EasySwoole\\Component\\Timer::getInstance()-&gt;after(10 * 1000, function () {\n    echo \"ten seconds later\\n\";\n});\nClear timer\nNote: this operation cannot be used to clear the timers of other processes, only for the current process\nWhen the timer is created successfully, an integer number will be returned. Call this function to pass in the number, and the timer can be stopped in advance. The corresponding native timer function of swoole is swoole_timer_clear\nFunction prototype\n/**\n* Clear timer\n* @param int $timerId|$timeName Timer number or name\n* @author : evalor &lt;master@evalor.cn&gt;\n*/\npublic function clear($timerId)\nSample code\n// Create a 2 second timer\n$timerId = \\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(2 * 1000, function () {\n    echo \"timeout\\n\";\n},'time');\n\n// Clear the timer\n//var_dump(\\EasySwoole\\Component\\Timer::getInstance()-&gt;clear($timerId)); // bool(true)\nvar_dump($timerId); // int(1)\n\n// Timer not available, no output：timeout\nApplication example\nNote: the timer cannot be used before the service starts. After the service is started, the added timer is only valid in the current process. When adding a timer in the workerstart event, please pay attention to judge whether the workerid of the timer needs to be added will be executed in each process\n// Add timer for first worker\nif ($workerId == 0) {\n    \\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(10 * 1000, function () {\n        echo \"timer in the worker number 0\\n\";\n    });\n}\npublic static function mainServerCreate(EventRegister $register)\n{\n    $register-&gt;add(EventRegister::onWorkerStart, function (\\swoole_server $server, $workerId) {\n        //How to avoid timer loss due to process restart\n        //For example, add a 10 second timer to the first process\n        if ($workerId == 0) {\n            \\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(10 * 1000, function () {\n                // From the database or redis, get the next task to be executed in the nearest 10 seconds\n                // For example: a task after 2 seconds and a task code after 3 seconds are as follows\n                \\EasySwoole\\Component\\Timer::getInstance()-&gt;after(2 * 1000, function () {\n                    //In order to prevent the timer from being inaccurate due to task blocking, the task is sent to the asynchronous process for processing\n                    Logger::getInstance()-&gt;console(\"time 2\", false);\n                });\n                \\EasySwoole\\Component\\Timer::getInstance()-&gt;after(3 * 1000, function () {\n                    //In order to prevent the timer from being inaccurate due to task blocking, the task is sent to the asynchronous process for processing\n                    Logger::getInstance()-&gt;console(\"time 3\", false);\n                });\n            });\n        }\n    });\n}\nClassic case - order status timeout monitoring\nScenario Description: in many rush to buy scenarios, after the order is placed, the payment time needs to be limited, or in chess and card games, the room status needs to be monitored. Then we\nYou can first press the order or room to be monitored into the redis queue. Then use timer + asynchronous process to realize the cyclic monitoring of order status.","link":"/Components/Component/timer.html"},{"id":32,"title":"crontab planning tasks","content":"Crontab timer\nEasysoole supports users to add timers according to crontab rules. The minimum granularity of time is 1 minute.\nRealization principle\nIn the main process, each task rule and callback are registered. After the service is started, in the user-defined process, the timer is used to detect whether there is a task to be executed. If there is one, it is delivered to the asynchronous process for asynchronous execution.\nThe resolution rules can be referred to https://github.com/dragonmantank/cron-expression 。\nSample code\nEasySwooleEvent.php中\nuse EasySwoole\\EasySwoole\\Crontab\\Crontab;\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // TODO: Implement mainServerCreate() method.\n\n        // Start a scheduled task plan \n        Crontab::getInstance()-&gt;addTask(TaskOne::class);\n        // Start a scheduled task plan \n        Crontab::getInstance()-&gt;addTask(TaskTwo::class);\n    }\nAfter task definition version 3.3.0\n\nnamespace App;\n\nuse EasySwoole\\EasySwoole\\Crontab\\AbstractCronTask;\nuse EasySwoole\\EasySwoole\\Task\\TaskManager;\n\nclass TaskOne extends AbstractCronTask\n{\n\n    public static function getRule(): string\n    {\n        return '*/1 * * * *';\n    }\n\n    public static function getTaskName(): string\n    {\n        return  'taskOne';\n    }\n\n    function run(int $taskId, int $workerIndex)\n    {\n        var_dump('c');\n        TaskManager::getInstance()-&gt;async(function (){\n           var_dump('r');\n        });\n    }\n\n    function onException(\\Throwable $throwable, int $taskId, int $workerIndex)\n    {\n        echo $throwable-&gt;getMessage();\n    }\n}\n\nnamespace App;\n\nuse EasySwoole\\EasySwoole\\Crontab\\AbstractCronTask;\nuse EasySwoole\\EasySwoole\\Task\\TaskManager;\n\nclass TaskTwo extends AbstractCronTask\n{\n\n    public static function getRule(): string\n    {\n        return '*/2 * * * *';\n    }\n\n    public static function getTaskName(): string\n    {\n        return  'taskTwo';\n    }\n\n    function run(int $taskId, int $workerIndex)\n    {\n        var_dump('c');\n        TaskManager::getInstance()-&gt;async(function (){\n           var_dump('r');\n        });\n    }\n\n    function onException(\\Throwable $throwable, int $taskId, int $workerIndex)\n    {\n        echo $throwable-&gt;getMessage();\n    }\n}\nBefore task definition version 3.3.0\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 18-11-6\n * Time: 下午3:30\n */\n\nnamespace App\\Crontab;\n\nuse EasySwoole\\EasySwoole\\Crontab\\AbstractCronTask;\n\nclass TaskOne extends AbstractCronTask\n{\n\n    public static function getRule(): string\n    {\n        // TODO: Implement getRule() method.\n        // Timing period (per hour)\n        return '@hourly';\n    }\n\n    public static function getTaskName(): string\n    {\n        // TODO: Implement getTaskName() method.\n        // Scheduled task name\n        return 'taskOne';\n    }\n\n    static function run(\\swoole_server $server, int $taskId, int $fromWorkerId,$flags=null)\n    {\n        // TODO: Implement run() method.\n        // Timed task processing logic\n        var_dump('run once per hour');\n    }\n}\n定时任务:TaskTwo.php\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 18-11-6\n * Time: 下午4:28\n */\n\nnamespace App\\Crontab;\n\nuse EasySwoole\\EasySwoole\\Crontab\\AbstractCronTask;\n\nclass TaskTwo extends AbstractCronTask\n{\n\n    public static function getRule(): string\n    {\n        // TODO: Implement getRule() method.\n        // Timing cycle (every two minutes)\n        return '*/2 * * * *';\n    }\n\n    public static function getTaskName(): string\n    {\n        // TODO: Implement getTaskName() method.\n        // Scheduled task name\n        return 'taskTwo';\n    }\n\n    static function run(\\swoole_server $server, int $taskId, int $fromWorkerId,$flags=null)\n    {\n        // TODO: Implement run() method.\n        // Timed task processing logic\n        var_dump('run once every two minutes');\n    }\n}\n\nThe general expression rules of cron are as follows：\n\n    *    *    *    *    *\n    -    -    -    -    -\n    |    |    |    |    |\n    |    |    |    |    |\n    |    |    |    |    +----- day of week (0 - 7) (Sunday=0 or 7)\n    |    |    |    +---------- month (1 - 12)\n    |    |    +--------------- day of month (1 - 31)\n    |    +-------------------- hour (0 - 23)\n    +------------------------- min (0 - 59)\nCron special expressions are as follows：\n@yearly                    Once a year is equivalent to(0 0 1 1 *) \n@annually                  Once a year is equivalent to((0 0 1 1 *)\n@monthly                   Once a month is equivalent to(0 0 1 * *) \n@weekly                    Once a week is equivalent to(0 0 * * 0) \n@daily                     Once a day is equivalent to(0 0 * * *) \n@hourly                    Once an hour is equivalent to(0 * * * *)\nDemo\nTasks running in odd times\n&lt;?php\n\nnamespace App\\Crontab;\n\nuse EasySwoole\\EasySwoole\\Crontab\\AbstractCronTask;\n\nclass OddNumber extends AbstractCronTask\n{\n\n    public static function getRule(): string\n    {\n        // TODO: Implement getRule() method.\n        //Odd cron expression\n        return '1-59/2 * * * *';\n    }\n\n    public static function getTaskName(): string\n    {\n        // TODO: Implement getTaskName() method.\n         //Scheduled task name\n        return  'task name';\n    }\n\n    function run(int $taskId, int $workerIndex)\n    {\n        // TODO: Implement run() method.\n        // Timed task processing logic\n        var_dump('Odd operation '.date('Y-m-d H:i'));\n    }\n\n    function onException(\\Throwable $throwable, int $taskId, int $workerIndex)\n    {\n        // TODO: Implement onException() method.\n        echo $throwable-&gt;getMessage();\n    }\n}\nEven time running tasks\n&lt;?php\n\nnamespace App\\Crontab;\n\nuse EasySwoole\\EasySwoole\\Crontab\\AbstractCronTask;\n\nclass OddNumber extends AbstractCronTask\n{\n\n    public static function getRule(): string\n    {\n        // TODO: Implement getRule() method.\n        //Even cron expression\n        return '0-58/2 * * * *';\n    }\n\n    public static function getTaskName(): string\n    {\n        // TODO: Implement getTaskName() method.\n         //Scheduled task name\n         return  'Even time operation';\n    }\n\n    function run(int $taskId, int $workerIndex)\n    {\n        // TODO: Implement run() method.\n        // Timed task processing logic\n        var_dump('Even operation '.date('Y-m-d H:i'));\n    }\n\n    function onException(\\Throwable $throwable, int $taskId, int $workerIndex)\n    {\n        // TODO: Implement onException() method.\n        echo $throwable-&gt;getMessage();\n    }\n}","link":"/BaseUsage/crontab.html"},{"id":33,"title":"log","content":"Log processing\nLogger\nAfter easyswoole 3.2.3, the default log processing class of easyswoole is separated into component form and component address：https://github.com/easy-swoole/log\nCustom log\nFirst, define a log template, which needs to be inherited and implemented\\EasySwoole\\Log\\LoggerInterface，as follows：\n\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-11-13\n * Time: 上午11:00\n */\n\nnamespace App\\Logger;\n\nuse EasySwoole\\Log\\LoggerInterface;\n\nclass Logger implements LoggerInterface\n{\n\n    function log(?string $msg, int $logLevel = self::LOG_LEVEL_INFO, string $category = 'DEBUG'): string\n    {\n        // TODO: Implement log() method.\n        $date = date('Y-m-d H:i:s');\n        $levelStr = $this-&gt;levelMap($logLevel);\n        $filePath = EASYSWOOLE_LOG_DIR.\"/\".date('Y-m-d').\".log\";\n        $str = \"[{$date}][{$category}][{$levelStr}] : [{$msg}]\\n\";\n        file_put_contents($filePath,\"{$str}\",FILE_APPEND|LOCK_EX);\n        return $str;\n    }\n\n    function console(?string $msg, int $logLevel = self::LOG_LEVEL_INFO, string $category = 'DEBUG')\n    {\n        // TODO: Implement console() method.\n        $date = date('Y-m-d H:i:s');\n        $levelStr = $this-&gt;levelMap($logLevel);\n        $temp =  $this-&gt;colorString(\"[{$date}][{$category}][{$levelStr}] : [{$msg}]\",$logLevel).\"\\n\";\n        fwrite(STDOUT,$temp);\n    }\n\n    private function colorString(string $str,int $logLevel)\n    {\n        switch($logLevel) {\n            case self::LOG_LEVEL_INFO:\n                $out = \"[42m\";\n                break;\n            case self::LOG_LEVEL_NOTICE:\n                $out = \"[43m\";\n                break;\n            case self::LOG_LEVEL_WARNING:\n                $out = \"[45m\";\n                break;\n            case self::LOG_LEVEL_ERROR:\n                $out = \"[41m\";\n                break;\n            default:\n                $out = \"[42m\";\n                break;\n        }\n        return chr(27) . \"$out\" . \"{$str}\" . chr(27) . \"[0m\";\n    }\n\n    private function levelMap(int $level)\n    {\n        switch ($level)\n        {\n            case self::LOG_LEVEL_INFO:\n                return 'INFO';\n            case self::LOG_LEVEL_NOTICE:\n                return 'NOTICE';\n            case self::LOG_LEVEL_WARNING:\n                return 'WARNING';\n            case self::LOG_LEVEL_ERROR:\n                return 'ERROR';\n            default:\n                return 'UNKNOWN';\n        }\n    }\n}\n\nIn theEasySwooleEvent initialize into the user-defined log processing， as follows：\n\npublic static function initialize()\n{\n    // TODO: Implement initialize() method.\n\n    Di::getInstance()-&gt;set(SysConst::LOGGER_HANDLER, new \\App\\Logger\\Logger());\n\n}\n\nLogger call method\nuse use EasySwoole\\EasySwoole\\Logger;\nLogger::getInstance()-&gt;log('log level info',Logger::LOG_LEVEL_INFO,'DEBUG');//Record the info level log the default values of the next two parameters in the example\nLogger::getInstance()-&gt;log('log level notice',Logger::LOG_LEVEL_NOTICE,'DEBUG2');//Record the notice level log the default values of the next two parameters in the example\nLogger::getInstance()-&gt;console('console',Logger::LOG_LEVEL_INFO,'DEBUG');//Log info level and output to console\nLogger::getInstance()-&gt;info('log level info');//Log info level and output to console\nLogger::getInstance()-&gt;notice('log level notice');//Log notice level and output to console\nLogger::getInstance()-&gt;waring('log level waring');//Log warning level and output to console\nLogger::getInstance()-&gt;error('log level error');//Log error level and output to console\nLogger::getInstance()-&gt;onLog()-&gt;set('myHook',function ($msg,$logLevel,$category){\n    //Add callback function after log writing\n});\nNote that for non framework use, such as unit test scripts, execute EasySwoole\\EasySwoole\\Core::getInstance()->initialize(); Used to initialize logs \n>=3.3.7:EasySwoole\\EasySwoole\\Core::getInstance()->initialize()->globalInitialize();\nThe following will be output / recorded:\n[2019-06-01 21:10:25][DEBUG][INFO] : [1]\n[2019-06-01 21:10:25][DEBUG][INFO] : [2]\n[2019-06-01 21:10:25][DEBUG][INFO] : [3]\n[2019-06-01 21:10:25][DEBUG][NOTICE] : [4]\n[2019-06-01 21:10:25][DEBUG][WARNING] : [5]\n[2019-06-01 21:10:25][DEBUG][ERROR] : [6]\n[2019-06-01 21:23:27][DEBUG][INFO] : [log level info]\n[2019-06-01 21:23:27][DEBUG2][NOTICE] : [log level notice]\n[2019-06-01 21:23:27][DEBUG][INFO] : [console]\n[2019-06-01 21:23:27][DEBUG][INFO] : [log level info]\n[2019-06-01 21:23:27][DEBUG][NOTICE] : [log level notice]\n[2019-06-01 21:23:27][DEBUG][WARNING] : [log level waring]\n[2019-06-01 21:23:27][DEBUG][ERROR] : [log level error]\nIn the new logger processing scheme, new LOG_LEVEL_INFO = 1，LOG_LEVEL_NOTICE = 2，LOG_LEVEL_WARNING = 3，LOG_LEVEL_ERROR = 4，4 log levels to help distinguish logs better\nTrigger\n\\EasySwoole\\EasySwoole\\TriggerTrigger, which is used to actively trigger an error or exception without interrupting the program execution.\nAfter easyswoole version 3.2.3, the default trigger class of easyswoole is separated into component form. The component address is:：https://github.com/easy-swoole/trigger\nFor example, in the onexception of the controller, we can record the error exception, and then output other contents to prevent the system terminal from running and the user from discovering the real error\nuse EasySwoole\\EasySwoole\\Trigger;\n//Record the error exception log with the level of exception\nTrigger::getInstance()-&gt;throwable($throwable);\n//Record the error information with the level of fatalerror\nTrigger::getInstance()-&gt;error($throwable-&gt;getMessage().'666');\n\nTrigger::getInstance()-&gt;onError()-&gt;set('myHook',function (){\n    //Add callback function when error occurs\n});\nTrigger::getInstance()-&gt;onException()-&gt;set('myHook',function (){\n\n});\nLog Center\nFor example, if you want to push data to the log center or the most TCP log, you can add an OnLog callback, and then push the log information to the log center.","link":"/BaseUsage/log.html"},{"id":34,"title":"exception","content":"Trigger\n\\EasySwoole\\EasySwoole\\Triggertrigger,Used to proactively trigger errors or exceptions without interrupting program execution. \nFor example, in the onexception of the controller, we can record the error exception, and then output other contents to prevent the system terminal from running and the user from discovering the real error.\nuse EasySwoole\\EasySwoole\\Trigger;\n//Record the error exception log with the level of exception\nTrigger::getInstance()-&gt;throwable($throwable);\n//Record the error information with the level of fatalerror\nTrigger::getInstance()-&gt;error($throwable-&gt;getMessage().'666');\n\nTrigger::getInstance()-&gt;onError()-&gt;set('myHook',function (){\n    //Add callback function when error occurs\n});\nTrigger::getInstance()-&gt;onException()-&gt;set('myHook',function (){\n\n});\nOnline real-time warning\nIn some important online services, we hope that when there is an error, it can be warned and handled in real time. Let's take SMS or email notification as an example.\nEarly warning processing class\n&lt;?php\n\nnamespace App\\Utility;\n\nuse App\\Model\\EventNotifyModel;\nuse App\\Model\\EventNotifyPhoneModel;\nuse App\\Utility\\Sms\\Sms;\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\EasySwoole\\Trigger;\nuse Swoole\\Table;\n\nclass EventNotify\n{\n    use Singleton;\n\n    private $evenTable;\n\n    function __construct()\n    {\n        $this-&gt;evenTable = new Table(2048);\n        $this-&gt;evenTable-&gt;column('expire',Table::TYPE_INT,8);\n        $this-&gt;evenTable-&gt;column('count',Table::TYPE_INT,8);\n        $this-&gt;evenTable-&gt;create();\n    }\n\n    function notifyException(\\Throwable $throwable)\n    {\n        $class = get_class($throwable);\n        //Exception in root directory, with msg as key\n        if($class == 'Exception'){\n            $key = substr(md5($throwable-&gt;getMessage()),8,16);\n        }else{\n            $key = substr(md5($class),8,16);\n        }\n        $this-&gt;onNotify($key,$throwable-&gt;getMessage());\n    }\n\n    function notify(string $msg)\n    {\n        $key = md5($msg);\n        $this-&gt;onNotify($key,$msg);\n    }\n\n    private function onNotify(string $key,string $msg)\n    {\n        $info = $this-&gt;evenTable-&gt;get($key);\n        //The same message will not be recorded in ten minutes\n        $this-&gt;evenTable-&gt;set($key,[\n            \"expire\"=&gt;time() + 10 * 60\n        ]);\n        if(!empty($info)){\n            return;\n        }\n        try{\n            EventNotifyPhoneModel::create()-&gt;chunk(function (EventNotifyPhoneModel $model)use($msg){\n                Sms::send($model-&gt;phone,$msg);\n            });\n            EventNotifyModel::create([\n                'msg'=&gt;$msg,\n                'time'=&gt;time()\n            ])-&gt;save();\n        }catch (\\Throwable $throwable){\n            //Avoid dead circulation\n            Trigger::getInstance()-&gt;error($throwable-&gt;getMessage());\n        }\n    }\n}\nNote that this is incomplete code. The following three classes need to be implemented by themselves\nuse App\\Model\\EventNotifyModel;\nuse App\\Model\\EventNotifyPhoneModel;\nuse App\\Utility\\Sms\\Sms;\ntarget:\n\nRecord the mobile number of the notification\nText messaging\nAbnormal information record\n\nCallback takeover registration\nRegister in the event mainServerCreate of easyswoole Global\n&lt;?php\n\nclass EasySwooleEvent implements Event\n{\n    public static function mainServerCreate(EventRegister $register)\n    {\n        //Instantiate exception notifier in advance and register callback\n        EventNotify::getInstance();\n        Trigger::getInstance()-&gt;onException()-&gt;set('notify',function (\\Throwable $throwable){\n            EventNotify::getInstance()-&gt;notifyException($throwable);\n        });\n\n        Trigger::getInstance()-&gt;onError()-&gt;set('notify',function ($msg){\n            EventNotify::getInstance()-&gt;notify($msg);\n        });\n    }\n}\nEffect\nSubsequently, trigger will be triggered in any business logic where trigger is called. The effect is as follows：\n\n\nThe easyswoole HTTP request callback has automatically caught exceptions, and unhandled exceptions will be caught by trigger.\n","link":"/BaseUsage/trigger.html"},{"id":35,"title":"unit testing","content":"Phpunit\nEasyswoole/Phpunit 是对 Phpunit 的协程定制化封装，主要为解决自动协程化入口的问题。并屏蔽了Swoole ExitException\nInstallation\ncomposer require easyswoole/phpunit\n使用\n执行\n./vendor/bin/co-phpunit tests\ntests为你写的测试文件的目录，可以自定义\n预处理\n/*\n * 允许自动的执行一些初始化操作，只初始化一次\n */\nif(file_exists(getcwd().'/phpunit.php')){\n    require_once getcwd().'/phpunit.php';\n}\neasyswoole/phpunit 支持在项目目录下定义一个phpunit.php，用户可以在该文件下进行统一的测试前预处理\n其他测试与phpunit一致\nEasySwoole中使用\n自3.2.5版本的Easyswoole起，已经默认集成了 easyswoole/phpunit 组件。命令行下执行：\nphp easyswoole phpunit tests\n即可进行测试，若部分测试需要Http或者tcp等服务，可以先以启动easyswoole并进入守护模式，再进行测试\ntests为你写的测试文件的目录，可以自定义","link":"/Components/phpunit.html"},{"id":36,"title":"remote console","content":"Console\nEasyswoole 提供了一个基于tcp的基础远程控制台，方便用户做开发阶段的调试或者是线上的一些远程管理。\nInstallation\ncomposer require easyswoole/console\nServer\nuse EasySwoole\\Console\\Console;\nuse EasySwoole\\Console\\ModuleInterface;\n$http = new swoole_http_server(\"127.0.0.1\", 9501);\n\n$http-&gt;on(\"request\", function ($request, $response) {\n    $response-&gt;header(\"Content-Type\", \"text/plain\");\n    $response-&gt;end(\"Hello World\\n\");\n});\n\n/*\n * 开一个tcp端口给console 用\n */\n$tcp = $http-&gt;addlistener('0.0.0.0',9600,SWOOLE_TCP);\n/*\n * 实例化一个控制台，设置密码为123456\n */\n$console = new Console('myConsole','123456');\n\n/*\n * 定义自己的一个命令\n */\n\nclass Test implements ModuleInterface\n{\n\n    public function moduleName(): string\n    {\n        return 'test';\n    }\n\n    public function exec(array $arg, int $fd, Console $console)\n    {\n       return 'this is test exec';\n    }\n\n    public function help(array $arg, int $fd, Console $console)\n    {\n        return 'this is test help';\n    }\n}\n\n/*\n * 命令注册\n */\n\n$console-&gt;moduleContainer()-&gt;set(new Test());\n/*\n * 依附给server\n */\n$console-&gt;protocolSet($tcp)-&gt;attachToServer($http);\n\n$http-&gt;start();\n\nClient\ntelnet 127.0.0.1 9600\n鉴权\nauth {PASSWORD}\n执行命令\n{MODULE} {ARG1} {ARG2}\n例子-如何在Easyswoole中实现日志推送\n模型定义\nnamespace App\\Utility;\n\nuse EasySwoole\\Console\\Console;\nuse EasySwoole\\Console\\ModuleInterface;\nuse EasySwoole\\EasySwoole\\Config;\n\nclass LogPusher implements ModuleInterface\n{\n\n    public function moduleName(): string\n    {\n        return 'log';\n    }\n\n    public function exec(array $arg, int $fd, Console $console)\n    {\n        /*\n         * 此处能这样做是因为easyswoole3.2.5后的版本改为swoole table存储配置了，因此配置不存在进程隔离\n         */\n        $op = array_shift($arg);\n        switch ($op){\n            case 'enable':{\n                Config::getInstance()-&gt;setConf('logPush',true);\n                break;\n            }\n            case \"disable\":{\n                Config::getInstance()-&gt;setConf('logPush',false);\n                break;\n            }\n        }\n        $status = Config::getInstance()-&gt;getConf('logPush');\n        $status = $status ? 'enable' : 'disable';\n        return \"log push is {$status}\";\n    }\n\n    public function help(array $arg, int $fd, Console $console)\n    {\n        return 'this is log help';\n    }\n}\nService Registration\n重点是在easyswoole 全局的事件中进行注册\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Utility\\LogPusher;\nuse EasySwoole\\Console\\Console;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        ServerManager::getInstance()-&gt;addServer('consoleTcp','9600',SWOOLE_TCP,'0.0.0.0',[\n            'open_eof_check'=&gt;false\n        ]);\n        $consoleTcp = ServerManager::getInstance()-&gt;getSwooleServer('consoleTcp');\n        /**\n            密码为123456\n        */\n        $console = new Console(\"MyConsole\",'123456');\n        /*\n         * 注册日志模块\n         */\n        $console-&gt;moduleContainer()-&gt;set(new LogPusher());\n        $console-&gt;protocolSet($consoleTcp)-&gt;attachToServer(ServerManager::getInstance()-&gt;getSwooleServer());\n        /*\n         * 给es的日志推送加上hook\n         */\n        Logger::getInstance()-&gt;onLog()-&gt;set('remotePush',function ($msg,$logLevel,$category)use($console){\n            if(Config::getInstance()-&gt;getConf('logPush')){\n                /*\n                 * 可以在 LogPusher 模型的exec方法中，对loglevel，category进行设置，从而实现对日志等级，和分类的过滤推送\n                 */\n                foreach ($console-&gt;allFd() as $item){\n                    $console-&gt;send($item['fd'],$msg);\n                }\n            }\n        });\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        // TODO: Implement afterAction() method.\n    }\n}\n测试\n链接远程服务器\ntelnet {IP} 9600\n鉴权登录\nauth 123456\n打开日志推送\nlog enable\n后续程序中的日志都会推送到你的控制台","link":"/Components/console.html"},{"id":37,"title":"ioc container","content":"Dependency Injection\nDependency Injection  \nEasySwooleA simple version of IOC is implemented，Using an IOC container makes it easy to store/retrieve resources and decouple them。\nOne of the most important benefits of using dependency injection is that it effectively separates the object from the external resources it needs, making them loosely coupled, facilitating functional reuse, and more importantly, making the overall architecture of the program very flexible。\nIn our daily development, the creation of objects is so common that it is very familiar and tedious at the same time. Every time we need an object, we need to new it by ourselves. In some cases, the object cannot be recycled due to bad programming habits, which is quite bad。\nBut what's more serious is that the principle of loose coupling and less intrusion, which we have been advocating, becomes useless in this case. So the predecessors began to seek to change this programming habit, and consider how to use coding to be more decoupled. The solution was interface oriented programming.\nNote: after the service starts, the fetch/injection to the IOC container is only valid for the current process. It does not affect other worker processes.\nMethods list\ngetInstance\n$di = Di::getInstance();\nset\nThe function prototype：set($key, $obj,...$arg)\n\n\nkey：Key name\n\n\nobj:   To inject content. Support injection object name, object instance, closure, resource, string and other common variables。\n\n\n$arg:  If the injected content is is_callable, you can set this parameter to be passed in when the callable executes。\n\n\n$di-&gt;set('test',new TestClass());\n$di-&gt;set('test',TestClass::class);\n\n// Set stores an array of [class name, method name]，You need to manually call call_user_func() execution yourself (Do not misunderstand that the error and exception section demo will be executed automatically)\n$di-&gt;set('test', [TestClass::class,'testFunction']);\n\n// Set passes the class name，Go to the new object when it is get，The variable is passed into the constructor and returns the instantiated object\n$di-&gt;set('test', TestClass::class, $arg_one, $arg_tow);\nDi's set method is lazy load mode, and if an object name or closure is set, the object is not immediately created.\nget\n$val = $di-&gt;get('test');\ndelete\n$di-&gt;delete('test');\nclear\nEmpty the IoC container of all contents.","link":"/Components/Component/ioc.html"},{"id":38,"title":"context manager","content":"Context\nContextManager\nIn The swoole,Because multiple coroutines execute concurrently, you cannot use class static variables/global variables to store the coroutine context content.\nIt is safe to use local variables，Because the value of the local variable is automatically stored in the coroutine stack, no other coroutine can access the local variable of the coroutine.\nBased on example\nuse EasySwoole\\Component\\Context\\ContextManager;\ngo(function (){\n    ContextManager::getInstance()-&gt;set('key','key in parent');\n    go(function (){\n        ContextManager::getInstance()-&gt;set('key','key in sub');\n        var_dump(ContextManager::getInstance()-&gt;get('key').\" in\");\n    });\n    \\co::sleep(1);\n    var_dump(ContextManager::getInstance()-&gt;get('key').\" out\");\n});\nWe can use the context manager to achieve the isolation of the coroutine context\nRegister a processing item\nFor example,When we have a key, we want to be in the coroutine environment，Perform a create when you get，It can be reclaimed when the coroutine exits，Then we can register a context processing item to do that.This scenario can be used for database short connection management within a coroutine.\nuse EasySwoole\\Component\\Context\\ContextManager;\nuse EasySwoole\\Component\\Context\\ContextItemHandlerInterface;\n\nclass Handler implements ContextItemHandlerInterface\n{\n\n    function onContextCreate()\n    {\n        $class = new \\stdClass();\n        $class-&gt;time = time();\n        return $class;\n    }\n\n    function onDestroy($context)\n    {\n        var_dump($context);\n    }\n}\n\nContextManager::getInstance()-&gt;registerItemHandler('key',new Handler());\n\ngo(function (){\n    go(function (){\n        ContextManager::getInstance()-&gt;get('key');\n    });\n    \\co::sleep(1);\n    ContextManager::getInstance()-&gt;get('key');\n});\nImplementation principle\nContext manager,Is by the coroutine id as the key,Process singleton pattern implemented,Ensure that each coroutine operates on the current coroutine data,With defer, the process is automatically destroyed after the end of the process, so the user doesn't need to do any recycling, just use it.","link":"/Components/Component/context.html"},{"id":39,"title":"create coroutine","content":"Coroutine\nStarting with version 4.0, Swoole provides a complete Coroutine + Channel feature that brings a new CSP programming model. The application layer can use fully synchronous programming, and the underlying layer automatically implements asynchronous IO.\nA coroutine can be understood as a thread of pure user mode, which switches by cooperation rather than preemption. Relative to the process or thread, all operations of the coroutine can be completed in the user mode, and the consumption of creation and switching is lower. Swoole can create a corresponding coroutine for each request, and reasonably schedule the coroutine according to the state of IO, which brings the following advantages:\nDevelopers can achieve asynchronous IO effects and performance in a non-perceived way with synchronous code writing, avoiding the discrete code logic and the multi-layer callbacks caused by traditional asynchronous callbacks.\nAt the same time, because the underlying package is packaged, the developer does not need to use the yield keyword to identify a coroutine IO operation compared to the traditional PHP layer coroutine framework, so there is no need to deeply understand the semantics of yield and for each level. The calls are all modified to yield, which greatly improves the development efficiency.\nCan meet the needs of most developers. For proprietary protocols, developers can use the TCP or UDP interface of the coroutine for convenient encapsulation.\nPrecautions\n\nGlobal variables: Coroutines synchronize the original asynchronous logic, but the switching of the coroutines occurs implicitly, so the consistency of global variables and static variables cannot be guaranteed before and after coroutine switching.\nIt is not compatible with zend extensions such as xdebug, xhprof, and blackfire. For example, you cannot use xhprof to perform performance analysis sampling on the coroutine server.\n\nCreate a coroutine\ngo(function () {\n    co::sleep(0.5);\n    echo \"hello\";\n});\ngo(\"test\");\ngo([$object, \"method\"]);","link":"/Introduction/coroutineCreate.html"},{"id":40,"title":"waitgroup","content":"waitgroup\nSample code：\ngo(function (){\n    $ret = [];\n\n    $wait = new \\EasySwoole\\Component\\WaitGroup();\n\n    $wait-&gt;add();\n    go(function ()use($wait,&amp;$ret){\n        \\co::sleep(0.1);\n        $ret[] = time();\n        $wait-&gt;done();\n    });\n\n    $wait-&gt;add();\n    go(function ()use($wait,&amp;$ret){\n        \\co::sleep(2);\n        $ret[] = time();\n        $wait-&gt;done();\n    });\n\n    $wait-&gt;wait();\n\n    var_dump($ret);\n});","link":"/Components/Component/waitGroup.html"},{"id":41,"title":"csp","content":"Csp concurrency mode\nWhen we need to execute some unrelated requests concurrently and get results, for example:\n$sql1-&gt;exec();\n$sql2-&gt;exec();\n$sql2-&gt;exec();\nIn the above code, we can't save the most time, because the sql statements are executed sequentially, so we introduced the concept of Csp concurrent programming.\nSample code\ngo(function (){\n    $channel = new \\Swoole\\Coroutine\\Channel();\n    go(function ()use($channel){\n        //Simulation execution sql\n        \\co::sleep(0.1);\n        $channel-&gt;push(1);\n    });\n    go(function ()use($channel){\n        //Simulation execution sql\n        \\co::sleep(0.1);\n        $channel-&gt;push(2);\n    });\n    go(function ()use($channel){\n        //Simulation execution sql\n        \\co::sleep(0.1);\n        $channel-&gt;push(3);\n    });\n\n    $i = 3;\n    while ($i--){\n        var_dump($channel-&gt;pop());\n    }\n});\nOf course, in the above code, we did not fully consider the timeout and so on.\nFurther packaging\ngo(function (){\n    $csp = new \\EasySwoole\\Component\\Csp();\n    $csp-&gt;add('t1',function (){\n        \\co::sleep(0.1);\n       return 't1 result';\n    });\n    $csp-&gt;add('t2',function (){\n        \\co::sleep(0.1);\n        return 't2 result';\n    });\n\n    var_dump($csp-&gt;exec());\n});\nThe exec method provides a default parameter: timeout (default is 5s). When calling $csp->exec(), waiting for about 5s will return the result. If you are in the t2 function co::sleep(6), then after 5s, the returned data will not contain the return data of the t2 function.","link":"/Components/Component/csp.html"},{"id":42,"title":"dispatch","content":"URL parsing rules\nOnly the URL resolution of the PATHINFO mode is supported, and it is consistent with the controller name (method), and the controller search rule is the priority complete matching mode.\nResolution rules\nIn the absence of routing intervention, the built-in parsing rules support infinite nested directories, as shown in the two examples below.\n\n\nhttp://serverName/api/auth/login\nThe corresponding execution method is \\App\\HttpController\\Api\\Auth::login()\n\n\nhttp://serverName/a/b/c/d/f\n\n\nIf f is the controller name, the method executed is \\App\\HttpController\\A\\B\\C\\D\\F::index()\n\n\nIf f is a method name, the method executed is \\App\\HttpControllers\\A\\B\\C\\D::f()\n\n\nIf the last path is index, the underlying will be automatically ignored and the controller's default method (ie index) will be called directly.\n\n\n\n\nImplementation code:\n&lt;?php\n//If the request is /Index/index, or /abc/index\n// will automatically delete the last index character, $path has been processed as /Index or /abc\n$pathInfo = ltrim($path,\"/\");\n$list = explode(\"/\",$pathInfo);\n$actionName = null;\n$finalClass = null;\n$controlMaxDepth = $this-&gt;maxDepth;\n$currentDepth = count($list);\n$maxDepth = $currentDepth &lt; $controlMaxDepth ? $currentDepth : $controlMaxDepth;\nwhile ($maxDepth &gt;= 0){//Resolution level\n    $className = '';\n    //According to the requested path, the layer-by-layer parsing string is converted to the first letter uppercase, and it is judged whether the string is valid. If it is invalid, the default is Index.\n    for ($i=0 ;$i&lt;$maxDepth;$i++){\n        $className = $className.\"\\\\\".ucfirst($list[$i] ?: 'Index');//Service for Level 1 Controller Index\n    }\n    //Exit the loop if the controller is found\n    if(class_exists($this-&gt;controllerNameSpacePrefix.$className)){\n        //Try to get the actionName after the class\n        $actionName = empty($list[$i]) ? 'index' : $list[$i];\n        $finalClass = $this-&gt;controllerNameSpacePrefix.$className;\n        break;\n    }else{\n        //Try to search index controller\n        $temp = $className.\"\\\\Index\";\n        if(class_exists($this-&gt;controllerNameSpacePrefix.$temp)){\n            $finalClass = $this-&gt;controllerNameSpacePrefix.$temp;\n            //Try to get the actionName after the class\n            $actionName = empty($list[$i]) ? 'index' : $list[$i];\n            break;\n        }\n    }\n    $maxDepth--;\n}\nAnalytic hierarchy\nIn theory, EasySwoole supports infinite-level URL-&gt;controller mapping, but for system efficiency and to prevent malicious URL access, the system defaults to level 3. If more levels of URL mapping match are required due to business requirements, please refer to the framework initialization event. Injects the constant SysConst::HTTP_CONTROLLER_MAX_DEPTH to the DI, which is the maximum level of URL parsing. The following code allows the URL to be parsed up to 5 levels.\npublic static function initialize()\n{\n    Di::getInstance()-&gt;set(SysConst::HTTP_CONTROLLER_MAX_DEPTH,5);\n}\nSpecial cases\nWhen the controller and method are both index, you can directly ignore it.\n\n\nIf the method is index, you can ignore it:\n     If the corresponding execution method is named \\App\\HttpController\\Api\\User::index()\n     Url can be written directly http://serverName/api/User\n\n\nIf the controller and method are both Index, they can be ignored\n     If the corresponding execution method is named \\App\\HttpController\\Index::index()\n     Url can be written directly http://serverName/\n\n\nThe index ignore rule theory supports an infinite level, and the layer-by-layer lookup is based on the maximum resolution level:\n     http://serverName\n     When \\App\\HttpController\\Index.php does not exist, it will search for Index.php layer by layer.\n     Such as \\App\\HttpController\\Index\\Index\\Index::index();\n     Until the maximum depth;\n\n\n  Note that the URL path of EasySwoole is case-sensitive, and the first letter of the controller supports lowercase conversion.","link":"/HttpServer/dispatch.html"},{"id":43,"title":"fastroute","content":"Custom routing\nReference Demo: Router.php\nEasySwoole supports custom routing, and its routing is implemented by [fastRoute] (https://github.com/nikic/FastRoute), so its routing rules are consistent with it. For detailed documentation of this component, please refer to [GitHub documentation] (https://github.com/nikic/FastRoute/blob/master/README.md)\nSample Code:\nCreate a new file App\\HttpController\\Router.php:\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/8/15\n * Time: 上午10:39\n */\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\AbstractRouter;\nuse FastRoute\\RouteCollector;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        $routeCollector-&gt;get('/user', '/index.html');\n        $routeCollector-&gt;get('/rpc', '/Rpc/index');\n\n        $routeCollector-&gt;get('/', function (Request $request, Response $response) {\n            $response-&gt;write('this router index');\n        });\n        $routeCollector-&gt;get('/test', function (Request $request, Response $response) {\n            $response-&gt;write('this router test');\n            return '/a';//Relocate to the /a method\n        });\n        $routeCollector-&gt;get('/user/{id:\\d+}', function (Request $request, Response $response) {\n            $response-&gt;write(\"this is router user ,your id is {$request-&gt;getQueryParam('id')}\");//Get the id of the route match\n            return false;//No longer request, end this response\n        });\n\n    }\n}\nVisit 127.0.0.1:9501/rpc, corresponding to App\\HttpController\\Rpc.php-&gt;index()\n  If the callback function is used to process the route, return false means that the request is not continued, and the method afterAction, gc cannot be triggered.\n\nImplementation principle can be viewed in the source code\n\nRouting Group\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        $routeCollector-&gt;addGroup('/admin',function (RouteCollector $collector){\n            $collector-&gt;addRoute('GET','/index.html',function (Request $request,Response $response){\n                $version = $request-&gt;getQueryParam('version');\n                // Here you can return the path according to the version parameter\n                if($version == 1){\n                    $path = '/V1'.$request-&gt;getUri()-&gt;getPath();\n                }else{\n                    $path = '/V2'.$request-&gt;getUri()-&gt;getPath();\n                }\n                //New path\n                return $path;\n            });\n        });\n    }\n}\nGlobal Mode Intercept\nAdd the following code in Router.php to enable global mode interception\n$this-&gt;setGlobalMode(true);\nUnder global mode interception, the route will only match the controller method response in Router.php, and the default parsing of the framework will not be performed.\nException error handling\nThe following two methods can be used to set the route matching error and the callback of the method not found:\n&lt;?php\n$this-&gt;setMethodNotAllowCallBack(function (Request $request,Response $response){\n    $response-&gt;write('No processing method found');\n    return false;//End this response\n});\n$this-&gt;setRouterNotFoundCallBack(function (Request $request,Response $response){\n    $response-&gt;write('Route matching not found');\n    return 'index';//Redirect to index route\n});\nThe callback function is only for the fastRoute unmatched condition. If the callback does not end the request response, the request will continue to Dispatch and try to find the corresponding controller for response processing.\nfastRoute use\naddRoute method\nThe prototype of the addRoute method that defines the route is as follows. This method requires three parameters. Below we have a deeper understanding of the routing components.\n$routeCollector-&gt;addRoute($httpMethod, $routePattern, $handler)\nhttpMethod\n\nThis parameter needs to pass in an uppercase HTTP method string, specifying the method that the route can intercept. A single method directly passes the string. You need to intercept multiple methods to pass in a one-dimensional array, as in the following example:\n// Intercept GET method\n$routeCollector-&gt;addRoute('GET', '/router', '/Index');\n\n// Intercept POST method\n$routeCollector-&gt;addRoute('POST', '/router', '/Index');\n\n// Intercept multiple methods\n$routeCollector-&gt;addRoute(['GET', 'POST'], '/router', '/Index');\n\nroutePattern\n\nPassing a route matching expression, the route that meets the expression requirements will be intercepted and processed. The expression supports placeholder matching such as {parameter name: matching rule}, which is used to qualify routing parameters.\nBasic match\nThe following definition will match http://localhost:9501/users/info\n$routeCollector-&gt;addRoute('GET', '/users/info', 'handler');\nBinding parameters\nThe following definition takes the part after /users/ as a parameter, and the qualified parameter can only be the number [0-9]\n// can match: http://localhost:9501/users/12667\n// Can't match: http://localhost:9501/users/abcde\n\n$routeCollector-&gt;addRoute('GET', '/users/{id:\\d+}', 'handler');\n\nThe following definitions are not restricted, only the matching URL part is taken as a parameter.\n// can match: http://localhost:9501/users/12667\n// can match: http://localhost:9501/users/abcde\n\n$routeCollector-&gt;addRoute('GET', '/users/{name}', 'handler');\nSometimes the partial location of the route is optional and can be defined as follows\n// can match: http://localhost:9501/users/to\n// can match: http://localhost:9501/users/to/username\n\n$routeCollector-&gt;addRoute('GET', '/users/to[/{name}]', 'handler');\nThe bound parameters will be assembled into the get data by the inside of the framework.\n&lt;?php\n$routeCollector-&gt;get('/user/{id:\\d+}', function (Request $request, Response $response) {\n    $response-&gt;write(\"this is router user ,your id is {$request-&gt;getQueryParam('id')}\");\n    return false;\n});\nhandler\n\nSpecify the method that needs to be processed after the route is successfully matched. You can pass in a closure. When passing in the closure, you must pay attention to the end of the response after processing. Otherwise, the request will continue to Dispatch to find the corresponding controller to handle. Of course, if you take advantage of this, you can also process some requests and then pass them to the controller execution logic.\n// Incoming closures\n$routeCollector-&gt;addRoute('GET', '/router/{id:\\d+}', function (Request $request, Response $response) {\n     $id = $request-&gt;getQueryParam('id');\n$response-&gt;write('Userid : ' . $id);\nReturn false;\n});\n\nCan also be directly passed to the controller path\n$routeCollector-&gt;addRoute('GET', '/router2/{id:\\d+}', '/Index');\n  For more details on usage, please check the FastRouter directly.","link":"/HttpServer/fastRoute.html"},{"id":44,"title":"controller","content":"Controller object\nThe controller object is an object in the http component that facilitates interaction between the client and the server. It uses the object pool object reuse pattern and injects request and response objects for data interaction.\nObject pool mode\nThe http controller object uses the object pool mode to get the created object.\nE.g:\n\nUser A requests /Index through url parsing and routing forwarding, and locates the App\\HttpController\\Index.php controller.\nSince it is the first request, new App\\HttpController\\Index.php and save the object in the object pool\nThe object pool is dequeued, the object is obtained, and the index method is called to process the request.\nAfter processing, reset the object's properties to the default value, the object recycles the object pool\nUser B requests /Index through url parsing and routing forwarding, and locates the App\\HttpController\\Index.php controller\nBecause it is a secondary request, the object pool directly obtains the first object, does not need new, directly calls the index method for processing\n\nThe object pool mode implements different requests to reuse the same object, reducing the overhead of creating/destroying objects. The constructor is called only when the object is requested for the first time, and will not be called again when the object is acquired for the second time. The pool mode does not reset the static attribute and the private private attribute. These two attributes will be reused. The object pool mode is for a single process, and the object pools of multiple work processes are not shared.\nConvention specification\n\n\nThe class name and class file (folder) in the project are named, both are big hump, and the variable and class method are small hump.\n\n\nIn the HTTP response, echo $var in the business logic code does not output the $var content to the corresponding content. Please call the wirte() method in the Response instance.\n    \nobject method\nScheduling class method\n\n\naction\n action is the final method executed by the controller. According to the matching of the routes, different controller methods are executed, such as the default index method, such as the test method that accesses the final parsing of ip/Index/test. , can be called action execution method.\n The action method can return a string, allowing the framework to schedule controller methods again, for example:\n\n\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/4/11 0011\n * Time: 14:40\n */\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\EasySwoole\\Trigger;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Http\\Message\\Status;\nclass Index extends Controller\n{\n    function index()\n    {\n        $this-&gt;writeJson(200, [], 'success');\n        return '/test';\n    }\n\n    function test()\n    {\n        $this-&gt;response()-&gt;write('this is test');\n        return '/test2';//After executing the test method, return /test2 to let the framework continue to dispatch the /test2 method.\n    }\n\n    function test2()\n    {\n        $this-&gt;response()-&gt;write('this is test2');\n        return true;\n    }\n}\nThe returned string will be parsed by the url parsing rule and the route route rule, but it should be noted that the A method must not return the B method, and the B method returns the string of the A method, otherwise an infinite loop call will occur.\n\nonRequest    \n\n\nprotected function onRequest(?string $action): ?bool  \n{\n    return true;   \n}\n\nThe event when the controller method is ready to process the request. If the method returns false, it will not continue to execute.\nCan be used to do controller base class permission verification, etc., for example:  \nfunction onRequest(?string $action): ?bool\n{\n    if (parent::onRequest($action)) {\n        //Determine whether to log in\n        if (1/*Fake code*/) {\n            $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', 'Login has expired');\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n\n\nafterAction\nThis method will be called when the controller method finishes executing, and the logic such as data recovery can be customized.\n\n\nindex\nIndex is an abstract method that represents the inheritance of the controller object and needs to implement the method. index will become the default controller method.\n\n\nactionNotFound\nWhen the request method is not found, the method is called automatically, and the method can be overridden to implement its own logic.\n\n\n  This method can be understood as default method, similar to the index method, so after the call, it will also trigger afterAction, gc and other methods.\n\nonException\nThis method is called when the controller logic throws an exception (the framework has already handled the exception by default)\nYou can override this method to perform custom exception handling, for example:\nfunction onException(\\Throwable $throwable): void\n{\n// Directly respond to the front end 500 and output the system busy\n$this-&gt;response()-&gt;withStatus(Status::CODE_INTERNAL_SERVER_ERROR);\n$this-&gt;response()-&gt;write('The system is busy, please try again later');\n}\n\n\nMore controller exceptions can be found in [Error and Exception Interception] (exception.md)\n\ngc  \nprotected function gc()\n{\n// TODO: Implement gc() method.\nif ($this-&gt;session instanceof SessionDriver) {\n    $this-&gt;session-&gt;writeClose();\n    $this-&gt;session = null;\n}\n//Restore Defaults\nforeach ($this-&gt;defaultProperties as $property =&gt; $value) {\n    $this-&gt;$property = $value;\n}\n}\nThe gc method will be called automatically after executing method, afterAction\nReset controller properties to default values, turn off session\nCan be covered by the implementation of other gc recycling logic.\n\n\nRequest response class method\n\nrequest\nAfter the request method is called, the EasySwoole\\Http\\Request object will be returned.\nThis object comes with all the data requested by the user, for example:\nfunction index()\n{\n$request = $this-&gt;request();\n$request-&gt;getRequestParam();//Get post/get data, get overwrite post\n    $request-&gt;getMethod();//Get request method (post/get/)\n    $request-&gt;getCookieParams();//Get the cookie parameter\n}\n\n\nMore request related can view [request object] (request.md)\n\nresponse\nThe response method will return EasySwoole\\Http\\Response to respond to the client with data, for example:\nfunction index()\n{\n$response = $this-&gt;response();\n$response-&gt;withStatus(200);//Set response status code, must be set\n$response-&gt;setCookie('name','Alan',time()+86400,'/');//Set a cookie\n$response-&gt;write('hello world');//Send a piece of data to the client (similar to the echo of the regular web mode)\n}\n\n\nFor more information about response, see [response object] (response.md)\n\nwriteJson\nThe writeJson method directly encapsulates the set response status code, sets the response header, and the array is converted to json output.\nfunction index()\n{\n$this-&gt;writeJson(200,['xsk'=&gt;'Alan'],'success');\n}\nWeb page output:\n{\"code\":200,\"result\":{\"xsk\":\"仙士可\"},\"msg\":\"success\"}\n\n\nDeserialization method\n\njson\n  Parse a json string with json_decode\nxml\n  Parse xml string using simpleml_load_string\n \nsession related\n\nsessionDriver\n   Set the session driver class, the default is EasySwoole\\Http\\Session\\SessionDriver\n\nsession\n  Return the session driver class to manage the session\n \nVerify related\n\nvalidate\n  The validate method can directly call the validation of the EasySwoole\\Validate\\Validate object, returning the result of the validation success/failure, and implementing the code:\nprotected function validate(Validate $validate)\n{\nreturn $validate-&gt;validate($this-&gt;request()-&gt;getRequestParam());\n}\nWe can use this method to verify the data sent by the client:\nfunction index()\n{\n$validate = new Validate();\n$validate-&gt;addColumn('name','Name')-&gt;required()-&gt;lengthMax(50);\n// Restricted name is required and cannot be greater than 50 strings\nif (!$this-&gt;validate($validate)){\n    $this-&gt;writeJson(400, [], $validate-&gt;getError()-&gt;__toString());\n    return false;\n}\n$this-&gt;writeJson(200, [], 'success');\n}\n\n\nMore validate related can be found [verifier] (./validate.md)","link":"/HttpServer/controller.html"},{"id":45,"title":"request","content":"Life cycle\nThe Request object exists in the system in singleton mode, and is automatically created when the client HTTP request is received, until the request ends automatically. The Request object is fully compliant with all the specifications in [PSR7] (psr-7.md).\nMethod list\ngetRequestParam()\nUsed to get the parameters submitted by the user through POST or GET (Note: If POST and GET have the same key name parameter, GET will be used).\nExample:\n// In the controller, the Request object can be obtained via $this-&gt;request()\n// $request = $this-&gt;request()；\n\n$data = $request-&gt;getRequestParam();\nvar_dump($data);\n\n$orderId = $request-&gt;getRequestParam('orderId');\nvar_dump($orderId);\n\n$mixData = $request-&gt;getRequestParam(\"orderId\",\"type\");\nvar_dump($mixData);\ngetSwooleRequest()\nThis method is used to get the current swoole_http_request object.\nPSR-7 Specifications Common Methods in the ServerRequest Object\ngetCookieParams()\nThis method is used to obtain the cookie information in the HTTP request.\n$all = $request-&gt;getCookieParams();\nvar_dump($all);\n$who = $request-&gt;getCookieParams('who');\nvar_dump($who);\ngetUploadedFiles()\nThis method is used to obtain all file information uploaded by the client.\n$img_file = $request-&gt;getUploadedFile('img');//Get an upload file that returns an object of \\EasySwoole\\Http\\Message\\UploadFile\n$data = $request-&gt;getUploadedFiles();//Get all uploaded files and return an array containing the \\EasySwoole\\Http\\Message\\UploadFile object\nvar_dump($data);\n#### \\EasySwoole\\Http\\Message\\UploadFile对象:\nClick to view [UploadFile object] (./uploadFile.md)\ngetBody()\nThis method is used to get the raw data submitted by POST in non-form-data or x-www-form-urlenceded encoding format, which is equivalent to $HTTP_RAW_POST_DATA in PHP.\nGet get content\n$get = $request-&gt;getQueryParams();\nGet post content\n$post = $request-&gt;getParsedBody();\nGet raw content\n$content = $request-&gt;getBody()-&gt;__toString();\n$raw_array = json_decode($content, true);\nGetting the head\n$header = $request-&gt;getHeaders();\nGet the server\n$server = $request-&gt;getServerParams();\nGet a cookie\n$cookie = $request-&gt;getCookieParams();","link":"/HttpServer/request.html"},{"id":46,"title":"response","content":"Response object\nLife cycle\nThe Response object exists in the system in singleton mode and is automatically created when the client HTTP request is received, until the request ends automatically. The Response object is fully compliant with all the specifications in [PSR7] (psr-7.md).\nOther details, interested students can view the corresponding code in the IDE.\nMethod list\nwrite\nThis method is used to respond to data to the customer.\n$this-&gt;response()-&gt;write('hello world');\nredirect\nThis method is used to redirect the request to the specified URL\n$this-&gt;response()-&gt;redirect(\"/newURL/index.html\");\nsetCookie\nSet a cookie to the client in the same way as the native setCookie.\ngetSwooleResponse\nUsed to get the original swoole_http_response instance.\nend\nEnd the response to the HTTP request. After the end, the data cannot be responded to the client again.\nisEndResponse\nDetermine whether the HTTP request ends the response. When you don't know whether the response has been ended, you can use this method to determine whether you can respond to the client again:\nIf(!$this-&gt;response()-&gt;isEndResponse()){\n     $this-&gt;response()-&gt;write('Continue to send data');\n}\nPSR-7 Specification Common Methods in Response Objects\nwithStatus\nSend an HTTP status code to the client.\n$this-&gt;response()-&gt;withStatus($statusCode);\nNote: $statusCode must be a standard HTTP allowed status code. See the Status object in the Http Message for details.\nwithHeader\nUsed to send a header to an HTTP client.\n$this-&gt;response()-&gt;withHeader('Content-type','application/json;charset=utf-8');","link":"/HttpServer/response.html"},{"id":47,"title":"view","content":"Template engine\nRendering driver\nEasySwoole introduces the form of the template rendering driver, and the data that needs to be rendered is delivered to the custom synchronization process through the coroutine client for rendering and returning the result. The reason for this is that some of the templating engines on the market have variable security issues under the Swoole coroutine. For example, the following process:\n\nrequest A reached, static A assign requestA-data\ncompiled template \nwrite compiled template (yiled current coroutine)\nrequest B reached，static A assign requestB-data\n\nrender static A data into complied template file\nThe above process we can find that the data requested by A is polluted by B. To solve this problem, EasySwoole introduced a template rendering driver mode.\n\n\nInstallation\ncomposer require easyswoole/template\nBasic implementation\nImplementing the rendering engine\nuse EasySwoole\\Template\\Config;\nuse EasySwoole\\Template\\Render;\nuse EasySwoole\\Template\\RenderInterface;\n\nclass R implements RenderInterface\n{\n\n    public function render(string $template, array $data = [], array $options = []):?string\n    {\n        return 'asas';\n    }\n\n    public function afterRender(?string $result, string $template, array $data = [], array $options = [])\n    {\n        // TODO: Implement afterRender() method.\n    }\n\n    public function onException(Throwable $throwable):string\n    {\n        return $throwable-&gt;getMessage();\n    }\n}\n\nHTTP服务中调用\n//在全局的主服务中创建事件中，实例化该Render,并注入你的驱动配置\nRender::getInstance()-&gt;getConfig()-&gt;setRender(new R());\n\n$http = new swoole_http_server(\"0.0.0.0\", 9501);\n$http-&gt;on(\"request\", function ($request, $response)use($render) {\n    //调用渲染器，此时会通过携程客户端，把数据发往自定义的同步进程中处理，并得到渲染结果\n    $response-&gt;end(Render::getInstance()-&gt;render('a.html'));\n});\n$render-&gt;attachServer($http);\n\n$http-&gt;start();\nRestart the rendering engine\nBecause some template engines cache template files\nThis may lead to the following situations:\n\nUser A requests 1.tpl to return ‘a’\nThe developer modified the 1.tpl data and changed it to ‘b’\nUser B, C, D may have two different values of ‘a’ and ‘b’ in subsequent requests.\n \nThat's because the template engine has already cached the file of the process in which A is located, causing subsequent requests to be cached if they are also assigned to A's process.\n\nThe solution is as follows:\n1: Restart easyswoole, you can solve\n2: The template rendering engine implements the restart method restartWorker, which can be called directly.\nRender::getInstance()-&gt;restartWorker();\nUsers can call the restartWorker method to restart according to their own logic.\nFor example, add a reload method to the controller:\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Template\\Render;\n\nclass Index extends Controller\n{\n\n    function index()\n    {\n        $this-&gt;response()-&gt;write(Render::getInstance()-&gt;render('index.tpl',[\n            'user'=&gt;'easyswoole',\n            'time'=&gt;time()\n        ]));\n    }\n\n    function reload(){\n        Render::getInstance()-&gt;restartWorker();\n        $this-&gt;response()-&gt;write(1);\n    }\n}\nSmarty rendering\nIntroducing Smarty\ncomposer require smarty/smarty   - request A reached, static A assign requestA-data\n   - compiled template \n   - write compiled template (yiled current coroutine)\n   - request B reached，static A assign requestB-data\n   - render static A data into complied template file\n\nImplement the rendering engine\nuse EasySwoole\\Template\\RenderInterface;\nuse EasySwoole\\Template\\RenderInterface;\n\nclass Smarty implements RenderInterface\n{\n\n    private $smarty;\n    function __construct()\n    {\n        $temp = sys_get_temp_dir();\n        $this-&gt;smarty = new \\Smarty();\n        $this-&gt;smarty-&gt;setTemplateDir(__DIR__.'/');\n        $this-&gt;smarty-&gt;setCacheDir(\"{$temp}/smarty/cache/\");\n        $this-&gt;smarty-&gt;setCompileDir(\"{$temp}/smarty/compile/\");\n    }\n\n    public function render(string $template, array $data = [], array $options = []): ?string\n    {\n        foreach ($data as $key =&gt; $item){\n            $this-&gt;smarty-&gt;assign($key,$item);\n        }\n        return $this-&gt;smarty-&gt;fetch($template,$cache_id = null, $compile_id = null, $parent = null, $display = false,\n            $merge_tpl_vars = true, $no_output_filter = false);\n    }\n\n    public function afterRender(?string $result, string $template, array $data = [], array $options = [])\n    {\n\n    }\n\n    public function onException(\\Throwable $throwable): string\n    {\n        $msg = \"{$throwable-&gt;getMessage()} at file:{$throwable-&gt;getFile()} line:{$throwable-&gt;getLine()}\";\n        trigger_error($msg);\n        return $msg;\n    }\n}\nCalled in HTTP service\n// Create an event in the global main service, instantiate the Render, and inject your driver configuration\nRender::getInstance()-&gt;getConfig()-&gt;setRender(new Smarty());\nRender::getInstance()-&gt;getConfig()-&gt;setTempDir(EASYSWOOLE_TEMP_DIR);\nRender::getInstance()-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n//Implement response in action\nRender::getInstance()-&gt;render('a.html');\n\nSupport for common template engines\n \nHere are some common template engine packages for easy introduction:\nsmarty/smarty\nSmarty is a template engine written in PHP and is one of the most famous PHP template engines in the industry.\ncomposer require smarty/smarty=~3.1\nleague/plates\nLower cost of learning and higher freedom with a non-compiled template engine using native PHP syntax\ncomposer require league/plates=3.*\nduncan3dc/blade\nTemplate engine used by the Laravel framework\ncomposer require duncan3dc/blade=^4.5\ntopthink/think-template\nTemplate engine used by the ThinkPHP framework\ncomposer require topthink/think-template","link":"/Components/template.html"},{"id":48,"title":"configure","content":"Configuration\nAn object instance that needs to be passed to Config before generating the verification code\nAfter the Config class is instantiated, there will be a default configuration, and a verification code image can be generated without configuration.\nImplementation code:\n&lt;?php\n// +----------------------------------------------------------------------\n// | easySwoole [ use swoole easily just like echo \"hello world\" ]\n// +----------------------------------------------------------------------\n// | WebSite: https://www.easyswoole.com\n// +----------------------------------------------------------------------\n// | Welcome Join QQGroup 633921431\n// +----------------------------------------------------------------------\n\nnamespace EasySwoole\\VerifyCode;\n\nuse EasySwoole\\Spl\\SplBean;\n\n/**\n * 验证码配置文件\n * Class VerifyCodeConf\n * @author  : evalor &lt;master@evalor.cn&gt;\n * @package Vendor\\VerifyCode\n */\nclass Conf extends SplBean\n{\n\n    public $charset   = '1234567890AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'; // 字母表\n    public $useCurve  = false;         // Confusion curve\n    public $useNoise  = false;         // Random noise\n    public $useFont   = null;          // Specified font\n    public $fontColor = null;          // font color\n    public $backColor = null;          // background color\n    public $imageL    = null;          // Image width\n    public $imageH    = null;          // Picture height\n    public $fonts     = [];            // Extra font\n    public $fontSize  = 25;            // font size\n    public $length    = 4;             // Number of generated bits\n    public $mime      = MIME::PNG;     // Setting type\n    public $temp      = '/tmp';  // Set the cache directory\n\n    public function setTemp($temp){\n        if (!is_dir($temp)) mkdir($temp,0755) &amp;&amp; chmod($temp,0755);\n        $this-&gt;temp = $temp;\n    }\n\n    /**\n     * Set image format\n     * @param $MimeType\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return Conf\n     */\n    public function setMimeType($MimeType)\n    {\n        $allowMime = [ MIME::PNG, MIME::GIF, MIME::JPG ];\n        if (in_array($MimeType, $allowMime)) $this-&gt;mime = $MimeType;\n        return $this;\n    }\n\n    /**\n     * Set character set\n     * @param string $charset\n     * @return Conf\n     */\n    public function setCharset($charset)\n    {\n        is_string($charset) &amp;&amp; $this-&gt;charset = $charset;\n        return $this;\n    }\n\n    /**\n     * Turn on the confusion curve\n     * @param bool $useCurve\n     * @return Conf\n     */\n    public function setUseCurve($useCurve = true)\n    {\n        is_bool($useCurve) &amp;&amp; $this-&gt;useCurve = $useCurve;\n        return $this;\n    }\n\n    /**\n     * Turn on noise generation\n     * @param bool $useNoise\n     * @return Conf\n     */\n    public function setUseNoise($useNoise = true)\n    {\n        is_bool($useNoise) &amp;&amp; $this-&gt;useNoise = $useNoise;\n        return $this;\n    }\n\n    /**\n     * Use custom fonts\n     * @param string $useFont\n     * @return Conf\n     */\n    public function setUseFont($useFont)\n    {\n        is_string($useFont) &amp;&amp; $this-&gt;useFont = $useFont;\n        return $this;\n    }\n\n    /**\n     * Set text color\n     * @param array|string $fontColor\n     * @return Conf\n     */\n    public function setFontColor($fontColor)\n    {\n        if (is_string($fontColor)) $this-&gt;fontColor = $this-&gt;HEXToRGB($fontColor);\n        if (is_array($fontColor)) $this-&gt;fontColor = $fontColor;\n        return $this;\n    }\n\n    /**\n     * Set the background color\n     * @param null $backColor\n     * @return Conf\n     */\n    public function setBackColor($backColor)\n    {\n        if (is_string($backColor)) $this-&gt;backColor = $this-&gt;HEXToRGB($backColor);\n        if (is_array($backColor)) $this-&gt;backColor = $backColor;\n        return $this;\n    }\n\n    /**\n     * Set image width\n     * @param int|string $imageL\n     * @return Conf\n     */\n    public function setImageWidth($imageL)\n    {\n        $this-&gt;imageL = intval($imageL);\n        return $this;\n    }\n\n    /**\n     * Set picture height\n     * @param null $imageH\n     * @return Conf\n     */\n    public function setImageHeight($imageH)\n    {\n        $this-&gt;imageH = intval($imageH);\n        return $this;\n    }\n\n    /**\n     * Set font set\n     * @param array|string $fonts\n     * @return Conf\n     */\n    public function setFonts($fonts)\n    {\n        if (is_string($fonts)) array_push($this-&gt;fonts, $fonts);\n        if (is_array($fonts) &amp;&amp; !empty($fonts)) {\n            if (empty($this-&gt;fonts)) {\n                $this-&gt;fonts = $fonts;\n            } else {\n                array_merge($this-&gt;fonts, $fonts);\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * Set the font size\n     * @param int $fontSize\n     * @return Conf\n     */\n    public function setFontSize($fontSize)\n    {\n        $this-&gt;fontSize = intval($fontSize);\n        return $this;\n    }\n\n    /**\n     * Set the verification code length\n     * @param int $length\n     * @return Conf\n     */\n    public function setLength($length)\n    {\n        $this-&gt;length = intval($length);\n        return $this;\n    }\n\n    /**\n     * Get configuration values\n     * @param $name\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        return $this-&gt;$name;\n    }\n\n    /**\n     * Hex to RGB\n     * @param $hexColor\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return array\n     */\n    function HEXToRGB($hexColor)\n    {\n        $color = str_replace('#', '', $hexColor);\n        if (strlen($color) &gt; 3) {\n            $rgb = array(\n                hexdec(substr($color, 0, 2)),\n                hexdec(substr($color, 2, 2)),\n                hexdec(substr($color, 4, 2))\n            );\n        } else {\n            $color = $hexColor;\n            $r = substr($color, 0, 1) . substr($color, 0, 1);\n            $g = substr($color, 1, 1) . substr($color, 1, 1);\n            $b = substr($color, 2, 1) . substr($color, 2, 1);\n            $rgb = array(\n                hexdec($r),\n                hexdec($g),\n                hexdec($b)\n            );\n        }\n        return $rgb;\n    }\n}","link":"/Components/VerifyCode/config.html"},{"id":49,"title":"use","content":"Verification code generation\nVerifyCode.php\nVerifyCode verification code operation class, if you do not pass in the Config instance, automatically instantiate a\nCalling method:\n$config = new Conf();\n$code = new \\EasySwoole\\VerifyCode\\VerifyCode($config);\n$code-&gt;DrawCode();//Generate a verification code and return a Result object\nResult.php\nThe captcha result class, created and returned by the VerifyCode captcha operation class when the DrawCode() method is called\nMethod list:\n    /**\n     * Get captcha image\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return mixed\n     */\n    function getImageByte()\n    {\n        return $this-&gt;CaptchaByte;\n    }\n\n    /**\n     * Return image Base64 string\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return string\n     */\n    function getImageBase64()\n    {\n        $base64Data = base64_encode($this-&gt;CaptchaByte);\n        $Mime = $this-&gt;CaptchaMime;\n        return \"data:{$Mime};base64,{$base64Data}\";\n    }\n\n    /**\n     * Get verification code content\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return mixed\n     */\n    function getImageCode()\n    {\n        return $this-&gt;CaptchaCode;\n    }\n\n    /**\n     * Get Mime information\n     * @author : evalor &lt;master@evalor.cn&gt;\n     */\n    function getImageMime()\n    {\n        return $this-&gt;CaptchaMime;\n    }\n\n    /**\n     * Get the verification code file path\n     * @author: eValor &lt; master@evalor.cn &gt;\n     */\n    function getImageFile()\n    {\n        return $this-&gt;CaptchaFile;\n    }","link":"/Components/VerifyCode/verifyCode.html"},{"id":50,"title":"file upload","content":"UploadFile object\nThis object is automatically generated when the user uploads a file. It can be obtained by the following methods.\n&lt;?php\n$request=  $this-&gt;request();\n$img_file = $request-&gt;getUploadedFile('img');//Get an upload file that returns an object of \\EasySwoole\\Http\\Message\\UploadFile\n$data = $request-&gt;getUploadedFiles();\nImplementation code:\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/5/24\n * Time: 3:20\n */\n\nnamespace EasySwoole\\Http\\Message;\n\nclass UploadFile\n{\n    private $tempName;\n    private $stream;\n    private $size;\n    private $error;\n    private $clientFileName;\n    private $clientMediaType;\n    function __construct( $tempName,$size, $errorStatus, $clientFilename = null, $clientMediaType = null)\n    {\n        $this-&gt;tempName = $tempName;\n        $this-&gt;stream = new Stream(fopen($tempName,\"r+\"));\n        $this-&gt;error = $errorStatus;\n        $this-&gt;size = $size;\n        $this-&gt;clientFileName = $clientFilename;\n        $this-&gt;clientMediaType = $clientMediaType;\n    }\n\n    public function getTempName() {\n        // TODO: Implement getTempName() method.\n        return $this-&gt;tempName;\n    }\n\n    public function getStream()\n    {\n        // TODO: Implement getStream() method.\n        return $this-&gt;stream;\n    }\n\n    public function moveTo($targetPath)\n    {\n        // TODO: Implement moveTo() method.\n        return file_put_contents($targetPath,$this-&gt;stream) ? true :false;\n    }\n\n    public function getSize()\n    {\n        // TODO: Implement getSize() method.\n        return $this-&gt;size;\n    }\n\n    public function getError()\n    {\n        // TODO: Implement getError() method.\n        return $this-&gt;error;\n    }\n\n    public function getClientFilename()\n    {\n        // TODO: Implement getClientFilename() method.\n        return $this-&gt;clientFileName;\n    }\n\n    public function getClientMediaType()\n    {\n        // TODO: Implement getClientMediaType() method.\n        return $this-&gt;clientMediaType;\n    }\n}\n","link":"/HttpServer/uploadFile.html"},{"id":51,"title":"validator","content":"Validate\nEasySwoole provides a built-in validation class. By default, there is a validate method in the controller. If you want to use other methods or tools to do the verification, you can override this method in the subclass controller to implement other methods. Tool for verification\n  Validator class: EasySwoole\\Validate\\Validate\nBasic use\n&lt;?php\nuse EasySwoole\\Validate\\Validate;\n\n$data = [\n    'name' =&gt; 'blank',\n    'age'  =&gt; 25\n];\n\n$valitor = new Validate();\n$valitor-&gt;addColumn('name', 'The name is not empty')-&gt;required('The name is not empty')-&gt;lengthMin(10,'Minimum length is not less than 10 digits');\n$bool = $valitor-&gt;validate($data);\nvar_dump($bool?\"true\":$valitor-&gt;getError()-&gt;__toString());\n\n/* result:\n     String(26) \"Minimum length is not less than 10 digits\"\n*/\nPackage use in the controller\nnamespace App\\HttpController;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\Validate\\Validate;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass BaseController extends Controller\n{\n\n    protected function onRequest(?string $action): ?bool\n    {\n        $ret =  parent::onRequest($action);\n        if($ret === false){\n            return false;\n        }\n        $v = $this-&gt;validateRule($action);\n        if($v){\n            $ret = $this-&gt;validate($v);\n            if($ret == false){\n                $this-&gt;writeJson(Status::CODE_BAD_REQUEST,null,\"{$v-&gt;getError()-&gt;getField()}@{$v-&gt;getError()-&gt;getFieldAlias()}:{$v-&gt;getError()-&gt;getErrorRuleMsg()}\");\n                return false;\n            }\n        }   \n        return true;\n    }\n\n    protected function validateRule(?string $action):?Validate\n    {\n\n    }\n}\n\nWe define a base controller with the validateRule method.。\nnamespace App\\HttpController;\n\nuse App\\HttpController\\Api\\BaseController;\nuse EasySwoole\\Validate\\Validate;\n\nclass Common extends BaseController\n{\n\n    function sms()\n    {\n        $phone = $this-&gt;request()-&gt;getRequestParam('phone');\n\n    }\n\n    protected function validateRule(?string $action): ?Validate\n    {\n        $v = new Validate();\n        switch ($action){\n            case 'sms':{\n                $v-&gt;addColumn('phone','phone number')-&gt;required('Can not be empty')-&gt;length(11,'Wrong length');\n                $v-&gt;addColumn('verifyCode','Verification code')-&gt;required('Can not be empty')-&gt;length(4,'Wrong length');\n                break;\n            }\n        }\n        return $v;\n    }\n}\nIn the controller method that needs to be verified, we can add the corresponding verification rule to the corresponding action, so that the automatic verification can be realized, so that the controller method can realize the logic with peace of mind.\nMethod list\nGet Error:\nfunction getError():?EasySwoole\\Validate\\Error\nAdd a rule to the field:\nVersion 1.1.9 to the present\n\nstring name field key\nstring alias alias\nstring reset reset rule\n\npublic function addColumn(string $name, ?string $alias = null,bool $reset = false):EasySwoole\\Validate\\Rule\nVersion 1.1.0 to 1.1.8\n\nstring name field key\nstring alias alias\n\npublic function addColumn(string $name, ?string $alias = null):EasySwoole\\Validate\\Rule\nVersion 1.0.1\n\nstring name field key\nstring errorMsg error message\nstring alias alias\n\npublic function addColumn(string $name,?string $errorMsg = null,?string $alias = null):EasySwoole\\Validate\\Rule\nVersion 1.0.0\n\nstring name field key\nstring alias alias\nstring errorMsg error message\n\npublic function addColumn(string $name,?string $alias = null,?string $errorMsg = null):EasySwoole\\Validate\\Rule\nReturn a Rule object to add a custom rule.\ndata verification:\n\narray data data\n\nFunction validate(array $data)\nValidation rule class\nCurrently the rules supported by the validator are as follows\nnamespace EasySwoole\\Validate;\n\n/**\n * Verification rule\n * Please sort the verification method in alphabetical order for post maintenance\n * Class Rule\n * @package EasySwoole\\Validate\n */\nclass Rule\n{\n    protected $ruleMap = [];\n\n    function getRuleMap(): array\n    {\n        return $this-&gt;ruleMap;\n    }\n\n    /**\n     * Whether the given URL can communicate successfully\n     * @param null|string $msg\n     * @return $this\n     */\n    function activeUrl($msg = null)\n    {\n        $this-&gt;ruleMap['activeUrl'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Whether the given parameter is a letter, ie [a-zA-Z]\n     * @param null|string $msg\n     * @return $this\n     */\n    function alpha($msg = null)\n    {\n        $this-&gt;ruleMap['alpha'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    function alphaNum($msg = null)\n    {\n        $this-&gt;ruleMap['alphaNum'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    function alphaDash($msg = null)\n    {\n        $this-&gt;ruleMap['alphaDash'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Whether the given parameter is between $min $max\n     * @param integer $min minimum does not contain this value\n     * @param integer $max maximum does not contain this value\n     * @param null|string $msg\n     * @return $this\n     */\n    function between($min, $max, $msg = null)\n    {\n        $this-&gt;ruleMap['between'] = [\n            'msg' =&gt; $msg,\n            'arg' =&gt; [\n                $min, $max\n            ]\n        ];\n        return $this;\n    }\n\n    /**\n     * Whether the given parameter is a boolean\n     * @param null|string $msg\n     * @return $this\n     */\n    function bool($msg = null)\n    {\n        $this-&gt;ruleMap['bool'] = [\n            'msg' =&gt; $msg,\n            'arg' =&gt; null\n        ];\n        return $this;\n    }\n\n    /**\n     * Whether the given parameter is in decimal format\n     * @param null|integer $precision specifies the number of decimal places null is not specified\n     * @param null $msg\n     * @return $this\n     */\n    function decimal(?int $precision = null, $msg = null)\n    {\n        $this-&gt;ruleMap['decimal'] = [\n            'msg' =&gt; $msg,\n            'arg' =&gt; $precision\n        ];\n        return $this;\n    }\n\n    /**\n     * Whether the given parameter is before a certain date\n     * @param null|string $date\n     * @param null|string $msg\n     * @return $this\n     */\n    function dateBefore(?string $date = null, $msg = null)\n    {\n        $this-&gt;ruleMap['dateBefore'] = [\n            'msg' =&gt; $msg,\n            'arg' =&gt; $date\n        ];\n        return $this;\n    }\n\n    /**\n     * Whether the given parameter is after a certain date\n     * @param null|string $date\n     * @param null|string $msg\n     * @return $this\n     */\n    function dateAfter(?string $date = null, $msg = null)\n    {\n        $this-&gt;ruleMap['dateAfter'] = [\n            'msg' =&gt; $msg,\n            'arg' =&gt; $date\n        ];\n        return $this;\n    }\n\n    /**\n     * Verify that the values are equal\n     * @param $compare\n     * @param null|string $msg\n     * @return $this\n     */\n    function equal($compare, $msg = null)\n    {\n        $this-&gt;ruleMap['equal'] = [\n            'msg' =&gt; $msg,\n            'arg' =&gt; $compare\n        ];\n        return $this;\n    }\n\n    /**\n     * Verify that the value is a floating point number\n     * @param null|string $msg\n     * @return $this\n     */\n    function float($msg = null)\n    {\n        $this-&gt;ruleMap['float'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Call custom closure validation\n     * @param callable $func\n     * @param null|string $msg\n     * @return $this\n     */\n    function func(callable $func, $msg = null)\n    {\n        $this-&gt;ruleMap['func'] = [\n            'arg' =&gt; $func,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Whether the value is in the array\n     * @param array $array\n     * @param bool $isStrict\n     * @param null|string $msg\n     * @return $this\n     */\n    function inArray(array $array, $isStrict = false, $msg = null)\n    {\n        $this-&gt;ruleMap['inArray'] = [\n            'arg' =&gt; [ $array, $isStrict ],\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Is it an integer value\n     * @param null|string $msg\n     * @return $this\n     */\n    function integer($msg = null)\n    {\n        $this-&gt;ruleMap['integer'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Is it a valid IP?\n     * @param array $array\n     * @param null $msg\n     * @return $this\n     */\n    function isIp($msg = null)\n    {\n        $this-&gt;ruleMap['isIp'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Is it not empty\n     * @param null $msg\n     * @return $this\n     */\n    function notEmpty($msg = null)\n    {\n        $this-&gt;ruleMap['notEmpty'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Whether a numeric value\n     * @param null $msg\n     * @return $this\n     */\n    function numeric($msg = null)\n    {\n        $this-&gt;ruleMap['numeric'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Not in the array\n     * @param array $array\n     * @param bool $isStrict\n     * @param null $msg\n     * @return $this\n     */\n    function notInArray(array $array, $isStrict = false, $msg = null)\n    {\n        $this-&gt;ruleMap['notInArray'] = [\n            'arg' =&gt; [ $array, $isStrict ],\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Verify the length of an array or string\n     * @param int $len\n     * @param null $msg\n     * @return $this\n     */\n    function length(int $len, $msg = null)\n    {\n        $this-&gt;ruleMap['length'] = [\n            'msg' =&gt; $msg,\n            'arg' =&gt; $len\n        ];\n        return $this;\n    }\n\n    /**\n     * Verify the length of an array or string...\n     * @param int $lengthMax\n     * @param null $msg\n     * @return $this\n     */\n    function lengthMax(int $lengthMax, $msg = null)\n    {\n        $this-&gt;ruleMap['lengthMax'] = [\n            'msg' =&gt; $msg,\n            'arg' =&gt; $lengthMax\n        ];\n        return $this;\n    }\n\n    /**\n     * Verify that the length of the array or string is reached\n     * @param int $lengthMin\n     * @param null $msg\n     * @return $this\n     */\n    function lengthMin(int $lengthMin, $msg = null)\n    {\n        $this-&gt;ruleMap['lengthMin'] = [\n            'msg' =&gt; $msg,\n            'arg' =&gt; $lengthMin\n        ];\n        return $this;\n    }\n\n    /**\n     * Verify that the length of the array or string is within a range\n     * @param null $msg\n     * @return $this\n     */\n    function betweenLen(int $min, int $max, $msg = null)\n    {\n        $this-&gt;ruleMap['betweenLen'] = [\n            'msg' =&gt; $msg,\n            'arg' =&gt; [\n                $min,\n                $max\n            ]\n        ];\n        return $this;\n    }\n\n    /**\n     * Verification value is not greater than (equal is considered not passed)\n     * @param int $max\n     * @param null|string $msg\n     * @return Rule\n     */\n    function max(int $max, ?string $msg = null): Rule\n    {\n        $this-&gt;ruleMap['max'] = [\n            'arg' =&gt; $max,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * The verification value is not less than (equal is considered not passed)\n     * @param int $min\n     * @param null|string $msg\n     * @return Rule\n     */\n    function min(int $min, ?string $msg = null): Rule\n    {\n        $this-&gt;ruleMap['min'] = [\n            'arg' =&gt; $min,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * The verification value is a legal amount\n     * 100 | 100.1 | 100.01\n     * @param integer|null $precision Decimal point\n     * @param string|null  $msg\n     * @return Rule\n     */\n    function money(?int $precision = null, string $msg = null): Rule\n    {\n        $this-&gt;ruleMap['money'] = [\n            'arg' =&gt; $precision,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Setting value is optional\n     * @return $this\n     */\n    function optional()\n    {\n        $this-&gt;ruleMap['optional'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; null\n        ];\n        return $this;\n    }\n\n    /**\n     * Regular expression verification\n     * @param $reg\n     * @param null $msg\n     * @return $this\n     */\n    function regex($reg, $msg = null)\n    {\n        $this-&gt;ruleMap['regex'] = [\n            'arg' =&gt; $reg,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Must have a value\n     * @param null $msg\n     * @return $this\n     */\n    function required($msg = null)\n    {\n        $this-&gt;ruleMap['required'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Value is a legal timestamp\n     * @param null $msg\n     * @return $this\n     */\n    function timestamp($msg = null)\n    {\n        $this-&gt;ruleMap['timestamp'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Timestamp before a specified date\n     * @param string $date Pass in any string that can be parsed by strtotime\n     * @param null $msg\n     * @return $this\n     */\n    function timestampBeforeDate($date, $msg = null)\n    {\n        $this-&gt;ruleMap['timestampBeforeDate'] = [\n            'arg' =&gt; $date,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Timestamp after a specified date\n     * @param string $date Pass in any string that can be parsed by strtotime\n     * @param null $msg\n     * @return $this\n     */\n    function timestampAfterDate($date, $msg = null)\n    {\n        $this-&gt;ruleMap['timestampAfterDate'] = [\n            'arg' =&gt; $date,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Specify a timestamp before a timestamp\n     * @param string|integer $beforeTimestamp before this timestamp\n     * @param null $msg\n     * @return $this\n     */\n    function timestampBefore($beforeTimestamp, $msg = null)\n    {\n        $this-&gt;ruleMap['timestampBefore'] = [\n            'arg' =&gt; $beforeTimestamp,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Specify the timestamp after a timestamp\n     * @param string|integer $afterTimestamp after this timestamp\n     * @param null $msg\n     * @return $this\n     */\n    function timestampAfter($afterTimestamp, $msg = null)\n    {\n        $this-&gt;ruleMap['timestampAfter'] = [\n            'arg' =&gt; $afterTimestamp,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Value is a legal link\n     * @param null $msg\n     * @return $this\n     */\n    function url($msg = null)\n    {\n        $this-&gt;ruleMap['url'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n\n    /**\n     * Value is a legal link\n     * @param null $msg\n     * @return $this\n     */\n    function allDigital($msg = null)\n    {\n        $this-&gt;ruleMap['allDigital'] = [\n            'arg' =&gt; null,\n            'msg' =&gt; $msg\n        ];\n        return $this;\n    }\n}","link":"/HttpServer/validate.html"},{"id":52,"title":"auth check","content":"Auth Check","link":"/HttpServer/interception.html"},{"id":53,"title":"errorsandexceptions","content":"Error and exception interception\nHttp controller error exception\nAn error occurs in the http controller, the system will use the default exception handling to output to the client, the code is as follows:\n&lt;?php\nprotected function hookThrowable(\\Throwable $throwable,Request $request,Response $response)\n{\n    if(is_callable($this-&gt;httpExceptionHandler)){\n        call_user_func($this-&gt;httpExceptionHandler,$throwable,$request,$response);\n    }else{\n        $response-&gt;withStatus(Status::CODE_INTERNAL_SERVER_ERROR);\n        $response-&gt;write(nl2br($throwable-&gt;getMessage().\"\\n\".$throwable-&gt;getTraceAsString()));\n    }\n}\nCan override the onException method directly on the controller:\n&lt;?php\nnamespace App\\HttpController;\n\nuse App\\ViewController;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Http\\Message\\Status;\n\nclass Base extends ViewController\n{\n\n    function index()\n    {\n        // TODO: Implement index() method.\n        $this-&gt;actionNotFound('index');\n    }\n\n    function onException(\\Throwable $throwable): void\n    {\n        var_dump($throwable-&gt;getMessage());\n    }\n\n    protected function actionNotFound(?string $action): void\n    {\n        $this-&gt;response()-&gt;withStatus(Status::CODE_NOT_FOUND);\n        $this-&gt;response()-&gt;write('action not found');\n    }\n}\n\nCan also customize exception handling files:\n&lt;?php\nnamespace App;\n\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass ExceptionHandler\n{\n    public static function handle( \\Throwable $exception, Request $request, Response $response )\n    {\n        var_dump($exception-&gt;getTraceAsString());\n    }\n}\nDI registration exception handling in the initialize event:\npublic static function initialize()\n{\n    Di::getInstance()-&gt;set(SysConst::HTTP_EXCEPTION_HANDLER,[ExceptionHandler::class,'handle']);\n}\n","link":"/HttpServer/exception.html"},{"id":54,"title":"commonproblem","content":"common problem\nHow to handle static resources\nApache URl rewrite\n&lt;IfModule mod_rewrite.c&gt;\n  Options +FollowSymlinks\n  RewriteEngine On\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteCond %{REQUEST_FILENAME} !-f\n  #RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]  fcgi下无效\n  RewriteRule ^(.*)$  http://127.0.0.1:9501/$1 [QSA,P,L]\n   #请开启 proxy_mod proxy_http_mod request_mod\n&lt;/IfModule&gt;\nNginx URl rewrite\nserver {\n    root /data/wwwroot/;\n    server_name local.swoole.com;\n    location / {\n        proxy_http_version 1.1;\n        proxy_set_header Connection \"keep-alive\";\n        proxy_set_header X-Real-IP $remote_addr;\n        if (!-e $request_filename) {\n             proxy_pass http://127.0.0.1:9501;\n        }\n    }\n}\nSwoole static file processor\n$server-&gt;set([\n    'document_root' =&gt; '/data/webroot/example.com', // V4.4.0 or lower, here must be an absolute path\n    'enable_static_handler' =&gt; true,\n]);\nSwoole comes with its own static file processor. The documentation can be found at https://wiki.swoole.com/wiki/page/783.html\nAbout cross-domain processing\nAdd the following code in the global event to block all requests to add cross-domain headers\npublic static function onRequest(Request $request, Response $response): bool\n{\n    // TODO: Implement onRequest() method.\n    $response-&gt;withHeader('Access-Control-Allow-Origin', '*');\n    $response-&gt;withHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n    $response-&gt;withHeader('Access-Control-Allow-Credentials', 'true');\n    $response-&gt;withHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');\n    if ($request-&gt;getMethod() === 'OPTIONS') {\n        $response-&gt;withStatus(Status::CODE_OK);\n        return false;\n    }\n    return true;\n}\nHow to get $HTTP_RAW_POST_DATA\n$content = $this-&gt;request()-&gt;getBody()-&gt;__toString();\n$raw_array = json_decode($content, true);\nHow to get the client IP\nFor example, how to get the client IP in the controller\n//Real address\n$ip = ServerManager::getInstance()-&gt;getSwooleServer()-&gt;connection_info($this-&gt;request()-&gt;getSwooleRequest()-&gt;fd);\nvar_dump($ip);\n//Header address, for example after nginx proxy\n$ip2 = $this-&gt;request()-&gt;getHeaders();\nvar_dump($ip2);\nHTTP status code is always 500\nSince the swoole 1.10.x and 2.1.x versions, in the http server callback, if response-&gt;end() is not executed, all 500 status codes are returned.\nHow to setCookie\nSet the cookie by calling the setCookie method of the response object.\n  $this-&gt;response()-&gt;setCookie('name','value');\nMore operations can be seen [Response object] (response.md)\nHow to customize the App name\nJust modify the namespace registration of composer.json.\n    \"autoload\": {\n        \"psr-4\": {\n            \"App\\\\\": \"Application/\"\n        }\n    }","link":"/HttpServer/problem.html"},{"id":55,"title":"tcp server","content":"EasySwoole Tcp Service\nTcp service and tcp client demo\nhttps://github.com/easy-swoole/demo/tree/3.x-subtcp\nCreate tcp service\nThere are two cases here.\n\nThe project only provides a TCP server\nOpen a TCP server on a separate port of the project\n\nIn the first case, we can declare the Swoole startup type as EASYSWOOLE_SERVER directly in the configuration file.\nThen in the EasySwooleEvent.php framework event file mainServerCreate method, TCP related callback registration\nPublic static function mainServerCreate(EventRegister $register)\n{\n     $register-&gt;add($register::onReceive, function (\\swoole_server $server, int $fd, int $reactor_id, string $data) {\n         Echo \"fd:{$fd} Send a message: {$data}\\n\";\n     });\n}\nA separate port opens the TCP server and you need to add a subservice.\nSubservice listening via the mainServerCreate event of the EasySwooleEvent.php file, for example:\n&lt;?php\npublic static function mainServerCreate(EventRegister $register)\n{\n    $server = ServerManager::getInstance()-&gt;getSwooleServer();\n\n    $subPort1 = $server-&gt;addlistener('0.0.0.0', 9502, SWOOLE_TCP);\n    $subPort1-&gt;set(\n        [\n            'open_length_check' =&gt; false, //Do not verify the packet\n        ]\n    );\n    $subPort1-&gt;on('connect', function (\\swoole_server $server, int $fd, int $reactor_id) {\n        echo \"fd:{$fd} connected\\n\";\n        $str = 'Congratulations on your successful connection';\n        $server-&gt;send($fd, $str);\n    });\n    $subPort1-&gt;on('close', function (\\swoole_server $server, int $fd, int $reactor_id) {\n        echo \"fd:{$fd} closed\\n\";\n    });\n    $subPort1-&gt;on('receive', function (\\swoole_server $server, int $fd, int $reactor_id, string $data) {\n        echo \"fd:{$fd} Send a message:{$data}\\n\";\n    });\n}\ntcpController Implementation\nIn TCP, how do we implement the same route as an Http request to distribute the request to different controllers.\nEasySwoole provides a solution for a solution. (not mandatory, can be extended and modified to meet the needs of the business)\nInstallation\nIntroducing the socket package:\nComposer require easyswoole/socket\nWarning: Please ensure that the version of easyswoole/socket you installed is large >= 1.0.7. Otherwise, the problem that the ws message sending client cannot be resolved will be caused.\nProtocol Rules and Resolution\nIn this example, the json data is transferred using pack N for binary processing. The json data has three parameters, for example:\n{\"controller\":\"Index\",\"action\":\"index\",\"param\":{\"name\":\"\\u4ed9\\u58eb\\u53ef\"}}\nWe will forward the data to the parser in theonReceive` message receiving callback.\nThe parser will press the json field, similar to the following to initialize and execute the request.\n$bean-&gt;setControllerClass($controller);\n$bean-&gt;setAction($action);\n$bean-&gt;setArgs($param);\nThe TCP controller needs to inherit the EasySwoole\\Socket\\AbstractInterface\\Controller class.\nOthers will generally be written as a normal controller! You can post Task tasks in the controller, forward them to other clients, go offline, etc...\nYou can see the complete implementation and code in the github demo (copy it and use it in your project)\nImplement the parser [Parser.php] (https://github.com/easy-swoole/demo/blob/3.x-subtcp/App/TcpController/Parser.php)\nParser Takeover Service EasySwooleEvent.php\n\nImplement Controller Index.php\n\nGet parameters\nPublic function args()\n{\n     $this-&gt;response()-&gt;setMessage('your args is:'.json_encode($this-&gt;caller()-&gt;getArgs()).PHP_EOL);\n}\nReply data\nPublic function index(){\n     $this-&gt;response()-&gt;setMessage(time());\n}\nGet the current fd\nPublic function who()\n{\n     $this-&gt;caller()-&gt;getClient()-&gt;getFd()\n}\nHTTP to TCP push\nIn the HTTP controller, the Swoole instance can be obtained through the ServerManager and then sent to the specified FD client content.\nFunction method(){\n    // pass the reference fd\n    $fd = intval($this-&gt;request()-&gt;getRequestParam('fd'));\n\n    // Take the connection information through the Swoole instance\n    $info = ServerManager::getInstance()-&gt;getSwooleServer()-&gt;connection_info($fd);\n\n    If(is_array($info)){\n        ServerManager::getInstance()-&gt;getSwooleServer()-&gt;send($fd,'push in http at '.time());\n    }else{\n        $this-&gt;response()-&gt;write(\"fd {$fd} not exist\");\n    }\n}\nIn actual production, it is usually after the user TCP connection comes up, do the verification, and then in the format of userName=>fd, there is redis, need http, or other places,\nFor example, when the timer pushes to a connection, it is to use the userName to get the corresponding fd in redis, and then send. Note that the child server created by the addServer form,\nTo register your own network event completely, you can register the onclose event and then delete the userName=>fd when the connection is broken.","link":"/Socket/tcp.html"},{"id":56,"title":"tcp packet","content":"Sticky bag problem\nDue to the nature of tcp, data sticking may occur, for example\n\nA connection Server\nA send hello\nA sent another hello\nServer may receive a &quot;hellohello&quot; data at a time\nServer may also receive &quot;he&quot;, &quot;llohello&quot; like this interrupt data\n\nSticky bag solution\n\nBy identifying the EOF, such as the http protocol, by \\r\\n\\r\\n to indicate that the data has been completed, we can customize a protocol, for example, when the &quot;end 666&quot; string is received, it represents the string. Has ended, if not obtained, then stored in the buffer, waiting for the end string, or if more than one is obtained, then cut out other data through the string\nDefine the message header, get it through the message header of a certain length. For example, we define a protocol. The first 10 digits of the string represent the length of the data body. Then we only need 000000000512346 when transferring data (the first 10 bits are the protocol header). , indicating the size of this data, the latter is the data), each time we read only read 10 bits, get the message length, and then read the message length as much data, so as to ensure the integrity of the data (but in order not to be confused, the protocol header has to be labeled like EOF)\nBy packet binary processing, equivalent to method 2, the data is spliced ​​into the message through the binary package, by verifying the binary data to read the information, sw is used this way\n\nSee the official swoole documentation: https://wiki.swoole.com/wiki/page/287.html\nAchieve sticky package processing\nServer:\n&lt;?php\n$subPort2 = $server-&gt;addlistener('0.0.0.0', 9503, SWOOLE_TCP);\n$subPort2-&gt;set(\n    [\n        'open_length_check'     =&gt; true,\n        'package_max_length'    =&gt; 81920,\n        'package_length_type'   =&gt; 'N',\n        'package_length_offset' =&gt; 0,\n        'package_body_offset'   =&gt; 4,\n    ]\n);\n$subPort2-&gt;on('connect', function (\\swoole_server $server, int $fd, int $reactor_id) {\n    echo \"Tcp service 2 fd:{$fd} connected\\n\";\n    $str = 'Congratulations on connecting to the successful server 2';\n    $server-&gt;send($fd, pack('N', strlen($str)) . $str);\n});\n$subPort2-&gt;on('close', function (\\swoole_server $server, int $fd, int $reactor_id) {\n    echo \"Tcp service 2  fd:{$fd} closed\\n\";\n});\n$subPort2-&gt;on('receive', function (\\swoole_server $server, int $fd, int $reactor_id, string $data) {\n    echo \"Tcp service 2  fd:{$fd} Send original message:{$data}\\n\";\n    echo \"Tcp service 2  fd:{$fd} Send a message:\" . substr($data, '4') . \"\\n\";\n});\nClient:\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/3/6 0006\n * Time: 16:22\n */\ninclude \"../vendor/autoload.php\";\ndefine('EASYSWOOLE_ROOT', realpath(dirname(getcwd())));\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n//::: warning \n//&gt;=3.3.7,initialize:`EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()-&gt;globalInitialize();`\n//:::\n/**\n * tcp Client 2, verify the packet, and process the sticky packet\n */\ngo(function () {\n    $client = new \\Swoole\\Client(SWOOLE_SOCK_TCP);\n    $client-&gt;set(\n        [\n            'open_length_check'     =&gt; true,\n            'package_max_length'    =&gt; 81920,\n            'package_length_type'   =&gt; 'N',\n            'package_length_offset' =&gt; 0,\n            'package_body_offset'   =&gt; 4,\n        ]\n    );\n    if (!$client-&gt;connect('127.0.0.1', 9503, 0.5)) {\n        exit(\"connect failed. Error: {$client-&gt;errCode}\\n\");\n    }\n    $str = 'hello world';\n    $client-&gt;send(encode($str));\n    $data = $client-&gt;recv();//The server has done the package processing\n    var_dump($data);//Unprocessed data, preceded by 4 (because pack type is N) bytes of pack\n    $data = decode($data);//Need to cut the analytical data yourself\n    var_dump($data);\n//    $client-&gt;close();\n});\n\n/**\n * Packet pack processing\n * encode\n * @param $str\n * @return string\n * @author Tioncico\n * Time: 9:50\n */\nfunction encode($str)\n{\n    return pack('N', strlen($str)) . $str;\n}\n\nfunction decode($str)\n{\n    $data = substr($str, '4');\n    return $data;\n}","link":"/Socket/tcpSticky.html"},{"id":57,"title":"websocket server","content":"WebSocket controller\nReference Demo: WebSocketController\nEasySwoole 3.x supports developing your code in controller mode.\nFirst, modify the configuration file dev.php in the root directory of the project, and modify the SERVER_TYPE to:\n'SERVER_TYPE' =&gt; EASYSWOOLE_WEB_SOCKET_SERVER,\nAnd introduce the easyswoole/socket composer package:\ncomposer require easyswoole/socket\nWarning: Please ensure that the version of easyswoole/socket you installed is large &gt;= 1.0.7 Otherwise it will cause the problem that the ws message sending client cannot be resolved\nNewcomer help\n\nThis article follows the PSR-4 autoloading class specification. If you don't know the specification yet, please learn the rules first.\nThe basic namespace app in this section defaults to the App folder in the project root directory. If your App points to a different location, please replace it yourself.\nAs long as you follow the PSR-4 specification, no matter how you organize the file structure, this section is only a simple example.\n\nThe command parsing here means that the request information is parsed into a specific execution command;\nIn easyswoole, TCP and WebSocket can be used to parse requests in the same way as the traditional framework in the controller->method;\nPlease read the TCP controller implementation chapter first, and the principle will be described in concise text. The following codes are more, mainly providing examples.\nThe parser needs to implement the decode and encode methods in the EasySwoole\\Socket\\AbstractInterface\\ParserInterface interface;\nImplement command parsing\nCreate the App/WebSocket/WebSocketParser.php file and write the following code\nnamespace App\\WebSocket;\n\nuse EasySwoole\\Socket\\AbstractInterface\\ParserInterface;\nuse EasySwoole\\Socket\\Client\\WebSocket;\nuse EasySwoole\\Socket\\Bean\\Caller;\nuse EasySwoole\\Socket\\Bean\\Response;\n\n/**\n * Class WebSocketParser\n *\n * This class is a custom websocket message parser\n * The design used here is to use json string as the message format\n * When the client message arrives at the server, the decode method is called for message parsing.\n * will convert the websocket message into a concrete Class -&gt; Action call and inject the parameters\n *\n * @package App\\WebSocket\n */\nclass WebSocketParser implements ParserInterface\n{\n    /**\n     * decode\n     * @param string $raw client raw message\n     * @param WebSocket $client WebSocket Client object\n     * @return Caller Socket call object\n     */\n    public function decode($raw, $client) : ? Caller\n    {\n        // Parse the client raw message\n        $data = json_decode($raw, true);\n        if (!is_array($data)) {\n            echo \"decode message error! \\n\";\n            return null;\n        }\n\n        // New caller object\n        $caller =  new Caller();\n        /**\n         * Set the called class. This will resolve the class parameter in the ws message to the controller you want to access.\n         * If you prefer the event method, you can customize the event and the map of the specific class.\n         * Note Currently, easyswoole 3.0.4 and below does not support direct pass class string can be used this way\n         */\n        $class = '\\\\App\\\\WebSocket\\\\'. ucfirst($data['class'] ?? 'Index');\n        $caller-&gt;setControllerClass($class);\n\n        // Provide an event style\n//         $eventMap = [\n//             'index' =&gt; Index::class\n//         ];\n//         $caller-&gt;setControllerClass($eventMap[$data['class']] ?? Index::class);\n\n        // Set the method to be called\n        $caller-&gt;setAction($data['action'] ?? 'index');\n        // Check for the presence of args\n        if (!empty($data['content'])) {\n            // Content cannot be resolved to array when returning content =&gt; string format\n            $args = is_array($data['content']) ? $data['content'] : ['content' =&gt; $data['content']];\n        }\n\n        // Set the called Args\n        $caller-&gt;setArgs($args ?? []);\n        return $caller;\n    }\n    /**\n     * encode\n     * @param  Response     $response Socket Response Object\n     * @param  WebSocket    $client   WebSocket Client Object\n     * @return string             Message sent to the client\n     */\n    public function encode(Response $response, $client) : ? string\n    {\n        /**\n         * This returns information that is sent to the client.\n         * This should only be a unified encode operation. The specific state should be handled by the Controller.\n         */\n        return $response-&gt;getMessage();\n    }\n}\n\nNote, please follow your actual rules, this test code corresponds to the front-end code. \nRegistration service\nNewcomer tips\nIf you don't understand the easyswoole operating mechanism, then you simply understand that when easyswoole runs to a certain moment, the following methods will be executed.\nThis refers to registering the parser you implemented above.\nIn the root directory, add the following code under the mainServerCreate method of the EasySwooleEvent.php file.\n//Note: The following namespace is introduced in this file\nuse EasySwoole\\Socket\\Dispatcher;\nuse App\\WebSocket\\WebSocketParser;\n\npublic static function mainServerCreate(EventRegister $register): void\n{\n    /**\n     * **************** Websocket controller **********************\n     */\n    // Create a Dispatcher configuration\n    $conf = new \\EasySwoole\\Socket\\Config();\n    // Set Dispatcher to WebSocket mode\n    $conf-&gt;setType(\\EasySwoole\\Socket\\Config::WEB_SOCKET);\n    // Set the parser object\n    $conf-&gt;setParser(new WebSocketParser());\n    // Create a Dispatcher object and inject the config object\n    $dispatch = new Dispatcher($conf);\n    // Register the relevant event for the server In the WebSocket mode, the on message event must be registered and passed to the Dispatcher object for processing.\n    $register-&gt;set(EventRegister::onMessage, function (\\swoole_websocket_server $server, \\swoole_websocket_frame $frame) use ($dispatch) {\n        $dispatch-&gt;dispatch($server, $frame-&gt;data, $frame);\n    });\n}\nRegister the service in EasySwooleEvent.\nFront End Test\nfriendly reminder\n  Easyswoole provides a powerful WebSocket debugging tool: [WEBSOCKET CLIEN] (https://www.easyswoole.com/wstool.html);\nWebSocket Controller\nNewcomer tips\nThe WebSocket controller must inherit EasySwoole\\Socket\\AbstractInterface\\Controller;\n  The actionNotFound method provides a return message when the method is not found. By default, the actionName of this request is passed.\nCreate an App/WebSocket/Index.php file and write the following\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Apple\n * Date: 2018/11/1 0001\n * Time: 14:42\n */\nnamespace App\\WebSocket;\n\nuse EasySwoole\\EasySwoole\\ServerManager;\nuse EasySwoole\\EasySwoole\\Task\\TaskManager;\nuse EasySwoole\\Socket\\AbstractInterface\\Controller;\n\n/**\n * Class Index\n *\n * This class is the default websocket message that is accessed after parsing the controller\n *\n * @package App\\WebSocket\n */\nclass Index extends Controller\n{\n    function hello()\n    {\n        $this-&gt;response()-&gt;setMessage('call hello with arg:'. json_encode($this-&gt;caller()-&gt;getArgs()));\n    }\n\n    public function who(){\n        $this-&gt;response()-&gt;setMessage('your fd is '. $this-&gt;caller()-&gt;getClient()-&gt;getFd());\n    }\n\n    function delay()\n    {\n        $this-&gt;response()-&gt;setMessage('this is delay action');\n        $client = $this-&gt;caller()-&gt;getClient();\n\n        // Asynchronous push, here directly use fd is also possible\n        TaskManager::getInstance()-&gt;async(function () use ($client){\n            $server = ServerManager::getInstance()-&gt;getSwooleServer();\n            $i = 0;\n            while ($i &lt; 5) {\n                sleep(1);\n                $server-&gt;push($client-&gt;getFd(),'push in http at '. date('H:i:s'));\n                $i++;\n            }\n        });\n    }\n}\nThe controller uses the task component: https://www.easyswoole.com/Cn/Components/task.html\nComposer require easyswoole/task\ntest\n\nIf you follow the configuration of this article, then your file structure should be in the following form*\n\nApp\n├── HttpController\n│   ├── websocket.html\n│   └── WebSocket.php\n├── Websocket\n│   └── Index.php\n└── └── WebSocketParser.php\nFirst run easyswoole in the root directory\nPhp easyswoole start\nIf there is no error, the easyswoole service has been started at this time;\nVisit 127.0.0.1:9501/WebSocket/index to see the test html file written before;\n\nNewcomer Tip: This access method will request the index method in Index.php under the HttpController controller.\n\nExtension\nCustom parser\nIn the above WebSocketParser.php, a simple parser has been implemented;\nWe can implement the scenario we need through a custom parser.\n/**\n * decode\n * @param string $raw client raw message\n * @param WebSocket $client WebSocket Client object\n * @return Caller Socket call object\n */\npublic function decode($raw, $client) : ? Caller\n{\n    // Parse the client raw message\n    $data = json_decode($raw, true);\n    if (!is_array($data)) {\n        echo \"decode message error! \\n\";\n        return null;\n    }\n\n    // new caller object\n    $caller = new Caller();\n    /**\n     * Set the called class. This will resolve the class parameter in the ws message to the controller you want to access.\n     * If you prefer the event method, you can customize the event and the map of the specific class.\n     * Note Currently, easyswoole 3.0.4 and below does not support direct pass class string can be used this way\n     */\n    $class = '\\\\App\\\\WebSocket\\\\'. ucfirst($data['class'] ?? 'Index');\n    $caller-&gt;setControllerClass($class);\n\n    // Provide an event style\n    // $eventMap = [\n    //     'index' =&gt; Index::class\n    // ];\n    // $caller-&gt;setControllerClass($eventMap[$data['class']] ?? Index::class);\n\n    // Set the method to be called\n    $caller-&gt;setAction($data['action'] ?? 'index');\n    // Check for the presence of args\n    if (!empty($data['content'])) {\n        // Content cannot be resolved to array when returning content =&gt; string format\n        $args = is_array($data['content']) ? $data['content'] : ['content' =&gt; $data['content']];\n    }\n\n    // Set the called Args\n    $caller-&gt;setArgs($args ?? []);\n    return $caller;\n}\n/**\n * encode\n * @param  Response     $response Socket Response Object\n * @param  WebSocket    $client   WebSocket Client Object\n * @return string             Message sent to the client\n */\npublic function encode(Response $response, $client) : ? string\n{\n    /**\n     * This returns information that is sent to the client.\n     * Here should only do a unified encode operation. The specific state should be handled by the Controller.\n     */\n    return $response-&gt;getMessage();\n}\nE.g: {\"class\":\"Index\",\"action\":\"hello\"}  \nWill access App/WebSocket/WebSocket/Index.php and execute the hello method\nOf course, here is an example, you can design according to your own business scenario.","link":"/Socket/webSocket.html"},{"id":58,"title":"websocket supports wss","content":"Websocket supports Wss\nIt is recommended to use the Nginx reverse proxy to solve the wss problem.\nThat is, the client connects Nginx through the wss protocol and then Nginx communicates with the server through the ws protocol.\nIn other words, Nginx is responsible for communication encryption and decryption, Nginx to server is plaintext, swoole does not need to open ssl, but also can hide server port and load balancing (he is not). \nserver {\n\n    # The following part is no different from your https configuration. If you are a pagoda or a oneinstack, there is no problem with the generated one.\n    Listen 443;\n    Server_name Here is the domain name you applied for;\n\n    Ssl on;\n\n    # Here is the certificate corresponding to your domain name (must pay attention to the path, suggest an absolute path)\n    ssl_certificate // Your certificate.crt;\n    ssl_certificate_key // your key.key;\n\n    ssl_session_timeout 5m;\n    ssl_session_cache shared:SSL:10m;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2 SSLv2 SSLv3;\n    ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;\n    ssl_prefer_server_ciphers on;\n    ssl_verify_client off;\n\n    # The following part is actually a reverse proxy. If you are a pagoda or a oneinstack, please check your .php related and rewrite the part of index.php.\n    location / {\n        proxy_redirect off;\n        proxy_pass http://127.0.0.1:9501;      # Forward to your local port 9501, here to fill in according to your business situation, thank you\n        proxy_set_header Host $host;\n        proxy_set_header X-Real_IP $remote_addr;\n        proxy_set_header X-Forwarded-For $remote_addr:$remote_port;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;   # Upgrade protocol header\n        proxy_set_header Connection upgrade;\n    }\n}\nRestart nginx if there are no errors\n[Click me to open the ws debugging tool] (https://www.easyswoole.com/wstool.html);\nService address input wss://Do not add the port number to your domain name above \nClick to open the connection. Congratulations, wss became","link":"/Socket/webSocketWss.html"},{"id":59,"title":"websocket custom handshake","content":"Custom handshake\nIn a common business scenario, we usually need to verify the identity of the client, so it can be done by customizing the WebSocket handshake rule.\nCreate an App/WebSocket/WebSocketEvent.php file and write the following\nnamespace App\\WebSocket;\n\n/**\n * Class WebSocketEvent\n *\n * This class is some non-mandatory custom event handling in WebSocket\n *\n * @package App\\WebSocket\n */\nclass WebSocketEvent\n{\n    /**\n     * Handshake event\n     *\n     * @param \\swoole_http_request  $request\n     * @param \\swoole_http_response $response\n     * @return bool\n     */\n    public function onHandShake(\\swoole_http_request $request, \\swoole_http_response $response)\n    {\n        /** Here the custom handshake rule returns false when the handshake is aborted */\n        if (!$this-&gt;customHandShake($request, $response)) {\n            $response-&gt;end();\n            return false;\n        }\n\n        /** Here is the WebSocket handshake verification process in the RFC specification. It must be executed. Otherwise, the handshake cannot be performed correctly. */\n        if ($this-&gt;secWebsocketAccept($request, $response)) {\n            $response-&gt;end();\n            return true;\n        }\n\n        $response-&gt;end();\n        return false;\n    }\n\n    /**\n     * Custom handshake event\n     *\n     * @param \\swoole_http_request  $request\n     * @param \\swoole_http_response $response\n     * @return bool\n     */\n    protected function customHandShake(\\swoole_http_request $request, \\swoole_http_response $response): bool\n    {\n        /**\n         * Here you can get the corresponding data through http request\n         * After custom verification\n         * (Note) JavaScript does not support custom handshake request headers in the browser. You can only choose other methods such as get parameters.\n         */\n        $headers = $request-&gt;header;\n        $cookie = $request-&gt;cookie;\n\n        // if (If I don't meet some of my custom requirements, return false, the handshake fails.) {\n        //    return false;\n        // }\n        return true;\n    }\n\n    /**\n     * WebSocket handshake verification process in RFC specification\n     * The following must be mandatory\n     *\n     * @param \\swoole_http_request  $request\n     * @param \\swoole_http_response $response\n     * @return bool\n     */\n    protected function secWebsocketAccept(\\swoole_http_request $request, \\swoole_http_response $response): bool\n    {\n        // The verification process agreed in the ws rfc specification\n        if (!isset($request-&gt;header['sec-websocket-key'])) {\n            // Requires Sec-WebSocket-Key if no handshake is refused\n            var_dump('shake fai1 3');\n            return false;\n        }\n        if (0 === preg_match('#^[+/0-9A-Za-z]{21}[AQgw]==$#', $request-&gt;header['sec-websocket-key'])\n            || 16 !== strlen(base64_decode($request-&gt;header['sec-websocket-key']))\n        ) {\n            //Do not accept handshake\n            var_dump('shake fai1 4');\n            return false;\n        }\n\n        $key = base64_encode(sha1($request-&gt;header['sec-websocket-key'] . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11', true));\n        $headers = array(\n            'Upgrade'               =&gt; 'websocket',\n            'Connection'            =&gt; 'Upgrade',\n            'Sec-WebSocket-Accept'  =&gt; $key,\n            'Sec-WebSocket-Version' =&gt; '13',\n            'KeepAlive'             =&gt; 'off',\n        );\n\n        if (isset($request-&gt;header['sec-websocket-protocol'])) {\n            $headers['Sec-WebSocket-Protocol'] = $request-&gt;header['sec-websocket-protocol'];\n        }\n\n        // Send verified header\n        foreach ($headers as $key =&gt; $val) {\n            $response-&gt;header($key, $val);\n        }\n\n        // Accepting the handshake also requires a 101 status code to switch status\n        $response-&gt;status(101);\n        var_dump('shake success at fd :' . $request-&gt;fd);\n        return true;\n    }\n}\n Add the following code under the mainServerCreate method of the EasySwooleEvent.php file in the root directory\n//Note: Introduce the following namespace in this file\nuse EasySwoole\\Socket\\Dispatcher;\nuse App\\WebSocket\\WebSocketParser;\nuse App\\WebSocket\\WebSocketEvent;\n\npublic static function mainServerCreate(EventRegister $register): void\n{\n    /**\n     * **************** Websocket controller **********************\n     */\n    // Create a Dispatcher configuration\n    $conf = new \\EasySwoole\\Socket\\Config();\n    // Set Dispatcher to WebSocket mode\n    $conf-&gt;setType(\\EasySwoole\\Socket\\Config::WEB_SOCKET);\n    // Set the parser object\n    $conf-&gt;setParser(new WebSocketParser());\n    // Create a Dispatcher object and inject the config object\n    $dispatch = new Dispatcher($conf);\n    \n    // Register the relevant event for the server In the WebSocket mode, the on message event must be registered and passed to the Dispatcher object for processing.\n    $register-&gt;set(EventRegister::onMessage, function (\\swoole_websocket_server $server, \\swoole_websocket_frame $frame) use ($dispatch) {\n        $dispatch-&gt;dispatch($server, $frame-&gt;data, $frame);\n    });\n    \n    // Custom handshake event\n    $websocketEvent = new WebSocketEvent();\n    $register-&gt;set(EventRegister::onHandShake, function (\\swoole_http_request $request, \\swoole_http_response $response) use ($websocketEvent) {\n        $websocketEvent-&gt;onHandShake($request, $response);\n    });\n}\nCustom Close Event\nIn a common business scenario, we usually need to set a callback event when the user disconnects or the server actively disconnects.\nCreate the App/WebSocket/WebSocketEvent.php file and add the following\n/**\n * Closing event\n *\n * @param \\swoole_server $server\n * @param int            $fd\n * @param int            $reactorId\n */\npublic function onClose(\\swoole_server $server, int $fd, int $reactorId)\n{\n    /** @var array $info */\n    $info = $server-&gt;getClientInfo($fd);\n    /**\n     * Determine if this fd is a valid websocket connection\n     * See https://wiki.swoole.com/wiki/page/490.html\n     */\n    if ($info &amp;&amp; $info['websocket_status'] === WEBSOCKET_STATUS_FRAME) {\n        /**\n         * Determine if the connection is server actively closed\n         * see https://wiki.swoole.com/wiki/page/p-event/onClose.html\n         */\n        if ($reactorId &lt; 0) {\n            echo \"server close \\n\";\n        }\n    }\n}\n Add the following code under the mainServerCreate method of the EasySwooleEvent.php file in the root directory\n    /**\n     * **************** Websocket controller **********************\n     */\n    //Create a Dispatcher configuration\n    $conf = new \\EasySwoole\\Socket\\Config();\n    // Set Dispatcher to WebSocket mode\n    $conf-&gt;setType(\\EasySwoole\\Socket\\Config::WEB_SOCKET);\n    // Set the parser object\n    $conf-&gt;setParser(new WebSocketParser());\n    // Create a Dispatcher object and inject the config object\n    $dispatch = new Dispatcher($conf);\n\n    // Register the relevant event for the server In the WebSocket mode, the on message event must be registered and passed to the Dispatcher object for processing.\n    $register-&gt;set(EventRegister::onMessage, function (\\swoole_websocket_server $server, \\swoole_websocket_frame $frame) use ($dispatch) {\n        $dispatch-&gt;dispatch($server, $frame-&gt;data, $frame);\n    });\n\n    //Custom handshake event\n    $websocketEvent = new WebSocketEvent();\n    $register-&gt;set(EventRegister::onHandShake, function (\\swoole_http_request $request, \\swoole_http_response $response) use ($websocketEvent) {\n        $websocketEvent-&gt;onHandShake($request, $response);\n    });\n\n    //Custom close event\n    $register-&gt;set(EventRegister::onClose, function (\\swoole_server $server, int $fd, int $reactorId) use ($websocketEvent) {\n        $websocketEvent-&gt;onClose($server, $fd, $reactorId);\n    });","link":"/Socket/webSocketShake.html"},{"id":60,"title":"udp server","content":"udp application\nudp server is enabled, create sub-services in EasySwooleEvent.php\n\npublic static function mainServerCreate(EventRegister $register)\n{\n    $server = ServerManager::getInstance()-&gt;getSwooleServer();\n    $subPort = $server-&gt;addListener('0.0.0.0','9601',SWOOLE_UDP);\n    $subPort-&gt;on('packet',function (\\swoole_server $server, string $data, array $client_info){\n        var_dump($data);\n    });\n}\nUdp client\n\npublic static function mainServerCreate(EventRegister $register)\n{\n  //Add a custom process to do regular udp send\n   $server-&gt;addProcess(new \\swoole_process(function (\\swoole_process $process){\n        //Service is closed normally\n        $process::signal(SIGTERM,function ()use($process){\n            $process-&gt;exit(0);\n        });\n        //Broadcast by default 5 seconds\n        \\Swoole\\Timer::tick(5000,function (){\n            if($sock = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))\n            {\n                socket_set_option($sock,SOL_SOCKET,SO_BROADCAST,true);\n                $msg= '123456';\n                socket_sendto($sock,$msg,strlen($msg),0,'255.255.255.255',9602);//Broadcast address\n                socket_close($sock);\n            }\n        });\n    }));\n}","link":"/Socket/udp.html"},{"id":61,"title":"common problem","content":"How to traverse all links\nuse EasySwoole\\EasySwoole\\ServerManager;\n$server = ServerManager::getInstance()-&gt;getSwooleServer();\n$start_fd = 0;\nwhile(true)\n{\n    $conn_list = $server-&gt;getClientList($start_fd, 10);\n    if ($conn_list===false or count($conn_list) === 0)\n    {\n        echo \"finish\\n\";\n        break;\n    }\n    $start_fd = end($conn_list);\n    var_dump($conn_list);\n    foreach($conn_list as $fd)\n    {\n        $server-&gt;send($fd, \"broadcast\");\n    }\n}\nhttps://wiki.swoole.com/wiki/page/p-connection_list.html\nHow to get the link information\nUse EasySwoole\\EasySwoole\\ServerManager;\n$server = ServerManager::getInstance()-&gt;getSwooleServer();\n$fdinfo = $server-&gt;getClientInfo($fd);\n  Https://wiki.swoole.com/wiki/page/p-connection_info.html\nWhat are the development scenarios for Socket?\nh5 instant game\nWeb chat room\nIoT development\nServer udp broadcast\nCar Networking\nSmart Home\nweb web server","link":"/Socket/question.html"},{"id":62,"title":"ddl definition","content":"DDL\nThe Database Definition Language (DDL) is a language used to describe real-world entities to be stored in a database. Easyswoole provides a DDL library that is easy for users to define a database table structure.\nInstallation\ncomposer require easyswoole/ddl\nTest code\nuse EasySwoole\\DDL\\Blueprint\\Table;\nuse EasySwoole\\DDL\\DDLBuilder;\nuse EasySwoole\\DDL\\Enum\\Character;\nuse EasySwoole\\DDL\\Enum\\Engine;\n\n$sql = DDLBuilder::table('user', function (Table $table) {\n\n    $table-&gt;setTableComment('User table')//Set the table name/\n    -&gt;setTableEngine(Engine::MYISAM)//Setting the table engine\n    -&gt;setTableCharset(Character::UTF8MB4_GENERAL_CI);//Set table character set\n    $table-&gt;colInt('user_id', 10)-&gt;setColumnComment('User ID')-&gt;setIsAutoIncrement()-&gt;setIsPrimaryKey();\n    $table-&gt;colVarChar('username')-&gt;setColumnLimit(30)-&gt;setIsNotNull()-&gt;setColumnComment('用户名');\n    $table-&gt;colChar('sex', 1)-&gt;setIsNotNull()-&gt;setDefaultValue(1)-&gt;setColumnComment('Gender: 1 male, 2 female');\n    $table-&gt;colTinyInt('age')-&gt;setIsUnsigned()-&gt;setColumnComment('age')-&gt;setIsNotNull();\n    $table-&gt;colInt('created_at', 10)-&gt;setIsNotNull()-&gt;setColumnComment('Creation time');\n    $table-&gt;colInt('updated_at', 10)-&gt;setIsNotNull()-&gt;setColumnComment('Update time');\n    $table-&gt;indexUnique('username_index', 'username');//Setting index\n});\necho $sql;\n\n//Results are as follows\n\nCREATE TABLE `user` (\n  `user_id` int(10) NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '用户ID',\n  `username` varchar(30) NOT NULL COMMENT 'username',\n  `sex` char(1) NOT NULL COMMENT 'Gender: 1 male, 2 female',\n  `age` tinyint UNSIGNED NOT NULL COMMENT 'age',\n  `created_at` int(10) NOT NULL COMMENT 'Creation time',\n  `updated_at` int(10) NOT NULL COMMENT 'Update time',\n  UNIQUE INDEX `username_index` (`username`)\n)\nENGINE = MYISAM DEFAULT COLLATE = 'utf8mb4_general_ci' COMMENT = 'user table';\n","link":"/Components/ddl.html"},{"id":63,"title":"installation and use","content":"Mysqli\nInstallation\ncomposer require easyswoole/mysqli\nClient usage\n$config = new \\EasySwoole\\Mysqli\\Config([\n    'host'          =&gt; '',\n    'port'          =&gt; 3300,\n    'user'          =&gt; '',\n    'password'      =&gt; '',\n    'database'      =&gt; '',\n    'timeout'       =&gt; 5,\n    'charset'       =&gt; 'utf8mb4',\n]);\n\n$client = new \\EasySwoole\\Mysqli\\Client($config);\n\ngo(function ()use($client){\n    //Build sql\n    $client-&gt;queryBuilder()-&gt;get('user_list');\n    //Execute SQL\n    var_dump($client-&gt;execBuilder());\n});\nNeed to call execBuilder () to execute","link":"/Components/Mysqli/install.html"},{"id":64,"title":"basic use","content":"Query constructor\nQueryBuilder is a SQL constructor for constructing prepare sql. E.g:\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n//Execution conditional construction logic\n$builder-&gt;where('col1',2)-&gt;get('my_table');\n\n//Get the last query parameter\necho $builder-&gt;getLastQueryOptions();\n\n//Get subquery\necho $builder-&gt;getSubQuery();\n\n//Get the pre-processing sql statement of the last condition construct\necho $builder-&gt;getLastPrepareQuery();\n// SELECT  * FROM whereGet WHERE  col1 = ? \n\n//Get the pre-processing sql statement of the last condition construct, so the required binding parameters\necho $builder-&gt;getLastBindParams();\n//[2]\n\n//Get the sql statement of the last conditional construct\necho $builder-&gt;getLastQuery();\n//SELECT  * FROM whereGet WHERE  col1 = 2 ","link":"/Components/Mysqli/builder.html"},{"id":65,"title":"query","content":"Query data\nBasic query\nQuery a user data with id:\n$client-&gt;queryBuilder()-&gt;where('id', 1)-&gt;getOne('user_list');\nQuery multiple pieces of data:\n$client-&gt;queryBuilder()-&gt;where('is_vip', 1)-&gt;get('user_list');\nGet/getOne return value to view the detailed documentation in the chain operation\nYou can use the chain operation method arbitrarily before using the operation methods such as get and getOne","link":"/Components/Mysqli/query.html"},{"id":66,"title":"insert","content":"Adding data\nINSERT INTO\n$client-&gt;queryBuilder()-&gt;insert('insertTable', ['a' =&gt; 1, 'b' =&gt; \"b\"]);\nREPLACE INTO\n$builder-&gt;replace('replaceTable', ['a' =&gt; 1]);","link":"/Components/Mysqli/insert.html"},{"id":67,"title":"update","content":"Update data\nWHERE UPDATE\n$client-&gt;queryBuilder()-&gt;where('whereUpdate', 'whereValue')-&gt;update('updateTable', ['a' =&gt; 1]);\nLIMIT UPDATE\n$client-&gt;queryBuilder()-&gt;update('updateTable', ['a' =&gt; 1], 5);\nQuick update\n$client-&gt;queryBuilder()\n    -&gt;where('whereUpdate', 'whereValue')\n    -&gt;update('updateTable', [\n        'age'    =&gt; QueryBuilder::inc(1),\n        'number' =&gt; QueryBuilder::dec(3),\n    ]);","link":"/Components/Mysqli/update.html"},{"id":68,"title":"delete","content":"Delete data\nLIMIT DELETE\n$client-&gt;queryBuilder()-&gt;delete('user_list', 3);\nWHERE DELETE\n$client-&gt;queryBuilder()-&gt;where('whereUpdate', 'whereValue')-&gt;delete('user_list');","link":"/Components/Mysqli/delete.html"},{"id":69,"title":"limit","content":"limit\nThe limit method is mainly used to specify the number of queries and operations, especially when using paging queries.\nNumber of queries\nQuery 10 user data:\n$builder-&gt;limit(10)-&gt;get('user_list');\nPass the instructions\nMethod prototype\nfunction limit(int $one, ?int $two = null)\n\n$one If the second parameter is not passed, it means how many pieces of data are taken; if the second parameter is passed, it means starting from the first line.\n$tow Can not pass, if passed, it means starting from $one, taking $tow line data\n","link":"/Components/Mysqli/Chain/limitMethod.html"},{"id":70,"title":"fields","content":"fields\nThe main purpose is to identify the field value to be returned when querying\nSpecified field\n$builder-&gt;fields(['id','title'])-&gt;get('user_list');\nSet alias\n$builder-&gt;fields(['id','title as notice'])-&gt;get('user_list');\nUsing SQL functions\n$builder-&gt;fields(['id','SUM(score)'])-&gt;get('user_list');\nPass the instructions\nMethod prototype\nfunction fields($fields)\n\n$fields array|String can only pass in a field name if it is not an array\n","link":"/Components/Mysqli/Chain/fieldsMethod.html"},{"id":71,"title":"where","content":"where\nQuickly complete the construction of conditional statements. The parameters of the where method support strings and arrays.\nGeneral query\n$builder-&gt;where('col1', 2)-&gt;get('getTable');\nString statement\nYou can use string statements to build more complex conditions\n// Generate a rough statement: where status = 1 AND (id &gt; 10 or id &lt; 2)\n$builder-&gt;where('status', 1)-&gt;where(' (id &gt; 10 or id &lt;2) ')-&gt;get('getTable);\nSpecial operator\n$builder-&gt;where('id', [1,2,3], 'IN')-&gt;get('getTable');\n$builder-&gt;where('age', 12, '&gt;')-&gt;get('getTable');\nConnection condition\norWhere\n$builder-&gt;where('is_vip', 1)-&gt;where('id', [1,2], '=', 'OR')-&gt;get('getTable');\n$builder-&gt;where('is_vip', 1)-&gt;orWhere('id', [1,2])-&gt;get('getTable');\nPass the instructions\nMethod prototype\nfunction where($whereProp, $whereValue = 'DBNULL', $operator = '=', $cond = 'AND')\n\n$whereProp string Support indexed arrays, kv arrays, or directly passed strings\n$whereValue stringConditional value\n$operator string Operator\n$cond string Connection condition\n","link":"/Components/Mysqli/Chain/whereMethod.html"},{"id":72,"title":"orwhere","content":"orWhere\nQuickly complete conditional statement construction\nThe following two methods are equivalent\n$builder-&gt;where('is_vip', 1)-&gt;where('id', [1,2], '=', 'OR')-&gt;get('getTable');\n$builder-&gt;where('is_vip', 1)-&gt;orWhere('id', [1,2])-&gt;get('getTable');\nPass the instructions\nMethod prototype\nfunction orWhere($whereProp, $whereValue = 'DBNULL', $operator = '=')\n\n$whereProp string Support indexed arrays, kv arrays, or directly passed strings\n$whereValue stringConditional value\n$operator string Operator\n","link":"/Components/Mysqli/Chain/orWhereMethod.html"},{"id":73,"title":"orderby","content":"orderBy\nUsed to sort the results of an operation.\nBasic usage\nDefault DESC collation\n$builder-&gt;orderBy('col1', 'ASC')-&gt;get('getTable');\n$builder-&gt;where('col1',2)-&gt;orderBy('col1', 'ASC')-&gt;get('getTable');\nORDER BY FIELD\nCan be implemented by the third parameter\n$array = [\n    'a',\n    'b'\n];\n$builder-&gt;orderBy('', 'DESC', $array)-&gt;get('getTable');\nPrinciple of implementation\nif (is_array($customFieldsOrRegExp)) {\n    foreach ($customFieldsOrRegExp as $key =&gt; $value) {\n        $customFieldsOrRegExp[$key] = preg_replace(\"/[^\\x80-\\xff-a-z0-9\\.\\(\\),_` ]+/i\", '', $value);\n    }\n    $orderByField = 'FIELD (' . $orderByField . ', \"' . implode('\",\"', $customFieldsOrRegExp) . '\")';\n}\nORDER BY REGEXP\nCan be implemented by the third parameter\nPrinciple of implementation\nif (is_string($customFieldsOrRegExp)) {\n    $orderByField = $orderByField . \" REGEXP '\" . $customFieldsOrRegExp . \"'\";\n}\nPass the instructions\nMethod prototype\nfunction orderBy($orderByField, $orderbyDirection = \"DESC\", $customFieldsOrRegExp = null)\n\n$orderByField Sort field\n$orderbyDirection Sort rule\n$customFieldsOrRegExp Other conditions\n","link":"/Components/Mysqli/Chain/orderbyMethod.html"},{"id":74,"title":"groupby","content":"groupBy\nTypically used to combine aggregate functions to group result sets based on one or more columns.\nThe group method has only one argument and can only use strings.\nUse\n$builder-&gt;groupBy('is_vip')-&gt;get('getTable');\n$builder-&gt;groupBy('is_vip,level')-&gt;get('getTable');\nPass the instructions\nMethod prototype\nfunction groupBy($groupByField)\n\n$groupByField string Grouping field\n","link":"/Components/Mysqli/Chain/groupbyMethod.html"},{"id":75,"title":"having","content":"having\nUsed to match the group method to filter data (usually aggregated conditions) from the results of the grouping.\nUse\n$builder-&gt;groupBy('user_id')-&gt;having('times', 3,'&gt;')-&gt;get('getTable');\nPass the instructions\nMethod prototype\nfunction having($havingProp, $havingValue = 'DBNULL', $operator = '=', $cond = 'AND')\n\n\n$havingProp condition\n\n$havingValue value\n\n$operator string Operator\n\n$cond string Connection condition\n","link":"/Components/Mysqli/Chain/havingMethod.html"},{"id":76,"title":"orhaving","content":"orHaving\nUsed to match the group method to filter data (usually aggregated conditions) from the results of the grouping.\nUse\n$builder-&gt;groupBy('user_id')-&gt;orHaving('times', 3,'&gt;')-&gt;get('getTable');\nEquivalent to\n$builder-&gt;groupBy('user_id')-&gt;having('times', 3,'&gt;'，'OR')-&gt;get('getTable');\nPass the instructions\nMethod prototype\nfunction orHaving($havingProp, $havingValue = 'DBNULL', $operator = '=')\n\n$havingProp Condition\n$havingValue value\n$operator string Operator\n","link":"/Components/Mysqli/Chain/orHavingMethod.html"},{"id":77,"title":"join","content":"Join\njoin usually have the following types, and different types of join operations can affect the returned data results.\n\nINNER JOIN: Equivalent to JOIN (the default JOIN type), returning rows if there is at least one match in the table\nLEFT JOIN: Return all rows from the left table even if there is no match in the right table\nRIGHT JOIN: Return all rows from the right table even if there is no match in the left table\nFULL JOIN: Return rows as long as there is a match in one of the tables\n\nBasic use\n$builder-&gt;join('table2','table2.col1 = getTable.col2')-&gt;get('getTable');\nSpecified type\n$builder-&gt;join('table2','table2.col1 = getTable.col2','LEFT')-&gt;get('getTable');\nPass the instructions\nMethod prototype\nfunction join($joinTable, $joinCondition, $joinType = '')\n\n$joinTable Table Name\n$joinCondition Condition\n$joinType Type\n","link":"/Components/Mysqli/Chain/joinMethod.html"},{"id":78,"title":"joinwhere","content":"joinWhere\nPass the instructions\nMethod prototype\nfunction joinWhere($whereJoin, $whereProp, $whereValue = 'DBNULL', $operator = '=', $cond = 'AND')","link":"/Components/Mysqli/Chain/joinWhereMethod.html"},{"id":79,"title":"joinorwhere","content":"joinOrWhere\nPass the instructions\nMethod prototype\nfunction joinOrWhere($whereJoin, $whereProp, $whereValue = 'DBNULL', $operator = '=')","link":"/Components/Mysqli/Chain/joinOrWhereMethod.html"},{"id":80,"title":"union","content":"union\nBuild a UNION statement\nPass the instructions\nMethod prototype\nfunction union($cond, $isUnionAll = false)\n\n$cond   Condition\n$isUnionAll\n","link":"/Components/Mysqli/Chain/unionMethod.html"},{"id":81,"title":"lockinsharemode","content":"LockInShareModel\nLockInShareModel lock(InnoDb)\nPass the instructions\nMethod prototype\nfunction lockInShareMode($isLock = true)\n\n$isLock   \n","link":"/Components/Mysqli/Chain/lockInShareModeMethod.html"},{"id":82,"title":"selectforupdate","content":"selectForUpdate\nSELECT FOR UPDATE lock(InnoDb)\nPass the instructions\nMethod prototype\nfunction selectForUpdate($isLock = true)\n\n$isLock   \n","link":"/Components/Mysqli/Chain/selectForUpdateMethod.html"},{"id":83,"title":"setlocktablemode","content":"setLockTableMode\nLock table mode (read/write)\nPass the instructions\nMethod prototype\nfunction  setLockTableMode($method)\n\n$method  Read/write\n","link":"/Components/Mysqli/Chain/setLockTableModeMethod.html"},{"id":84,"title":"locktable","content":"lockTable\nObtain a table lock\nPass the instructions\nMethod prototype\nfunction lockTable($table)\n\n$table  Table name\n","link":"/Components/Mysqli/Chain/lockTableMethod.html"},{"id":85,"title":"unlocktable","content":"unlockTable\nRelease table lock\nPass the instructions\nMethod prototype\nfunction unlockTable()","link":"/Components/Mysqli/Chain/unlockTableMethod.html"},{"id":86,"title":"setqueryoption","content":"setQueryOption\nSet query conditions\nUsage\n$builder-&gt;setQueryOption(\"FOR UPDATE\")-&gt;where('whereUpdate', 'whereValue')-&gt;update('updateTable', ['a' =&gt; 1], 2);\nPass the instructions\nMethod prototype\nfunction setQueryOption($options)","link":"/Components/Mysqli/Chain/setQueryOptionMethod.html"},{"id":87,"title":"setprefix","content":"setPrefix\nSet table prefix\nPass the instructions\nMethod prototype\nfunction setPrefix($prefix = '')","link":"/Components/Mysqli/Chain/setPrefixMethod.html"},{"id":88,"title":"withtotalcount","content":"withTotalCount\nNumber of rows of statistical results\nQuery usage\nQuery the number of user lines:\n$builder-&gt;withTotalCount()-&gt;get(\"user\",null,\"*\");\nPass the instructions\nMethod prototype\nfunction withTotalCount(): QueryBuilder","link":"/Components/Mysqli/Chain/withTotalCountMethod.html"},{"id":89,"title":"replace","content":"replace\nReplace insert\nPass the instructions\nMethod prototype\nfunction replace($tableName, $insertData)\n\n$tableName Table Name\n$insertData Need to insert data\n","link":"/Components/Mysqli/Chain/replaceMethod.html"},{"id":90,"title":"onduplicate","content":"onDuplicate\nonDuplicate insertion\nPass the instructions\nMethod prototype\nfunction onDuplicate($updateColumns, $lastInsertId = null)\n\n$updateColumns Updated column\n$lastInsertId Can not pass, if passed, update the $lastInsertId line data\n","link":"/Components/Mysqli/Chain/onDuplicateMethod.html"},{"id":91,"title":"install","content":"ORM\nA new coroutine-safe ORM package from Easyswoole.\nInstallation\nDependency\n\nswoole &gt;= 4.4.8\n\nEasyswoole  &gt;=3.3.2 \nmysqli &gt; 2.x\n\n\ncomposer require easyswoole/orm\n\nOrm的功能是依赖于mysqli 2.x组件的，update的$data参数将会传递给mysqli构造sql。\n所以我们可以直接使用大部分mysqli的功能\n","link":"/Components/Orm/install.html"},{"id":92,"title":"configuration information registration","content":"Configuration information registration\nThe connection configuration information (database connection information) of the ORM needs to be registered in the &quot;Connection Manager&quot;.\nDatabase connection manager\nORM's connection management is done by the EasySwoole\\ORM\\DbManager class, which is a singleton class.\nuse EasySwoole\\ORM\\DbManager;\n\nDbManager::getInstance();\nRegister database connection configuration\nYou can register the connection in the framework mainServerCreate main service creation event.\nuse EasySwoole\\ORM\\DbManager;\nuse EasySwoole\\ORM\\Db\\Connection;\nuse EasySwoole\\ORM\\Db\\Config;\n\npublic static function mainServerCreate($register)\n{\n    $config = new Config();\n    $config-&gt;setDatabase('easyswoole_orm');\n    $config-&gt;setUser('root');\n    $config-&gt;setPassword('');\n    $config-&gt;setHost('127.0.0.1');\n\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n}\nDatabase connection comes with a connection pool description\nIn the default implementation, ORM comes with a connection class based on the connection pool `implementation.\nEasySwoole\\ORM\\Db\\Connection implements the use of the connection pool\nuse EasySwoole\\ORM\\DbManager;\nuse EasySwoole\\ORM\\Db\\Connection;\nuse EasySwoole\\ORM\\Db\\Config;\n\npublic static function mainServerCreate($register)\n{\n    $config = new Config();\n    $config-&gt;setDatabase('easyswoole_orm');\n    $config-&gt;setUser('root');\n    $config-&gt;setPassword('');\n    $config-&gt;setHost('127.0.0.1');\n    //Connection pool configuration\n    $config-&gt;setGetObjectTimeout(3.0); //Set the timeout period for getting the connection pool object\n    $config-&gt;setIntervalCheckTime(30*1000); //Set the detection connection to survive the cycle of recycling and creation\n    $config-&gt;setMaxIdleTime(15); //Maximum idle time of the connection pool object (seconds)\n    $config-&gt;setMaxObjectNum(20); //Set the maximum number of connection objects in the connection pool\n    $config-&gt;setMinObjectNum(5); //Set the minimum connection pool to have the number of connected objects\n\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n}\nDetailed connection pool properties introduction Click to view","link":"/Components/Orm/configurationRegister.html"},{"id":93,"title":"defining the table structure","content":"Defining the table structure\nAutomatically generate table structure\n$model = new User();\n$table = $model-&gt;schemaInfo();\nUse the schemaInfo() method in the model to get the structure of the current model specified data table and return an EasySwoole\\ORM\\Utility\\Schema\\Table object.\nThe model itself will automatically generate the table structure, but each time you start Easyswoole, it will re-acquire the table structure information and cache it in this service until the Easyswoole service stops or restarts.\nIf you don't want to request the database every time you restart, you can define the method and return the Table object.\nCustom Table Structure\nIn the model class, we implement a getSchemaInfo method that returns an EasySwoole\\ORM\\Utility\\Schema\\Table instantiated object.\nuse EasySwoole\\ORM\\Utility\\Schema\\Table;\nuse EasySwoole\\ORM\\AbstractModel;\n\nclass User extends AbstractModel\n{\n    protected $tableName = 'user';\n    /**\n     * Acquisition of the table\n     * Here you need to return an EasySwoole\\ORM\\Utility\\Schema\\Table\n     * @return Table\n     */\n    public function schemaInfo(bool $isCache = true): Table\n    {\n        $table = new Table($this-&gt;tableName);\n        $table-&gt;colInt('id')-&gt;setIsPrimaryKey(true);\n        $table-&gt;colChar('name', 255);\n        $table-&gt;colInt('age');\n        return $table;\n    }\n}\n\nTable Field\nIn the Table, there is a colX series method for representing the type of the table field, such as the Int, Char of the above example.\n$table-&gt;colInt('id');\n$table-&gt;colChar('name', 255);\nTable primary key\nIf you need to specify a field as the primary key, you can use the continuous operation mode and continue to specify it later.\n$table-&gt;colInt('id')-&gt;setIsPrimaryKey(true);","link":"/Components/Orm/DefineModel/defineTableStructure.html"},{"id":94,"title":"specify the connection name","content":"Specify the connection name\nFrom the Configuration Information Registration section, we already know that when registering configuration information, you can specify a `connection name' for this configuration.\nYou can specify the connection configuration to be used by the model class custom property connectionName. The default is default\nAssume that a read connection name configuration has been registered through the configuration information registration section.\nThen we can define the read connection name in the Model.\nClass AdminModel extends \\EasySwoole\\ORM\\AbstractModel\n{\n     Protected $connectionName = 'read';\n}\nYou can continue to see the Reading and Writing Separation section for further details on how to use different database configurations.","link":"/Components/Orm/DefineModel/specifyConnectionName.html"},{"id":95,"title":"timestamp","content":"Timestamp\nAdded automatic timestamp feature support after the ORM component version &gt;= 1.0.18.\nUsed to: automatically write time fields for creation and update\n\nWhen inserting data, automatically set the insertion time to current,\nWhen updating data, the update time is automatically set to current.\n\nHow to use\nUse \\EasySwoole\\ORM\\AbstractModel ;\n\nClass AdminModel extends AbstractModel\n{\n    // are optional, the default value to see the document below\n    Protected $autoTimeStamp = true;\n    Protected $createTime = 'create_at';\n    Protected $updateTime = 'update_at';\n}\nautoTimeStamp\nWhether to enable automatic timestamp, default value false\nOptional value:\n\ntrue field defaults to int type save timestamp\nint field is int type save timestamp\ndatetime field is datetime type Y-m-d H:i:s\n\ncreateTime\nData creation time field name, default value create_time\nOptional value\n\nany string corresponding to the field name in the table where the creation time is to be stored\nfalse, does not process the creation time field\n\nupdateTime\nData update time field name, default value update_time\nOptional value\n\nany string corresponding to the field name in the table where the creation time is to be stored\nfalse, does not process the update time field\n","link":"/Components/Orm/DefineModel/timestamp.html"},{"id":96,"title":"invoke execution","content":"orm invoke\nIn the case of high concurrency, the shorter the waste time is, the better the service efficiency can be improved.\nBy default, the ORM uses the defer method to obtain the connection resources in the pool, and returns them automatically when the collaboration exits. In this case, it will bring convenience and waste unnecessary resources.\nWe can use the invoke method to return resources as soon as the ORM query is finished, which can improve the utilization of resources.\nDbManager::getInstance()-&gt;invoke(function ($client){\n\n    $testUserModel = Model::invoke($client);\n    $testUserModel-&gt;state = 1;\n    $testUserModel-&gt;name = 'Siam';\n    $testUserModel-&gt;age = 18;\n    $testUserModel-&gt;addTime = date('Y-m-d H:i:s');\n\n    $data = $testUserModel-&gt;save();\n});\nMethod support\nIn this mode, there are two main methods to be explained.\n\nInvoke method under DbManager (get a connection from the connection pool and return the connection when the closure is completed)\nInvoke method of Model (inject client connection, no longer get from defer in connection pool)\n","link":"/Components/Orm/invokeExecution.html"},{"id":97,"title":"custom sql execution","content":"Custom SQL execution\nSometimes you may need to use a native expression in your query. You can construct a native SQL expression using QueryBuilder\nThe ORM internally relies on the QueryBuilder of the mysqli component.\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$queryBuild = new QueryBuilder();\n$queryBuild-&gt;raw(\"show tables\");\n\n// The second parameter raw specifies true, which means that the native sql is executed.\n// The third parameter connectionName specifies the connection name to use, the default default\n$data = DbManager::getInstance()-&gt;query($queryBuild, true, 'default');\n\nExecuted by Model\n// Note that the sql statement here is just an example.\n// The correct recommended practice should still be to query the table corresponding to the Model class, get the data of the table structure field\n$data = Model::create()-&gt;get(function ($queryBuild){\n    $queryBuild-&gt;raw(\"shwo tables\");\n});\nNative SQL expressions will be injected into the query as strings, so you should be careful to avoid creating SQL injection vulnerabilities.","link":"/Components/Orm/customSqlExecution.html"},{"id":98,"title":"last result","content":"Results of Enforcement\nWhen a model executes a statement, it will save the execution result to$model-&gt;lastQueryResult()and the method will return anEasySwoole\\ORM\\Db\\Resultobject\n&lt;?php\n$model = new AdminModel();\n$model-&gt;all();\n//Get query result object\n$lastResult = $model-&gt;lastQueryResult();\n//Get the total number of query data. You need to call`withTotalCount`to use this method\nvar_dump($lastResult-&gt;getTotalCount());\n//Get the last inserted ID\nvar_dump($lastResult-&gt;getLastInsertId());\n//Get the number of data affected by execution using update, delete and other methods\nvar_dump($lastResult-&gt;getAffectedRows());\n//Get error code\nvar_dump($lastResult-&gt;getLastErrorNo());\n//Get error message\nvar_dump($lastResult-&gt;getLastError());\n//Get the result of executing MySQL\nvar_dump($lastResult-&gt;getResult());\n\n// The following is provided after version &gt; = 1.2.2\n\n// Get the first of the results\nvar_dump($lastResult-&gt;getResultOne());\n// Get a column in the result\nvar_dump($lastResult-&gt;getResultColumn(string $column));\n// Get the first data of a column in the result\nvar_dump($lastResult-&gt;getResultScalar(string $column));\n// Return the result array with a field named key\nvar_dump($lastResult-&gt;getResultIndexBy(string $column));\nWhen $model executes get, all, save and other similar methods, it can get error messages for debugging by calling GetLastError method:::","link":"/Components/Orm/lastResult.html"},{"id":99,"title":"last query","content":"Last execution statement\nAfter a model executes a statement, it will save the executed statement to $model - &gt; lastquery():\n&lt;?php\n$model = new AdminModel();\n//Execute all query\nvar_dump($model-&gt;all());\n//Print last executed`EasySwoole\\Mysqli\\QueryBuilder` object\nvar_dump($model-&gt;lastQuery());\n//Print the last executed SQL statement\nvar_dump($model-&gt;lastQuery()-&gt;getLastQuery());\n$model->lastQuery() Query object is returned, and specific documents can be viewed:Query Builder 文档","link":"/Components/Orm/lastQuery.html"},{"id":100,"title":"transaction operation","content":"Transaction operation\nOpen transaction\nPass the instructions\n\n\n\nParameter Name\nRequired\nParameter Description\n\n\n\n\nconnectionNames\nNo\nOpen the connection name of the transaction; string or array is specified in addConnection. Under normal circumstances, no special settings are required.\n\n\n\nReturn Description: bool returns true if it is successful, false if it fails to open\nDbManager::getInstance()-&gt;startTransaction($connectionNames = 'default');\nSubmitting a transaction\nPass the instructions\n\n\n\nParameter Name\nRequired\nParameter Description\n\n\n\n\nConnectName\nNo\nSpecifies to submit a connection name, if not passed, automatically submit the transaction connection obtained in the current coroutine. In general, no special settings are required.\n\n\n\nReturn Description: bool returns true if the submission is successful, false if it fails\nDbManager::getInstance()-&gt;commit($connectName = null);\nRollback transaction\nPass the instructions\n\n\n\nParameter Name\nRequired\nParameter Description\n\n\n\n\nConnectName\nNo\nSpecifies to submit a connection name, if not passed, automatically submit the transaction connection obtained in the current coroutine. In general, no special settings are required.\n\n\n\nReturn Description: bool returns true if the submission is successful, false if it fails\nDbManager::getInstance()-&gt;rollback();\nTransaction use case\n$user = UserModel::create()-&gt;get(4);\n\n$user-&gt;age = 4;\n// Open the transaction\n$strat = DbManager::getInstance()-&gt;startTransaction();\n\n// update operation\n$res = $user-&gt;update();\n\n// Roll back directly regardless of whether the update succeeded or failed\n$rollback = DbManager::getInstance()-&gt;rollback();\n\n// returns false because the connection has been rolled back. The transaction is closed.\n$commit = DbManager::getInstance()-&gt;commit();\nVar_dump($commit);","link":"/Components/Orm/transactionOperations.html"},{"id":101,"title":"read and write separation","content":"Read and write separation\nRegister read and write link configuration information\nFirst, we need to register to read/write the information of the two links according to Configuration Information Registration.\nThe main code is probably as follows\nDbManager::getInstance()-&gt;addConnection($con, 'read');\nDbManager::getInstance()-&gt;addConnection($con2, 'write');\nSpecify to use the link\nThere are two ways to use it. You can choose according to your needs.\nMainly use the connection() method provided by AbstractModel\nFunction connection(string $name, bool $isTemp = false)\nThe second parameter needs to be passed as true, indicating temporary use, otherwise it is considered to be fixed use (the effect is equivalent to defining the connectionName attribute in the class)\nModel inheritance definition\nClass Test extends AbstractModel{\n     /** This is because you are not using the default configuration link name, so you need to specify */\n     Protected $connectionName = 'write';\n    \n     /** get method uses read link */\n     Public function get($where = null, bool $returnAsArray)\n     {\n         $this-&gt;connection('read', true);\n         Return parent::get($where, $returnAsArray);\n     }\n}\nExternal use\nTest::create()-&gt;connection('read',true)-&gt;all();","link":"/Components/Orm/readWriteSeparation.html"},{"id":102,"title":"inquire","content":"Inquire\nQuery a line\n\nget($where, $returnAsArray = false)\nfindOne(where) is equivalent to the equivalent get($where, true)\n\nQuery multiple lines\n\nall($where, $returnAsArray = false)\nselect(where) is equivalent to the equivalent all($where, true)\nfindAll(where) is equivalent to the equivalent all($where, true)\n\nReturn value description\n\n\nget returns an instance of EasySwoole\\ORM\\AbstractModel, which can be ** reused to perform other operations on the model. Returns null when there is no query result.\n\n\nall returns an array with each element inside it being an instance of EasySwoole\\ORM\\AbstractModel\n\n\nWhen get/all has an error, it returns false and the user can get lastError by itself.\n\n\nfindOne returns an array of key-value pairs\n\n\nselect, findAll returns a two-dimensional array, returning null when there is no query result.\n\n\nMultiple transmission methods\nIn the above list of methods, the most important is the $where parameter, which can be used in multiple ways.\n// via the primary key\n$res = UserModel::create()-&gt;get(1);\n// Through the key =&gt; value array\n$res = UserModel::create()-&gt;get([\n  'u_id' =&gt; 1,\n  'u_state' =&gt; 0,\n  'is_vip' ​​=&gt; 1\n]);\n// Through the closure method, construct a complex sql\n// This is a very powerful and flexible way. The closure parameter is a mysqli component query constructor that can call all consecutive operations.\n// http://www.easyswoole.com/Components/Mysqli/builder.html\n$res = UserModel::create()-&gt;get(function(QueryBuilder $queryBuilder){\n    $queryBuilder-&gt;where('u_state', 1);\n    $queryBuilder-&gt;where('age', 12, '&gt;');// Various special operators between like : != etc. can be completed\n    $queryBuilder-&gt;order('u_id');\n});\n// Consistent operation, continue to view the ORM documentation\n$res = UserModel::create()-&gt;where('u_id', 1)-&gt;get();\nPagination\nLimit and withTotalCount, get the paging list data and the total number of bars.\nThe following simulation obtains the page data of the page, the page is the page number, and the limit is how many numbers are displayed per page.\n$page = 1; // current page number\n$limit = 10; // How many data per page\n\n$model = AdminModel::create()-&gt;limit($limit * ($page - 1), $limit * $page - 1)-&gt;withTotalCount();\n\n// list data\n$list = $model-&gt;all(null, true);\n\n$result = $model-&gt;lastQueryResult();\n\n// total number of articles\n$total = $result-&gt;getTotalCount();\nError getting\n$user = UserModel::create()-&gt;where(['There is an error in the case of a field that does not exist' =&gt; 1])-&gt;get();\nIf ($user === false){\n     Echo $user-&gt;lastQueryResult()-&gt;getLastError();\n}","link":"/Components/Orm/query.html"},{"id":103,"title":"quick query","content":"Quick Query\nDependency relationship\n\nmysqli &gt;=2.1.2\nORM &gt;= 1.2.5\n\nQuery the specified field value of a single line\n\nval(string $column)\nscalar(?string $column = null)\n\nQuery multiple rows of specified field values\n\ncolumn(?string $column = null)\nindexBy(string $column)\n\nReturn value description\n\n\nval When the row data exists and the field exists, the field value is returned.\nWhen the field does not exist, the row data array is returned.\nWhen the row does not exist, return null\n\n\nscalar When the qualified data exists, the first data field value is returned.\nWhen the condition does not exist，Returns an empty array.\nWhen no parameter is passed, the primary key value is returned by default.\n\n\ncolumn Returns an array of values for the field.\nWhen the parameter is not passed, the primary key array is returned by default.\n\n\nindexByReturns an array of data with the specified field as the key.\n\n\n示例\n\n// val Directly return a column of a row\n$res = UserModel::create()-&gt;val('loginName');\nvar_dump($res);\n\n// column A column of quick query results\n$res = UserModel::create()-&gt;column('loginName');\nvar_dump($res);\n\n// scalar First data in a column of quick query results\n$res = UserModel::create()-&gt;scalar('loginName');\nvar_dump($res);\n\n// indexBy Return the result array with the data of a field name\n$res = UserModel::create()-&gt;indexBy('loginName');\nvar_dump($res);\n","link":"/Components/Orm/quickQuery.html"},{"id":104,"title":"special query","content":"Special Query\nfind_in_set\nGenerating conditions  find_in_set(1, name)\n? represents parameter binding. You can write the conditions directly. The second parameter is not passed, but you need to pay attention to prevent injection risk\n$data = Model::create()-&gt;where(\"find_in_set(?, name)\", [1])-&gt;get();\ncomplex where or\n// Generate approximate statements：where status = 1 AND (id &gt; 10 or id &lt; 2)\nModel::create()-&gt;where('status', 1)-&gt;where(' (id &gt; 10 or id &lt;2) ')-&gt;get();","link":"/Components/Orm/specialQuery.html"},{"id":105,"title":"add","content":"New\nTo add a new record to the database, first create a new model instance, set the properties for the instance, and then call the save method:\n$model = new UserModel();\n// Different ways of setting values\n$model-&gt;setAttr('id', 7);\n$model-&gt;name = 'name';\n$model['name'] = 'name';\n\n$res = $model-&gt;save();\nvar_dump($res); // Returns the value of the self-incrementing id or primary key. If it fails, it returns null.\nIn this example, we assign id and name to the id and name attributes of the UserModel model instance. When the save method is called, a new record will be inserted.\nArray assignment\nYou can pass in the array [field name=&gt;field value] and call the save method to save it.\n$model = UserModel::create([\n    'name' =&gt; 'siam',\n    'age'  =&gt; 21,\n]);\n\n$res = $model-&gt;save();\n// data($data, $setter = true)  \n// The second parameter can determine whether you want to call the modifier (if you want to set it, the documentation below)\n$user = UserModel::create()-&gt;data([\n    'name' =&gt; 'siam',\n    'age'  =&gt; 21,\n], false)-&gt;save();","link":"/Components/Orm/add.html"},{"id":106,"title":"delete","content":"delete\nDeleting records uses the destroy method, which can pass in multiple expression type parameters. The number of records that are affected after execution\nBy existing model\nThis approach is our most recommended, and is the core idea of the ORM component, mapping the operation of the data to the operation of the object.\n$user = UserModel::create()-&gt;get(1);\n$user-&gt;destroy();\nBy Primary Key\n$res = UserModel::create()-&gt;destroy(1); //by specifying the primary key directly (if it exists)\n$res = UserModel::create()-&gt;destroy('2,4,5');//Specify multiple parameters for each parameter as a different primary key\n$res = UserModel::create()-&gt;destroy([3, 7]);//Array specifies multiple primary keys\nBy where condition\n$res = UserModel::create()-&gt;destroy(['age' =&gt; 21]);//Array specifies where condition results are removed\n$res = UserModel::create()-&gt;destroy(function (QueryBuilder $builder) {\n     $builder-&gt;where('id', 1);\n});\nDelete full table data\nIf you need to empty the table, you can use the destroy method to pass in (null, true), which will delete all rows.\n$res = UserModel::create()-&gt;destroy(null,true);","link":"/Components/Orm/delete.html"},{"id":107,"title":"update","content":"Update\n\nThe function of ORM depends on mysqli2.x component. The $data parameter of update will be passed to mysqli to construct SQL.\nSo we can use most of mysqli's functions directly\n\nBy existing model\nThis approach is our most recommended, and is the core idea of the ORM component, mapping the operation of the data to the operation of the object.\n$user = UserModel::create()-&gt;get(1);\n$user-&gt;update([\n  'is_vip' =&gt; 1\n]);\n\n$user = UserModel::create()-&gt;get(1);\n// After the specified field assignment\n$user-&gt;is_vip = 1;\n$user-&gt;update();\nvia where update\nupdate parameter 1 is passed to the update array [field name=&gt;field value], parameter 2 is passed where condition array\n$res = UserModel::create()-&gt;update([\n     'name' =&gt; 'new'\n], ['id' =&gt; 1]);\nThe number of rows affected by the actual update\nUpdate returns the execution statement is successful, only false when the mysql statement error, otherwise true\n, so you need getAffectedRows to determine if the update is successful.\n$user = UserModel::create()-&gt;get(1);\n$user-&gt;update([\n  'is_vip' =&gt; 1\n]);\nvar_dump($user-&gt;lastQueryResult()-&gt;getAffectedRows());\nGet specific syntax errors\nIf update returns false, then there is an error on your statement, you can get specific error information through getLastError\n$user = UserModel::create()-&gt;get(1);\n$suc = $user-&gt;update([\n   'is_vip' =&gt; 1\n]);\nIf($suc=== false){\nVar_dump($user-&gt;lastQueryResult()-&gt;getLastError());\n}\n\nEffective field description\nThe data in the model is divided into normal data and auxiliary data.\nIf the table structure has data for the field, it belongs to normal data, and the others belong to the ancillary data.\nRecommended update usage\nFirst map the correct data object through the model, then change the value and update.\nThe fields within the table structure will be automatically validated. Other ancillary data does not make up update sql.\n$user = UserModel::create()-&gt;get(1);\n$user-&gt;is_vip = 1;\n$user['vip_time'] = 15;\n$res = $user-&gt;update();\nBatch update\nIn this way, the data of the non-table structure fields will not be filtered, and all of them constitute sql, which may cause mysql error.\n$res = UserModel::create()-&gt;update([\n   'is_vip' =&gt; 0,\n   'test' =&gt; 3333, // table structure does not exist in the field\n], [\n   'vip_time' =&gt; 0\n]);\nQuick update\nTestUserModel::create()-&gt;update([\n    'age' =&gt; QueryBuilder::inc(3), // Self increment 3\n    'test' =&gt; QueryBuilder::dec(4), // Self descending 4\n], [\n    'name' =&gt; 'Siam222'\n]);","link":"/Components/Orm/update.html"},{"id":108,"title":"coherent operation","content":"Coherent operation\nThe chain operation method provided by ORM can effectively improve the code definition and development efficiency of data access.\nwhere\nYou can use the where method. The most basic way to call where is to pass a parameter\nThis parameter can pass a variety of different performances:\nPrimary key\n// Primary key\n$user = UserListModel::create()-&gt;where(1)-&gt;get();\n\n// Multiple primary keys\n$user = UserListModel::create()-&gt;where([1,2,3])-&gt;all();\nArray\n// [field name =&gt; field value] array mode\n$user = UserListModel::create()-&gt;where(['state' =&gt; 1])-&gt;get();\n\n// Complex condition array\n$user = UserListModel::create()-&gt;where([\n    'age'  =&gt; [[18,23], 'between'],\n    'name' =&gt; ['siam', 'like', 'or'],\n])\nNative sql\n$user = UserListModel::create()-&gt;where(\"Sql statement needs to pay attention to the injection risk\")-&gt;get();\nOther Mysqli chain operation where the reference parameter\nImplement the where in the EasySwoole\\Mysqli\\QueryBuilder\nMore operations can also refer to the where section of the Mysqli chain operation\n// Take the builder where is the native\n$getCoherent5 = UserListModel::create()-&gt;where('id', 1, '=')-&gt;get();\n$getCoherent6 = UserListModel::create()-&gt;where('id', 1, '!=')-&gt;get();\n$getCoherent6 = UserListModel::create()-&gt;where('id', 1, 'like')-&gt;get();\nalias\nalias is used to set the alias of the current data table\n$res = TestUserListModel::create()-&gt;alias('siam')-&gt;where(['siam.name' =&gt; 'test'])-&gt;all();\ngroup\nThe group method can group the results.\n$group = TestUserListModel::create()-&gt;field('sum(age) as age, `name`')-&gt;group('name')-&gt;all(null);\norder\nThe order method can be used to set the native string to the value of the order by clause:\n$order = TestUserListModel::create()-&gt;order('id', 'DESC')-&gt;get();\njoin\nJoins usually have the following types, and different types of join operations can affect the returned data results.\n\nINNER JOIN: is equivalent to JOIN (the default JOIN type), returning rows if there is at least one match in the table\nLEFT JOIN: returns all rows from the left table even if there is no match in the right table\nRIGHT JOIN: returns all rows from the right table even if there is no match in the left table\nFULL JOIN: return rows as long as there is a match in one of the tables\n\nobject join ( mixed $joinTable , string $joinCondition = null [, string $type = 'INNER'] )\n$joinTable (complete) table name and alias to be associated\n$joinCondition association condition.\n$type association type. Can be: 'LEFT', 'RIGHT', 'OUTER', 'INNER', 'LEFT OUTER', 'RIGHT OUTER', 'NATURAL', case insensitive, defaults to INNER (database software default).\n$join = TestUserListModel::create()-&gt;join('table2','table2.col1 = user_list.col2')-&gt;get();\n\n$join2 = TestUserListModel::create()-&gt;alias('list')-&gt;join('table2 as t2','t2.col1 = list.col2')-&gt;get();","link":"/Components/Orm/coherentOperation.html"},{"id":109,"title":"polymerization","content":"aggregation\nORM also provides various aggregation methods such as count, max, min, avg, and sum. You can call any method after constructing the query:\nmax\n$max = TestUserListModel::create()-&gt;max('age');\nmin\n$min = TestUserListModel::create()-&gt;min('age');\ncount\n// count No need to pass field name\n$count = TestUserListModel::create()-&gt;count();\navg\n$avg = TestUserListModel::create()-&gt;avg('age');\nsum\n$sum = TestUserListModel::create()-&gt;sum('age');","link":"/Components/Orm/aggregation.html"},{"id":110,"title":"getter","content":"Getter\nThe function of the getter is to automatically process the field value of the data.\nTo define an acquirer, you must create a &quot;get field name Attr&quot; method on your model.\nThe getter method of the field to be accessed needs to be named using &quot;Little Hump&quot;. In this example, we will define an accessor for the status property.\nThe fields of the data table are automatically converted to hump method access when using the getter\nThis accessor is called automatically when an ORM instance attempts to get the value of status :\nClass UserModel extends AbstractModel\n{\n    /**\n     * $value mixed is the original value\n     * $data array is the current model all values\n     */\n    Protected function getStatusAttr($value, $data)\n    {\n        $status = [-1=&gt;'delete', 0=&gt;'disabled', 1=&gt;'normal', 2=&gt;'pending'];\n        Return $status[$value];\n    }\n}\nThe getter can also define fields that do not exist in the data table, for example:\nProtected function getEasyswooleAttr($value,$data)\n{\n  Return 'Easyswoole user-'.$data['id'];\n}\nThen we can use this easyswoole field on the outside.\n$res = UserModel::create()-&gt;get(4);\nvar_dump($res-&gt;easyswoole);","link":"/Components/Orm/getter.html"},{"id":111,"title":"modifier","content":"modifier\nThe role of the modifier is to automatically process when the model instance modifies the field assignment\nTo define a modifier, you must create a &quot;set field name Attr&quot; method on your model.\nThe modifier method to be defined needs to be named using &quot;Little Hump&quot;. In this example, we will define a modifier for the name property.\nThe fields of the data table are automatically converted to hump method access when using the getter\nThis modifier is called automatically when the model instance attempts to modify the value of the name field:\nClass UserModel extends AbstractModel\n{\n     /**\n      * $value mixed is the original value\n      * $data array is the current model all values\n      */\n     Protected function setNameAttr($value, $data)\n     {\n         Return $value.\"_plus a uniform suffix\";\n     }\n}\nThe following code will be saved by the modifier when the settings are saved.\n$model = new UserModel([\n     'name' =&gt; 'siam',\n     'age' =&gt; 21,\n]);\n$model-&gt;save();\n//name is stored as: siam_ plus a uniform suffix","link":"/Components/Orm/modifier.html"},{"id":112,"title":"one-to-one association","content":"One to one Association\nDefinition\nFor example, a user model might be associated with a relationship model.\nIn order to define this association, we need to write a relationship method in the user model. Call the hasone method inside the relation method and return the result:\nThe first parameter of the hasone method is the class name of the associated model.\npublic function relation()\n{\n    return $this-&gt;hasOne(Relation::class);\n}\nModel association methods allow you to add custom restrictions to associations\nThe following case shows that the u id in the relation table is equal to the ID value of the current model (assuming user)\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\npublic function settingWhere()\n{\n    return $this-&gt;hasOne(Relation::class, function(QueryBuilder $query){\n        $query-&gt;where('u_id', $this-&gt;id);\n        $query-&gt;where('status', 1);\n        return $query;\n    });\n}\nORM Automatically associate based on the primary key column of the associated model。\nIn this case, the relationship ID primary key is used automatically. If you want to override this Convention, you can pass the third and fourth parameters to the hasone method:\nThe third parameter is the 'column' of the current model, and the fourth parameter is the corresponding 'column' of the associated model`\npublic function settingWhere()\n{\n    return $this-&gt;hasOne(Relation::class, null, 'id', 'user_id');\n}\nuse\nOnce the model association is defined, we can use the ORM dynamic properties to get the relevant records. Dynamic properties allow you to access relational methods just like properties defined in the model:\nIf the query is not found, it will be null. If the query is not found, the instance of a model class can continue to call ORM for quick update and deletion\n$res = User::create()-&gt;get(1);\n$hasOneRelation = $res-&gt;relation; //The access is actually the result of the relation method processing; the return is the relation model object\n\n$userid = $hasOneRelation-&gt;user_id;","link":"/Components/Orm/Associat/oneToOneAssociations.html"},{"id":113,"title":"one-to-many association","content":"One-to-many association\nDefinition\nFor example, a user model may be associated with multiple relationship models.\nIn order to define this association, we need to write a relationship method in the user model. Call the hasmany method inside the relation method and return the result:\nThe first parameter of the hasmany method is the class name of the associated model.\npublic function relation()\n{\n    return $this-&gt;hasMany(Relation::class);\n}\nModel association methods allow you to add custom restrictions to associations\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\npublic function settingWhere()\n{\n    return $this-&gt;hasMany(Relation::class, function(QueryBuilder $query){\n        $query-&gt;where('u_id', $this-&gt;id);\n        $query-&gt;where('status', 1);\n        return $query;\n    });\n}\nThe ORM automatically associates based on the primary key column of the associated model.\nIn this case, the relationship ID primary key is used automatically. If you want to override this Convention, you can pass the third and fourth parameters to the hasmany method:\nThe third parameter is the 'column' of the current model, and the fourth parameter is the corresponding 'column' of the associated model`\npublic function settingWhere()\n{\n    return $this-&gt;hasMany(Relation::class, null, 'id', 'user_id');\n}\nuse\nOnce the model association is defined, we can use the ORM dynamic properties to get the relevant records. Dynamic properties allow you to access relational methods just like properties defined in the model:\nIf the query is not found, it will be null. If the query is not found, it will be an array. Each array element is an instance of the model class. You can continue to call ORM for quick update and deletion\n$userModel = User::create()-&gt;get(1);\n$hasManyRelation = $userModel-&gt;relation; //The access is actually the result of the processing of the relation method; what is returned is that each array element of the array is a relation model object\n\n$userId = [];\nforeach($res-&gt;relation as $relationModel) {\n    $userId[] = $relationModel-&gt;user_id;\n}","link":"/Components/Orm/Associat/oneToManyAssociations.html"},{"id":114,"title":"associated pre query","content":"Associated pre query\nIn normal association, we can quickly associate query data after defining the relationship in the model class file.\nBut at this time, we still need to get the association name manually to execute.\nPre query provides a way to automatically query the usage of associated data as soon as the master data is queried.\nORM version requires&gt;= 1.2.0\nwith method\nThe with method passes in an array containing the association name already defined in the class file\n$res = Model::create()-&gt;with(['user_list', 'user_store'])-&gt;get(1);\n\nvar_dump($res); // At this time, there are already data of two associated fields, user list and user sotre. It is no longer necessary to call them manually first.","link":"/Components/Orm/Associat/preWithQuery.html"},{"id":115,"title":"callback event","content":"Callback event\nFor the overall situation onQuery\nSet callback events for the global as follows:\n// When registering ORM, call the callback function\npublic static function mainServerCreate(EventRegister $register)\n{\n    ...\n\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n    DbManager::getInstance()-&gt;onQuery(function ($res, $builder, $start) {\n        // Print parameter or write log\n    });\n}\nThe onquery callback will inject three parameters\n\n\nresQuery result object, class name isEasySwoole\\ORM\\Db\\Result\n\n\nCan refer to results of enforcement Document for more results\n\n\nbuilderQuery statement object, class name isEasySwoole\\Mysqli\\QueryBuilder\n\n\nstartStart query timestamp, unit iss, type is float\n\n\nIf the withTotalCount () method is invoked during the query, there will be second callback results.\nIt should be noted that this callback party legal must be called when registering ORM, otherwise no result will be generated\nModel specific onQuery\nIf we don't want to use the global onquery, we can call the onquery method when we perform the operation, so as to realize the callback for a specific model\n$res = User::create()-&gt;onQuery(function ($res, $builder, $start) {\n    // Print parameter or write log\n})-&gt;get(1);\nThe three parameters of callback injection are the same as the global onquery\nLog slow\nWe can manually determine the execution time to achieve a slow log recording function\npublic static function mainServerCreate(EventRegister $register)\n{\n    ...\n\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n    DbManager::getInstance()-&gt;onQuery(function ($res, $builder, $start) {\n        $queryTime = Query time threshold;\n        if (bcsub(time(), $start, 3) &gt; $queryTime) {\n            // Write log\n        }\n    });\n}","link":"/Components/Orm/Event/onQuery.html"},{"id":116,"title":"model event","content":"Model events\nModel event refers to the behavior event triggered when the model performs write, modify, and delete operations\nMethod list\n\n\n\nEvent name\nEvent description\nparameter\n\n\n\n\nonBeforeInsert\nPre insert event\n$model\n\n\nonAfterInsert\nPost insert event\n$model, $res\n\n\nonBeforeUpdate\nEvents before update\n$model\n\n\nonAfterUpdate\nPost update events\n$model, $res\n\n\nonBeforeDelete\nEvent before deleting\n$model\n\n\nonAfterDelete\nEvent after deletion\n$model, $res\n\n\n\n\n$model Current model instance\n$res The execution result of the current behavior is the same as bool type false when the execution fails. There are two situations when the execution succeeds:\nExecution of onafterdelete event: Int affects the number of records, other events: bool type true:::\nModel events will not be available if ORM version is less than 1.1.19\n\nclass User extends AbstractModel\n{\n    /**\n     * @var string\n     */\n    protected $tableName = 'users';\n\n    public static $insert = false;\n    public static $update = false;\n    public static $delete = false;\n\n    protected static function onBeforeInsert($model)\n    {\n        return self::$insert;\n    }\n\n    protected static function onAfterInsert($model, $res)\n    {\n\n    }\n\n    protected static function onBeforeUpdate($model)\n    {\n        return self::$update;\n    }\n\n    protected static function onAfterUpdate($model, $res)\n    {\n\n    }\n\n    protected static function onBeforeDelete($model)\n    {\n        return self::$delete;\n    }\n\n    public static function onAfterDelete($model, $res)\n    {\n\n    }\n}","link":"/Components/Orm/Event/model.html"},{"id":117,"title":"install and use","content":"Elasticsearch\nInstall\ncomposer require easyswoole/elasticsearch\nClient\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Search();\n    $bean-&gt;setIndex('my_index');\n    $bean-&gt;setType('my_type');\n    $bean-&gt;setBody(['query' =&gt; ['matchAll' =&gt; []]]);\n    $response = $elasticsearch-&gt;client()-&gt;search($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n})\nx-pack validation\nWhen elastic search turns on x-pack login verification, just pass in the username and password in config\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200,\n    'username'      =&gt; 'elastic',\n    'password'      =&gt; '123456'\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\nModify HTTP to HTTPS\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200,\n    'username'      =&gt; 'elastic',\n    'password'      =&gt; '123456',\n    'scheme'        =&gt; 'https'\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);","link":"/Components/Elasticsearch/install.html"},{"id":118,"title":"insert","content":"Insert\nSingle insertion\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Create();\n    $bean-&gt;setIndex('my_index');\n    $bean-&gt;setType('my_type');\n    $bean-&gt;setId('my_id');\n    $bean-&gt;setBody(['test_field' =&gt; 'test_data']);\n    $response = $elasticsearch-&gt;client()-&gt;create($bean)-&gt;getBody();\n    $response = json_decode($response,true);\n    var_dump($response['result']);\n})\nBulk insert\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Bulk();\n    $bean-&gt;setIndex('my_index');\n    $bean-&gt;setType('my_type');\n\n    $body = [];\n    for ($i = 1; $i &lt;= 5; $i++) {\n        $body[] = [\n            'create' =&gt; [  \n                '_index' =&gt; 'my-index',\n                '_type' =&gt; 'my-type',\n                '_id' =&gt; $i * 1000\n            ]\n        ];\n        $body[] = [\n            'test-field' =&gt; 'test-data',\n        ];\n    }\n\n    $bean-&gt;setBody($body);\n    $response = $elasticsearch-&gt;client()-&gt;bulk($bean)-&gt;getBody();\n    $response = json_decode($response,true);\n    var_dump($response);\n})","link":"/Components/Elasticsearch/create.html"},{"id":119,"title":"delete","content":"delete\nDelete by ID\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Delete();\n    $time = time();\n    $bean-&gt;setIndex('my-index-' . $time);\n    $bean-&gt;setId('my-id-' . $time);\n    $response = $elasticsearch-&gt;client()-&gt;delete($bean)-&gt;getBody();\n    $response = json_decode($response,true);\n    var_dump($response);\n})\nDelete according to query\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\DeleteByQuery();\n    $time = time();\n    $bean-&gt;setIndex('my-index-' . $time);\n    $bean-&gt;setBody([\n        'query' =&gt; [\n            'match'=&gt;['name'=&gt;'Test delete']\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;deleteByQuery($bean)-&gt;getBody();\n    $response = json_decode($response,true);\n    var_dump($response);\n})","link":"/Components/Elasticsearch/delete.html"},{"id":120,"title":"update","content":"Update\nUpdate according to ID\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Update();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setId('my-id');\n    $bean-&gt;setBody([\n        'doc' =&gt; [\n            'test-field' =&gt; 'abd'\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;update($bean)-&gt;getBody();\n    $response = json_decode($response,true);\n    var_dump($response);\n})\nUpdate according to query\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\UpdateByQuery();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setBody([\n        'query' =&gt; [\n            'match' =&gt; ['test-field' =&gt; 'abd']\n        ],\n        'script' =&gt; [\n            'source' =&gt; 'ctx._source[\"test-field\"]=\"testing\"'\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;updateByQuery($bean)-&gt;getBody();\n    $response = json_decode($response,true);\n    var_dump($response);\n})\nReindex\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Reindex();\n    $bean-&gt;setBody([\n        'source' =&gt; [\n            'index' =&gt; 'my-index'\n        ],\n        'dest' =&gt; [\n            'index' =&gt; 'my-index-new'\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;reindex($bean)-&gt;getBody();\n    $response = json_decode($response,true);\n    var_dump($response);\n})","link":"/Components/Elasticsearch/update.html"},{"id":121,"title":"search","content":"Create\nQuery document according to document ID\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Get();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setId('my-id');\n    $response = $elasticsearch-&gt;client()-&gt;get($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n})\nBatch query document according to ID\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Mget();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setBody(['ids' =&gt; ['my-id', '1']]);\n    $response = $elasticsearch-&gt;client()-&gt;mget($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n})\nQuery source according to document ID\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Get();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setId('my-id');\n    $response = $response = $elasticsearch-&gt;client()-&gt;getSource($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n})\nquery\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Search();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setBody(['query' =&gt; ['match' =&gt; ['test-field' =&gt; 'ab']]]);\n    $response = $elasticsearch-&gt;client()-&gt;search($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n})\nTotal queries\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Count();\n    $response = $elasticsearch-&gt;client()-&gt;count($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response['count']);\n})\nScroll paging query\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Search();\n    $sBean-&gt;setIndex('my-index');\n    $sBean-&gt;setScroll('1m');\n    $sBean-&gt;setBody([\n                      'query' =&gt; [\n                          'match' =&gt; [\n                              'test-field' =&gt; 'abd'\n                          ]\n                      ],\n                      'sort' =&gt; ['_doc'],\n                      'size' =&gt; 1\n                  ]);\n    $sResponse = $elasticsearch-&gt;client()-&gt;search($sBean)-&gt;getBody();\n    $sResponse = json_decode($sResponse, true);\n\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Scroll();\n    $bean-&gt;setScrollId($sResponse['_scroll_id']);\n    $bean-&gt;setScroll('1m');\n    $response = $elasticsearch-&gt;client()-&gt;scroll($bean)-&gt;getBody();\n    var_dump(json_decode($response,true));\n})\nTemplate query\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\SearchTemplate();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setBody([\n        'inline' =&gt;\n            [\n                'query' =&gt;\n                    [\n                        'match' =&gt; [\"{{field}}\" =&gt; \"{{value}}\"]\n                    ]\n            ],\n        'params' =&gt;\n            [\n                'field' =&gt; 'test-field',\n                'value' =&gt; '博客'\n            ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;searchTemplate($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n})\ntermVectors\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\TermVectors();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setId('my-id');\n    $bean-&gt;setPretty(true);\n    $bean-&gt;setBody([\n        'fields' =&gt; ['test-field'],\n        'offsets' =&gt; true,\n        'payloads' =&gt; true,\n        'positions' =&gt; true,\n        \"term_statistics\" =&gt; true,\n        \"field_statistics\" =&gt; true\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;termvectors($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n})\nFragment information query\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\SearchShards();\n    $bean-&gt;setIndex('my-index');\n    $response = $elasticsearch-&gt;client()-&gt;searchShards($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n})\nNode status\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Info();\n    $response = $elasticsearch-&gt;client()-&gt;info($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n})","link":"/Components/Elasticsearch/search.html"},{"id":122,"title":"analysis","content":"Analysis\nfield Analysis\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\FieldCaps();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setFields('test-field');\n\n    $response = $elasticsearch-&gt;client()-&gt;fieldCaps($bean)-&gt;getBody();\n    $response = json_decode($response,true);\n    var_dump($response);\n})\nquery Analysis\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'          =&gt; '127.0.0.1',\n    'port'          =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function()use($elasticsearch){\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Explain();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setId('my-id');\n    $bean-&gt;setBody([\n        'query' =&gt; [\n            'bool' =&gt; [\n                'must' =&gt; [\n                    ['match' =&gt;\n                        [\n                            'test-field' =&gt; 'abd'\n                        ]\n                    ]\n                ]\n\n            ]\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;explain($bean)-&gt;getBody();\n    $response = json_decode($response,true);\n    var_dump($response);\n})","link":"/Components/Elasticsearch/analysis.html"},{"id":123,"title":"introduce","content":"Redis coroutine client\nAlthough swoole has its own coroutine client, we found some problems in the production environment:\nSwoole's redis client does not fully support Redis's full commands, such as geo search, and transactions, especially in cluster mode redis, which is not supported by the swoole client. To this end, we decided to implement a full version of the redis client using the swoole tcp client.\nSupport method\nCurrently, the redis client component already supports all methods except scripting (currently supports 178 methods):\n\nconnection\ncluster\ngeohash\nhash\nkeys\nlists\npub/sub\nserver\nstring\nsorted sets\nsets\ntransaction\npipe\n\n\nDue to more redis commands, 1 or 2 commands may be missed\n","link":"/Components/Redis/introduction.html"},{"id":124,"title":"install","content":"Redis coroutine client\nRedis coroutine client,Implemented by swoole coroutine client\ngithub地址: https://github.com/easy-swoole/redis \nComposer installation\ncomposer require easyswoole/redis\nUse the client (requires a coroutine environment):\n$redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; '6379',\n    'auth' =&gt; 'easyswoole',\n    'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n]));\nRedis usage example\n&lt;?php\ninclude \"../vendor/autoload.php\";\ngo(function (){\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host' =&gt; '127.0.0.1',\n        'port' =&gt; '6379',\n        'auth' =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    var_dump($redis-&gt;set('a',1));\n    var_dump($redis-&gt;get('a'));\n});\nRedis cluster usage example\n&lt;?php\ninclude \"../vendor/autoload.php\";\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\RedisCluster(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ], [\n        'auth' =&gt; '',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n    ]));\n    var_dump($redis-&gt;set('a',1));\n    var_dump($redis-&gt;get('a'));\n    var_dump($redis-&gt;clusterKeySlot('a'));\n\n});","link":"/Components/Redis/install.html"},{"id":125,"title":"configure","content":"Configuration\nredis configuration\nWhen redis is instantiated, you need to pass in the \\EasySwoole\\Redis\\Config\\RedisConfig instance:\n$config = new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'db'        =&gt; null,\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]);\nThe configuration items are as follows:\n\n\n\nConfiguration name\nDefault parameter\nDescription\nNotes\n\n\n\n\nhost\n127.0.0.1\nRedis ip\n\n\n\nport\n6379\nRedis port\n\n\n\nauth\n\nAuth password\n\n\n\ndb\nnull\nRedis database\nWhen the db configuration is not equal to null, the configuration will be automatically selected when connected\n\n\ntimeout\n3.0\novertime time\n\n\n\nreconnectTimes\n3\nClient abnormal reconnection times\n\n\n\nserialize\nSERIALIZE_NONE\nWhether the data is serialized\n\n\n\n\nSerialization parameters are: SERIALIZE_NONE, SERIALIZE_PHP, SERIALIZE_JSON\nredis cluster configuration\nWhen the redis cluster is instantiated, you need to pass in the \\EasySwoole\\Redis\\Config\\RedisConfig instance:\n$config = new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ], [\n        'auth' =&gt; '',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n    ]);\nThe cluster configuration first passes a multi-dimensional array of ip and port, and then passes other configuration items. Other configuration items are consistent with redis configuration.","link":"/Components/Redis/config.html"},{"id":126,"title":"stand alone client","content":"Redis stand-alone client\nExample:\n&lt;?php\ngo(function (){\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host' =&gt; '127.0.0.1',\n        'port' =&gt; '6379',\n        'auth' =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    var_dump($redis-&gt;set('a',1));\n    var_dump($redis-&gt;get('a'));\n});","link":"/Components/Redis/redis.html"},{"id":127,"title":"cluster client","content":"redis cluster configuration\nWhen the redis cluster is instantiated, you need to pass in the \\EasySwoole\\Redis\\Config\\RedisConfig instance:\n$config = new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ], [\n        'auth' =&gt; '',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n    ]);\nThe cluster configuration first passes a multi-dimensional array of ip and port, and then passes other configuration items. Other configuration items are consistent with redis configuration.\nNote that the auth password needs to be the same for all nodes in the cluster, only one password is supported.\nCall example:\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\RedisCluster(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ], [\n        'auth' =&gt; '',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n    ]));\n    var_dump($redis-&gt;set('a',1));\n    var_dump($redis-&gt;get('a'));\n    var_dump($redis-&gt;clusterKeySlot('a'));\n});\n\nCluster Compatibility Method\nUnder normal circumstances, some methods cannot be directly called by the cluster client, such as the mSet method, which involves multiple key name operations, and multiple key names are assigned to other nodes.\nAt present, the redis cluster client implements compatibility of some multi-key name operation methods, and the implementation principle is as follows:\nFor the multi-key name operation method, split into a single-key name, and then obtain the slot node by the key name, and then execute it through the client assigned by the slot node, and only execute one key name at a time.\nA compatible method has been implemented:\n\n\n\nMethod Name\nParameters\nDescription\nNotes\n\n\n\n\nmSet\n$data\nSetting multiple key-value pairs\n\n\n\nmGet\n$keys\nGet the value of multiple key names\n\n\n\nmSetNx\n$data\nSetting multiple key-value pairs\nThis method will not accurately determine &quot;set multiple key values when all keys do not exist&quot;\n\n\n\nCluster Client Scheduling Logic\nClient default scheduling\nWhen the cluster client calls the redis method, it automatically defaults to a client to send and receive commands:\nfunction sendCommand(array $com, ?ClusterClient $client = null): bool\n{\n    $client = $client ?? $this-&gt;getDefaultClient();\n    $this-&gt;setDefaultClient($client);\n    return $this-&gt;sendCommandByClient($com, $client);\n}\n\nfunction recv($timeout = null, ?ClusterClient $client = null): ?Response\n{\n    $client = $client ?? $this-&gt;getDefaultClient();\n    $this-&gt;setDefaultClient($client);\n    return $this-&gt;recvByClient($client, $timeout);\n}\nWhen the get or set key value slots are inconsistent, the client will automatically switch the send and receive commands:\n// Node transfer client processing\nif ($result-&gt;getErrorType() == 'MOVED') {\n    $nodeId = $this-&gt;getMoveNodeId($result);\n    $client = $this-&gt;getClient($nodeId);\n    $this-&gt;clientConnect($client);\n    //Only processed once, if it is wrong, it will not be processed\n    $client-&gt;sendCommand($command);\n    $result = $client-&gt;recv($timeout ?? $this-&gt;config-&gt;getTimeout());\n}\nAfter the switch is completed, the next command is still the default client. \nGet the client of the cluster\nList of cluster operation methods:\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\ngetNodeClientList\n\nGet the cluster client list\n\n\n\ngetNodeList\n\nGet cluster node information array\n\n\n\nclientAuth\nClusterClient $client, $password\nCluster client auth verification\n\n\n\nsetDefaultClient\nClusterClient $defaultClient\nSet a default client\n\n\n\ngetDefaultClient\n\nGet a default client (initialization will automatically default to one)\n\n\n\ntryConnectServerList\n\nTry to get the client list again\nWhen the call command returns false, try to retrieve it again.\n\n\ngetClient\n$nodeKey = null\nGet a client based on nodeKey\n\n\n\ngetMoveNodeId\nResponse $response\nGet a nodeKey according to the Move message returned by recv\n\n\n\ngetSlotNodeId\n$slotId\nGet nodeKey based on slot id\n\n\n\n\nThese methods are used by the user to send commands to the redis server, or to define the default client to send.\nCluster compatible pipeline method\nDue to the characteristics of the pipeline, after the pipeline is opened, the commands executed later will not be sent directly until the last execution of execPipe will be sent once.\nIn a cluster, you can only select one client and send a one-time command:\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\nexecPipe\n?ClusterClient $client = null\nOne-time execution of methods saved in the pipeline\nYou can customize a client to send by obtaining a client list.\n\n\ndiscardPipe\n\nCancel the pipeline\n\n\n\nstartPipe\n\nPipeline starts recording\n\n\n\n\nCluster disable method\nDue to the characteristics of the cluster, different keys are assigned to different slots. When you call sUnion, sUnIonStore and other commands involving multiple key operations, it will return false, and the error message will be displayed in $redis->getErrorMsg():\n$redis = new \\EasySwoole\\Redis\\RedisCluster(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n    ['172.16.253.156', 9001],\n    ['172.16.253.156', 9002],\n    ['172.16.253.156', 9003],\n    ['172.16.253.156', 9004],\n], [\n    'auth'      =&gt; '',\n    'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n]));\n\n$data = $redis-&gt;sUnIonStore('a','v','c');\nvar_dump($data,$redis-&gt;getErrorMsg());\nWill output:\nbool(false)\nstring(53) \"CROSSSLOT Keys in request don't hash to the same slot\"","link":"/Components/Redis/cluster.html"},{"id":128,"title":"connection pool","content":"Redis Connection Pool Example\nredis-pool component\nThe connection pool can be implemented by directly installing [redis-pool component] (../redisPool.md):\ncomposer require easyswoole/redis-pool\nInstall the easyswoole/pool component custom implementation:\ncomposer require easyswoole/pool\nAdd redisPool manager\nAdd file /App/Pool/RedisPool.php\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/10/15 0015\n * Time: 14:46\n */\n\nnamespace App\\Pool;\n\nuse EasySwoole\\Pool\\Config;\nuse EasySwoole\\Pool\\AbstractPool;\nuse EasySwoole\\Redis\\Config\\RedisConfig;\nuse EasySwoole\\Redis\\Redis;\n\nclass RedisPool extends AbstractPool\n{\n    protected $redisConfig;\n\n    /**\n     * Override the constructor in order to pass in the redis configuration\n     * RedisPool constructor.\n     * @param Config      $conf\n     * @param RedisConfig $redisConfig\n     * @throws \\EasySwoole\\Pool\\Exception\\Exception\n     */\n    public function __construct(Config $conf,RedisConfig $redisConfig)\n    {\n        parent::__construct($conf);\n        $this-&gt;redisConfig = $redisConfig;\n    }\n\n    protected function createObject()\n    {\n        //New redis based on the incoming redis configuration\n        $redis = new Redis($this-&gt;redisConfig);\n        return $redis;\n    }\n}\nRegister to the Manager:\n$config = new \\EasySwoole\\Pool\\Config();\n\n$redisConfig1 = new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS1'));\n\n$redisConfig2 = new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS2'));\n\n\\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\RedisPool($config,$redisConfig1),'redis1');\n\n\\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\RedisPool($config,$redisConfig2),'redis2');\n\nCall (can be called globally in the controller):\ngo(function (){\n\n    $redis1=\\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis1')-&gt;getObj();\n    $redis2=\\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis1')-&gt;getObj();\n\n    $redis1-&gt;set('name','Alan');\n    var_dump($redis1-&gt;get('name'));\n\n    $redis2-&gt;set('name','Allan');\n    var_dump($redis2-&gt;get('name'));\n\n    //Recycling object\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis1')-&gt;recycleObj($redis1);\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis2')-&gt;recycleObj($redis2);\n});\nFor detailed usage, see [pool universal connection pool] (../Pool/introduction.md)\nThis article redis connection pool is based on [pool universal connection pool] (../Pool/introduction.md)","link":"/Components/Redis/pool.html"},{"id":129,"title":"connection","content":"connection method\nThe connection method includes some auth, echo, ping, and similar methods. The list is as follows:   \n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\nconnect\n$timeout\nConnection\n\n\n\ndisconnect\n\nDisconnect\n\n\n\nauth\n$password\nAuth certification\n\n\n\necho\n$str\nEcho\n\n\n\nping\n\nPing\n\n\n\nselect\n$db\nSelect database\n\n\n\n\nInstance\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $data = $redis-&gt;connect();\n    var_dump($data);\n    $data = $redis-&gt;auth('easyswoole');\n    var_dump($data);\n    $data = $redis-&gt;echo('test echo');\n    var_dump($data);\n    $data = $redis-&gt;ping();\n    var_dump($data);\n    $data = $redis-&gt;select(1);\n    var_dump($data);\n    $redis-&gt;disconnect();\n});","link":"/Components/Redis/connection.html"},{"id":130,"title":"key","content":"key operation method\nMethod list\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\ndel\n$key\nDelete a key\n\n\n\ndump\n$key\nSerialization\n\n\n\nexists\n$key\nWhether the query exists\n\n\n\nexpire\n$key, $expireTime = 60\nSet the expiration time (in seconds) for the key\n\n\n\nexpireAt\n$key, $expireTime\nSet the expiration time (in milliseconds) for the key\n\n\n\nkeys\n$pattern\nMatch key\n\n\n\nmove\n$key, $db\nMove key\nCluster mode cannot be used\n\n\npersist\n$key\nRemove the expiration time of the key\n\n\n\npTTL\n$key\nReturn millisecond expiration time\n\n\n\nttl\n$key\nReturn expired time\n\n\n\nrandomKey\n\nRandomly return a key\n\n\n\nrename\n$key, $new_key\nModify the name of the key\nCluster mode cannot be used\n\n\nrenameNx\n$key, $new_key\nModify the key name when newkey does not exist\nCluster mode cannot be used\n\n\ntype\n$key\nReturns the data type stored by the key\n\n\n\n\nInstance\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $key = 'test123213Key';\n    $redis-&gt;select(0);\n    $redis-&gt;set($key, 123);\n    $data = $redis-&gt;dump($key);\n    var_dump($data);\n    $data = $redis-&gt;dump($key . 'x');\n    var_dump($data);\n\n    $data = $redis-&gt;exists($key);\n    var_dump($data);\n\n    $data = $redis-&gt;expire($key, 1);\n    var_dump($data);\n    \\Swoole\\Coroutine::sleep(2);\n    var_dump($redis-&gt;exists($key));\n\n    $redis-&gt;expireAt($key, 1 * 100);\n    \\Swoole\\Coroutine::sleep(0.1);\n    var_dump($redis-&gt;exists($key));\n\n    $redis-&gt;set($key, 123);\n    $data = $redis-&gt;keys(\"{$key}\");\n    var_dump($data);\n\n    $redis-&gt;select(1);\n    $redis-&gt;del($key);\n    $redis-&gt;select(0);\n    $data = $redis-&gt;move($key, 1);\n    var_dump($data);\n    $data = $redis-&gt;exists($key);\n    var_dump($data);\n    $redis-&gt;select(0);\n\n    $redis-&gt;set($key, 123);\n    $data = $redis-&gt;expire($key, 1);\n    var_dump($data);\n    $data = $redis-&gt;persist($key);\n    var_dump($data);\n\n    $redis-&gt;expire($key, 1);\n    $data = $redis-&gt;pTTL($key);\n    var_dump($data);\n\n    $data = $redis-&gt;ttl($key);\n    var_dump($data);\n\n    $data = $redis-&gt;randomKey();\n    var_dump($data);\n    $data = $redis-&gt;rename($key, $key . 'new');\n    var_dump($data);\n    var_dump($redis-&gt;expire($key . 'new'));\n    var_dump($redis-&gt;expire($key));\n\n    $data = $redis-&gt;renameNx($key, $key . 'new');\n    var_dump($data);\n    $redis-&gt;renameNx($key . 'new', $key);\n    $data = $redis-&gt;renameNx($key, $key . 'new');\n    var_dump($data);\n    $data = $redis-&gt;type($key);\n    var_dump($data);\n    $data = $redis-&gt;type($key . 'new');\n    var_dump($data);\n});","link":"/Components/Redis/keys.html"},{"id":131,"title":"string","content":"key operation method\nMethod list\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\nset\n$key, $val, $timeout = 0\nSet a key and set the expiration time in seconds\nThe $timeout value can be int (expiration time seconds), can be string(&quot;NX&quot;,&quot;XX&quot;), or array['NX', 'EX'=&gt;10]\n\n\nget\n$key\nGet a key\n\n\n\ngetRange\n$key, $start, $end\nReturn substring\n\n\n\ngetSet\n$key, $value\nReturn the old value of the key and set the new value\n\n\n\ngetBit\n$key, $offset\nGet the bit value on the specified offset\n\n\n\nmGet\n$keys\nGet the value of multiple keys (parameters can be string or array)\nIn the cluster, it will be handled separately\n\n\nsetBit\n$key, $offset, $value\nSet the bit value of the offset\n\n\n\nsetEx\n$key, $expireTime, $value\nSet value and expiration time (seconds)\n\n\n\nsetNx\n$key, $value\nSet the value of key when the key does not exist.\n\n\n\nsetRange\n$key, $offset, $value\nSet the value of the offset\n\n\n\nstrLen\n$key\nReturns the length of the string value stored by key\n\n\n\nmSet\n$data\nSet the value of multiple keys, the parameter is an associative array\n\n\n\nmSetNx\n$data\nWhen all keys do not exist, set multiple key values, the parameters are the same as mSet\nIn the cluster, the keys will be processed separately\n\n\npSetEx\n$key, $expireTime, $value\nSame as setEx, the expiration time is milliseconds\n\n\n\nincr\n$key\nSelf-increase 1\n\n\n\nincrBy\n$key, $value\nIncrease the value of $value\n\n\n\nincrByFloat\n$key, $value\nIncrease $value floating point value\n\n\n\ndecr\n$key\nSelf-reduction 1\n\n\n\ndecrBy\n$key, $value\nSelf-decrementing $value\n\n\n\nappEnd\n$key, $value\nAppend string\n\n\n\nscan\n&amp;$cursor, $pattern=null, $count=null\nIterate string key name\nCluster mode cannot be used\n\n\n\nIf the serialization configuration is enabled, getRange, setRange, getBit, setBit, strLen, self-incrementing and decrementing commands, append, etc. will be invalidated.\nIn the cluster, batch settings, batch acquisition are all processed by splitting arrays, so the characteristics of mSetNx will be invalid.\nInstance\n\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $key = 'test';\n    $value = 1;\n    $data = $redis-&gt;del($key);\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value);\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value,'XX');\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value,'NX');\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value,['NX','EX'=&gt;20]);\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value,['NX','PX'=&gt;20000]);\n    var_dump($data);\n\n    $data = $redis-&gt;get($key);\n    var_dump($data);\n\n    $data = $redis-&gt;exists($key);\n    var_dump($data);\n\n    $data = $redis-&gt;set($key, $value);\n    var_dump($data);\n    $value += 1;\n    $data = $redis-&gt;incr($key);\n    var_dump($data);\n\n    $value += 10;\n    $data = $redis-&gt;incrBy($key, 10);\n    var_dump($data);\n\n    $value -= 1;\n    $data = $redis-&gt;decr($key);\n    var_dump($data);\n\n    $value -= 10;\n    $data = $redis-&gt;decrBy($key, 10);\n    var_dump($data);\n\n    $key = 'stringTest';\n    $value = 'tioncico';\n    $redis-&gt;set($key, $value);\n    $data = $redis-&gt;getRange($key, 1, 2);\n    var_dump($data);\n\n    $data = $redis-&gt;getSet($key, $value . 'a');\n    var_dump($data);\n    $redis-&gt;set($key, $value);\n\n    $bitKey = 'testBit';\n    $bitValue = 10000;\n    $redis-&gt;set($bitKey, $bitValue);\n    $data = $redis-&gt;setBit($bitKey, 1, 0);\n    var_dump($data);\n    $data = $redis-&gt;getBit($key, 1);\n    var_dump($data);\n\n    $field = [\n        'stringField1',\n        'stringField2',\n        'stringField3',\n        'stringField4',\n        'stringField5',\n    ];\n    $value = [\n        1,\n        2,\n        3,\n        4,\n        5,\n    ];\n    $data = $redis-&gt;mSet([\n        \"{$field[0]}\" =&gt; $value[0],\n        \"{$field[1]}\" =&gt; $value[1],\n        \"{$field[2]}\" =&gt; $value[2],\n        \"{$field[3]}\" =&gt; $value[3],\n        \"{$field[4]}\" =&gt; $value[4],\n    ]);\n    var_dump($data);\n    $data = $redis-&gt;mGet([$field[3], $field[2], $field[1]]);\n    var_dump($data);\n\n    $data = $redis-&gt;setEx($key, 1, $value[0] . $value[0]);\n    var_dump($data);\n    var_dump($redis-&gt;get($key));\n\n    $data = $redis-&gt;pSetEx($key, 1, $value[0]);\n    var_dump($data);\n    var_dump($redis-&gt;get($key));\n\n    $redis-&gt;del($key);\n    $data = $redis-&gt;setNx($key, 1);\n    var_dump($data);\n\n    $redis-&gt;del($field[0]);\n    $data = $redis-&gt;mSetNx([\n        \"{$field[0]}\" =&gt; $value[0],\n        \"{$field[1]}\" =&gt; $value[1],\n    ]);\n    var_dump($data);\n    var_dump( $redis-&gt;get($field[1]));\n    $redis-&gt;del($field[1]);\n    $data = $redis-&gt;mSetNx([\n        \"{$field[0]}\" =&gt; $value[0] + 1,\n        \"{$field[1]}\" =&gt; $value[1] + 1,\n    ]);\n    var_dump($data);\n    var_dump($redis-&gt;get($field[0]));\n\n    $data = $redis-&gt;setRange($field[0], 1, 1);\n    var_dump($data);\n    var_dump($redis-&gt;get($field[0]));\n\n    $data = $redis-&gt;strLen($field[0]);\n    var_dump($data);\n\n    $redis-&gt;set($key, 1);\n    $data = $redis-&gt;incrByFloat($key, 0.1);\n    var_dump($data);\n    $data = $redis-&gt;appEnd($field[0], '1');\n    var_dump($data);\n    var_dump($redis-&gt;get($field[0]));\n\n    //Iterative test\n    $cursor = 0;//Iteration initial value 0\n    $redis-&gt;flushAll();\n    $redis-&gt;set('xxxa', 'Alan');\n    $redis-&gt;set('xxxb', 'Alan');\n    $redis-&gt;set('xxxc', 'Alan');\n    $redis-&gt;set('xxxd', 'Alan');\n    $data = [];\n    do {\n        //$cursor is set once for each iteration, and 0 means iterative completion\n        $keys = $redis-&gt;scan($cursor, 'xxx*', 1);\n        $data = array_merge($data,$keys);\n    } while ($cursor);\n    var_dump($data);\n});","link":"/Components/Redis/string.html"},{"id":132,"title":"hash","content":"Hash operation method\nMethod list\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\nhDel\n$key, ...$field\nDelete key, multiple\n\n\n\nhExists\n$key, $field\nWhether the query field exists\n\n\n\nhGet\n$key, $field\nGet a field value\n\n\n\nhGetAll\n$key\nGet all the field values of this key\n\n\n\nhSet\n$key, $field, $value\nSet the field value of the key\n\n\n\nhValS\n$key\nGet all the values in the hash table\n\n\n\nhKeys\n$key\nGet the fields in all hash tables\n\n\n\nhLen\n$key\nGet the number of fields in the hash table\n\n\n\nhMGet\n$key, $hashKeys\nGet the value of all the given field $hashKeys array\n\n\n\nhMSet\n$key, $data\nSet multiple $data key-value pairs to $key at the same time\n\n\n\nhIncrBy\n$key, $field, $increment\nAdd $increment to the specified field\n\n\n\nhIncrByFloat\n$key, $field, $increment\nAdd a floating point number to the specified field $increment\n\n\n\nhSetNx\n$key, $field, $value\nSet the value of $field only if $filed does not exist\n\n\n\nhScan\n$key,&amp;$cursor, $pattern=null, $count=null\nIterate over the key-value pairs in the hash table.\n\n\n\n\nInstance\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n\n    $key = 'hKey';\n    $field = [\n        'hField1',\n        'hField2',\n        'hField3',\n        'hField4',\n        'hField5',\n    ];\n    $value = [\n        1,\n        2,\n        3,\n        4,\n        5,\n    ];\n\n    $redis-&gt;del($key);\n    $data = $redis-&gt;hSet($key, $field[0], $value[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hGet($key, $field[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hExists($key, $field[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hDel($key, $field[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hExists($key, $field[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hMSet($key, [\n        \"{$field[0]}\" =&gt; $value[0],\n        \"{$field[1]}\" =&gt; $value[1],\n        \"{$field[2]}\" =&gt; $value[2],\n        \"{$field[3]}\" =&gt; $value[3],\n        \"{$field[4]}\" =&gt; $value[4],\n    ]);\n    var_dump($data);\n    $data = $redis-&gt;hValS($key);\n    var_dump($data);\n\n    $data = $redis-&gt;hGetAll($key);\n    var_dump($data);\n\n    $data = $redis-&gt;hKeys($key);\n    var_dump($data);\n\n    $data = $redis-&gt;hLen($key);\n    var_dump($data);\n\n   $data = $redis-&gt;hMGet($key, [$field[0], $field[1], $field[2]]);\n    var_dump($data);\n\n    $data = $redis-&gt;hIncrBy($key, $field[4], 1);\n    var_dump($data);\n\n    $data = $redis-&gt;hIncrByFloat($key, $field[1], 1.1);\n    var_dump($data);\n\n    $data = $redis-&gt;hSetNx($key, $field[0], 1);\n    var_dump($data);\n\n    $data = $redis-&gt;hSetNx($key, $field[0] . 'a', 1);\n    var_dump($data);\n    var_dump($redis-&gt;hGet($key, $field[0] . 'a'));\n\n    $cursor = 0;\n    $redis-&gt;del('a');\n    $redis-&gt;hMSet('a',[\n        'a'=&gt;'tioncico',\n        'b'=&gt;'tioncico',\n        'c'=&gt;'tioncico',\n        'd'=&gt;'tioncico',\n        'e'=&gt;'tioncico',\n        'f'=&gt;'tioncico',\n        'g'=&gt;'tioncico',\n        'h'=&gt;'tioncico',\n    ]);\n\n    $data = [];\n    do {\n        $keys = $redis-&gt;hScan('a',$cursor);\n        $data = array_merge($data,$keys);\n        var_dump($keys);\n    } while ($cursor);\n\n});\n","link":"/Components/Redis/hash.html"},{"id":133,"title":"lists","content":"List operation method\nMethod list\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\nlPush\n$key, ...$data\nInsert one or more values ​​into the list header\n\n\n\nbLPop\n$keys,$timeout\nMove out and get the first element of the $keys list. If there are no elements in the $keys list, it will block the list until it waits for a timeout or finds that the element can be popped up.\n$keys can be either string or an array\n\n\nbRPop\n$keys,$timeout\nMove out and get the last element of the $keys list. If there are no elements in the $keys list, it will block the list until it waits for a timeout or finds that the element can be popped up.\n$keys can be either string or an array\n\n\nbRPopLPush\n$source, $destination, $timeout\nPops a value from the list, inserts the pop-up element into another list and returns it; if the list has no elements, it blocks the list until it waits for a timeout or finds a pop-up element.\n\n\n\nrPopLPush\n$source, $destination\nRemove the last element of the list and add the element to another list and return\n\n\n\nlIndex\n$key,$index\nGet the elements in the list by index\n\n\n\nlLen\n$key\nGet list length\n\n\n\nlInsert\n$key,$bool,$pivot,$value\nInsert elements before or after the elements of the list\n\n\n\nrPush\n$key, ...$data\nAdd one or more values ​​to the list\n\n\n\nlRange\n$key,$start,$stop\nGet the elements in the specified range of the list\n\n\n\nlPop\n$key\nMove out and get the first element of the list\n\n\n\nrPop\n$key\nMove out and get the last element of the list\n\n\n\nlPuShx\n$key,$value\nInsert a value into the existing list header\n\n\n\nrPuShx\n$key,$value\nAdd a value to an existing list\n\n\n\nlRem\n$key,$count,$value\nRemove list element\n\n\n\nlSet\n$key,$index,$value\nSet the value of a list element by index\n\n\n\nlTrim\n$key,$start,$stop\nTrim a list, that is, let the list retain only the elements in the specified range, and elements that are not within the specified range will be deleted.\n\n\n\n\nInstance\n\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    $key = [\n        'listKey1',\n        'listKey2',\n        'listKey3',\n    ];\n    $value = [\n        'a', 'b', 'c', 'd'\n    ];\n\n    $redis-&gt;flushAll();\n\n    //When testing null\n    $data = $redis-&gt;bLPop([$key[0],$key[1]], 1);\n    var_dump($data);\n    $data = $redis-&gt;lPush($key[0], $value[0], $value[1]);\n    var_dump($data);\n\n    //When testing null\n    $data = $redis-&gt;bLPop([$key[1]], 1);\n    var_dump($data);\n    $data = $redis-&gt;bRPop([$key[1]], 1);\n    var_dump($data);\n\n    $data = $redis-&gt;bLPop([$key[0],$key[1]], 1);\n    var_dump($data);\n\n    $data = $redis-&gt;bRPop([$key[0],$key[1]], 1);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;lPush($key[0], $value[0], $value[1]);\n    $data = $redis-&gt;bRPopLPush($key[0], $key[1], 1);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;lPush($key[0], $value[0], $value[1]);\n    $data = $redis-&gt;rPopLPush($key[0], $key[1]);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;lPush($key[0], $value[0], $value[1]);\n    $data = $redis-&gt;lIndex($key[0], 1);\n    var_dump($data);\n    $data = $redis-&gt;lLen($key[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;lInsert($key[0], true, 'b', 'c');\n    var_dump($data);\n    $data = $redis-&gt;lInsert($key[0], true, 'd', 'c');\n    var_dump($data);\n\n    $redis-&gt;del($key[1]);\n    $data = $redis-&gt;rPush($key[1], $value[0], $value[2], $value[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;lRange($key[1], 0, 3);\n    var_dump($data);\n\n    $data = $redis-&gt;lPop($key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;rPop($key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;lPuShx($key[1], 'x');\n    var_dump($data);\n\n    $data = $redis-&gt;rPuShx($key[1], 'z');\n    var_dump($data);\n\n    $redis-&gt;del($key[1]);\n    $redis-&gt;rPush($key[1], $value[0], $value[0], $value[0]);\n    $data = $redis-&gt;lRem($key[1], 1, $value[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;lSet($key[1], 0, 'xx');\n    var_dump($data);\n\n    $data = $redis-&gt;lTrim($key[1], 0, 2);\n    var_dump($data);\n});\n","link":"/Components/Redis/lists.html"},{"id":134,"title":"sets","content":"Collection operation method\nMethod list\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\nsAdd\n$key, ...$data\nAdd one or more members to the collection\n\n\n\nsCard\n$key\nGet the number of members of the collection\n\n\n\nsDiff\n$key1, ...$keys\nReturns the difference set for all sets\n\n\n\nsMembers\n$destination, ...$keys\nReturn all members in the collection\n\n\n\nsDiffStore\n$key1, ...$keys\nReturns the difference set for all collections and stores them in destination\n\n\n\nsInter\n$destination, ...$keys\nReturns the intersection of all the given sets\n\n\n\nsInterStore\n$key, $member\nReturns the intersection of all the collections given and stored in destination\n\n\n\nsIsMember\n$key\nDetermine if the member element is a member of the collection key\n\n\n\nsMove\n$source, $destination, $member\nMove the member element from the source collection to the destination collection\n\n\n\nsPop\n$key\nRemove and return a random element in the collection\n\n\n\nsRandMemBer\n$key, $count = null\nReturn one or more random numbers in the collection\n\n\n\nsRem\n$key, $member1, ...$members\nRemove one or more members from the collection\n\n\n\nsUnion\n$key1, ...$keys\nReturns the union of all given collections\n\n\n\nsUnIonStore\n$destination, $key1, ...$keys\nThe union of all given collections is stored in the destination collection\n\n\n\nsScan\n$key,&amp;$cursor, $pattern=null, $count=null\nIterating over the elements in the collection\n\n\n\n\nIn cluster mode, sDiff, sDiffStore, sInter, sMove, sUnion, sUnIonStore, etc. cannot be used.\nInstance\ngo(function () {\n     $redis =  new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $key = [\n            'muster1',\n            'muster2',\n            'muster3',\n            'muster4',\n            'muster5',\n        ];\n        $value = [\n            '1',\n            '2',\n            '3',\n            '4',\n        ];\n    $redis-&gt;del($key[0]);\n    $redis-&gt;del($key[1]);\n    $data = $redis-&gt;sAdd($key[0], $value[0], $value[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sCard($key[0]);\n    var_dump($data);\n\n    $redis-&gt;sAdd($key[1], $value[0], $value[2]);\n    $data = $redis-&gt;sDiff($key[0], $key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sDiff($key[1], $key[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;sMembers($key[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;sMembers($key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sDiffStore($key[2], $key[0], $key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sInter($key[0], $key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sInterStore($key[3], $key[0], $key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sIsMember($key[0], $value[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;sMove($key[0], $key[1], $value[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sPop($key[0]);\n    var_dump($data);\n\n    $redis-&gt;del($key[3]);\n    $redis-&gt;sAdd($key[3], $value[0], $value[1], $value[2], $value[3]);\n    $data = $redis-&gt;sRandMemBer($key[3], 4);\n    var_dump($data);\n\n    $data = $redis-&gt;sRem($key[3], $value[0], $value[1], $value[2], $value[3]);\n    var_dump($data);\n\n    $data = $redis-&gt;sUnion($key[0], $key[1]);\n    var_dump($data);\n\n    $redis-&gt;del($key[1]);\n    $redis-&gt;del($key[2]);\n    $redis-&gt;del($key[3]);\n    $redis-&gt;del($key[4]);\n    $redis-&gt;sAdd($key[1], 1, 2, 3, 4);\n    $redis-&gt;sAdd($key[2], 5);\n    $redis-&gt;sAdd($key[3], 6, 7);\n    $data = $redis-&gt;sUnIonStore($key[4], $key[1], $key[2], $key[3]);\n    var_dump($data);\n\n    $cursor = 0;\n    $redis-&gt;del('a');\n    $redis-&gt;sAdd('a','a1','a2','a3','a4','a5');\n    $data= [];\n    do {\n        $keys = $redis-&gt;sScan('a',$cursor,'*',1);\n        $data = array_merge($data,$keys);\n    } while ($cursor);\n    var_dump($data);\n});","link":"/Components/Redis/sets.html"},{"id":135,"title":"sorted sets","content":"Ordered collection operation method\nMethod list\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\nzAdd\n$key, $score1, $member1, ...$data\nAdd one or more members to an ordered collection, or update the scores of existing members\n\n\n\nzCard\n$key\nGet the number of members of an ordered collection\n\n\n\nzCount\n$key, $min, $max\nCalculate the number of members specifying the interval score in an ordered collection\n\n\n\nzInCrBy\n$key, $increment, $member\nThe fraction of the specified member in the ordered collection plus the increment increment\n\n\n\nzInTerStore\n$destination, array $keys, array $weights = [], $aggregate = 'SUM'\nComputes the intersection of a given set of one or more ordered sets and stores the result set in a new ordered set key\n\n\n\nzLexCount\n$key, $min, $max\nCalculate the number of members in a specified dictionary interval in an ordered collection\n\n\n\nzRange\n$key, $start, $stop, $withScores = false\nReturns the members of the specified range in the ordered collection through the index interval\n\n\n\nzRangeByLex\n$key, $min, $max, ...$data\nReturning members of an ordered collection through a dictionary interval\n\n\n\nzRangeByScore\n$key, $min, $max, array $options\nReturning the members of the specified range by the ordered set by the score\n\n\n\nzRank\n$key, $member\nReturns the index of the specified member in the ordered collection\n\n\n\nzRem\n$key, $member, ...$members\nRemove one or more members from an ordered collection\n\n\n\nzRemRangeByLex\n$key, $min, $max\nRemove all members of a given dictionary interval in an ordered collection\n\n\n\nzRemRangeByRank\n$key, $start, $stop\nRemove all members of a given ranking interval from an ordered collection\n\n\n\nzRemRangeByScore\n$key, $min, $max\nRemove all members of a given score interval in an ordered collection\n\n\n\nzRevRange\n$key, $start, $stop, $withScores = false\nReturns the members in the specified interval in the ordered set, through the index, the score is from high to low\n\n\n\nzRevRangeByScore\n$key, $max, $min, array $options\nReturns the members in the specified fractional interval in the ordered set, sorting the scores from high to low\n\n\n\nzRevRank\n$key, $member\nReturns the rank of the specified member in the ordered collection, the ordered members are sorted by the fractional value (large to small)\n\n\n\nzScore\n$key, $member\nReturns the ordered set, the member's score\n\n\n\nzUnionStore\n$destination, array $keys, array $weights = [], $aggregate = 'SUM'\nComputes the union of a given set of one or more ordered sets and stores them in a new key\n\n\n\nzScan\n$key,&amp;$cursor, $pattern=null, $count=null\nIterate over the elements in an ordered collection (including element members and element scores)\n\n\n\n\nIn cluster mode, methods such as zInTerStore, zUnionStore cannot be used.\nInstance\ngo(function (){\n    $redis =  new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $key = [\n            'sortMuster1',\n            'sortMuster2',\n            'sortMuster3',\n            'sortMuster4',\n            'sortMuster5',\n        ];\n    $member = [\n        'member1',\n        'member2',\n        'member3',\n        'member4',\n        'member5',\n    ];\n    $score = [\n        1,\n        2,\n        3,\n        4,\n    ];\n    $redis-&gt;del($key[0]);\n    $data = $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;zCard($key[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;zCount($key[0], 0, 3);\n    var_dump($data);\n\n    $data = $redis-&gt;zInCrBy($key[0], 1, $member[1]);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;del($key[1]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1]);\n    $redis-&gt;zAdd($key[1], $score[0], $member[0], $score[3], $member[3]);\n    $data = $redis-&gt;zInTerStore($key[2], [$key[0], $key[1]], [1, 2]);\n    var_dump($data);\n\n    $data = $redis-&gt;zLexCount($key[0], '-', '+');\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRange($key[0], 0, -1, true);\n    var_dump($data);\n\n    $data = $redis-&gt;zRangeByLex($key[0], '-', '+');\n    var_dump($data);\n\n    $data = $redis-&gt;zRangeByScore($key[0], 2, 3, ['withScores' =&gt; true, 'limit' =&gt; array(0, 2)]);\n    var_dump($data);\n\n    $data = $redis-&gt;zRank($key[0], $member[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;zRem($key[0], $member[1], $member[2]);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRemRangeByLex($key[0], '-', '+');\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRemRangeByRank($key[0], 0, 2);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRemRangeByScore($key[0], 0, 3);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRevRange($key[0], 0, 3, true);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRevRangeByScore($key[0], 3, 0, ['withScores' =&gt; true, 'limit' =&gt; array(0, 3)]);\n    var_dump($data);\n\n    $data = $redis-&gt;zRevRank($key[0], $member[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;zScore($key[0], $member[0]);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;del($key[1]);\n    $redis-&gt;del($key[2]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1]);\n    $redis-&gt;zAdd($key[1], $score[0], $member[0], $score[3], $member[3]);\n    $data = $redis-&gt;zUnionStore($key[2], [$key[1], $key[0]]);\n    var_dump($data);\n\n    $cursor = 0;\n    $redis-&gt;del('a');\n    $redis-&gt;zAdd('a',1,'a1',2,'a2',3,'a3',4,'a4',5,'a5');\n    $data = [];\n    do {\n        $keys = $redis-&gt;zScan('a',$cursor,'*',1);\n        $data = array_merge($data,$keys);\n    } while ($cursor);\n    var_dump($data);\n\n})","link":"/Components/Redis/sortedSets.html"},{"id":136,"title":"hyperloglog","content":"HyperLog method\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\npfAdd\n$key, $elements\nAdd the specified element to the HyperLogLog.\nPass in an indexed array\n\n\npfCount\n$key\nReturns the cardinality estimate for a given HyperLogLog.\n\n\n\npfMerge\n$deStKey, array $sourceKeys\nCombine multiple HyperLogLogs into one HyperLogLog\nPass in an indexed array\n\n\n\nInstance\n\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    $key = [\n        'hp1',\n        'hp2',\n        'hp3',\n        'hp4',\n        'hp5',\n    ];\n    $redis-&gt;del($key[0]);\n    $redis-&gt;del($key[1]);\n    $data = $redis-&gt;pfAdd($key[0], [1, 2, 2, 3, 3]);\n    var_dump($data);\n\n    $redis-&gt;pfAdd($key[1], [1, 2, 2, 3, 3]);\n    $data = $redis-&gt;pfCount([$key[0], $key[1]]);\n    var_dump($data);\n\n    $data = $redis-&gt;pfMerge($key[2], [$key[0], $key[1]]);\n    var_dump($data);\n});\n","link":"/Components/Redis/hyperLogLog.html"},{"id":137,"title":"pub/sub","content":"Subscription/release method\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\n\npSubscribe\n$callback, $pattern, ...$patterns\nSubscribe to one or more channels that match a given pattern.\n$callback is a callback function\n\n\n\npubSub\n$subCommand, ...$arguments\nView subscription and release system status.\n\n\n\n\npublish\n$channel, $message\nSend the message to the specified channel.\n\n\n\n\npUnSubscribe\n$pattern, ...$patterns\nUnsubscribe from all channels in a given mode.\n\n\n\n\n\n\n                 \n\n\n\n\nsubscribe\n$callback, $channel, ...$channels\nSubscribe to information for a given channel or channels.\n\n\n\n\n\n\n                 \n\n\n\n\nunsubscribe\n$channel, ...$channels\nRefers to unsubscribing to a given channel.\n\n\n\n\n\n\n                 \n\n\n\n\nsetSubscribeStop\nbool $subscribeStop\nSet whether to opt out of the subscription\nCall this command when your callback function wants to exit\n\n\n\nisSubscribeStop\n\nView current subscription status\n\n\n\n\n\nInstance\n\ndefined(\"REDIS_HOST\") ?: define('REDIS_HOST', '127.0.0.1');\ndefined(\"REDIS_PORT\") ?: define('REDIS_PORT', 6379);\ndefined(\"REDIS_AUTH\") ?: define('REDIS_AUTH', 'easyswoole');\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    //Open a new coroutine to subscribe\n    go(function () {\n        $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n            'host' =&gt; REDIS_HOST,\n            'port' =&gt; REDIS_PORT,\n            'auth' =&gt; REDIS_AUTH\n        ]));\n        $redis-&gt;pSubscribe(function (\\EasySwoole\\Redis\\Redis $redis, $pattern, $str) {\n            var_dump($pattern,$str);\n            $data = $redis-&gt;unsubscribe('test');\n            var_dump($data);\n            $redis-&gt;setSubscribeStop(true);\n        }, 'test', 'test1', 'test2');\n    });\n\n    //Open a new coroutine to subscribe\n    go(function () {\n        $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n            'host' =&gt; REDIS_HOST,\n            'port' =&gt; REDIS_PORT,\n            'auth' =&gt; REDIS_AUTH\n        ]));\n        $redis-&gt;subscribe(function (\\EasySwoole\\Redis\\Redis $redis, $pattern, $str) {\n            var_dump($pattern,$str);\n            $data = $redis-&gt;unsubscribe('test');\n            var_dump($data);\n            $redis-&gt;setSubscribeStop(true);\n        }, 'test', 'test1', 'test2');\n    });\n\n    $data = $redis-&gt;pubSub('CHANNELS');\n    var_dump($data);\n    \\Swoole\\Coroutine::sleep(1);\n\n    $data = $redis-&gt;publish('test2', 'test');\n    var_dump($data);\n\n    $data = $redis-&gt;pUnSubscribe('test');\n    var_dump($data);\n\n});\n","link":"/Components/Redis/pubSub.html"},{"id":138,"title":"transaction","content":"Redis transaction method list\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\ndiscard\n\nCancel transaction (rollback)\n\n\n\nexec\n\nExecute transaction (get transaction result)\n\n\n\nmulti\n\nStart transaction\n\n\n\nunWatch\n\nCancel the monitoring of all keys by the WATCH command\n\n\n\nwatch\n$key,...$keys\nMonitoring key\n\n\n\n\nAfter starting the transaction, the operation command will return \"QUEUED\" until the transaction is canceled or the transaction is executed. After executing exec, all command results will be returned.\nTransactions in the cluster are not reliable\nInstance\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $data = $redis-&gt;multi();\n    var_dump($data);\n    $redis-&gt;del('ha');\n    $data = $redis-&gt;hset('ha', 'a', 1);\n    var_dump($data);\n    $data = $redis-&gt;hset('ha', 'b', '2');\n    var_dump($data);\n    $data = $redis-&gt;hset('ha', 'c', '3');\n    var_dump($data);\n    $data = $redis-&gt;hGetAll('ha');\n    var_dump($data);\n    $data = $redis-&gt;exec();\n    var_dump($data);\n\n    $redis-&gt;multi();\n    $data = $redis-&gt;discard();\n    var_dump($data);\n    $data = $redis-&gt;watch('a', 'b', 'c');\n    var_dump($data);\n    $data = $redis-&gt;unwatch();\n    var_dump($data);\n\n});","link":"/Components/Redis/transaction.html"},{"id":139,"title":"geohash","content":"geoHash方法\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\ngeoAdd\n$key, $locationData\n## Instance...\n$locationData为一个数组,写法为:[[longitude=&gt;'',latitude=&gt;'',name=&gt;'']] 或者 $locationData[[longitude,latitude,name]]\n\n\ngeoDist\n$key, $location1, $location2, $unit = 'm'\nReturns the distance between two members in the geospatial index represented by the sorted collection.\n\n\n\ngeoHash\n$key, $location, ...$locations\nReturns a hash value representing the geospatial index\n\n\n\ngeoPos\n$key, $location1, ...$locations\nReturns the position (longitude, latitude) of all specified members of the geospatial index represented by the ordered collection at the button.\n\n\n\ngeoRadius\n$key, $longitude, $latitude, $radius, $unit = 'm', $withCoord = false, $withDist = false, $withHash = false, $count = null, $sort = null, $storeKey = null, $storeDistKey = null\nReturns members of a sorted collection populated with geospatial information\n\n\n\ngeoRadiusByMember\n$key, $location, $radius, $unit = 'm', $withCoord = false, $withDist = false, $withHash = false, $count = null, $sort = null, $storeKey = null, $storeDistKey = null\nThis command is identical to GEORADIUS, except that it does not use the center of the query area as the longitude and latitude values, but the name of the member that already exists in the geospatial index represented by the ordered set.\n\n\n\n\nInstance\n\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    $key = 'testGeohash';\n\n    $redis-&gt;del($key);\n    $data = $redis-&gt;geoAdd($key, [\n        ['118.6197800000', '24.88849', 'user1',],\n        ['118.6197800000', '24.88859', 'user2',],\n        ['114.8197800000', '25.88849', 'user3'],\n        ['118.8197800000', '22.88849', 'user4'],\n    ]);\n    var_dump($data);\n\n    $data = $redis-&gt;geoDist($key, 'user1', 'user2');\n    var_dump($data);\n\n    $data = $redis-&gt;geoHash($key, 'user1', 'user2');\n    var_dump($data);\n\n    $data = $redis-&gt;geoPos($key, 'user1', 'user2');\n    var_dump($data);\n\n    $data = $redis-&gt;geoRadius($key, '118.6197800000', '24.88849', 100, 'm', false, false, false, 'desc');\n    var_dump($data);\n\n    $data = $redis-&gt;geoRadiusByMember($key, 'user1', 100, 'm', false, false, false, 'desc');\n    var_dump($data);\n});","link":"/Components/Redis/geoHash.html"},{"id":140,"title":"cluster","content":"Cluster related methods\nMethod list\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\nclusterNodes\n\nGet cluster nodes\n\n\n\nclusterAddSlots\n$slots\nThe cluster slot is changed. $slots can be a string and can be an array.\n\n\n\nclusterCountFailureReports\n$nodeId\nCluster count failure report\n\n\n\nclusterCountKeySinSlot\n$slot\nReturns the number of keys in the specified Redis Cluster hash slot.\n\n\n\nclusterDelSlots\n$slot\nDelete a hash slot\n\n\n\nclusterFailOver\n$option = null\nManual failover\n\n\n\nclusterForget\n$nodeId\nDelete the specified node.\n\n\n\nclusterGetKeySinSlot\n$slot, $count\nReturns an array of key names in the storage node and hashes to the specified hash slot.\n\n\n\nclusterInfo\n\nCluster information\n\n\n\nclusterKeySlot\n$key\nReturn the cluster slot of the key\n\n\n\nclusterMeet\n$ip, $port\nThe node is connected to a working cluster.\n\n\n\nclusterReplicate\n$nodeId\nCluster replication\n\n\n\nclusterReset\n$option = null\nCluster reset\n\n\n\nclusterSaveConfig\n\nForce the node to save the nodes.conf configuration to disk.\n\n\n\nclusterSetConfigEpoch\n$configEpoch\nSet a specific configuration period in the new node\n\n\n\nclusterSetSlot\n$slot, $subCommand, $nodeId = null\nChange the state of the hash slot in the receiving node\n\n\n\nclusterSlaves\n$nodeId\nGets a list of slave nodes copied from the specified master node.\n\n\n\nclusterSlots\n\nReturns details about which cluster slots are mapped to which Redis instances.。\n\n\n\nreadonly\n\nEnable read queries to connect to Redis cluster slave nodes.\n\n\n\nreadwrite\n\nA read query that disables connections to Redis cluster slave nodes.\n\n\n\n\nInstance\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\RedisCluster(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ], [\n        'auth'      =&gt; '',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n    ]));\n\n    $data = $redis-&gt;clusterNodes();\n    var_dump($data);\n\n    $data = $redis-&gt;clusterKeySlot('key1');\n    var_dump($data);\n\n    $data = $redis-&gt;clusterCountFailureReports(current($redis-&gt;getNodeList())['name']);\n    var_dump($data);\n\n    $data = $redis-&gt;clusterCountKeySinSlot(1);\n    var_dump($data);\n\n    $data = $redis-&gt;clusterFailOver('FORCE');\n    var_dump($data);\n\n    $redis-&gt;tryConnectServerList();\n    $data = $redis-&gt;clusterForget(array_column(($redis-&gt;getNodeList()), 'name')[0]);\n    var_dump($data);\n\n    $redis-&gt;set('a', 1);\n    $data = $redis-&gt;clusterKeySlot('a');\n    var_dump($data);\n    $data = $redis-&gt;clusterGetKeySinSlot($data, 1);\n    var_dump($data);\n\n    $data = $redis-&gt;clusterInfo();\n    var_dump($data);\n\n    $data = $redis-&gt;clusterKeySlot('b');\n    var_dump($data);\n\n    $data = $redis-&gt;clusterMeet('172.16.253.156', '9005');\n    var_dump($data);\n});\n\nBecause the cluster method is more complicated and needs to operate different clients to implement an instance of a certain method, this example only provides some code, not all, you can call the test yourself.","link":"/Components/Redis/clusterMethod.html"},{"id":141,"title":"pipe","content":"Pipe pipe method\n\n\n\nMethod name\nParameter\nDescription\nNotes\n\n\n\n\ndiscardPipe\n\nCancel the pipeline\n\n\n\nexecPipe\n\nSend command once\n\n\n\nstartPipe\n\nPipeline starts recording\n\n\n\n\nAfter starting the pipeline, the operation command will return \"PIPE\" until the pipeline is canceled or executed. After executing exec, all command results will be returned.\nAfter the pipeline starts, all commands will not be executed after the call, but will be recorded, and then sent to the redis server once waiting for exec.\nSo you need to pay attention to memory, do not execute too many commands in one pipeline.\nIn the cluster, only the execPipe command will select a client to send data, and other times, regardless of how it is called, it has nothing to do with the client.\nInstance\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    $redis-&gt;get('a');\n    $data = $redis-&gt;startPipe();\n    var_dump($data);\n    $redis-&gt;del('ha');\n    $data = $redis-&gt;hset('ha', \"a\", \"a\\r\\nb\\r\\nc\");\n    var_dump($data);\n    $data = $redis-&gt;hset('ha', 'b', '2');\n    var_dump($data);\n    $data = $redis-&gt;hset('ha', 'c', '3');\n    var_dump($data);\n    $data = $redis-&gt;hGetAll('ha');\n    var_dump($data);\n    $data = $redis-&gt;execPipe();\n\n    var_dump($data);\n\n    $redis-&gt;startPipe();\n    $data = $redis-&gt;set(\"a\", '1');\n    var_dump($data);\n    $data = $redis-&gt;discardPipe();\n    var_dump($data);\n\n});","link":"/Components/Redis/pipe.html"},{"id":142,"title":"client","content":"Memcache coroutine client\nMemcache coroutine client, implemented by swoole coroutine client\nGithub address: https://github.com/easy-swoole/memcache \nComposer installation\ncomposer require easyswoole/memcache\nUse the client (requires a coroutine environment):\n$config = new \\EasySwoole\\Memcache\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 11211\n]);\n$client = new EasySwoole\\Memcache\\Memcache($config);\nExample of use:\n$config = new \\EasySwoole\\Memcache\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 11211\n]);\n$client = new EasySwoole\\Memcache\\Memcache($config);\n$client-&gt;set('a',1);\n$client-&gt;get('a');\nInstructions:\ntouchTouch (refresh validity period)\nTouch($key, $expiration, $timeout = null)\nIncrement increment KEY\nIncrement($key, $offset = 1, $initialValue = 0, $expiration = 0, $timeout = null)\ndecrement decrement KEY\nDecrement($key, $offset = 1, $initialValue = 0, $expiration = 0, $timeout = null)\nsetSet KEY (overwrite)\nSet($key, $value, $expiration = 0, $timeout = null)\naddAdd KEY (non-overwrite)\nAdd($key, $value, $expiration = 0, $timeout = null)\nreplace replaces a KEY\nReplace($key, $value, $expiration = 0, $timeout = null)\nappend append data to the end\nappend($key, $value, $timeout = null)\nprepend append data to the beginning\nPrepend($key, $value, $timeout = null)\ngetGet KEY\nGet($key, $timeout = null)\ndelete Delete a key\nDelete($key, $timeout = null)\nstatsGet server status\nStats($type = null, $timeout = null)\nversionGet the server version\nVersion(int $timeout = null)\nflush Clear the cache\nflush(int $expiration = null, int $timeout = null)","link":"/Components/Memcache/memcache.html"},{"id":143,"title":"connection pool","content":"Memcache connection pool example\nInstall the easyswoole/pool component:\ncomposer require easyswoole/pool\nAdd MemcachePool Manager\nNew file/App/Pool/MemcachePool.php\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/10/15 0015\n * Time: 14:46\n */\n\nnamespace App\\Pool;\n\nuse EasySwoole\\Memcache\\Memcache;\nuse EasySwoole\\Pool\\Config;\nuse EasySwoole\\Pool\\AbstractPool;\nuse EasySwoole\\Memcache\\Config as MemcacheConfig;\n\nclass MemcachePool extends AbstractPool\n{\n    protected $memcacheConfig;\n\n    /**\n     * Override the constructor in order to pass in the memcache configuration\n     * RedisPool constructor.\n     * @param Config      $conf\n     * @param MemcacheConfig $memcacheConfig\n     * @throws \\EasySwoole\\Pool\\Exception\\Exception\n     */\n    public function __construct(Config $conf,MemcacheConfig $memcacheConfig)\n    {\n        parent::__construct($conf);\n        $this-&gt;memcacheConfig = $memcacheConfig;\n    }\n\n    protected function createObject():Memcache\n    {\n        //New a memcache client based on the incoming memcache configuration\n        $memcache = new Memcache($this-&gt;memcacheConfig);\n        return $memcache;\n    }\n}\nRegister into the Manager (registered in the initialize event):\n\n$config = new \\EasySwoole\\Pool\\Config();\n\n$memcacheConfig1 = new \\EasySwoole\\Memcache\\Config(Config::getInstance()-&gt;getConf('MEMCACHE1'));\n\\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\MemcachePool($config,$memcacheConfig1),'memcache1');\n\n$memcacheConfig2 = new \\EasySwoole\\Memcache\\Config(Config::getInstance()-&gt;getConf('MEMCACHE2'));\n\\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\MemcachePool($config,$memcacheConfig2),'memcache2');\n    \nCall (can be called globally in the controller):\ngo(function (){\n    $memcachePool1 = Manager::getInstance()-&gt;get('memcache1');\n    $memcachePool2 = Manager::getInstance()-&gt;get('memcache2');\n    $memcache1 = $memcachePool1-&gt;getObj();\n    $memcache2 = $memcachePool2-&gt;getObj();\n\n    var_dump($memcache1-&gt;set('name', 'Alan'));\n    $this-&gt;response()-&gt;write($memcache1-&gt;get('name'));\n    var_dump($memcache2-&gt;set('name', 'Allan'));\n    $this-&gt;response()-&gt;write($memcache2-&gt;get('name'));\n\n    //Recycling object\n    $memcachePool1-&gt;recycleObj($memcache1);\n    $memcachePool2-&gt;recycleObj($memcache2);\n});\nFor detailed usage, see [pool universal connection pool] (../Pool/introduction.md)\nThis article memcache connection pool is based on [pool universal connection pool] (../Pool/introduction.md)","link":"/Components/Memcache/pool.html"},{"id":144,"title":"basic use","content":"FastCache\nEasySwoole provides a fast cache, which is implemented by the basic UnixSock communication and custom process storage data, and provides basic cache service. This cache appears to solve the small application and needs to deploy Redis service.\nInstallation\ncomposer require easyswoole/fast-cache\nService Registration\nWe register in the event of EasySwoole global\nUse EasySwoole\\FastCache\\Cache;\nCache::getInstance()-&gt;setTempDir(EASYSWOOLE_TEMP_DIR)-&gt;attachToServer(ServerManager::getInstance()-&gt;getSwooleServer());\n  FastCache can only be used after the service is started. It needs to create Unix sock permission (recommended to use vm, docker or linux system development). The virtual machine shared directory folder cannot create Unix sock listener.\nClient call\nCan be called anywhere after the service is started\nuse EasySwoole\\FastCache\\Cache;\nCache::getInstance()-&gt;set('get','a');\nvar_dump(Cache::getInstance()-&gt;get('get'));\nSupport Method List\n\n\npublic function setTempDir(string $tempDir): Cache\n     &gt; Setting up a temporary directory\n    \n\n\npublic function setProcessNum(int $num): Cache\n     &gt; Set the number of cache processes\n    \n\n\npublic function setServerName(string $serverName): Cache\n     &gt; Set the service name of the cache process\n    \n\n\npublic function setOnTick($onTick): Cache\n     &gt; Set timing callback, which can be used for data timing landing\n    \n\n\npublic function setTickInterval($tickInterval): Cache\n     &gt; Set the timing callback interval\n    \n\n\npublic function setOnStart($onStart): Cache\n     &gt; Set process startup callback, which can be used for data landing recovery\n    \n\n\npublic function setOnShutdown(callable $onShutdown): Cache\n     &gt; Set process close callback, can be used for data landing\n\n\npublic function set($key, $value, ?int $ttl = null, float $timeout = 1.0)\n\n\npublic function get($key, float $timeout = 1.0)\n\n\npublic function unset($key, float $timeout = 1.0)\n\n\npublic function keys($key = null, float $timeout = 1.0): ?array\n\n\npublic function flush(float $timeout = 1.0)\n\n\npublic function enQueue($key, $value, $timeout = 1.0)\n\n\npublic function deQueue($key, $timeout = 1.0)\n\n\npublic function queueSize($key, $timeout = 1.0)\n\n\npublic function unsetQueue($key, $timeout = 1.0)\n\n\npublic function queueList($timeout = 1.0): ?array\n\n\npublic function flushQueue(float $timeout = 1.0): bool\n\n\npublic function expire($key, int $ttl, $timeout = 1.0)\n\n\npublic function persist($key, $timeout = 1.0)\n\nRemove the expiration time of a key\n\n\n\npublic function ttl($key, $timeout = 1.0)\n\n\nfunction hSet($key, $field, $value, float $timeout = 1.0)\n\n\nfunction hGet($key, $field = null, float $timeout = 1.0)\n\n\nfunction hDel($key, $field = null, float $timeout = 1.0)\n\n\nfunction hFlush(float $timeout = 1.0)\n\n\nfunction hKeys($key, float $timeout = 1.0)\n\n\nfunction hScan($key, $cursor = 0, $limit = 10, float $timeout = 1.0)\n\n\nfunction hSetnx($key, $field, $value, float $timeout = 1.0)\n\n\nfunction hExists($key, $field, float $timeout = 1.0)\n\n\nfunction hLen($key, float $timeout = 1.0)\n\n\nfunction hIncrby($key, $field, $value, float $timeout = 1.0)\n\n\nfunction hMset($key, $fieldValues, float $timeout = 1.0)\n\n\nfunction hMget($key, $fields, float $timeout = 1.0)\n\n\nfunction hVals($key, float $timeout = 1.0)\n\n\nfunction hGetAll($key, float $timeout = 1.0)\n\n\nLanding restart recovery data plan\nFastCache provides three methods for data landing and restart recovery. Set the following method in the mainServerCreate callback event in EasySwooleEvent.php:\n  Setting callbacks You must not change the callback event after registering the service before registering the cache service. \n&lt;?php\n\nuse EasySwoole\\FastCache\\Cache;\nuse EasySwoole\\FastCache\\CacheProcessConfig;\nuse EasySwoole\\FastCache\\SyncData;\nuse EasySwoole\\Utility\\File;\n\n// Save data back to file every 5 seconds\nCache::getInstance()-&gt;setTickInterval(5 * 1000);//Set timing frequency\nCache::getInstance()-&gt;setOnTick(function (SyncData $SyncData, CacheProcessConfig $cacheProcessConfig) {\n    $data = [\n        'data'  =&gt; $SyncData-&gt;getArray(),\n        'queue' =&gt; $SyncData-&gt;getQueueArray(),\n        'ttl'   =&gt; $SyncData-&gt;getTtlKeys(),\n     // Queue support\n        'jobIds'     =&gt; $SyncData-&gt;getJobIds(),\n        'readyJob'   =&gt; $SyncData-&gt;getReadyJob(),\n        'reserveJob' =&gt; $SyncData-&gt;getReserveJob(),\n        'delayJob'   =&gt; $SyncData-&gt;getDelayJob(),\n        'buryJob'    =&gt; $SyncData-&gt;getBuryJob(),\n    ];\n    $path = EASYSWOOLE_TEMP_DIR . '/FastCacheData/' . $cacheProcessConfig-&gt;getProcessName();\n    File::createFile($path,serialize($data));\n});\n\n// Rewrite the file that was saved back at startup\nCache::getInstance()-&gt;setOnStart(function (CacheProcessConfig $cacheProcessConfig) {\n    $path = EASYSWOOLE_TEMP_DIR . '/FastCacheData/' . $cacheProcessConfig-&gt;getProcessName();\n    if(is_file($path)){\n        $data = unserialize(file_get_contents($path));\n        $syncData = new SyncData();\n        $syncData-&gt;setArray($data['data']);\n        $syncData-&gt;setQueueArray($data['queue']);\n        $syncData-&gt;setTtlKeys(($data['ttl']));\n        // Queue support\n        $syncData-&gt;setJobIds($data['jobIds']);\n        $syncData-&gt;setReadyJob($data['readyJob']);\n        $syncData-&gt;setReserveJob($data['reserveJob']);\n        $syncData-&gt;setDelayJob($data['delayJob']);\n        $syncData-&gt;setBuryJob($data['buryJob']);\n        return $syncData;\n    }\n});\n\n// In the daemon process, php easyswoole stop will be called, landing data\nCache::getInstance()-&gt;setOnShutdown(function (SyncData $SyncData, CacheProcessConfig $cacheProcessConfig) {\n    $data = [\n        'data'  =&gt; $SyncData-&gt;getArray(),\n        'queue' =&gt; $SyncData-&gt;getQueueArray(),\n        'ttl'   =&gt; $SyncData-&gt;getTtlKeys(),\n         // Queue support\n        'jobIds'     =&gt; $SyncData-&gt;getJobIds(),\n        'readyJob'   =&gt; $SyncData-&gt;getReadyJob(),\n        'reserveJob' =&gt; $SyncData-&gt;getReserveJob(),\n        'delayJob'   =&gt; $SyncData-&gt;getDelayJob(),\n        'buryJob'    =&gt; $SyncData-&gt;getBuryJob(),\n    ];\n    $path = EASYSWOOLE_TEMP_DIR . '/FastCacheData/' . $cacheProcessConfig-&gt;getProcessName();\n    File::createFile($path,serialize($data));\n});\n\nCache::getInstance()-&gt;setTempDir(EASYSWOOLE_TEMP_DIR)-&gt;attachToServer(ServerManager::getInstance()-&gt;getSwooleServer());\n\nMessage Queue Support","link":"/Components/FastCache/fastCache.html"},{"id":145,"title":"install","content":"Queue Introduction\nThe Easyswoole package implements a lightweight queue, with Redis as the queue driver by default.\nYou can implement a queue driver yourself to implement queue storage in kafka or boot mode.\nAs you can see, Queue is not a separate component, it is more like a facade component that uniformly encapsulates different driver queues.\nstart installation\nComposer require easyswoole/queue\nmanual\n\nRegister queue driver\nSet the consumption process\nProducer delivery task\n\nRedis driver example\nuse EasySwoole\\Redis\\Config\\RedisConfig;\nuse EasySwoole\\RedisPool\\RedisPool;\nuse EasySwoole\\Queue\\Driver\\Redis;\nuse EasySwoole\\Queue\\Queue;\nuse EasySwoole\\Queue\\Job;\n\n$config = new RedisConfig([\n    'host'=&gt;'127.0.0.1'\n]);\n$redis = new RedisPool($config);\n\n$driver = new Redis($redis);\n$queue = new Queue($driver);\n\ngo(function ()use($queue){\n    while (1){\n        $job = new Job();\n        $job-&gt;setJobData(time());\n        $id = $queue-&gt;producer()-&gt;push($job);\n        var_dump('job create for Id :'.$id);\n        \\co::sleep(3);\n    }\n});\n\ngo(function ()use($queue){\n    $queue-&gt;consumer()-&gt;listen(function (Job $job){\n        var_dump($job-&gt;toArray());\n    });\n});","link":"/Components/Queue/install.html"},{"id":146,"title":"custom driver","content":"QueueDrive\nWe can customize the driver to implement the packaging of consumer queue software such as RabbitMQ.\nDefine the class and inherit the EasySwoole\\Queue\\QueueDriverInterface interface to implement several methods.\nQueueDriverInterface\nnamespace EasySwoole\\Queue;\ninterface QueueDriverInterface\n{\n    public function push(Job $job):bool ;\n    public function pop(float $timeout = 3.0):?Job;\n    public function size():?int ;\n}\nComes with redis drive\nnamespace EasySwoole\\Queue\\Driver;\n\nuse EasySwoole\\Queue\\Job;\nuse EasySwoole\\Queue\\QueueDriverInterface;\nuse EasySwoole\\Redis\\Redis as Connection;\nuse EasySwoole\\RedisPool\\RedisPool;\n\nclass Redis implements QueueDriverInterface\n{\n\n    protected $pool;\n    protected $queueName;\n    public function __construct(RedisPool $pool,string $queueName = 'EasySwoole')\n    {\n        $this-&gt;pool = $pool;\n        $this-&gt;queueName = $queueName;\n    }\n\n    public function push(Job $job): bool\n    {\n        $data = $job-&gt;__toString();\n        return $this-&gt;pool-&gt;invoke(function (Connection $connection)use($data){\n            return $connection-&gt;lPush($this-&gt;queueName,$data);\n        });\n    }\n\n    public function pop(float $timeout = 3.0): ?Job\n    {\n        return $this-&gt;pool-&gt;invoke(function (Connection $connection){\n            $data =  json_decode($connection-&gt;rPop($this-&gt;queueName),true);\n            if(is_array($data)){\n                return new Job($data);\n            }else{\n                return null;\n            }\n        });\n    }\n\n    public function size(): ?int\n    {\n        return $this-&gt;pool-&gt;invoke(function (Connection $connection){\n            return $connection-&gt;lLen($this-&gt;queueName);\n        });\n    }\n}","link":"/Components/Queue/driver.html"},{"id":147,"title":"use example","content":"Queue use\nDefining a queue\nnamespace App\\Utility;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\Queue\\Queue;\n\nclass MyQueue extends Queue\n{\n    use Singleton;\n}\nDefine the consumption process\nnamespace App\\Utility;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Queue\\Job;\n\nclass QueueProcess extends AbstractProcess\n{\n\n    protected function run($arg)\n    {\n        go(function (){\n            MyQueue::getInstance()-&gt;consumer()-&gt;listen(function (Job $job){\n                var_dump($job-&gt;getJobData());\n            });\n        });\n    }\n}\n\nCan multi-process, multi-correlation consumption\n\nDriver registration\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Utility\\MyQueue;\nuse App\\Utility\\QueueProcess;\nuse EasySwoole\\Component\\Timer;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\Queue\\Driver\\Redis;\nuse EasySwoole\\Queue\\Job;\nuse EasySwoole\\Redis\\Config\\RedisConfig;\nuse EasySwoole\\RedisPool\\RedisPool;\nuse EasySwoole\\Utility\\Time;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        //Redis pool use please see redis chapter documentation\n        $config = new RedisConfig([\n            'host'=&gt;'127.0.0.1'\n        ]);\n        $redis = new RedisPool($config);\n        $driver = new Redis($redis);\n        MyQueue::getInstance($driver);\n        //Register a consumer process\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new QueueProcess());\n        //Simulated producers, can be delivered anywhere\n        $register-&gt;add($register::onWorkerStart,function ($ser,$id){\n            if($id == 0){\n                Timer::getInstance()-&gt;loop(3000,function (){\n                   $job = new Job();\n                   $job-&gt;setJobData(['time'=&gt;\\time()]);\n                   MyQueue::getInstance()-&gt;producer()-&gt;push($job);\n                });\n            }\n        });\n\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        // TODO: Implement onRequest() method.\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        // TODO: Implement afterAction() method.\n    }\n}","link":"/Components/Queue/usage.html"},{"id":148,"title":"kafka","content":"kafka\nThis project code is referenced from https://github.com/weiboad/kafka-php\nInstallation\ncomposer required easyswoole/kafka\nRegister kafka service\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Producer\\Process as ProducerProcess;\nuse App\\Consumer\\Process as ConsumerProcess;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // TODO: Implement mainServerCreate() method.\n        // Producer\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new ProducerProcess());\n        // consumer\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new ConsumerProcess());\n    }\n\n    ......\n\n}\n\nProducer\nnamespace App\\Producer;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Kafka\\Config\\ProducerConfig;\nuse EasySwoole\\Kafka\\kafka;\n\nclass Process extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        go(function () {\n            $config = new ProducerConfig();\n            $config-&gt;setMetadataBrokerList('127.0.0.1:9092,127.0.0.1:9093');\n            $config-&gt;setBrokerVersion('0.9.0');\n            $config-&gt;setRequiredAck(1);\n\n            $kafka = new kafka($config);\n            $result = $kafka-&gt;producer()-&gt;send([\n                [\n                    'topic' =&gt; 'test',\n                    'value' =&gt; 'message--',\n                    'key'   =&gt; 'key--',\n                ],\n            ]);\n\n            var_dump($result);\n            var_dump('ok');\n        });\n    }\n}\nconsumer\nnamespace App\\Consumer;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Kafka\\Config\\ConsumerConfig;\nuse EasySwoole\\Kafka\\kafka;\n\nclass Process extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        go(function () {\n            $config = new ConsumerConfig();\n            $config-&gt;setRefreshIntervalMs(1000);\n            $config-&gt;setMetadataBrokerList('127.0.0.1:9092,127.0.0.1:9093');\n            $config-&gt;setBrokerVersion('0.9.0');\n            $config-&gt;setGroupId('test');\n\n            $config-&gt;setTopics(['test']);\n            $config-&gt;setOffsetReset('earliest');\n\n            $kafka = new kafka($config);\n            // Set consumption callback\n            $func = function ($topic, $partition, $message) {\n                var_dump($topic);\n                var_dump($partition);\n                var_dump($message);\n            };\n            $kafka-&gt;consumer()-&gt;subscribe($func);\n        });\n    }\n}\n\nBonus\n\nKafka cluster deployment docker-compose.yml one, use as follows\n\nEnsure that the ports 2181, 9092, 9093, and 9000 are not occupied (you can modify the port number in the compose file after occupying)\nUnder the root directory, docker-compose up -d\nVisit localhost:9000 to view the kafka cluster status.\n    \nany Question\nKafka use questions and bugs, welcome to questions or feedback in the kaka group of Easyswoole\nQQ group number: 827432930\n\n\n\n","link":"/Components/kafka.html"},{"id":149,"title":"fastcache queue","content":"FastCacheQueue\nThe EasySwoole FastCache component adds a similar · beanstalkd message queue feature when &gt;= 1.2.1.\n\nCan create multiple queues\nSupport for delayed delivery\nTask timeout resumes execution\nTask resend execution\nMaximum number of retransmissions for the task\nSupport for putJob, delayJob, releaseJob, reserveJob, buryJob, kickJob, etc.\n\nService registration\nFirst check the FastCache basic user manual for component registration.\nAfter the update, the EasySwoole\\FastCache\\CacheProcessConfig class has the following methods.\n/** Set process maximum memory Default 512M */\nPublic function setMaxMem(string $maxMem): void\n/** Set message queue retention time Default 60s (If you do not confirm in time after removing the task, it will be put back into the queue) */\nPublic function setQueueReserveTime(int $queueReserveTime): void\n/** Set the maximum number of resends for the message queue. Default 10 Retransmission will be discarded after the number of hits */\nPublic function setQueueMaxReleaseTimes(int $queueMaxReleaseTimes): void\nstart using\nThe following code is used for both the Job and Cache of the sample code below.\nuse EasySwoole\\FastCache\\Cache;\nuse EasySwoole\\FastCache\\Job;\nDelivery task\nAfter the delivery is successful, the jobId of the task will be returned.\nThere is no failure unless the fastCache registration fails.\n$job = new Job();\n$job-&gt;setData(\"siam\"); // any type of data\n$job-&gt;setQueue(\"siam_queue\");\n$jobId = Cache::getInstance()-&gt;putJob($job);\nVar_dump($jobId);\nTake out the task\nYou can turn on the custom process as the consumer, loop the listener queue, and perform task processing.\n  Note: There must be a result when the task is completed. Either delete the task or resend it. Otherwise, when the task is taken out for a certain period of time (default 60s), it will be automatically put back into the queue.\n$job = Cache::getInstance()-&gt;getJob('siam_queue');// Job object or null\nif ($job === null){\n    echo \"No task\\n\";\n}else{\n    // Execute business logic\n    Var_dump($job);\n    // After the execution is finished, delete or resend, otherwise the timeout will be automatically resent.\n    Cache::getInstance()-&gt;deleteJob($job);\n}\nEmpty the ready task queue\n\n var_dump(Cache::getInstance()-&gt;flushReadyJobQueue('siam_queue'));\n\n var_dump(Cache::getInstance()-&gt;jobQueueSize('siam_queue'));\nDelayed execution of tasks\n$job = new Job();\n$job-&gt;setData(\"siam\");\n$job-&gt;setQueue(\"siam_queue_delay\");\n$job-&gt;setDelay(5);// Delay 5s\n$jobId = Cache::getInstance()-&gt;putJob($job);\nvar_dump($jobId);\n// I will fail to get it right away. I will succeed only after 5s.\n$job = Cache::getInstance()-&gt;getJob('siam_queue_delay');\nvar_dump($job);\nDelete task\nIt can be an object taken by getJob, or you can declare the Job object yourself, and pass in the JobId to delete it.\n$job = new Job();\n$job-&gt;setJobId(1);\n$job-&gt;setQueue('siam_queue_delay');\nCache::getInstance()-&gt;deleteJob($job);\nTask resend\nIf the task fails to execute, or some scenarios need to be re-executed, you can resend it.\nWhen resending, you can specify whether to delay execution.\n// get the task that failed to execute can be resent\n$job = new Job();\n$job-&gt;setData(\"siam\");\n$job-&gt;setQueue(\"siam_queue\");\n$jobId = Cache::getInstance()-&gt;putJob($job);\n\n$job = Cache::getInstance()-&gt;getJob('siam_queue');\n\nif ($job === null){\n    echo \"No task\\n\";\n}else{\n    // Execution of business logic\n    $doRes = false;\n    if (!$doRes){\n        // Business logic failed and needs to be resent\n        // If the delay queue needs to be resent immediately, you need to clear the delay attribute here.\n        // $job-&gt;setDelay(0);\n        // If the normal queue needs to delay retransmission, set the delay attribute\n        // $job-&gt;setDelay(5);\n        $res = Cache::getInstance()-&gt;releaseJob($job);\n        var_dump($res);\n    }else{\n        // To delete or resend after execution, otherwise the timeout will be automatically resent.\n        Cache::getInstance()-&gt;deleteJob($job);\n    }\n}\nBack to what queue is there now\n$queues = Cache::getInstance()-&gt;jobQueues();\nVar_dump($queues);\nReturns the length of a queue\n$queueSize = Cache::getInstance()-&gt;jobQueueSize(\"siam_queue\");\n$queueSize2 = Cache::getInstance()-&gt;jobQueueSize(\"siam_queue_delay\");\nvar_dump($queueSize);\nvar_dump($queueSize2);\nClear Queue Can specify a name\n// empty all\n$res = Cache::getInstance()-&gt;flushJobQueue();\nVar_dump($res);\n\n// empty the siam_queue queue\n$res = Cache::getInstance()-&gt;flushJobQueue('siam_queue');\nVar_dump($res);\nChange task to delayed state\n// Add a task\n$job = new Job();\n$job-&gt;setData(\"LuffyQAQ\");\n$job-&gt;setQueue(\"LuffyQAQ_queue_delay\");\n$jobId = Cache::getInstance()-&gt;putJob($job);\n\n// Method 1 directly into the jobId\n$job-&gt;setJobId($jobId);\n$job-&gt;setDelay(30);\nVar_dump(Cache::getInstance()-&gt;delayJob($job));\n\n//Method 2 Take the task\n$job = Cache::getInstance()-&gt;getJob('LuffyQAQ_queue_delay');\n$job-&gt;setDelay(30);\nVar_dump(Cache::getInstance()-&gt;delayJob($job));\n\n// Use jobQueueSize to view the queue length\n$queueSize = Cache::getInstance()-&gt;jobQueueSize(\"LuffyQAQ_queue_delay\");\nvar_dump($queueSize);\n\nTake from the delayed execution queue\n// Incoming queue name\nVar_dump(Cache::getInstance()-&gt;getDelayJob('LuffyQAQ_queue_delay'));\n\nClear the delay task queue\n\n  Var_dump(Cache::getInstance()-&gt;flushDelayJobQueue('LuffyQAQ_queue_delay'));\n\n  Var_dump(Cache::getInstance()-&gt;jobQueueSize('LuffyQAQ_queue_delay'));\nChange task to reserved state\n// Add a task\n$job = new Job();\n$job-&gt;setData(\"LuffyQAQ\");\n$job-&gt;setQueue(\"LuffyQAQ_queue_reserve\");\n$jobId = Cache::getInstance()-&gt;putJob($job);\n\n// Method 1 directly into the jobId\n$job-&gt;setJobId($jobId);\nVar_dump(Cache::getInstance()-&gt;reserveJob($job));\n\n//Method 2 Take the task\n$job = Cache::getInstance()-&gt;getJob('LuffyQAQ_queue_reserve');\nVar_dump(Cache::getInstance()-&gt;reserveJob($job));\n\n// Use jobQueueSize to view the queue length\n$queueSize = Cache::getInstance()-&gt;jobQueueSize(\"LuffyQAQ_queue_reserve\");\nVar_dump($queueSize);\nTake from the reservation queue\n// Incoming queue name\nVar_dump(Cache::getInstance()-&gt;getReserveJob('LuffyQAQ_queue_reserve'));\n\nEmpty the reserve task queue\n\n  Var_dump(Cache::getInstance()-&gt;flushReserveJobQueue('LuffyQAQ_queue_reserve'));\n\n  Var_dump(Cache::getInstance()-&gt;jobQueueSize('LuffyQAQ_queue_reserve'));\nChange the task to the buried state\n$job = new Job();\n$job-&gt;setQueue('LuffyQAQ_queue_bury');\n$job-&gt;setData('LuffyQAQ');\n$jobId = Cache::getInstance()-&gt;putJob($job);\n$job-&gt;setJobId($jobId);\n\nvar_dump(Cache::getInstance()-&gt;buryJob($job));\n\n//Use jobQueueSize to view queue length\n$queueSize = Cache::getInstance()-&gt;jobQueueSize(\"LuffyQAQ_queue_bury\");\nvar_dump($queueSize);\n\nTake from the buried queue\n// Incoming queue name\nVar_dump(Cache::getInstance()-&gt;getBuryJob('LuffyQAQ_queue_bury'));\n\nRestore buried queue tasks to ready\n\nVar_dump(Cache::getInstance()-&gt;kickJob($job));\n\nEmpty bury task queue\n\n var_dump(Cache::getInstance()-&gt;flushBuryJobQueue('LuffyQAQ_queue_bury'));\n\n var_dump(Cache::getInstance()-&gt;jobQueueSize('LuffyQAQ_queue_bury'));","link":"/Components/FastCache/fastCacheQueue.html"},{"id":150,"title":"singleton","content":"Single case\nThe singleton pattern ensures that a class can only have one instance globally, because its instances are saved by itself and cannot be instantiated outside of the class.  \nEffect\nPHP's singleton mode is to avoid the resource consumption caused by repeated creation of objects.\nUse\nThe actual project is like a database query, log output, global callback, unified check and other modules. These modules have a single function, but require multiple accesses. If they are globally unique, multiple reuses will greatly improve performance.\nExample\n\nnamespace EasySwoole\\Component;\n\nclass MySingleton\n{\n    use Singleton;\n}\n\n$mySingleton = Mysingleton::getInstance();\n\nCore object method\nCore class: EasySwoole\\Component\\Singleton。\nGet object\n\nmixed     $args     parameter\n\nstatic function getInstance(...$args)","link":"/Components/Component/singleton.html"},{"id":151,"title":"coroutine singleton","content":"Coroutine Singleton\nFor the security of singleton mode under the compatible coroutine environment, coroutinesingleton can be used\nReference method can refer to common Singleton trait\nnamespace EasySwoole\\Component;\nuse Swoole\\Coroutine;\ntrait CoroutineSingleTon\n{\n    private static $instance = [];\n    static function getInstance(...$args)\n    {\n        $cid = Coroutine::getCid();\n        if(!isset(self::$instance[$cid])){\n            self::$instance[$cid] = new static(...$args);\n            /*\n             * Compatible with non coroutine environment\n             */\n            if($cid &gt; 0){\n                Coroutine::defer(function ()use($cid){\n                    unset(self::$instance[$cid]);\n                });\n            }\n        }\n        return self::$instance[$cid];\n    }\n    function destroy(int $cid = null)\n    {\n        if($cid === null){\n            $cid = Coroutine::getCid();\n        }\n        unset(self::$instance[$cid]);\n    }\n} ","link":"/Components/Component/coroutineSingleton.html"},{"id":152,"title":"ready waiting","content":"ReadyScheduler\nSince the 1.8.7 release of the Easyswoole base component, a ready-to-plan program based on the Swoole Table implementation has been provided to resolve some sub-service not-ready issues when the main service starts.\nBasic test use\nnamespace EasySwoole\\Component\\Tests;\n\nuse EasySwoole\\Component\\ReadyScheduler;\nuse PHPUnit\\Framework\\TestCase;\nuse Swoole\\Coroutine;\n\nclass ReadySchedulerTest extends TestCase\n{\n    function testNormal()\n    {\n        ReadyScheduler::getInstance()-&gt;addItem('worker');\n        ReadyScheduler::getInstance()-&gt;addItem('rpc');\n        ReadyScheduler::getInstance()-&gt;addItem('fastCache');\n\n        go(function (){\n            Coroutine::sleep(1);\n            ReadyScheduler::getInstance()-&gt;ready('worker');\n            ReadyScheduler::getInstance()-&gt;ready('rpc');\n        });\n        $this-&gt;assertEquals(false,ReadyScheduler::getInstance()-&gt;waitReady(['rpc','worker'],0.1));\n        $this-&gt;assertEquals(true,ReadyScheduler::getInstance()-&gt;waitReady('rpc'));\n        $this-&gt;assertEquals(true,ReadyScheduler::getInstance()-&gt;waitReady(['rpc','worker']));\n        $this-&gt;assertEquals(false,ReadyScheduler::getInstance()-&gt;waitReady(['rpc','worker','fastCache'],1.1));\n    }\n}\nUsed in the EasySwoole service\nTake Http service as a basic example\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\Component\\ReadyScheduler;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse Swoole\\Coroutine;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        /*\n         * Main process initialization table\n         */\n        ReadyScheduler::getInstance();\n        /*\n         * Assume that when the service starts, it depends on serviceOne, serviceTwo and other services, such as linking third-party apis.\n         * When the service is not ready, we do not want this machine to start external service.\n         */\n        $register-&gt;add($register::onWorkerStart,function ($serv, $workerId){\n            if($workerId == 0){\n                /*\n                 * If not mandatory, please pay attention to addItem, unready, ready implementation\n                 */\n                Coroutine::sleep(3);\n                ReadyScheduler::getInstance()-&gt;ready('serviceOne',true);\n                var_dump('r1');\n            }else if($workerId == 1){\n                Coroutine::sleep(4);\n                ReadyScheduler::getInstance()-&gt;ready('serviceTwo',true);\n                var_dump('r2');\n            }\n        });\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        /*\n         * When the link comes in, determine if the dependent service is ready, and wait for 1s (tcp, ws service is also the same)\n         * When the service is not ready, we first refuse the service.\n        */\n        if(!ReadyScheduler::getInstance()-&gt;waitReady(['serviceOne','serviceTwo'],1.0)){\n            $response-&gt;write('not ready,try again');\n            return false;\n        }\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n\n    }\n}","link":"/Components/Component/readyScheduler.html"},{"id":153,"title":"coroutine actuator","content":"CoroutineRunner\nCoroutine runner is similar to CSP component, but it is more flexible. It can post the tasks of coroutine and limit the maximum number of simultaneous execution, the maximum execution time, success or failure callback\nSimple example\nuse co;\nuse EasySwoole\\Component\\CoroutineRunner\\Runner;\nuse EasySwoole\\Component\\CoroutineRunner\\Task;\n\n$runner = new Runner(10);\n$runner-&gt;setOnException(function(\\Throwable  $e, $task){\n    echo $e-&gt;getMessage();\n    echo PHP_EOL;\n});\n\n$max = 30;\n$allTask = [];\nwhile($max&gt;0){\n    $task = new Task(function() use ($max) {\n        echo $max .PHP_EOL;\n        co::sleep(1);\n        // It will be assumed that this is a curl crawling task. Return crawling results can be obtained externally\n        return 'ok';\n    });\n    $runner-&gt;addTask($task);\n    $allTask[] = $task;\n    $max--;\n}\n\n$runner-&gt;start(1);// The longest execution time is 1 second, 30 posts are posted in total, and the maximum concurrent execution time is 10, which takes 3 seconds to complete, so some of them will be discarded. See the parameter description list below\n\nforeach($allTask as $key =&gt; $task){\n    var_dump($task-&gt;getResult());\n}\n\nParameter description\nRunner constructor\nTwo parameters can be received __construct($concurrency = 64,$taskChannelSize = 1024)\n\nconcurrency Maximum number of concurrent processes\ntaskChannelSize Deliverable task queue length\n\nRunner-&gt;setOnException\nThere are two parameters for setting exception callback (\\Throwable $e, Task $task) \nRunner-&gt;start\nTo start the execution of the delivered task process, there is a parameter\n\nfloat $waitTime = 30 The maximum execution time. If this time is exceeded, the remaining tasks will be discarded and will not be executed.\n\nTask constructor\nYou need a callable parameter to call execution. You can use '$task - &gt; getresult()' to get the return data in the 'closure' and external use '$task - &gt; getresult()'\n\nreturn Data not equal to false will trigger onsuccess\nreturn False will trigger onfail\n\nTask-&gt;setOnSuccess\nA call parameter is required\n[not required] callback after task execution\nTask-&gt;setOnFail\nA call parameter is required\n[not required] callback for task execution failure\nTask-&gt;getResult\nGet the return data after the call function is executed","link":"/Components/Component/coroutineRunner.html"},{"id":154,"title":"swoole table","content":"TableManager\nEasySwoole\\Component\\TableManager\nEasySwoole has a basic package for Swoole table for shared memory\nMethod list\ngetInstance()\nThis method is used to get the TableManager manager instance.\nadd($name,array $columns,$size = 1024)\nThis method is used to create a table\nget($name):?Table\nThis method is used to get the table that has been created.\nSample code\nTableManager::getInstance()-&gt;add(\n    self::TABLE_NAME,\n    [\n        'currentNum'=&gt;['type'=&gt;Table::TYPE_INT,'size'=&gt;2],\n    ],\n    1024\n);\nNote: Do not create a swoole table in callback locations such as onRequest, OnReceive, etc. The swoole table should be created before the service is started, for example in the mainServerCreate event.","link":"/Components/Component/tableManager.html"},{"id":155,"title":"atomic counter","content":"Atomic\nswoole_atomic is an atomic count operation class provided by the swoole extension, which can facilitate the increase and decrease of integer-free lock-free atoms.\n\n\nswoole_atomic uses shared memory to manipulate counts between different processes\n\nswoole_atomic is based on the CPU atomic instructions provided by gcc, no need to lock\n\nswoole_atomic must be created before the swoole_server-&gt;start in the server program to be used in the Worker process.\n\nswoole_atomic uses 32-bit unsigned types by default. If you need 64-signed integers, you can use Swoole\\Atomic\\Long.\n\nNote: Do not create atomic numbers in callback functions such as onReceive, otherwise the underlying GlobalMemory memory will continue to grow, causing memory leaks.\nUse\nInitialization count:\n\nInt init_value initial value\n\npublic function __construct($init_value)\nIncrease the count:\n\nInt add_value increased value\n\npublic function add($add_value)\nReduce the count:\n\nInt sub_value reduced value\n\npublic function sub($sub_value)\nGet the current count value:\npublic function get()\nSet the current value to the specified number:\n\nint value count value\n\npublic function set($value)\nIf the current value is equal to parameter 1, the current value is set to parameter 2:\n\nint cmp_value is the value to be compared\nint set_value is set to the specified count value after the current value is equal to the value being compared\n\npublic function cmpset($cmp_value, $set_value)\nExamples\nRegister the atomic object in the `EasySwooleEvent initialization function.\n// Register an atomic object\nAtomicManager::getInstance()-&gt;add('second');\nGet the atomic object from AtomicManager and use it.\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/3/18 0018\n * Time: 15:39\n */\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Component\\AtomicManager;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    function index()\n    {\n\n        AtomicManager::getInstance()-&gt;add('second',0);\n        $atomic = AtomicManager::getInstance()-&gt;get('second');\n        $atomic-&gt;add(1);\n        $this-&gt;response()-&gt;write($atomic-&gt;get());\n        // TODO: Implement index() method.\n    }\n}","link":"/Components/Component/atomic.html"},{"id":156,"title":"channel lock coroutine lock","content":"channel Lock\nNamespace:\\EasySwoole\\Component\\ChannelLock.\nChannelLock adoptCoroutine channelFeature implements the locking mechanism of the cooperation level.  \ngo(function (){\n    //Lock up\n    $result = \\EasySwoole\\Component\\ChannelLock::getInstance()-&gt;lock('a');\n    var_dump($result);\n    co::sleep(1);\n    //Unlock\n    $result = \\EasySwoole\\Component\\ChannelLock::getInstance()-&gt;unlock('a');\n    var_dump($result);\n});\nlock\nTry locking$lockName.\nMethod prototype:  function lock(string $lockName,float $timeout = -1):bool\nParameter introduction:  \n\n$lockName Lock name\n$timeout Timeout -1 means never timeout\nWhen this function is called, it will try to lock $lockname '. If it succeeds, it will return true. If other processes have locked this $lockname', it will block until the timeout returns false (- 1 does not use timeout, which means blocking forever)  \n\nunlock\nUnlock\nMethod prototype:  function unlock(string $lockName,float $timeout = -1):bool\nParameter introduction:  \n\n$lockName Lock name\n$timeout Timeout - 1 means never timeout\nUnlock ` $lockname '. True will be returned after success\n\ndeferLock\nTry to lock ` $lockname 'and unlock it automatically after the cooperation\nMethod prototype:  deferLock(string $lockName,float $timeout = -1):bool\nParameter introduction:  \n\n$lockName Lock name\n$timeout Timeout,-1 is never timeout\n","link":"/Components/Component/channelLock.html"},{"id":157,"title":"splarray","content":"SplArray related methods\nMethod list\n\n\n\nMethod name\nparameter\nDescription\nRemarks\n\n\n\n\nset\n$key,$value\nSetting parameters\n\n\n\nget\n$key\nGet parameters\n\n\n\n__toString\n\nTransfer character\n\n\n\ngetArrayCopy\n\nArray assignment\n\n\n\nunset\n$key\nDestroy array elements\n\n\n\ndelete\n$key\nRemove a data item\n\n\n\nunique\n\nArray value unique\n\n\n\nmultiple\n\nGet duplicate values in an array\n\n\n\nasort\n\nSort and maintain index relationships\n\n\n\nksort\n\nSort by key name\n\n\n\nsort\n$sort_flags = SORT_REGULAR\nCustom sort\n\n\n\ncolumn\n$key\nGet a column\n\n\n\nflip\n\nSwap keys and values in an array\n\n\n\nfilter\n$key,[$key2....],$bool\nFilter array data\n\n\n\nkeys\n$key\nGet array index\n\n\n\nvalues\n\nGet all the values in the array\n\n\n\nflush\n\nClear data\n\n\n\nloadArray\n$data\nReload data\n\n\n\ntoXML\n\nConvert to xml\n\n\n\n\nThe basic tools for easyswoole to handle array encapsulation are as follows:\n/**\n *\n * User: LuffyQAQ\n * Date: 2019/10/16 16:02\n * Email: &lt;1769360227@qq.com&gt;\n */\ninclude \"./vendor/autoload.php\";\n\n$data = [\n    'fruit' =&gt; [\n        'apple' =&gt; 2,\n        'orange' =&gt; 1,\n        'grape' =&gt; 4\n    ],\n    'color' =&gt; [\n        'red' =&gt; 12,\n        'blue' =&gt; 8,\n        'green' =&gt; 6\n    ],\n    'name' =&gt; [\n        'name1' =&gt; 'LuffyQAQ',\n        'name2' =&gt; 'LuffyQAQ'\n    ]\n];\n$splArray = new \\EasySwoole\\Spl\\SplArray($data);\n\n$splArray-&gt;set('fruit.apple', 3);\n\nvar_dump($splArray);\n\nvar_dump($splArray-&gt;get('fruit.apple'));\n\nvar_dump($splArray-&gt;__toString());\n\nvar_dump($splArray-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;unset('color'));\n\nvar_dump($splArray-&gt;delete('fruit.apple'));\n\nvar_dump($splArray-&gt;unique()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;multiple()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;asort()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;ksort()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;sort()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;column('name')-&gt;getArrayCopy());\n\n$splArrays = new \\EasySwoole\\Spl\\SplArray(['es' =&gt; 'easyswoole']);\n\nvar_dump($splArrays-&gt;flip()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;filter('green,grape', false)-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;filter('green,grape', true)-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;keys('name'));\n\nvar_dump($splArray-&gt;values()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;flush()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;loadArray(['name' =&gt; 'easyswoole'])-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;toXML());\n","link":"/Components/Spl/splArray.html"},{"id":158,"title":"splbean","content":"Use\nUsed to define the table structure and filter out invalid field data.\nSplBean related methods\nMethod list\n\n\n\nMethod Name\nParameters\nDescription\nNotes\n\n\n\n\n__construct\narray $data = null,$autoCreateProperty = false\nConstructor, initialize bean data\n\n\n\nallProperty\n\nFilter and convert to array data\n\n\n\ntoArray\narray $columns = null,$filter = null\nTransfer character\n\n\n\ntoArrayWithMapping\narray $columns = null,$filter = null\nGet filtered array data with field aliases\n\n\n\narrayToBean\narray $data,$autoCreateProperty = false\nSet class properties\n\n\n\naddProperty\n$name,$value = null\nSet class member variables\n\n\n\ngetProperty\n$name\nGet class member variable values\n\n\n\njsonSerialize\n\nGet class member variable collection\n\n\n\ninitialize\n\nInitialization operation\n\n\n\nsetKeyMapping\n\nSet the keyMapping relationship, which is the field alias\n\n\n\nsetClassMapping\n\nSet the classMapping relationship, which is the associated class.\n\n\n\nrestore\narray $data = [], $autoCreateProperty = false\nReinitialize bean data\n\n\n\nclassMap\n\nBinding association class\n\n\n\n\nhow to use\n\n/**\n *\n * User: LuffyQAQ\n * Date: 2019/10/16 16:45\n * Email: &lt;1769360227@qq.com&gt;\n */\ninclude \"./vendor/autoload.php\";\nuse EasySwoole\\Spl\\SplBean;\n\nclass TestBean extends SplBean\n{\n    public $a = 2;\n    protected $b;\n    private $c;\n    protected $d_d;\n\n    protected function setKeyMapping(): array\n    {\n        return [\n            'd-d' =&gt; \"d_d\"\n        ];\n    }\n}\n\n$bean = new TestBean([\n    'a'=&gt;'a',\n    'b'=&gt;'b',\n    'c'=&gt;'c',\n    'd_d'=&gt;'d_d'\n]);\n\nvar_dump($bean-&gt;allProperty());\n\n$data = $bean-&gt;toArray(null, function ($a) {\n    if (in_array($a, ['d_d'])) {\n        return $a;\n    }\n});\n\n$bean = new TestBean([\n    'a'=&gt;1,\n    'b'=&gt;2,\n    'c'=&gt;3,\n    'd_d'=&gt;4\n]);\n$data = $bean-&gt;toArrayWithMapping(['a', 'b', 'd-d'], function ($val) {\n    return $val;\n});\n\nvar_dump($data);\n\nvar_dump($bean-&gt;toArrayWithMapping(['a','d-d']));\n\n$bean = new TestBean();\n$bean-&gt;addProperty('a', 'es');\n$bean-&gt;addProperty('b', 'es');\n$bean-&gt;addProperty('d_d', 'es');\n\nvar_dump($bean-&gt;toArray());\n\nvar_dump($bean-&gt;getProperty('a'));\n\nvar_dump( $bean-&gt;jsonSerialize());\n\nvar_dump($bean-&gt;restore()-&gt;toArray());\n","link":"/Components/Spl/splBean.html"},{"id":159,"title":"splenum","content":"Use\nUsed to define a collection of enumerations and normalize enumeration data.\nSplEnum related methods\nMethod list\n\n\n\nMethod Name\nParameters\nDescription\nNotes\n\n\n\n\n__construct\n$val\nConstructor\n\n\n\ngetName\n\nGet the key that defines the constant\n\n\n\ngetValue\n\nGet defined constants\n\n\n\nisValidName\nstring $name\nFinding if the constant's key value is valid\n\n\n\nisValidValue\n$val\nFinding if the value of a constant is valid\n\n\n\ngetEnumList\n\nGet Enumeration Collection\n\n\n\ngetConstants\n\nGet Enumeration Collection\n\n\n\n\nhow to use\n/**\n *\n * User: zs\n * Date: 2019/10/16 17:08\n * Email: &lt;1769360227@qq.com&gt;\n */\n\ninclude \"./vendor/autoload.php\";\n\nclass Month extends \\EasySwoole\\Spl\\SplEnum {\n    const JANUARY = 1;\n    const FEBRUARY = 2;\n    const MARCH = 3;\n    const APRIL = 4;\n    const MAY = 5;\n    const JUNE = 6;\n    const JULY = 7;\n    const AUGUST = 8;\n    const SEPTEMBER = 9;\n    const OCTOBER = 10;\n    const NOVEMBER = 11;\n    const DECEMBER = 12;\n}\n$month = new Month(1);\n\nvar_dump($month-&gt;getName());\n\nvar_dump($month-&gt;getValue());\n\nvar_dump(Month::isValidName('JANUARY'));\n\nvar_dump(Month::isValidValue(1));\n\nvar_dump( Month::getEnumList());\n","link":"/Components/Spl/splEnum.html"},{"id":160,"title":"splstream","content":"SplStream\nUse\nResource flow data operation\nHow to operate\n\n\n\nMethod name\nparameter\nDescription\n\n\n\n\n__construct\n$resource = '',$mode = 'r+'\nInitialize resources and read and write operations\n\n\n__toString\n\nOutput resource\n\n\nclose\n\nClose an open file pointer\n\n\ndetach\n\nGet resources and reset resource objects\n\n\ngetSize\nGet resource size\nCode conversion\n\n\ntell\n\nReturns the location of the file pointer read/write\n\n\neof\n\nWhether the file pointer has reached the end of the file\n\n\nisSeekable\n\nGet can be positioned in the current stream\n\n\nseek\n$offset, $whence = SEEK_SET\nPositioning in the file pointer\n\n\nrewind\n\nRewind the position of the file pointer\n\n\nisWritable\n\nIs it writable\n\n\nwrite\n$string\nWrite content\n\n\nisReadable\n\nReadable\n\n\nread\n$length\nReading content\n\n\nlength\n\nGet the length of the string\n\n\ngetContents\n\nRead resource stream to a string\n\n\ngetMetadata\n$key = null\nGet header/metadata from the package protocol file pointer\n\n\ngetStreamResource\n\nAccess to resources\n\n\ntruncate\n$size = 0\nTruncate the file to the given length\n\n\n\nexample\n__construct\nInitialize resources and read and write operations\n\nmixed $resource resource\nmixed $mode read and write operation type\nfunction __construct($resource = '',$mode = 'r+')\n\n\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$resource = fopen('./test.txt', 'ab+');\n$stream = new \\EasySwoole\\Spl\\SplStream($resource);\nvar_dump($stream-&gt;__toString());\n\n/**\n * The output is over:\n * string(10) \"Easyswoole\"\n */\n\n__toString\nOutput resource\npublic function __toString()\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\nvar_dump($stream-&gt;__toString());\n\n/**\n * The output is over:\n * string(10) \"Easyswoole\"\n */\n\nclose\nClose an open file pointer\npublic function close()\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;close();\nvar_dump($stream-&gt;__toString());\n\n/**\n * The output is over:\n * string(0) \"\"\n */\n\ndetach\nGet resources and reset resource objects\npublic function detach()\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;detach();\nvar_dump($stream-&gt;__toString());\n\n/**\n * The output is over:\n * string(0) \"\"\n */\n\ngetSize\nGet resource size\npublic function getSize()\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$size = $stream-&gt;getSize();\nvar_dump($size);\n\n/**\n * The output is over:\n * int(10)\n */\n\ntell\nReturns the location of the file pointer read/write\npublic function tell()\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$position = $stream-&gt;tell();\nvar_dump($position);\n\n/**\n * The output is over:\n * int(10)\n */\n\neof\nWhether the file pointer has reached the end of the file\npublic function eof()\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$eof = $stream-&gt;eof();\nvar_dump($eof);\n$stream-&gt;detach();\n$eof = $stream-&gt;eof();\nvar_dump($eof);\n\n/**\n * The output is over:\n * bool(false)\n * bool(true)\n */\n\nisSeekable\nGet can be positioned in the current stream\npublic function isSeekable()\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$seekable = $stream-&gt;isSeekable();\nvar_dump($seekable);\n\n/**\n * The output is over:\n * bool(true)\n */\n\nseek\nPositioning in the file pointer\n\n\nmixed $offset offset\n\n\nmixed $whence specified type\npublic function seek($offset, $whence = SEEK_SET)\nSpecified type:\n\n\nSEEK_SET set position equal to offset byte\n\n\nSEEK_CUR sets the position to the current position plus offset\n\n\nSEEK_END sets the position to the end of the file plus offset\n\n\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;seek(2);\n$position = $stream-&gt;tell();\nvar_dump($position);\n\n/**\n * The output is over:\n * int(2)\n */\n\nrewind\nRewind the position of the file pointer\npublic function rewind()\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;rewind();\n$position = $stream-&gt;tell();\nvar_dump($position);\n\n/**\n * The output is over:\n * int(0)\n */\n\nisWritable\nIs it writable\npublic function isWritable()\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$writeAble = $stream-&gt;isWritable();\nvar_dump($writeAble);\n\n/**\n * The output is over:\n * bool(true)\n */\n\nwrite\nWrite content\n\nmixed $string content\npublic function write($string)\n\n\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;write(', 666');\nvar_dump($stream-&gt;__toString());\n\n/**\n * The output is over:\n * string(15) \"Easyswoole, 666\"\n */\n\nisReadable\nWhether to read\npublic function isReadable()\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$readAble = $stream-&gt;isReadable();\nvar_dump($readAble);\n\n/**\n * The output is over:\n * bool(true)\n */\n\nread\nReading content\n\nmixed     $length       length\npublic function read($length)\n\n\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;rewind();\n$string = $stream-&gt;read(4);\nvar_dump($string);\n\n/**\n * The output is over:\n * string(4) \"Easy\"\n */\n\ngetContents\nRead resource stream to a string\npublic function getContents()\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;rewind();\n$string = $stream-&gt;getContents();\nvar_dump($string);\n\n/**\n * The output is over:\n * string(10) \"Easyswoole\"\n */\n\ngetMetadata\nGet header/metadata from the package protocol file pointer\npublic function getMetadata($key = null)\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$meta = $stream-&gt;getMetadata();\nvar_dump($meta['stream_type']);\n\n/**\n * The output is over:\n * string(6) \"MEMORY\"\n */\n\ngetStreamResource\nAccess to resources\nfunction getStreamResource()\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$resource = $stream-&gt;getStreamResource();\nfseek($resource, 0, SEEK_SET);\nvar_dump(stream_get_contents($resource));\n\n/**\n * The output is over:\n * string(10) \"Easyswoole\"\n */\n\ntruncate\nTruncate the file to the given length\n\nmixed     $size       Intercept file size\nfunction truncate($size = 0)\n\n\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 10:25 am\n */\n\nrequire_once 'vendor/autoload.php';\n\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;truncate(4);\nvar_dump($stream-&gt;__toString());\n\n/**\n * The output is over:\n * string(4) \"Easy\"\n */\n\nPs: There is a difference between resources and resource flows. The resources mentioned here are data or variables. The resource flow is a file stream.","link":"/Components/Spl/splStream.html"},{"id":161,"title":"splfilestream","content":"SplFileStream\nUse\nFile resource stream data operation\nHow to operate\n\n\n\nMethod Name\nParameters\nDescription\n\n\n\n\n__construct\n$file,$mode = 'c+'\nInitialize resources and read and write operations\n\n\nlock\n$mode = LOCK_EX\nFile Lock\n\n\nunlock\n$mode = LOCK_UN\nRelease Lock\n\n\n\nThe SplFileStream class inherits SplStream, and other related methods refer to SplStream。\nexample\n__construct\nInitialize resources and read and write operations\n\nmixed $file file\nmixed $mode read and write operation type\n\nfunction __construct($file,$mode = 'c+')\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 上午10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$fileStream = new \\EasySwoole\\Spl\\SplFileStream('./test.txt');\n$type = $fileStream-&gt;getMetadata('stream_type');\nvar_dump($type);\n\n/**\n * The output is over:\n * string(5) \"STDIO\"\n */\n\nlock\nFile lock\n\nmixed $mode lock type\n\nLock type:\n\nLOCK_SH gets shared lock (read program)\nLOCK_EX gets exclusive lock (written program)\nLOCK_UN release lock (whether shared or exclusive)\nfunction lock($mode = LOCK_EX)\n\n\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 上午10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$fileStream = new \\EasySwoole\\Spl\\SplFileStream('./test.txt');\n$lock = $fileStream-&gt;lock();\nvar_dump($lock);\n\n/**\n * The output is over:\n * bool(true)\n */\n\nunlock\nRelease lock\n\nmixed     $mode       Lock type\nfunction unlock($mode = LOCK_UN)\n\n\nexample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 上午10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$fileStream = new \\EasySwoole\\Spl\\SplFileStream('./test.txt');\n$unlock = $fileStream-&gt;unlock();\nvar_dump($unlock);\n\n/**\n * The output is over:\n * bool(true)\n */\n","link":"/Components/Spl/splFileStream.html"},{"id":162,"title":"splstring","content":"SplString\nUse\nUsed to process strings.\nMethod\n\n\n\nMethod name\nparameter\nDescription\n\n\n\n\nsetString\nstring $string\nSet string\n\n\nsplit\nint $length = 1\nSplit a string by length\n\n\nexplode\nstring $delimiter\nSplit a string by separator\n\n\nsubString\nint $start, int $length\nIntercept string\n\n\nencodingConvert\nstring $desEncoding, $detectList = ['UTF-8', 'ASCII', 'GBK',...]\nCode conversion\n\n\nutf8\n\nConvert to utf\n\n\nunicodeToUtf8\n\nConvert unicode encoding to utf-8\n\n\ntoUnicode\n\nConvert to unicode encoding (seconds)\n\n\ncompare\nstring $str, int $ignoreCase = 0\nBinary string comparison\n\n\nlTrim\nstring $charList = &quot; \\t\\n\\r\\0\\x0B&quot;\nDelete whitespace characters (or other characters) at the beginning of the string\n\n\nrTrim\nstring $charList = &quot; \\t\\n\\r\\0\\x0B&quot;\nDelete whitespace characters (or other characters) at the end of the string\n\n\ntrim\nstring $charList = &quot; \\t\\n\\r\\0\\x0B&quot;\nRemove whitespace characters (or other characters) at the beginning and end of the string\n\n\npad\nint $length, string $padString = null, int $pad_type = STR_PAD_RIGHT\nFill the string to the specified length with another string\n\n\nrepeat\nint $times\nRepeat a string\n\n\nlength\n\nGet the length of the string\n\n\nupper\n\nConvert a string to uppercase\n\n\nlower\n\nConvert a string to lowercase\n\n\nstripTags\nstring $allowable_tags = null\nRemove HTML and PHP tags from strings\n\n\nreplace\nstring $find, string $replaceTo\nSubstring replacement\n\n\nbetween\nstring $startStr, string $endStr\nGet the intermediate string of the specified target\n\n\nregex\n$regex, bool $rawReturn = false\nFind strings according to regular rules\n\n\nexist\nstring $find, bool $ignoreCase = true\nWhether the specified string exists\n\n\nkebab\n\nConvert to skewers\n\n\nsnake\nstring $delimiter = '_'\nTurn into a snake\n\n\nstudly\n\nhump\n\n\ncamel\n\nSmall hump\n\n\nreplaceArray\nstring $search, array $replace\nReplace the string in turn\n\n\nreplaceFirst\nstring $search, string $replace\nReplace the first occurrence of the given value in the string\n\n\nreplaceLast\nstring $search, string $replace\nReplace the last occurrence of the given value in the string\n\n\nstart\nstring $prefix\nStart a string with a single instance of a given value\n\n\nafter\nstring $search\nReturns the rest of the string after the given value\n\n\nbefore\nstring $search\nGet a part of the string before the given value\n\n\nendsWith\n$needles\nDetermines if the given string ends with the given substring\n\n\nstartsWith\n$needles\nDetermine if the given string starts with the given substring\n\n\n\nExample\nsetString\nSet the string.\n\n\nstring $string Data item index\nfunction setString( string $string ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$string = new \\EasySwoole\\Spl\\SplString();\nvar_dump($string-&gt;setString('Hello, EasySwoole')-&gt;__toString());\n\n/**\n * The output is over:\n * string(17) \"Hello, EasySwoole\"\n */\n\nsplit\nSets the value of an item in the array.\n\n\nint $length Length of each segment\nfunction split( int $length = 1 ) : SplArray\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;split(5)-&gt;getArrayCopy());\n\n/**\n * The output is over:\n * array(4) {\n *   [0]=&gt;\n *   string(5) \"Hello\"\n *   [1]=&gt;\n *   string(5) \", Eas\"\n *   [2]=&gt;\n *   string(5) \"ySwoo\"\n *   [3]=&gt;\n *   string(2) \"le\"\n * }\n */\n\nexplode\nSplit string\n\n\nstring $delimiter separator\nfunction explode( string $delimiter ) : SplArray\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;explode(',')-&gt;getArrayCopy());\n\n/**\n * The output is over:\n * array(2) {\n *   [0]=&gt;\n *   string(5) \"Hello\"\n *   [1]=&gt;\n *   string(11) \" EasySwoole\"\n * }\n */\n\nsubString\nIntercept string\n\n\nint $start Starting position\n\nint $length Intercept length\nfunction subString( int $start, int $length ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;subString(0, 5)-&gt;__toString());\n\n/**\n * The output is over:\n * string(5) \"Hello\"\n */\n\nencodingConvert\nCode conversion\n\n\nstring $desEncoding The encoding format to be converted\n\nmixed $detectList Character encoding list\nfunction encodingConvert( string $desEncoding, $detectList = ['UTF-8', 'ASCII', 'GBK', 'GB2312', 'LATIN1', 'BIG5', \"UCS-2\",] ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;encodingConvert('UTF-8')-&gt;__toString());\n\n/**\n * The output is over:\n * string(17) \"Hello, EasySwoole\"\n }\n\n */\n\nutf8\nConvert to utf-8\nfunction utf8() : SplString\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;utf8()-&gt;__toString());\n\n/**\n * The output is over:\n * string(17) \"Hello, EasySwoole\"\n }\n\n */\n\nunicodeToUtf8\nConvert unicode encoding to utf-8\nfunction unicodeToUtf8() : SplString\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = '\\u4e2d';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;unicodeToUtf8()-&gt;__toString());\n\n/**\n * The output is over:\n * string(3) \"中\"\n */\n\ntoUnicode\nConvert to unicode encoding\nfunction toUnicode() : SplString\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = '中';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;toUnicode()-&gt;__toString());\n\n/**\n * The output is over:\n * string(6) \"\\U4E2D\"\n */\n\ncompare\nBinary string comparison\n\n\nstring $str The string to be compared\n\nint $ignoreCase Need to be slightly different\nfunction compare( string $str, int $ignoreCase = 0 ) : int\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;compare('apple'));\n\n/**\n * The output is over:\n * int(19)\n */\n\nlTrim\nDelete whitespace characters (or other characters) at the beginning of the string\n\n\nstring $charList Deleted characters\nfunction lTrim( string $charList = \" \\t\\n\\r\\0\\x0B\" ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = '  test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;lTrim()-&gt;__toString());\n\n/**\n * The output is over:\n * string(4) \"test\"\n */\n\nrTrim\nDelete whitespace characters (or other characters) at the end of the string\n\n\nstring $charList Deleted characters\nfunction rTrim( string $charList = \" \\t\\n\\r\\0\\x0B\" ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'test  ';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;rTrim()-&gt;__toString());\n\n/**\n * The output is over:\n * string(4) \"test\"\n */\n\ntrim\nRemove whitespace characters (or other characters) at the beginning and end of the string\n\n\nstring     $charList           Deleted characters\nfunction trim( string $charList = \" \\t\\n\\r\\0\\x0B\" ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = '  test  ';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;trim()-&gt;__toString());\n\n/**\n * The output is over:\n * string(4) \"test\"\n */\n\npad\nFill the string to the specified length with another string\n\n\nint $length         Value is negative, less than or equal to the length of the input string, no padding will occur\n\n\nstring $padString   Fills the string\n\n\nint $pad_type       Fill type\nfunction pad( int $length, string $padString = null, int $pad_type = STR_PAD_RIGHT ) : SplString\n$pad_type type:\n\n\nSTR_PAD_RIGHT     Right padding\n\n\nSTR_PAD_LEFT      Left padding\n\n\nSTR_PAD_BOTH      Left and right padding\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;pad(5, 'game')-&gt;__toString());\n\n/**\n * The output is over:\n * string(5) \"testg\"\n */\n\nrepeat\nRepeat a string\n\n\nint    $times     repeat times\nfunction repeat( int $times ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;repeat(2)-&gt;__toString());\n\n/**\n * The output is over:\n * string(8) \"testtest\"\n */\n\nlength\nGet the length of the string\nfunction length() : int\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;length());\n\n/**\n * The output is over:\n * int(4)\n */\n\nupper\nConvert a string to uppercase\nfunction upper() : SplString\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;upper()-&gt;__toString());\n\n/**\n * The output is over:\n * string(4) \"TEST\"\n */\n\nlower\nConvert a string to lowercase\nfunction lower() : SplString\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;lower()-&gt;__toString());\n\n/**\n * The output is over:\n * string(4) \"test\"\n */\n\nstripTags\nRemove HTML and PHP tags from strings\n\n\nstring    $allowable_tags     Specify a list of characters that are not removed\nfunction stripTags( string $allowable_tags = null ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = '&lt;a&gt;test&lt;/a&gt;';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;stripTags()-&gt;__toString());\n\n/**\n* The output is over:\n * string(4) \"test\"\n */\n\nreplace\nSubstring replacement\n\n\nstring    $find           Target value of lookup\n\nstring    $replaceTo      Replacement value\nfunction replace( string $find, string $replaceTo ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;replace('t', 's')-&gt;__toString());\n\n/**\n * The output is over:\n * string(4) \"sess\"\n */\n\nbetween\nGet the intermediate string of the specified target\n\n\nstring    $startStr       Specify the starting string of the target\n\nstring    $endStr         Specify the end string of the target\nfunction between( string $startStr, string $endStr ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'easyswoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;between('easy', 'le')-&gt;__toString());\n\n/**\n * The output is over:\n * string(4) \"swoo\"\n */\n\nregex\nFind strings according to regular rules\n\n\nmixed    $regex           Regular rule\n\nbool     $rawReturn       Whether to return the original string\npublic function regex( $regex, bool $rawReturn = false )\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'easyswoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;regex('/swoole/'));\n\n/**\n * The output is over:\n * string(6) \"swoole\"\n */\nexist\nWhether the specified string exists\n\n\nstring    $find           Find string\n\nbool      $ignoreCase     Ignore case\npublic function exist( string $find, bool $ignoreCase = true ) : bool\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'easyswoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;exist('Swoole', true));\n\n/**\n * The output is over:\n * bool(true)\n */\nkebab\nConvert to skewers\nfunction kebab() : SplString\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;kebab()-&gt;__toString());\n\n/**\n * The output is over:\n * string(11) \"easy-swoole\"\n */\nsnake\nTurn into a snake\n\n\nstring    $delimiter           Separator\nfunction snake( string $delimiter = '_' ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;kebab()-&gt;__toString());\n\n/**\n * The output is over:\n * string(11) \"easy_swoole\"\n */\nstudly\nHump\nfunction studly() : SplString\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'easy_swoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;studly()-&gt;__toString());\n\n/**\n * The output is over:\n * string(10) \"EasySwoole\"\n */\ncamel\nSmall hump\nfunction camel() : SplString\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'easy_swoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;camel()-&gt;__toString());\n\n/**\n * The output is over:\n * string(10) \"easySwoole\"\n */\nreplaceArray\nReplace the string for each element of the array\n\n\nstring    $search           Find string\n\narray     $replace          Replacement target\npublic function replaceArray( string $search, array $replace ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'easy_swoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;replaceArray('easy', ['as', 'bs', 'cs'])-&gt;__toString());\n\n/**\n * The output is over:\n * string(9) \"as_swoole\"\n */\nreplaceFirst\nReplace the first occurrence of the given value in the string\n\n\nstring    $search          Find string\n\nstring    $replace         Replace string\npublic function replaceFirst( string $search, string $replace ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'easy_swoole_easy';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;replaceFirst('easy', 'as')-&gt;__toString());\n\n/**\n * The output is over:\n * string(14) \"as_swoole_easy\"\n */\nreplaceLast\nReplace the last occurrence of the given value in the string\n\n\nstring    $search          Find string\n\nstring    $replace         Replace string\npublic function replaceLast( string $search, string $replace ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'easy_swoole_easy';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;replaceLast('easy', 'as')-&gt;__toString());\n\n/**\n * The output is over:\n * string(14) \"easy_swoole_as\"\n */\nstart\nStart a string with a single instance of a given value\n\n\nstring    $prefix          Opening string\npublic function start( string $prefix ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;start('Hello,')-&gt;__toString());\n\n/**\n * The output is over:\n * string(16) \"Hello,EasySwoole\"\n */\nafter\nReturns the rest of the string after the given value\n\n\nstring    $search       Find string  \nfunction after( string $search ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;after('Easy')-&gt;__toString());\n\n/**\n * The output is over:\n * string(6) \"Swoole\"\n */\nbefore\nGet a part of the string before the given value\n\n\nstring    $search       Find string  \nfunction before( string $search ) : SplString\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;before('Swoole')-&gt;__toString());\n\n/**\n * The output is over:\n * string(4) \"Easy\"\n */\nendsWith\nDetermines if the given string ends with the given substring\n\n\nstring    $needles        Find string  \npublic function endsWith( $needles ) : bool\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;endsWith('Swoole'));\n\n/**\n * The output is over:\n * bool(true)\n */\nstartsWith\nDetermine if the given string starts with the given substring\n\n\nstring    $needles        Find string  \npublic function startsWith( $needles ) : bool\n\n\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;startsWith('Easy'));\n\n/**\n * The output is over:\n * bool(true)\n */","link":"/Components/Spl/splString.html"},{"id":163,"title":"introduce","content":"Common connection pool\nEasysoole's common coroutine connection pool management.\nComponent requirements\n\nphp: &gt;=7.1.0\next-json: *\neasyswoole/component: ^2.2.1\neasyswoole/spl: ^1.3\neasyswoole/utility: ^1.1\n\nInstall\n\ncomposer require easyswoole/pool\n\nWarehouse address\neasyswoole/pool\nConfig\nWhen instantiating a connection pool object, you need to pass in a connection pool configuration objectEasySwoole\\Pool\\Config,The properties of the object are as follows:\n\n\n\nConfiguration item\nDefault value\nexplain\nremarks\n\n\n\n\n$intervalCheckTime\n30*1000\nTimer execution frequency\nIt is used to periodically perform connection pool object recycling and creation operations\n\n\n$maxIdleTime\n15\nMaximum idle time of connection pool objects (seconds)\nAfter this time, unused objects will be recycled by the timer\n\n\n$maxObjectNum\n20\nMaximum number of connection pools\nEach process can create at most $maxobjectnum connection pool objects. If all objects are in use, it will return null or wait for the connection to be idle\n\n\n$minObjectNum\n5\nMinimum number of connection pools (hot start)\nWhen the total number of connection pool objects is less than $minobjectnum, the connection will be created automatically to keep the connection active, so that the controller can get the connection as soon as possible\n\n\n$getObjectTimeout\n3.0\nGets the timeout of the connection pool\nWhen the connection pool is empty, it will wait for $getobjecttimeout seconds. If there are connections idle during this period, it will return the connection object, otherwise it will return null\n\n\n$extraConf\n\nAdditional configuration information\nBefore instantiating the connection pool, you can put some additional configuration here, such as database configuration information, redis configuration, and so on\n\n\n\nPool Manager\nPool manager can do global connection pool management, such as inEasySwooleEvent.phpAfter that, you can get the connection pool in the controller to get the connection\npublic static function initialize()\n{\n    // TODO: Implement initialize() method.\n    date_default_timezone_set('Asia/Shanghai');\n\n    $config = new \\EasySwoole\\Pool\\Config();\n\n    $redisConfig1 = new \\EasySwoole\\Redis\\Config\\RedisConfig(Config::getInstance()-&gt;getConf('REDIS1'));\n    $redisConfig2 = new \\EasySwoole\\Redis\\Config\\RedisConfig(Config::getInstance()-&gt;getConf('REDIS2'));\n    //Register connection pool management objects\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\RedisPool($config,$redisConfig1),'redis1');\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\RedisPool($config,$redisConfig2),'redis2');\n\n}\nThe controller gets the connection pool connection:\npublic function index()\n{\n    //Take out the connection pool management object and getobj\n\n    $redis1=\\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis1')-&gt;getObj();\n    $redis2=\\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis1')-&gt;getObj();\n\n    $redis1-&gt;set('name','test');\n    var_dump($redis1-&gt;get('name'));\n\n    $redis2-&gt;set('name','test2');\n    var_dump($redis2-&gt;get('name'));\n\n    //Recycling objects\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis1')-&gt;recycleObj($redis1);\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis2')-&gt;recycleObj($redis2);\n}\nPool object method\n\n\n\nMethod name\nparameter\nexplain\n备注\n\n\n\n\ncreateObject\n\nAbstract method, create connection object\n\n\n\nrecycleObj\n$obj\nRecycle a connection\n\n\n\ngetObj\nfloat $timeout = null, int $tryTimes = 3\nGet a connection, timeout $timeout, try to get $trytimes times\n\n\n\nunsetObj\n$obj\nRelease a connection directly\n\n\n\nidleCheck\nint $idleTime\nRecycle connections that are not queued for more than $idletime\n\n\n\nitemIntervalCheck\nObjectInterface $item\nDetermine whether the current client is still available\n\n\n\nintervalCheck\n\nReclaim the connection, and the hot start method, allowing external calls to the hot start\n\n\n\nkeepMin\n?int $num = null\nKeep minimum connection (hot start)\n\n\n\ngetConfig\n\nGets the configuration information of the connection pool\n\n\n\nstatus\n\nGet connection pool status information\nGet the current connection pool created, used, maximum created, minimum created data\n\n\nisPoolObject\n$obj\nCheck whether the $obj object was created by the connection pool\n\n\n\nisInPool\n$obj\nGets whether the current connection is not used in the connection pool\n\n\n\ndestroyPool\n\nDestroy the connection pool\n\n\n\nreset\n\nReset the connection pool\n\n\n\ninvoke\ncallable $call,float $timeout = null\nGet a connection, pass it into the $call callback function for processing, and automatically recycle the connection after the callback\n\n\n\ndefer\nfloat $timeout = null\nGet a connection and recycle it automatically after the collaboration\n\n\n\n\ngetObj\nGets the object of a connection pool:\ngo(function (){\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    $redis = $redisPool-&gt;getObj();\n    var_dump($redis-&gt;echo('仙士可'));\n    $redisPool-&gt;recycleObj($redis);\n});\nThe objects obtained by getobj method must be recycled by calling unsetobj or recycleobj, otherwise the connection pool objects will be fewer and fewer\nunsetObj\nRelease a connection pool object directly. Other collaborators can no longer obtain the connection, but will create a new one\nAfter release, the object is not destroyed immediately, but after the end of the scope\nrecycleObj\nRecycle a connection object. After recycling, other coroutines can get the connection normally\nAfter recycling, other coroutines can get the connection normally, but at this time, the connection is still in the current coroutine. If the connection is called again for data operation, the coroutine will be confused, so developers need to restrict themselves. When recycleobj can no longer operate the object\ninvoke\nGet a connection, pass it into the $call callback function for processing, and automatically recycle the connection after the callback:\ngo(function (){\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    $redisPool-&gt;invoke(function (\\EasySwoole\\Redis\\Redis $redis){\n        var_dump($redis-&gt;echo('test'));\n    });\n});\n\nThis method does not need to recycle the connection manually, but will recycle automatically after the callback function is finished\ndefer\nGet a connection and recycle it automatically after the collaboration\ngo(function () {\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    $redis = $redisPool-&gt;defer();\n    var_dump($redis-&gt;echo('test'));\n});\nThis method does not need to manually reclaim the connection, but automatically reclaims the connection after the end of the collaboration\nNote that the defer method does not recycle until the end of the collaboration. If your current collaboration runs for a long time, it will not be recycled until the end of the collaboration\nkeepMin\nKeep minimum connection (hot start)\nBecause easywoole/pool\nWhen a service starts with excessive concurrency, it may suddenly need dozens or hundreds of connections. At this time, in order to disperse the time of connection creation, you can warm up and start the connection by calling keepmin\nAfter calling this method, n connections will be created in advance for the controller to obtain the connection directly after the service is started\nInEasySwooleEvent.phpIn mainservercreate, when the worker process starts, the connection is hot started\n\npublic static function mainServerCreate(EventRegister $register)\n{\n    $register-&gt;add($register::onWorkerStart,function (\\swoole_server $server,int $workerId){\n        if ($server-&gt;taskworker == false) {\n            //Each worker process pre creates a connection\n            \\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis')-&gt;keepMin(10);\n            var_dump(\\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis')-&gt;status());\n        }\n    });\n\n    // TODO: Implement mainServerCreate() method.\n}\nWill output:\narray(4) {\n  [\"created\"]=&gt;\n  int(10)\n  [\"inuse\"]=&gt;\n  int(0)\n  [\"max\"]=&gt;\n  int(20)\n  [\"min\"]=&gt;\n  int(5)\n}\nKeepmin creates different connections according to different processes. For example, if you have 10 worker processes, you will output 10 times, creating a total of 10 * 10 = 100 connections\ngetConfig\nGets the configuration of the connection pool:\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    var_dump($redisPool-&gt;getConfig());\n\ndestroyPool\nDestroy connection pool\nAfter the call, all the remaining links in the connection pool will unsetobj, and the connection queue will be closed. After the call, getobj and other methods will be invalid\ngo(function (){\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    var_dump($redisPool-&gt;getObj());\n    $redisPool-&gt;destroyPool();\n    var_dump($redisPool-&gt;getObj());\n});\nreset\nReset the connection pool. After calling reset, the destroypool will be automatically called to destroy the connection pool, and the connection pool will be reinitialized at the next getobj\ngo(function (){\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    var_dump($redisPool-&gt;getObj());\n    $redisPool-&gt;reset();\n    var_dump($redisPool-&gt;getObj());\n});\nstatus\nGet the current state of the connection pool. After calling, the output will be:\narray(4) {\n  [\"created\"]=&gt;\n  int(10)\n  [\"inuse\"]=&gt;\n  int(0)\n  [\"max\"]=&gt;\n  int(20)\n  [\"min\"]=&gt;\n  int(5)\n}\nidleCheck\nReclaim idle timed out connections\nintervalCheck\nAfter calling this method, idlecheck and keepmin methods are called to manually recycle idle connections and manually hot start connections\npublic function intervalCheck()\n{\n    $this-&gt;idleCheck($this-&gt;getConfig()-&gt;getMaxIdleTime());\n    $this-&gt;keepMin($this-&gt;getConfig()-&gt;getMinObjectNum());\n}\nitemIntervalCheck\nWhen the internal timer discards the timeout client (if the client is idle for more than a specified time, it will be disconnected first), the itemintervalcheck function will be triggered, and the client will be passed in, which can realize the user's own logic to judge whether the client is available.\nIf the function returns true, it means available (by default) and returns false, which will cause the client to discard directly.\nCan be used to: maintain client heartbeat, etc. For example, the usage scenarios in ORM are as follows: maintain the MySQL connection and reduce the probability of MySQL offline gone away\n    /**\n     * @param MysqliClient $item\n     * @return bool\n     */\n    public function itemIntervalCheck($item): bool\n    {\n        /*\n         * If the last use time exceeds the autoping interval\n         */\n        /** @var Config $config */\n        $config = $this-&gt;getConfig();\n        if($config-&gt;getAutoPing() &gt; 0 &amp;&amp; (time() - $item-&gt;__lastUseTime &gt; $config-&gt;getAutoPing())){\n            try{\n                //Execute an SQL to trigger active information\n                $item-&gt;rawQuery('select 1');\n                //Mark the usage time to avoid being used again\n                $item-&gt;__lastUseTime = time();\n                return true;\n            }catch (\\Throwable $throwable){\n                //Exception indicates that there is an error in the link, return to recycle\n                return false;\n            }\n        }else{\n            return true;\n        }\n    }\nBasic use\nDefine pool objects\nclass Std implements \\EasySwoole\\Pool\\ObjectInterface {\n    function gc()\n    {\n        /*\n         * When this object is unset by pool\n         */\n    }\n\n    function objectRestore()\n    {\n        /*\n         * Back to the connection pool\n         */\n    }\n\n    function beforeUse(): ?bool\n    {\n        /*\n         * If false is returned when taking out the connection pool, the current object will be discarded and recycled\n         */\n        return true;\n    }\n\n    public function who()\n    {\n        return spl_object_id($this);\n    }\n}\nDefine pool\n\nclass StdPool extends \\EasySwoole\\Pool\\AbstractPool{\n\n    protected function createObject()\n    {\n        return new Std();\n    }\n}\n\n\nYou don't have to create a return EasySwoole\\Pool\\ObjectInterface Object, any type of object\n\nAfter pool component version '&gt; = 1.0.2', magic pool support is provided to quickly define pool\nuse \\EasySwoole\\Pool\\MagicPool;\n$magic = new MagicPool(function (){\n    return new \\stdClass(); // Example, you can return the object that implements the objectinterface\n});\n\n// Get after registration\n$test = $magic-&gt;getObj();\n// return\n$magic-&gt;recycleObj($test);\nThe second parameter of magic pool construction method can receive a config (easysoole / pool / Config class) to define the number of pools and other configurations.\nSimple example\n\n$config = new \\EasySwoole\\Pool\\Config();\n$pool = new StdPool($config);\n\ngo(function ()use($pool){\n    $obj = $pool-&gt;getObj();\n    $obj2 = $pool-&gt;getObj();\n    var_dump($obj-&gt;who());\n    var_dump($obj2-&gt;who());\n});\nAdvanced use\nRedis connection pool based on pool\n[MySQL connection pool based on pool]()\nRelated warehouse\neasyswoole/redis-pool","link":"/Components/Pool/introduction.html"},{"id":168,"title":"redis-pool connection pool","content":"Redis-Pool\nRedis-Pool is based on [pool universal connection pool] (./Pool/introduction.md), [redis coroutine client] (./Redis/introduction.md) packaged components\nInstallation\ncomposer require easyswoole/redis-pool\nConnection pool registration\nRegister the Redis connection pool before using the connection:\n//Redis connection pool registration (config defaults to 127.0.0.1, port 6379)\n\\EasySwoole\\RedisPool\\Redis::getInstance()-&gt;register('redis',new \\EasySwoole\\Redis\\Config\\RedisConfig());\n\n//Redis cluster connection pool registration\n\\EasySwoole\\RedisPool\\Redis::getInstance()-&gt;register('redisCluster',new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ]\n));\nConnection pool configuration\nWhen registered, the poolConf that will return the connection pool is used to configure the connection pool:\n$redisPoolConfig = \\EasySwoole\\RedisPool\\Redis::getInstance()-&gt;register('redis',new \\EasySwoole\\Redis\\Config\\RedisConfig());\n//Configure connection pool connections\n$redisPoolConfig-&gt;setMinObjectNum(5);\n$redisPoolConfig-&gt;setMaxObjectNum(20);\n\n$redisClusterPoolConfig = \\EasySwoole\\RedisPool\\Redis::getInstance()-&gt;register('redisCluster',new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ]\n));\n//Configure connection pool connections\n$redisPoolConfig-&gt;setMinObjectNum(5);\n$redisPoolConfig-&gt;setMaxObjectNum(20);\nUse a connection pool:\n//Redis connection pool registration (config defaults to 127.0.0.1, port 6379)\n\\EasySwoole\\RedisPool\\Redis::getInstance()-&gt;register('redis',new \\EasySwoole\\Redis\\Config\\RedisConfig());\n\n//Redis cluster connection pool registration\n\\EasySwoole\\RedisPool\\Redis::getInstance()-&gt;register('redisCluster',new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ]\n));\ngo(function () {\n    //defer mode to get the connection\n    $redis = \\EasySwoole\\RedisPool\\Redis::defer('redis');\n    $redisCluster = \\EasySwoole\\RedisPool\\Redis::defer('redisCluster');\n    $redis-&gt;set('a', 1);\n    $redisCluster-&gt;set('a', 1);\n\n    //invoke mode to get the connection\n    \\EasySwoole\\RedisPool\\Redis::invoker('redis', function (\\EasySwoole\\Redis\\Redis $redis) {\n        var_dump($redis-&gt;set('a', 1));\n    });\n    \\EasySwoole\\RedisPool\\Redis::invoker('redisCluster', function (\\EasySwoole\\Redis\\Redis $redis) {\n        var_dump($redis-&gt;set('a', 1));\n    });\n\n    //Get the connection pool object\n    $redisPool = \\EasySwoole\\RedisPool\\Redis::getInstance()-&gt;get('redis');\n    $redisClusterPool = \\EasySwoole\\RedisPool\\Redis::getInstance()-&gt;get('redisCluster');\n\n    $redis = $redisPool-&gt;getObj();\n    $redisPool-&gt;recycleObj($redis);\n\n    //Clear the timer in the pool\n    \\EasySwoole\\Component\\Timer::getInstance()-&gt;clearAll();\n});","link":"/Components/redisPool.html"},{"id":169,"title":"install","content":"EasySwoole coroutine HTTPClient component\nThe coroutine httpClient component, based on the swoole [asynchronous http client client] (https://wiki.swoole.com/wiki/page/p-http_client.html), can initiate http requests in the coroutine without being blocked. In downloading files, requesting apis, crawlers, etc.\ninstallation\ncomposer require easyswoole/http-client\nSingle request\n&lt;?php\n$url = 'http://docker.local.com/test.php/?get1=get1';\n$test = new \\EasySwoole\\HttpClient\\HttpClient($url);\n//$test-&gt;post();\n\n$test-&gt;addCookie('c1','c1')-&gt;addCookie('c2','c2');\n\n$test-&gt;setHeader('myHeader','myHeader');\n\n$ret = $test-&gt;postJSON(json_encode(['json'=&gt;1]));\n\nvar_dump($ret-&gt;getBody());\nConcurrent request\nFor the Http Client Concurrency Request section, we recommend that users use the [Csp Package] (../Component/csp.md) provided in the EasySwoole component.","link":"/Components/HttpClient/install.html"},{"id":170,"title":"request","content":"Request\nInstantiate the client\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: tioncico\n * Date: 19-6-22\n * Time: 2:43\n */\n\ninclude \"./vendor/autoload.php\";\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n//::: warning \n//在3.3.7版本后,initialize事件调用改为:`EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()-&gt;globalInitialize();`\n//:::\ngo(function () {\n    //Instantiation\n    $client = new \\EasySwoole\\HttpClient\\HttpClient('http://easyswoole.com');\n});\nRequest instance:\n&lt;?php\n     /**\n      * Created by PhpStorm.\n      * User: tioncico\n      * Date: 19-6-22\n      * Time: 2:43\n      */\n\n     include \"./vendor/autoload.php\";\n     \\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n//::: warning \n//&gt;=3.3.7,initialize:`EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()-&gt;globalInitialize();`\n//:::\n     go(function () {\n         //Instantiation\n         $client = new \\EasySwoole\\HttpClient\\HttpClient('http://easyswoole.com');\n\n         //Initiate a simple get request\n         $response = $client-&gt;get();\n         var_dump($response);\n\n         //Initiate a simple head request\n         $response = $client-&gt;head();\n         var_dump($response);\n\n         //Initiate a delete request\n         $response = $client-&gt;delete();\n\n         //Initiate a put request\n         $response = $client-&gt;put('testPut');\n\n         //Initiate a post request\n         $response = $client-&gt;post([\n             'post1' =&gt; 'post1'\n         ]);\n\n         //Initiate a patch request\n         $response = $client-&gt;patch('testPath');\n\n         //Initiate an option request\n         $response = $client-&gt;options(['op' =&gt; 'op1'], ['head' =&gt; 'headtest']);\n\n         //Initiate a post, xml format request\n         $response = $client-&gt;postXml('&lt;xml&gt;&lt;/xml&gt;');\n\n         //Initiate a post, json format request\n         $response = $client-&gt;postJson(json_encode(['json' =&gt; 'json1']));\n\n         //Initiate a download request, the requested content will be directly written to the file, saving one read and write process\n         $response = $client-&gt;download('./test.html');\n\n         //Initiate a post request\n         $response = $client-&gt;post('postStr');\n\n         //Initiate a post request for a new file\n         $response = $client-&gt;post([\n             'post1' =&gt; 'post1',\n             'file'  =&gt; new \\CURLFile(__FILE__)\n         ]);\n\n         //Set the head\n         $client-&gt;setHeaders([\n             'head1' =&gt; 'head1',\n             'head2' =&gt; 'head2'\n         ]);\n         $client-&gt;setHeader('head1', 'head1');\n\n         // set basic auth \n         $client-&gt;setBasicAuth('admin', '111111');\n\n         //Set cookie\n         $client-&gt;addCookies([\n             'cookie1' =&gt; 'cookie1',\n             'cookie2' =&gt; 'cookie2'\n         ]);\n         $client-&gt;addCookie('cookie1', 'cook');\n         // Set form data data\n         $client-&gt;setContentTypeFormData();\n         ///Set the current URL to request\n         $client-&gt;setUrl('http://easyswoole.com');\n         //Set whether to enable ssl\n         $client-&gt;setEnableSSL(false);\n         //Set wait timeout\n         $client-&gt;setTimeout(5);\n         //Set connection timeout\n         $client-&gt;setConnectTimeout(10);\n         // Enable or disable HTTP long connections\n         $client-&gt;setKeepAlive(true);\n         // Enable or disable server certificate verification\n         // Can be set at the same time whether to allow self-signed certificate (not allowed by default)\n         $client-&gt;setSslVerifyPeer(true,true);\n         // Set the server host name\n         // Use with ssl_verify_peer configuration or Client::verifyPeerCert\n         $client-&gt;setSslHostName('');\n         //Set the SSL certificate for verification\n         $client-&gt;setSslCafile('');\n         //Set the SSL certificate directory (for verification)\n         $client-&gt;setSslCapath('');\n         //Set the certificate file used for the request\n         $client-&gt;setSslCertFile('');\n         //Set the certificate key file to be used for the request\n         $client-&gt;setSslKeyFile('');\n         //Set up an HTTP proxy\n         $client-&gt;setProxyHttp('127.0.0.1','8080','user','pass');\n         //Set up the Socks5 agent\n         $client-&gt;setProxySocks5('127.0.0.1','8080','user','pass');\n         // Set the port binding\n         // when the client has multiple network cards\n         // Set the client's underlying Socket using which network card and port to communicate\n         $client-&gt;setSocketBind('127.0.0.1','8090');\n         //Set client configuration directly\n         $client-&gt;setClientSetting('timeout',1);\n         $client-&gt;setClientSetting('keep_alive',true);\n         //Directly set client configuration in batches\n         $client-&gt;setClientSettings([\n             'bind_address'=&gt;'127.0.0.1',\n             'bind_port'=&gt;'8090',\n         ]);\n         //Setting request method\n         $client-&gt;setMethod('POST');\n         //Set to XMLHttpRequest request\n         $client-&gt;setXMLHttpRequest();\n         //Set to Json request\n         $client-&gt;setContentTypeJson();\n         //Set to Xml request\n         $client-&gt;setContentTypeXml();\n         //Set to FromData request\n         $client-&gt;setContentTypeFormData();\n         //Set to FromUrlencoded request\n         $client-&gt;setContentTypeFormUrlencoded();\n         //Set ContentType\n         $client-&gt;setContentType(\\EasySwoole\\HttpClient\\HttpClient::CONTENT_TYPE_APPLICATION_XML);\n         //\n     });","link":"/Components/HttpClient/request.html"},{"id":171,"title":"response","content":"Response\n&lt;?php\ninclude \"./vendor/autoload.php\";\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n//::: warning \n//&gt;=3.3.7,initialize:`EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()-&gt;globalInitialize();`\n//:::\ngo(function () {\n    $client = new \\EasySwoole\\HttpClient\\HttpClient();\n    $client-&gt;setUrl('http://www.baidu.com');//Set the url, note that you need http and https, https\n    $client-&gt;addCookie('a','1');\n    $response = $client-&gt;get();\n    var_dump($response-&gt;getBody());//Get response body\n    var_dump($response-&gt;getErrCode());//Get the error code\n    var_dump($response-&gt;getErrMsg());//Get error message\n    var_dump($response-&gt;getStatusCode());//Get response status code\n    var_dump($response-&gt;getSetCookieHeaders());//Get the cookie that the response header wants to set\n    var_dump($response-&gt;getCookies());//Get the cookie you sent yourself and the cookie that the response header wants to set\n});\n","link":"/Components/HttpClient/response.html"},{"id":172,"title":"websocketclient","content":"WebSocket-Client\nRequest instance:\n&lt;?php\n$client = new \\EasySwoole\\HttpClient\\HttpClient('127.0.0.1:9501');\n$upgradeResult = $client-&gt;upgrade('cookie1', 'cook');\n$frame = new \\Swoole\\WebSocket\\Frame();\n//Set the sent message frame\n$frame-&gt;data = json_encode(['action' =&gt; 'hello','content'=&gt;['a'=&gt;1]]);\n$pushResult = $client-&gt;push($frame);\n$recvFrame = $client-&gt;recv();\n//Will return bool or a message frame, you can judge\nvar_dump($recvFrame);\nRecv will only receive the server's message once, if you need to receive it all the time, please increase the while(1) infinite loop","link":"/Components/HttpClient/webSocket.html"},{"id":173,"title":"install","content":"ACTOR\nProvides Actor mode support to help the game industry develop. EasySwoole's Actor uses a custom process as the storage carrier, with the coroutine as the minimum scheduling unit, the coroutine Channel as the mail box, and the communication between the client and the process, using UnixSocket, and implementing the distributed ActorClient via TCP. It can be easily handled with super high concurrency.\nHow Actors work\nThere are generally two strategies for communicating in concurrent threads: sharing data and messaging. One of the biggest problems faced by concurrent programming using shared data is data condition competition. When two instances need to access the same data, in order to ensure data consistency, it is usually necessary to lock the data, and the Actor model uses the message passing mechanism. To avoid data competition, no complicated locking operations are required, and each instance only needs to pay attention to its own state and process the received messages.\nActors are fully object-oriented, lock-free, asynchronous, instance-isolated, distributed, concurrent development models. Actor instances are isolated from each other. Actor instances have their own independent state. Each Actor cannot directly access the other party's state. You need to notify the other party to change the state through the message delivery mechanism. Since the state of each instance is independent and no data is shared, data competition does not occur, thus avoiding the locking problem under concurrent.\nAs an example of a game scene, in a game room, there are 5 players, each player is a PlayerActor, with its own attributes, such as character ID, nickname, current blood volume, attack power, etc. The game room itself is also a RoomActor, the room also has properties, such as the current online player, the number of monsters in the current scene, the amount of monster blood. At this time player A attacks a monster, PlayerActor-A sends an attack monster command to the RoomActor. The RoomActor calculates the damage value of player A to the monster and sends a message to all PlayerActors in the room. Monster A, causing 175 damage, monster A remaining 1200 points), similar to this process, each PlayerActor can know what is happening in the room, but will not cause simultaneous access to the properties of Monster A, resulting in sharing Lock problem\nBasic usage\nActors are not built-in components. You need to import the package first and configure it to be able to use it.\ncomposer require easyswoole/actor=2.x-dev\nBuild an Actor\nEach type of object (player, room, and even log service can also be used as an Actor object) to create an Actor to manage, an object can have multiple instances (Client) and can send messages to each other through the mailbox to handle the business.\n&lt;?php\n\nnamespace App\\Player;\n\nuse EasySwoole\\Actor\\AbstractActor;\nuse EasySwoole\\Actor\\ActorConfig;\n\n/**\n * Player Actor\n * Class PlayerActor\n * @package App\\Player\n */\nclass PlayerActor extends AbstractActor\n{\n    /**\n     * Configure the current Actor\n     * @param ActorConfig $actorConfig\n     */\n    public static function configure(ActorConfig $actorConfig)\n    {\n        $actorConfig-&gt;setActorName('PlayerActor');\n        $actorConfig-&gt;setWorkerNum(3);\n    }\n\n    /**\n     * When the Actor first starts\n     */\n    protected function onStart()\n    {\n        $actorId = $this-&gt;actorId();\n        echo \"Player Actor {$actorId} onStart\\n\";\n    }\n\n    /**\n     * When the Actor receives the message\n     * @param $msg\n     */\n    protected function onMessage($msg)\n    {\n        $actorId = $this-&gt;actorId();\n        echo \"Player Actor {$actorId} onMessage\\n\";\n    }\n\n    /**\n     * Actor is about to quit before\n     * @param $arg\n     */\n    protected function onExit($arg)\n    {\n        $actorId = $this-&gt;actorId();\n        echo \"Player Actor {$actorId} onExit\\n\";\n    }\n\n    /**\n     * When an Actor is abnormal\n     * @param \\Throwable $throwable\n     */\n    protected function onException(\\Throwable $throwable)\n    {\n        $actorId = $this-&gt;actorId();\n        echo \"Player Actor {$actorId} onException\\n\";\n    }\n\n}\nRegister Actor Service\nYou can use setListenAddress and setListenPort to specify the port that the local machine listens to. Other machines can send messages to the Actor of this machine through this port.\n\npublic static function mainServerCreate(EventRegister $register) {\n\n    // Register Actor Manager\n    $server = ServerManager::getInstance()-&gt;getSwooleServer();\n    Actor::getInstance()-&gt;register(PlayerActor::class);\n    Actor::getInstance()-&gt;setTempDir(EASYSWOOLE_TEMP_DIR)\n        -&gt;setListenAddress('0.0.0.0')-&gt;setListenPort('9900')-&gt;attachServer($server);\n\n}\nActor instance management\nAfter the service is started, the Actor can be operated. If the Client instance of the machine is managed, the client does not need to pass the $node parameter to the client. The default node is the local machine, and the other machines need to be imported.\n\n    // Actors managing this machine do not need to declare nodes\n    $node = new ActorNode;\n    $node-&gt;setIp('127.0.0.1');\n    $node-&gt;setListenPort(9900);\n\n    // Start an Actor and get the ActorId. Subsequent operations need to rely on the ActorId.\n    $actorId = PlayerActor::client($node)-&gt;create(['time' =&gt; time()]);   // 00101000000000000000001\n    // Send a message to an actor\n    PlayerActor::client($node)-&gt;send($actorId, ['data' =&gt; 'data']);\n    // Send a message to all Actors of this type\n    PlayerActor::client($node)-&gt;sendAll(['data' =&gt; 'data']);\n    // Exit an Actor\n    PlayerActor::client($node)-&gt;exit($actorId, ['arg' =&gt; 'arg']);\n    // Exit all Actors\n    PlayerActor::client($node)-&gt;exitAll(['arg' =&gt; 'arg']);\n","link":"/Components/Actor/actor.html"},{"id":174,"title":"interpretation of design","content":"Actor2 architecture interpretation\nActor\nIt should be called ActorManager more precisely, it is used to register Actor, start Proxy and ActorWorker process.\nWhen you define several Actors in the business logic, such as RoomActor, PlayerActor, we need to register them when SwooleServer starts.\nSpecifically, add the following code in the EasySwooleEvent.mainServerCreate method.\n$actor = Actor::getInstance();\n$actor-&gt;register(RoomActor::class);\n$actor-&gt;register(PlayerActor::class);\n$actorConf = Config::getInstance()-&gt;getConf('ACTOR_SERVER');\n$actor-&gt;setMachineId($actorConf['MACHINE_ID'])\n    -&gt;setListenAddress($actorConf['LISTEN_ADDRESS'])\n    -&gt;setListenPort($actorConf['PORT'])\n    -&gt;attachServer($server);\nThe ListenAddress and the ListenPort are the listening address ports of the Proxy process, and the MachineId is the machine code of the ActorWorker process.\nMachineId corresponds to IP:PORT.\nattachServer will open the corresponding number of Proxy processes, as well as the ActorWorker process registered in front.\nworking principle\nThe Proxy process does the message relay, and the Worker process does the message distribution push. Let's look at a concrete example:\nIn the game, the player P requests to enter the room R, abstracting into the Actor model is the PlayerActor needs to send a request to the RoomActor to join.\nThen this time you need to write like this:\nRoomActor::client($node)-&gt;send($roomActorId, [\n    'user_actor_id' =&gt; $userActorId,\n    'data'  =&gt; 'Other parameters to enter the room'\n])\nWhere $roomActorId and $userActorId are your pre-xxActor::client()-&gt;create().\nThe above code means that a $userActorId user's UserActor instance is pushed to the room in the RoomActor instance of $roomActorId.\nThe parameter $node is used to address the Proxy, which is determined by the Worker.MachineId of the target Actor instance, which in this case is the MachineProcess for which MachineId is created.\nFind the IP:PORT via the machine code in $roomActorId and generate $node.\nWhen sending, a coroutine TcpClient is created, and the message is sent to the Proxy. Then the Proxy forwards the message (UnixClient) to the native WorkerProcess, and the WorkerProcess receives the message and pushes it to the specific Actor instance.\nThis completes the request communication from the PlayerActor to the RoomActor. After receiving the request message and processing it, the RoomActor sends back the processing result to the PlayerActor, using the same communication flow.\nIf it is a stand-alone deployment, you can ignore the $node parameter because all communication is done locally.\nFor multi-machine, you need to implement how to distribute and locate Actors according to your business.\nMain attribute\nmachineId machine code\nproxyNum starts several ProxyProcess\nlistenPort listening port\nlistenAddress listen ip\nAbstractActor\nThe base class of the Actor instance, all the Actors used in the business will inherit from AbstractActor. For example, in a room in a game scene, you can:\nclass RoomActor extends AbstractActor\nworking principle\nEach Actor instance maintains a separate data and state. When an Actor instance passes client()-&gt;create(), it will start the coroutine loop, receive the message of mailbox pop, and then process the business logic and update its own data. And status. The concrete implementation is the __run() method.\nStatic method configure\nTo configure ActorCofig, you only need to override this method in a specific Actor (such as RoomActor).\nFor the specific properties of ActorConfig, see the ActorConfig section below.\nSeveral virtual methods\nThe following virtual methods need to be implemented in the Actor subclass. These methods are used in __run() to complete the Actor's run cycle.\nonStart() is executed before the coroutine is started. You can perform some operations on the Actor initialization, such as getting the basic properties of the room.\nonMessage() When executed, the lifetime of an Actor instance is basically in the message-handling-message, where you need to parse the message.\nonExit() is executed when an exit command is received. For example, if you want to quit an Actor instance, you can also notify some related Actors at the same time, which can be handled here.\nOther\nexit() is used to exit the operation itself, and will send an exit command to itself.\ntick(), after() Two timers, used for timed tasks of the Actor instance, such as the timing of the game room (tick); how long after the line is automatically kicked (after).\nstatic client() is used to create an ActorClient to communicate with the corresponding Actor.\nActorClient\nThe Actor communication client calls xxActor::client() to create an ActorClient for Actor communication.\nThe above has already talked about the Actor communication process, the essence is TcpClient-&gt;Proxy process-&gt;UnixClient-&gt;ActorWorker process-&gt;xxActor.\nSee what methods it implements:\ncreate() creates a xxActor instance and returns the actorId, which you can then use to communicate with this instance.\nsend() specifies the actorId to send a message to.\nexit() tells xxActor to exit the instance of the specified actorId.\nsendAll() sends a message to all xxActor instances.\nexitAll() exits all xxActor instances.\nexist() Whether there is currently a xxActor instance of the specified actorId.\nstatus() The current state of the xxActor under ActorWorker.\nActorConfig\nConfiguration items for specific Actors, such as RoomActor and PlayerActor, have their own configuration.\nactorName generally uses the class name. Note that this cannot be repeated in the same service.\nactorClass will write the corresponding class name in Actor-&gt;register().\nworkerNum starts several processes for the Actor. Actor-&gt;attachServer() will start the WorkerNum Worker process for the corresponding Actor according to this parameter.\nActorNode\nAs mentioned above, xxActor::client($node), this $node is the ActorNode object, and the attributes are Ip and Port, which are used to address the Proxy, so I won't say much.\nWorkerConfig\nWorkerProcess configuration item, used when WorkerProcess starts.\nworkerId worker process Id, used to generate actorId when creating Actor\nmachineId worker process machine code, used to generate actorId when creating Actor\ntrigger exception trigger processing interface\nWorkerProcess\nThe focus of the Actor is here, and each registered Actor (class) will launch the corresponding number of WorkerProcess.\nFor example, if you register RoomActor, PlayerActor, and WorkerNum are configured with 3, then the system will launch 3 RoomActor Worker processes and 3 PlayerActor Worker processes.\nEach WorkerProcess maintains an ActorList, and your Actors via client()-&gt;create() will be distributed among different Worker processes and managed by its ActorList.\nWorkerProcess receives the client (this client is the UnixClient when the proxy is forwarding) through the coroutine, distinguishes the message type, and then distributes it to the corresponding Actor instance.\nPlease read the source code of WorkerProcess carefully, which inherits from AbstractUnixProcess.\nUnixClient\nUnixStream Socket, understand it yourself. The Proxy forwards the message to the Client used by the native Actor.\nProtocol\nData packet protocol.\nProxyCommand\nThe message command object, Actor2 encapsulates different types of messages into formatted commands, which are ultimately passed to WorkerProcess.\nYou can find out the correspondence between methods and commands in ActorClient, but this does not need to be changed at the business layer.\nProxyConfig\nThe configuration item of the message broker.\nactorList Registered actor list.\nmachineId machine code\ntempDir temporary directory\ntrigger error trigger processing interface\nProxyProcess\nActor-&gt;attachServer() will start proxyNum ProxyProcess.\nUsed to make message relays in Actor instances and WorkerProcess.","link":"/Components/Actor/analysis.html"},{"id":175,"title":"whoops","content":"Whoops\nEasyswoole provides the Whoops driver for the development phase, friendly troubleshooting of HTTP business errors and exceptions.\n\nDo not use it in the production phase, otherwise the code leaks EasySwoole is not responsible for it! ! !\nInstallation\ncomposer require easyswoole/easy-whoops=3.x\nUse\nRegister directly in the event of EasySwoole global\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\Whoops\\Handler\\CallbackHandler;\nuse EasySwoole\\Whoops\\Handler\\PrettyPageHandler;\nuse EasySwoole\\Whoops\\Run;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n        $whoops = new Run();\n        $whoops-&gt;pushHandler(new PrettyPageHandler);  // Output a nice page\n        $whoops-&gt;pushHandler(new CallbackHandler(function ($exception, $inspector, $run, $handle) {\n            // Can push multiple Handle support callbacks for more follow-up\n        }));\n        $whoops-&gt;register();\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n        Run::attachTemplateRender(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        //Intercept request\n        Run::attachRequest($request, $response);\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        // TODO: Implement afterAction() method.\n    }\n}","link":"/Components/whoops.html"},{"id":176,"title":"mongodb client case","content":"MongoDb\n目前，MongoDB并没有提供协程版本的php客户端，只有同步阻塞版本。\nEasySwoole 的协程版客户端已经在排期内。\n在实际生产中，直接 创建原生的mongoDB客户端来进行数据交互，也不是不可。\n若希望将同步调用转为协程调用，可以用Easyswoole 提供的sync-invoker组件。\n定义驱动\nnamespace App\\Mongodb;\n\nuse EasySwoole\\EasySwoole\\Trigger;\nuse EasySwoole\\SyncInvoker\\AbstractInvoker;\nuse MongoDB\\Client;\n\nclass Driver extends AbstractInvoker\n{\n    private $db;\n\n    function getDb():Client\n    {\n        if($this-&gt;db == null){\n            $mongoUrl = \"mongodb://127.0.0.1:27017\";\n            $this-&gt;db = new Client($mongoUrl);\n        }\n        return $this-&gt;db;\n    }\n\n    protected function onException(\\Throwable $throwable)\n    {\n        Trigger::getInstance()-&gt;throwable($throwable);\n        return null;\n    }\n}\n客户端\nnamespace App\\Mongodb;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\SyncInvoker\\SyncInvoker;\n\nclass MongoClient extends SyncInvoker\n{\n    use Singleton;\n}\n服务注册\n在Easyswoole全局事件mainServerCreate中进行服务注册\nMongoClient::getInstance(new Driver())-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n开始使用\n$ret = MongoClient::getInstance()-&gt;client()-&gt;callback(function (Driver $driver){\n    $ret = $driver-&gt;getDb()-&gt;user-&gt;list-&gt;insertOne([\n        'name' =&gt;Random::character(8),\n        'sex'=&gt;'man',\n    ]);\n    if(!$ret){\n        return false;\n    }\n    return $ret-&gt;getInsertedId();\n});\n\n$ret = MongoClient::getInstance()-&gt;client()-&gt;callback(function (Driver $driver){\n    $ret = [];\n    $collections = $driver-&gt;getDb()-&gt;user-&gt;listCollections();\n    foreach ($collections as $collection) {\n        $ret[] = (array)$collection;\n    }\n    return $ret;\n});","link":"/Components/SyncInvoker/mongoDb.html"},{"id":177,"title":"link tracking","content":"Tracker\nEasyswoole provides a basic tracking component that allows users to implement basic server status monitoring and call chain logging.\nInstallation\ncomposer require easyswoole/tracker\nCall chain\nEasyswoole's call chain tracking is implemented by deconstruction of a similar ordered tree list, deconstructed as follows:\nstruct Point{\n    struct Point* nextPoint;\n    struct Point[] subPoints;\n    const END_SUCCESS = 'success';\n    const END_FAIL = 'fail';\n    const END_UNKNOWN = 'unknown';\n    int startTime;\n    mixed startArg;\n    int endTime;\n    string pointName;\n    string endStatus = self::END_UNKNOWN;\n    mixed endArg;\n    string pointId;\n    string parentId;\n    int depth = 0;\n    bool isNext\n}\nSample code\n\nuse EasySwoole\\Tracker\\Point;\nuse EasySwoole\\Component\\WaitGroup;\nuse EasySwoole\\Tracker\\PointContext;\n/*\n * Suppose our call chain is like this\n * onRequest  -&gt;&gt; actionOne -&gt;&gt; actionOne call remote Api(1,2)  -&gt;&gt;  afterAction\n */\n\ngo(function (){\n    /*\n     * Create an entry\n     */\n    $onRequest = new Point('onRequest');\n    //Record request parameters and simulate access log\n    \\co::sleep(0.01);\n    $onRequest-&gt;setStartArg([\n        'requestArg' =&gt; 'requestArgxxxxxxxx',\n        'accessLogId'=&gt;'logIdxxxxxxxxxx'\n    ]);\n    //onRequest completed\n    $onRequest-&gt;end();\n    //Go to next actionOne\n    $actionOne = $onRequest-&gt;next('actionOne');\n        //action one Enter the sub-link call\n        $waitGroup = new WaitGroup();\n        //sub pointOne\n        $waitGroup-&gt;add();\n        $subOne = $actionOne-&gt;appendChild('subOne');\n        go(function ()use($subOne,$waitGroup){\n                \\co::sleep(0.1);\n                $subOne-&gt;end();\n                $waitGroup-&gt;done();\n        });\n        //sub pointTwo,And assume failure\n        $waitGroup-&gt;add();\n        $subTwo = $actionOne-&gt;appendChild('subTwo');\n            go(function ()use($subTwo,$waitGroup){\n                \\co::sleep(1);\n                $subTwo-&gt;end($subTwo::END_FAIL,['failMsg'=&gt;'timeout']);\n                $waitGroup-&gt;done();\n            });\n        $waitGroup-&gt;wait();\n    $actionOne-&gt;end();\n    //End of actionOne，Enter afterAction\n    $afterAction = $actionOne-&gt;next('afterAction');\n    //Analog response record\n    \\co::sleep(0.01);\n    $afterAction-&gt;end($afterAction::END_SUCCESS,['log'=&gt;'success']);\n    /*\n     * Print the call chain from the entrance\n     */\n    echo Point::toString($onRequest);\n});\n//The above code is equivalent to the following\ngo(function (){\n    PointContext::getInstance()-&gt;createStart('onRequest')-&gt;next('actionOne')-&gt;next('afterAction');\n    //Record request parameters and simulate access log\n    \\co::sleep(0.01);\n    PointContext::getInstance()-&gt;find('onRequest')-&gt;setStartArg([\n        'requestArg' =&gt; 'requestArgxxxxxxxx',\n        'accessLogId'=&gt;'logIdxxxxxxxxxx'\n    ])-&gt;end();\n    $subOne = PointContext::getInstance()-&gt;find('actionOne')-&gt;appendChild('subOne');\n    $subTwo = PointContext::getInstance()-&gt;find('actionOne')-&gt;appendChild('subTwo');\n    $waitGroup = new WaitGroup();\n    $waitGroup-&gt;add();\n    go(function ()use($subOne,$waitGroup){\n        \\co::sleep(0.1);\n        $subOne-&gt;end();\n        $waitGroup-&gt;done();\n    });\n    //sub pointTwo,And assume failure\n    $waitGroup-&gt;add();\n    go(function ()use($subTwo,$waitGroup){\n        \\co::sleep(1);\n        $subTwo-&gt;end($subTwo::END_FAIL,['failMsg'=&gt;'timeout']);\n        $waitGroup-&gt;done();\n    });\n    $waitGroup-&gt;wait();\n    PointContext::getInstance()-&gt;find('actionOne')-&gt;end();\n    //Analog response record\n    \\co::sleep(0.01);\n    PointContext::getInstance()-&gt;find('afterAction')-&gt;end(Point::END_SUCCESS,['log'=&gt;'success']);\n    /*\n    * Print the call chain from the entrance\n    */\n    echo Point::toString(PointContext::getInstance()-&gt;startPoint());\n});\nThe above code output results:\n#\nPointName:onRequest\nStatus:success\nPointId:AoRVFMgrsbNwukBZc7\nDepth:0\nIsNext:false\nStart:1561736477.2808\nStartArg:{\"requestArg\":\"requestArgxxxxxxxx\",\"accessLogId\":\"logIdxxxxxxxxxx\"}\nEnd:1561736477.2939\nEndArg:null\nChildCount:0\nChildren:None\nNextPoint:\n#\nPointName:actionOne\nStatus:success\nPointId:2zOWG1SvMbyBcnRmje\nDepth:0\nIsNext:true\nStart:1561736477.2809\nStartArg:null\nEnd:1561736478.2993\nEndArg:null\nChildCount:2\nChildren:\n        #\n        PointName:subOne\n        Status:success\n        PointId:0wU31l8brpfCnXdTxH\n        Depth:1\n        IsNext:false\n        Start:1561736477.2939\n        StartArg:null\n        End:1561736477.4006\n        EndArg:null\n        ChildCount:0\n        Children:None\n        NextPoint:None\n        #\n        PointName:subTwo\n        Status:fail\n        PointId:Jphr6RD8KSHmYbt70A\n        Depth:1\n        IsNext:false\n        Start:1561736477.2939\n        StartArg:null\n        End:1561736478.2993\n        EndArg:{\"failMsg\":\"timeout\"}\n        ChildCount:0\n        Children:None\n        NextPoint:None\nNextPoint:\n#\nPointName:afterAction\nStatus:success\nPointId:oPnGNrkj6qwb381BQl\nDepth:0\nIsNext:true\nStart:1561736477.2809\nStartArg:null\nEnd:1561736478.3119\nEndArg:{\"log\":\"success\"}\nChildCount:0\nChildren:None\nNextPoint:None\nIf you want to record to the database in your own format, you can specifically look at the method implemented by Point. Each Point has its own Id.\nBasic API HTTP API Request Tracking\nEasySwooleEvent.php\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\Tracker\\Point;\nuse EasySwoole\\Tracker\\PointContext;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        $point = PointContext::getInstance()-&gt;createStart('onRequest');\n        $point-&gt;setStartArg([\n            'uri'=&gt;$request-&gt;getUri()-&gt;__toString(),\n            'get'=&gt;$request-&gt;getQueryParams()\n        ]);\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        $point = PointContext::getInstance()-&gt;startPoint();\n        $point-&gt;end();\n        echo Point::toString($point);\n        $array = Point::toArray($point);\n    }\n}\nIndex.php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Component\\WaitGroup;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Tracker\\PointContext;\n\nclass Index extends Controller\n{\n\n    protected function onRequest(?string $action): ?bool\n    {\n        /*\n         * Call relationship  HttpRequest-&gt;OnRequest\n         */\n        $point = PointContext::getInstance()-&gt;next('ControllerOnRequest');\n        //Assume that the permission verification is performed here and the time spent in the simulation database is simulated.\n        \\co::sleep(0.01);\n        $point-&gt;setEndArg([\n            'userId'=&gt;'xxxxxxxxxxx'\n        ]);\n        $point-&gt;end();\n        return true;\n    }\n\n    function index()\n    {\n        //Simulation calls third-party Api, calling relationship  OnRequest-&gt;sub(subApi1,subApi2)\n        $actionPoint = PointContext::getInstance()-&gt;next('indexAction');\n        $wait = new WaitGroup();\n        $subApi = $actionPoint-&gt;appendChild('subOne');\n        $wait-&gt;add();\n        go(function ()use($wait,$subApi){\n            \\co::sleep(1);\n            $subApi-&gt;end();\n            $wait-&gt;done();\n        });\n\n        $subApi = $actionPoint-&gt;appendChild('subTwo');\n        $wait-&gt;add();\n        go(function ()use($wait,$subApi){\n            \\co::sleep(0.3);\n            $subApi-&gt;end($subApi::END_FAIL);\n            $wait-&gt;done();\n        });\n\n        $wait-&gt;wait();\n\n        $actionPoint-&gt;end();\n        $this-&gt;response()-&gt;write('hello world');\n    }\n}\nEach request above will output the following format:\n#\nPointName:onRequest\nStatus:success\nPointId:1561743038GyV4lnus\nParentId:\nDepth:0\nIsNext:false\nStart:1561743038.7011\nStartArg:{\"uri\":\"http://127.0.0.1:9501/\",\"get\":[]}\nEnd:1561743039.7152\nEndArg:null\nChildCount:0\nChildren:None\nNextPoint:\n#\nPointName:ControllerOnRequest\nStatus:success\nPointId:15617430386f0OQDsS\nParentId:1561743038GyV4lnus\nDepth:0\nIsNext:true\nStart:1561743038.7025\nStartArg:null\nEnd:1561743038.713\nEndArg:null\nChildCount:0\nChildren:None\nNextPoint:\n#\nPointName:indexAction\nStatus:success\nPointId:1561743038XEmF0M49\nParentId:15617430386f0OQDsS\nDepth:0\nIsNext:true\nStart:1561743038.7131\nStartArg:null\nEnd:1561743039.7151\nEndArg:null\nChildCount:2\nChildren:\n        #\n        PointName:subOne\n        Status:success\n        PointId:1561743038uIkzYgcS\n        ParentId:1561743038XEmF0M49\n        Depth:1\n        IsNext:false\n        Start:1561743038.7135\n        StartArg:null\n        End:1561743039.7151\n        EndArg:null\n        ChildCount:0\n        Children:None\n        NextPoint:None\n        #\n        PointName:subTwo\n        Status:fail\n        PointId:1561743038PslVSY4n\n        ParentId:1561743038XEmF0M49\n        Depth:1\n        IsNext:false\n        Start:1561743038.7136\n        StartArg:null\n        End:1561743039.0149\n        EndArg:null\n        ChildCount:0\n        Children:None\n        NextPoint:None\nNextPoint:None\nApi call chain record\n$array = Point::toArray($point);\nYou can turn an entry point into an array. For example, we can store the following key structures in the MYSQL database:\nCREATE TABLE `api_tracker_point_list` (\n  `pointd` varchar(18) NOT NULL,\n  `pointName` varchar(45) DEFAULT NULL,\n  `parentId` varchar(18) DEFAULT NULL,\n  `depth` int(11) NOT NULL DEFAULT '0',\n  `isNext` int(11) NOT NULL DEFAULT '0',\n  `startTime` varchar(14) NOT NULL,\n  `endTime` varchar(14) DEFAULT NULL,\n  `status` varchar(10) NOT NULL,\n  PRIMARY KEY (`pointd`),\n  UNIQUE KEY `trackerId_UNIQUE` (`pointd`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nThe remaining request parameters can be recorded by themselves.\nThe core fields are in the four fields of pointId, parentId and isNext, status. For example, I want to get the call chain timeout, then it is directly\nwhere status = fail\nIf you want to see which call takes time, you can\nwhere spendTime &gt; 3\nspendTime is calculated with startTime and endTime\nBasic Server Information\nObtain basic server state information by executing the shell, for example, obtaining hard disk partition information:\n$list = \\EasySwoole\\Tracker\\Shell\\Shell::diskPartitions();\nforeach ($list as $item){\n   var_dump($item-&gt;toArray());\n}\nThe list of supported methods is as follows:\n\narpCache() \nbandWidth() \ncpuIntensiveProcesses() \ndiskPartitions() \ncurrentRam() \ncpuInfo() \ngeneralInfo() \nioStats() \nipAddresses() \nloadAvg() \nmemoryInfo() \nramIntensiveProcesses() \nswap() \nuserAccounts()\n\nNote that the above method may require root privileges and is not compatible with mac.","link":"/Components/tracker.html"},{"id":178,"title":"policy permissions","content":"Policy\nA policy is a class that organizes authorization logic in a specific model or resource to handle user authorization actions.\nInstallation\ncomposer require easyswoole/policy\nInstructions\n\nuse EasySwoole\\Policy\\PolicyNode;\nuse EasySwoole\\Policy\\Policy;\n\n//Authorized action\n//PolicyNode::EFFECT_ALLOW      Allowed\n//PolicyNode::EFFECT_DENY       Refused\n//PolicyNode::EFFECT_UNKNOWN    Unknown\n\n$policy = new Policy();\n//Add node authorization   \n$policy-&gt;addPath('/user/add',PolicyNode::EFFECT_ALLOW);\n$policy-&gt;addPath('/user/update',PolicyNode::EFFECT_ALLOW);\n$policy-&gt;addPath('/user/delete',PolicyNode::EFFECT_DENY);\n$policy-&gt;addPath('/user/*',PolicyNode::EFFECT_DENY);\n\n//Verify node permissions\nvar_dump($policy-&gt;check('user/asdasd'));//deny\nvar_dump($policy-&gt;check('user/add'));   //allow\nvar_dump($policy-&gt;check('user/update'));//allow\n\n/*\n * Allow /api/*, but only reject /api/order/charge, /api/order/info, /api/sys/*\n */\n\n$policy-&gt;addPath('/api/*',PolicyNode::EFFECT_ALLOW);\n$policy-&gt;addPath('/api/order/charge',PolicyNode::EFFECT_DENY);\n$policy-&gt;addPath('/api/order/info',PolicyNode::EFFECT_DENY);\n$policy-&gt;addPath('/api/sys/*',PolicyNode::EFFECT_DENY);\n\nvar_dump($policy-&gt;check('/api/whatever'));\nvar_dump($policy-&gt;check('/api/order/charge'));\nvar_dump($policy-&gt;check('/api/order/info'));\nvar_dump($policy-&gt;check('/api/sys/whatever'));\n\n//Object addition\n$root = new PolicyNode('*');\n$userChild = $root-&gt;addChild('user');\n$userAddChild = $userChild-&gt;addChild('add');\n$userAddChild-&gt;addChild('aaaaaa')-&gt;setAllow(PolicyNode::EFFECT_ALLOW);\n$userChild-&gt;addChild('update')-&gt;setAllow(PolicyNode::EFFECT_DENY);\n$userChild-&gt;addChild('*')-&gt;setAllow(PolicyNode::EFFECT_ALLOW);\n\n$apiChild = $root-&gt;addChild('charge');\n$apiChild-&gt;addChild('*');\n\n$node = $root-&gt;search('/user/add/aaaa');\nif ($node) {\n    var_dump($node-&gt;isAllow());\n}\n","link":"/Components/policy.html"},{"id":179,"title":"use","content":"use\ninstall\ncomposer require easyswoole/jwt \nrely on\n\nPHP version >= PHP 7.1\neasyswoole components include spl and utility\n\nGenerate token\nuse EasySwoole\\Jwt\\Jwt;\n\n$jwtObject = Jwt::getInstance()\n    -&gt;setSecretKey('easyswoole') // Secret key\n    -&gt;publish();\n\n$jwtObject-&gt;setAlg('HMACSHA256'); // Encryption mode\n$jwtObject-&gt;setAud('user'); // user\n$jwtObject-&gt;setExp(time()+3600); // Expiration date\n$jwtObject-&gt;setIat(time()); // Release time\n$jwtObject-&gt;setIss('easyswoole'); // Publisher\n$jwtObject-&gt;setJti(md5(time())); // jwt id Used to identify the JWT\n$jwtObject-&gt;setNbf(time()+60*5);\n$jwtObject-&gt;setSub('theme'); // theme\n\n// Custom data\n$jwtObject-&gt;setData([\n    'other_info'\n]);\n\n// Finally generated token\n$token = $jwtObject-&gt;__toString();\nParsing token\nuse EasySwoole\\Jwt\\Jwt;\n\n$token = \"eyJhbGciOiJITUFDU0hBMjU2IiwiaXNzIjoiZWFzeXN3b29sZSIsImV4cCI6MTU3MzgzNTIxMSwic3ViIjoi5Li76aKYIiwibmJmIjoxNTczODMxOTExLCJhdWQiOiJ1c2VyIiwiaWF0IjoxNTczODMxNjExLCJqdGkiOiJjYWJhZmNiMWIxZTkxNTU3YzIxMDUxYTZiYTQ0MTliMiIsInNpZ25hdHVyZSI6IjZlNTI1ZjJkOTFjZGYzMjBmODE1NmEwMzE1MDhiNmU0ZDQ0YzhkNGFhYzZjNmU1YzMzMTNjMDIyMGJjYjJhZjQiLCJzdGF0dXMiOjEsImRhdGEiOlsib3RoZXJfaW5mbyJdfQ%3D%3D\";\n\ntry {\n    $jwtObject = Jwt::getInstance()-&gt;decode($token);\n\n    $status = $jwtObject-&gt;getStatus();\n\n    // If the encode has a secret key set, you need to specify\n    // $status = $jwt-&gt;setSecretKey('easyswoole')-&gt;decode($token)\n\n    switch ($status)\n    {\n        case  1:\n            echo 'Verifying and passing';\n            $jwtObject-&gt;getAlg();\n            $jwtObject-&gt;getAud();\n            $jwtObject-&gt;getData();\n            $jwtObject-&gt;getExp();\n            $jwtObject-&gt;getIat();\n            $jwtObject-&gt;getIss();\n            $jwtObject-&gt;getNbf();\n            $jwtObject-&gt;getJti();\n            $jwtObject-&gt;getSub();\n            $jwtObject-&gt;getSignature();\n            $jwtObject-&gt;getProperty('alg');\n            break;\n        case  -1:\n            echo 'invalid';\n            break;\n        case  -2:\n            echo 'Token expired';\n        break;\n    }\n} catch (\\EasySwoole\\Jwt\\Exception $e) {\n\n}","link":"/Components/Jwt/use.html"},{"id":180,"title":"encode","content":"Coding related methods\nSet encryption method, defaultHMACSHA256\n    function algMethod(string $method):Jwt\nSet secret key, defaultEasyswoole\n    function setSecretKey(string $key):Jwt\nInitializing the jwtobject of a token without additional information\n    public function publish():JwtObject\nSet encryption method, defaultHMACSHA256\n    public function setAlg($alg): void\nset user\n    public function setAud($aud): void\nSet expiration time\n    public function setExp($exp): void\nSet publishing time\n    public function setIat($iat): void\nSet up the issuer\n    public function setIss(string $iss): void\nSet JWT ID to identify the JWT\n    public function setJti($jti): void\nNot available until\n    public function setNbf($nbf): void\nset topic\n    public function setSub($sub): void\nSet other data\n    public function setData($data): void\nget token\n    function __toString()","link":"/Components/Jwt/encode.html"},{"id":181,"title":"decode","content":"Decoding correlation method\nDecode\n    public function decode(?string $raw):?JwtObject\nGet decoding status, 1: pass, - 1: invalid, - 2: token expired\n    public function getStatus(): int\nGet encryption method\n    public function getAlg()\nget user\n    public function getAud()\nGet expiration time\n    public function getExp()\nGet release time\n    public function getIat()\nGet issuer\n    public function getIss(): string\nGet jwt-id\n    public function getJti()\nGet effective time\n    public function setNbf($nbf): void\nGet topic\n    public function getSub()\nGet custom data\n    public function getData()\nGet signature\n    public function getSignature()\nGet relevant data through key\n    final public function getProperty($name)","link":"/Components/Jwt/decode.html"},{"id":182,"title":"atomic current limiter","content":"AtomicLimit\nEasyswoole provides a current limiter based on Atomic counters\nprinciple\nThe basic current limit is achieved by limiting the total number of requests in a certain time period. For example, if the maximum number of requests allowed is 200 in 5 seconds, then the theoretical average is 40 and the peak is 200.\nInstallation\ncomposer require easyswoole/atomic-limit\nSample code\n/*\n * egUrl http://127.0.0.1:9501/index.html?api=1\n */\n\nuse EasySwoole\\AtomicLimit\\AtomicLimit;\nAtomicLimit::getInstance()-&gt;addItem('default')-&gt;setMax(200);\nAtomicLimit::getInstance()-&gt;addItem('api')-&gt;setMax(2);\n\n$http = new swoole_http_server(\"127.0.0.1\", 9501);\n\nAtomicLimit::getInstance()-&gt;enableProcessAutoRestore($http,10*1000);\n\n$http-&gt;on(\"request\", function ($request, $response) {\n    if(isset($request-&gt;get['api'])){\n        if(AtomicLimit::isAllow('api')){\n            $response-&gt;write('api success');\n        }else{\n            $response-&gt;write('api refuse');\n        }\n    }else{\n        if(AtomicLimit::isAllow('default')){\n            $response-&gt;write('default success');\n        }else{\n            $response-&gt;write('default refuse');\n        }\n    }\n    $response-&gt;end();\n});\n\n$http-&gt;start();\nNote that this example uses a custom process plus timer to implement the count timing reset. In fact, it is not worthwhile to use a process to do this. Therefore, the actual production can specify a worker and set a timer to implement.\nUse\nWe can register the current limiter in the mainServerCreate event of the Easyswoole global.\nuse EasySwoole\\AtomicLimit\\AtomicLimit;\nAtomicLimit::getInstance()-&gt;addItem('default')-&gt;setMax(200);\nAtomicLimit::getInstance()-&gt;addItem('api')-&gt;setMax(2);\nAtomicLimit::getInstance()-&gt;enableProcessAutoRestore(ServerManager::getInstance()-&gt;getSwooleServer(),10*1000)\n  The above code indicates that the default limiter allows a maximum flow of 200 in 5 seconds, while the api has a maximum flow of 2 in the limiter.\nSubsequently, we can perform request interception in the base controller of Easyswoole. For example, in the onRequest event, the traffic check is performed first. If the check passes, the next step is performed.","link":"/Components/atomicLimit.html"},{"id":183,"title":"introduction","content":"words-match\nwords-matchThe component is based on the dictionary tree (DFA) and is realized by using the unixsock communication and custom process. The purpose of developing this component is to help the young people quickly deploy the content detection service\nUse scenario\nProducts related to text content have application scenarios.\nsuch as：\nBlog articles, comments detection\nDetection of chat content\nBlocking junk content\ninstall\ncomposer require easyswoole/words-match\nPrepare Thesaurus\nWhen the service is started, the data will be read out row by row. The first column of each row is sensitive words and the other columns are subsidiary information\nphp,Is the best language in the world\njava\ngolang\nCode example\nService registration\n&lt;?php\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\WordsMatch\\WordsMatchClient;\nuse EasySwoole\\WordsMatch\\WordsMatchServer;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // TODO: Implement mainServerCreate() method.\n        $config = [\n            'wordBank' =&gt; '/Users/xxx/sites/easyswoole/WordsMatch/comment.txt', // Thesaurus address\n            'processNum' =&gt; 3, // Number of processes\n            'maxMem' =&gt; 1024, // Maximum memory per process(M)\n            'separator' =&gt; ',', // Separators for words and other information\n        ];\n        WordsMatchServer::getInstance()\n            -&gt;setConfig($config)\n            -&gt;attachToServer(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        // TODO: Implement onRequest() method.\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        // TODO: Implement afterAction() method.\n    }\n}\nClient use\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\WordsMatch\\WordsMatchClient;\n\nclass Index extends Controller\n{\n\n    function append()\n    {\n        WordsMatchClient::getInstance()-&gt;append('easyswoole', [3,4,5]);\n    }\n\n    function detect()\n    {\n        $content = 'PHP is the best language in the world';\n        WordsMatchClient::getInstance()-&gt;detect($content);\n    }\n\n    function remove()\n    {\n        WordsMatchClient::getInstance()-&gt;remove('easyswoole');\n    }\n\n}","link":"/Components/WordsMatch/introduction.html"},{"id":184,"title":"service","content":"Prepare Thesaurus\nWhen the service is started, the data will be read out row by row, the first column of each row is sensitive words, and the other columns are subsidiary information.\nOfficial does not provide thesaurus, only tools\nSample file content：\nphp,Is the best language in the world\njava\ngolang\n服务注册\n&lt;?php\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\WordsMatch\\WordsMatchClient;\nuse EasySwoole\\WordsMatch\\WordsMatchServer;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // TODO: Implement mainServerCreate() method.\n        $config = [\n            'wordBank' =&gt; '/Users/xxx/sites/easyswoole/WordsMatch/comment.txt', // Thesaurus address\n            'processNum' =&gt; 3, // Number of processes\n            'maxMem' =&gt; 1024, // Maximum memory per process(M)\n            'separator' =&gt; ',', // Separators for words and other information\n        ];\n        WordsMatchServer::getInstance()\n            -&gt;setConfig($config)\n            -&gt;attachToServer(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        // TODO: Implement onRequest() method.\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        // TODO: Implement afterAction() method.\n    }\n}\nconfig\nwordBank\nThesaurus path\nprocessNum\nwords-match number of processes, default 3\nmaxMem\nMaximum memory occupied by each process, 512M by default\nseparator\nSeparator for each line of word information, default comma","link":"/Components/WordsMatch/service.html"},{"id":185,"title":"client","content":"Supported methods\ndetect\nTest content\npublic function detect(string $content, float $timeout = 3.0) : array\nappend\nAdd word, first parameter: word, second parameter: other information of word\npublic function append(string $word, array $otherInfo=[], float $timeout = 3.0)\nremove\nRemove words\npublic function remove(string $word, float $timeout = 3.0)","link":"/Components/WordsMatch/client.html"},{"id":186,"title":"common problems","content":"What to do after the service stops?\n\nWhen the 1. X version service stops, it will drop all the running words to the file, and 2. X will remove this feature\nWe are more inclined to let users handle these words themselves. For example: for example, all your words exist in dB. When you add or remove words online, you can update DB accordingly,\nThen regularly refresh the thesaurus file.\n\nHow to change &quot;dirty words&quot; into *?\n\nIn the detection result, there will be hit words in the specific position of the article, and then you can make corresponding replacement according to the length of the words, or you can simply replace the hit words directly according to this idea\nCan achieve more fun things.\n\nQQ will according to chat content under the expression of rain, this is how to do?\n\nDetect chat content, hit corresponding keywords, pull corresponding expressions and throw them on your screen.\n\n","link":"/Components/WordsMatch/problem.html"},{"id":187,"title":"pressure test results","content":"Pressure test results\nThis component is tested with 15000 and 130000 level thesaurus respectively, and the service starts three processes by default.\nComputer configuration\nMacBook Air (13-inch, 2017)\n处理器 1.8 GHz Intel Core i5\n内存 8 GB 1600 MHz DDR3\n15000 words\nConcurrent 10 total requests 100\n10 100\nConcurrency Level:      10\nTime taken for tests:   0.067 seconds\nComplete requests:      100\nFailed requests:        0\nNon-2xx responses:      100\nTotal transferred:      17300 bytes\nHTML transferred:       2600 bytes\nRequests per second:    1492.49 [#/sec] (mean)\nTime per request:       6.700 [ms] (mean)\nTime per request:       0.670 [ms] (mean, across all concurrent requests)\nTransfer rate:          252.15 [Kbytes/sec] received\nConcurrent 100 total requests 1000\nConcurrency Level:      100\nTime taken for tests:   0.239 seconds\nComplete requests:      1000\nFailed requests:        0\nNon-2xx responses:      1000\nTotal transferred:      173000 bytes\nHTML transferred:       26000 bytes\nRequests per second:    4189.17 [#/sec] (mean)\nTime per request:       23.871 [ms] (mean)\nTime per request:       0.239 [ms] (mean, across all concurrent requests)\nTransfer rate:          707.74 [Kbytes/sec] received\n130000 words\nConcurrent 10 total requests 100\nConcurrency Level:      10\nTime taken for tests:   0.057 seconds\nComplete requests:      100\nFailed requests:        0\nNon-2xx responses:      100\nTotal transferred:      17300 bytes\nHTML transferred:       2600 bytes\nRequests per second:    1751.71 [#/sec] (mean)\nTime per request:       5.709 [ms] (mean)\nTime per request:       0.571 [ms] (mean, across all concurrent requests)\nTransfer rate:          295.94 [Kbytes/sec] received\nConcurrent 100 total requests 1000\nConcurrency Level:      100\nTime taken for tests:   0.225 seconds\nComplete requests:      1000\nFailed requests:        0\nNon-2xx responses:      1000\nTotal transferred:      173000 bytes\nHTML transferred:       26000 bytes\nRequests per second:    4444.84 [#/sec] (mean)\nTime per request:       22.498 [ms] (mean)\nTime per request:       0.225 [ms] (mean, across all concurrent requests)\nTransfer rate:          750.93 [Kbytes/sec] received","link":"/Components/WordsMatch/ab.html"},{"id":188,"title":"arraytotexttable","content":"ArrayToTextTable\nUse\nUsed to convert array data to table output.\nCore Object Class\nTo implement this component function you need to load the core class:\nEasySwoole\\Utility\\ArrayToTextTable\nCore Object Method\ngetTable\nGet the form\n\nmixed $data table data\n\nPublic function getTable($data = null)\nsetIndentation\nSet table indentation\n\nmixed $indentation setting indentation\n\npublic function setIndentation($indentation)\nisDisplayHeader\nSet the table header\n\nbool $displayHeader Do you need a table header?\n\nPublic function isDisplayHeader(bool $displayHeader)\nsetKeysAlignment\nSet table header alignment\n\nmixed $keysAlignment table header alignment\n\nPublic function setKeysAlignment($keysAlignment)\nsetValuesAlignment\nSet table data alignment\n\nmixed $keysAlignment table header alignment\n\nPublic function setValuesAlignment($valuesAlignment)\nsetFormatter\nProcessing tabular data format\n\nmixed $formatter data mode\n\npublic function setFormatter($formatter)\nhow to use\nCreating objects of the core class\n$data = [\n    [\n        'name' =&gt; 'James',\n        'age' =&gt; '20',\n        'sex'=&gt;'man'\n    ],\n    [\n        'name' =&gt; 'Tony',\n        'age' =&gt; 50,\n        'email' =&gt; '291323003@qq.com',\n    ],\n];\n// Create a core class object, and bring in the data parameter $data\n$renderer = new \\EasySwoole\\Utility\\ArrayToTextTable($data);\n// Set the table indentation\n$renderer-&gt;setIndentation(\"\\t\");\n// Set the table header\n$renderer-&gt;isDisplayHeader(true);\n// Set the table header alignment\n$renderer-&gt;setKeysAlignment(\\EasySwoole\\Utility\\ArrayToTextTable::AlignLeft);\n// Set the table data alignment\n$renderer-&gt;setValuesAlignment(\\EasySwoole\\Utility\\ArrayToTextTable::AlignLeft);\n// Processing table data format\n$renderer-&gt;setFormatter(function (&amp;$value,$key){\n    if($key == 'sex'){\n        if(empty($value)){\n            $value = 'Unknown gender';\n        }\n    }else if($key == 'email'){\n        if(empty($value)){\n            $value = 'Unknown mailbox';\n        }\n    }\n});\n\n$table =  $renderer-&gt;getTable();\n\necho $renderer;\n​       Ps: Please run in the command line mode. If the border of the table is not aligned, check whether the space ratio of the Chinese font and the English font is 2:1.","link":"/Components/Sundries/arrayToTextTable.html"},{"id":189,"title":"file","content":"File\nUse\nUsed to manipulate files or directories.\nCore Object Class\nTo implement this component function you need to load the core class:\nEasySwoole\\Utility\\File\nCore Object Method\ncreateDirectory\nCreate a directory:\n\nstring $dirPath directory path\nstring $permissions directory permissions\n\nstatic function createDirectory($dirPath, $permissions = 0755):bool\ncleanDirectory\nEmpty the directory:\n\nstring $dirPath directory path\nstring $keepStructure whether to maintain the directory structure\n\nstatic function cleanDirectory($dirPath, $keepStructure = false):bool\ndeleteDirectory\nDelete directory:\n\nstring $dirPath directory path\n\nstatic function deleteDirectory($dirPath):bool\ncopyDirectory\nCopy directory:\n\nstring $source source location\nstring $target target location\nbool $overwrite whether to overwrite\n\nstatic function copyDirectory($source, $target, $overwrite = true):bool\nmoveDirectory\nMobile directory:\n\nstring $source source location\nstring $target target location\nbool $overwrite whether to overwrite\n\nStatic function moveDirectory($source, $target ,$overwrite = true):bool\ncopyFile\nCopy the file:\n\nstring $source source location\nstring $target target location\nbool $overwrite whether to overwrite\n\nStatic function copyFile($source, $target, $overwrite = true):bool\ntouchFile\nCreate an empty file:\n\nstring $filePath filename\nbool $overwrite whether to overwrite\n\nstatic function touchFile($filePath, $overwrite = true):bool\ncreateFile\nCreate a content file:\n\nstring $filePath filename\nstring $content content\nbool $overwrite whether to overwrite\n\nStatic function createFile($filePath, $content, $overwrite = true):bool\nmoveFile\nMove files:\n\nstring $source source location\nstring $target target location\nbool $overwrite whether to overwrite\n\nStatic function moveFile($source, $target, $overwrite = true):bool\n\nscanDir\nGet an array of file directories or directory files:\n\nstring $dirPath directory path\n\nstatic function scanDir($dirPath)","link":"/Components/Sundries/file.html"},{"id":190,"title":"hash","content":"Hash\nUse\nUsed to quickly process hash passwords and data integrity check scenarios\nCore Object Class\nTo implement this component function you need to load the core class:\nEasySwoole\\Utility\\Hash\nCore Object Method\nmakePasswordHash\nProduce a hash from a plaintext value\n\nmixed $value needs to produce the original text of the hash\nmixed $cost recursive layers\n\nStatic function makePasswordHash($value, $cost = 10)\nvalidatePasswordHash\nCheck if the plaintext value matches the hash\n\nmixed $value\nmixed $cost hash encrypted\nstatic function validatePasswordHash($value, $hashValue)\n\n\nHow to use\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$password = 123456;\n$hash = \\EasySwoole\\Utility\\Hash::makePasswordHash($password);\nvar_dump($hash);\nvar_dump(\\EasySwoole\\Utility\\Hash::validatePasswordHash($password, $hash));\n\n/**\n * Output results:\n * string(60) \"$2y$10$ESx0z8TGSJpMI3Hgr6nJJOdbretS2TBqv4d5L0XjlTkSjSiCiq/f6\"\n * bool(true) \n */","link":"/Components/Sundries/hash.html"},{"id":191,"title":"random","content":"Random\nUse\nUsed to generate random verification codes, random strings, etc.\nCore Object Class\nTo implement this component function you need to load the core class:\nEasySwoole\\Utility\\Random\nCore Object Method\nCharacter\nStrings are randomly generated:\n\nint $length generation length\nstring $alphabet custom generated character set\n\nstatic function character($length = 6, $alphabet = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789')\nNumber\nPure numeric strings are randomly generated:\n\nint $length generation length\n\nStatic function number(length = 6)\nArrayRandOne\nGenerate an individual randomly from the collection:\n\narray $length array collection\n\nStatic function arrayRandOne(array $data)\nHow to use\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Random::character());\nvar_dump(\\EasySwoole\\Utility\\Random::number());\nvar_dump(\\EasySwoole\\Utility\\Random::arrayRandOne(['one', 'two', 'three']));\n\n/**\n * Output results:\n * string(6) \"W94ohx\"\n * string(6) \"986543\"\n * string(3) \"two\"\n */","link":"/Components/Sundries/random.html"},{"id":192,"title":"snowflake","content":"Snowflake algorithm\nUse\nGenerate a unique number\nCore Object Class\nTo implement this component function you need to load the core class:\nEasySwoole\\Utility\\Random\nCore Object Method\nMake\nGenerate a random number based on the snowflake algorithm\n\nmixed $dataCenterID data center\nmixed $workerID task process\n\nStatic function make($dataCenterID = 0, $workerID = 0)\nUnmake\nReverse analysis of the number generated by the snowflake algorithm\n\nmixed $snowFlakeId number\n\nstatic function unmake($snowFlakeId)\nHow to use\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = \\EasySwoole\\Utility\\SnowFlake::make(1,1);//Incoming data center id (0-31), task process id (0-31)\nvar_dump($str);\nvar_dump(\\EasySwoole\\Utility\\SnowFlake::unmake($str));\n\n/**\n * Output results:\n * int(194470364728922112)\n * object(stdClass)#3 (4) {\n *   [\"timestamp\"]=&gt;\n *   int(1532127766018)\n *   [\"dataCenterID\"]=&gt;\n *   int(1)\n *   [\"workerID\"]=&gt;\n *   int(1)\n *   [\"sequence\"]=&gt;\n *   int(0)\n * }\n */","link":"/Components/Sundries/snowFlake.html"},{"id":193,"title":"str","content":"Str\nUse\nStr string helper\nCore Object Class\nTo implement this component function you need to load the core class:\nEasySwoole\\Utility\\Str\nCore Object Method\nContains\nCheck if another string is included in the string\n\nmixed $haystack checked string\nmixed $needles need to contain the string\nmixed $strict is case sensitive\n\nStatic function contains($haystack, $needles, $strict = true)\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Str::contains('hello, easyswoole', 'Swoole', false));\n\n/**\n * Output results:\n * bool(true)\n */\nstartsWith\nCheck if the string starts with a string\n\nmixed $haystack checked string\nmixed $needles need to contain the string\nmixed $strict is case sensitive\n\nstatic function startsWith($haystack, $needles, $strict = true)\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Str::startsWith('hello, easyswoole', 'Hello', false));\n\n/**\n * Output results:\n * bool(true)\n */\nendsWith\nCheck if the string ends with a string\n\nmixed $haystack checked string\nmixed $needles need to contain the string\nmixed $strict is case sensitive\n\nstatic function endsWith($haystack, $needles, $strict = true)\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Str::endsWith('hello, easyswoole', 'Swoole', false));\n\n/**\n * Output results:\n * bool(true)\n */\nsnake\nHump downline\n\nmixed $value pending string\nmixed $delimiter separator\n\nstatic function snake($value, $delimiter = '_')\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Str::snake('EasySwoole'));\n\n/**\n * Output results:\n * string(11) \"easy_swoole\"\n */\ncamel\nUnderline to hump (lower initial)\n\nmixed $value pending string\n\nstatic function camel($value)\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Str::camel('easy_swoole'));\n\n/**\n * Output results:\n * string(10) \"easySwoole\"\n */\nstudly\nUnderline to hump (initial capitalization)\n\nmixed $value pending string\n\nstatic function studly($value)\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Str::studly('easy_swoole'));\n\n/**\n * Output results:\n * string(10) \"EasySwoole\"\n */","link":"/Components/Sundries/str.html"},{"id":194,"title":"time","content":"Time\nUse\nTimestamp assistant\nCore Object Class\nTo implement this component function you need to load the core class:\nEasySwoole\\Utility\\Time\nCore Object Method\nStartTimestamp\nReturn the timestamp starting at a certain day\n\nmixed $date string date or timestamp\n\nstatic function startTimestamp($date = '')\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Time::startTimestamp('2019-4-15'));\n\n/**\n * Output results:\n * int(1555286400)\n */\nendTimestamp\n返Back to the end of the day\n\nmixed $date string date or timestamp\n\nstatic function endTimestamp($date = '')\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Time::endTimestamp('2019-4-15'));\n\n/**\n * Output results:\n * int(1555372799)\n */\nendTimestamp\nCreate a Datetime object from a string\n\nmixed $datetime incoming text date or timestamp\n\nstatic function createDateTimeClass($datetime = '')\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Time::createDateTimeClass('2019-4-15'));\n\n/**\n * Output results:\n * object(DateTime)#3 (3) {\n *   [\"date\"]=&gt;\n *   string(26) \"2019-04-15 00:00:00.000000\"\n *   [\"timezone_type\"]=&gt;\n *   int(1)\n *   [\"timezone\"]=&gt;\n *   string(6) \"+00:00\"\n * }\n */\nparserDateTime\nGet the year, month, day, hour, minute, and second from the DateTime object\n\nmixed $datetime incoming text date or timestamp\n\nstatic function parserDateTime($dateTime)\nExample\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Time::parserDateTime('2019-4-15'));\n\n/**\n * Output results:\n * array(6) {\n *   [0]=&gt;\n *   string(2) \"00\"\n *   [1]=&gt;\n *   string(2) \"00\"\n *   [2]=&gt;\n *   string(2) \"00\"\n *   [3]=&gt;\n *   string(1) \"4\"\n *   [4]=&gt;\n *   string(2) \"15\"\n *   [5]=&gt;\n *   string(4) \"2019\"\n * }\n */","link":"/Components/Sundries/time.html"},{"id":195,"title":"introduce","content":"Smtp\nEasyswoole provides a mail sending component. E-mail is a kind of communication mode that provides information exchange by electronic means. It is the most widely used service on the Internet. Email is essential to almost every web application, whether it's a newsletter or an order confirmation. This component uses the swoole cooperation client to realize the sending of e-mail。\nInstall\ncomposer require easyswoole/smtp\nUse\nuse EasySwoole\\Smtp\\Mailer;\nuse EasySwoole\\Smtp\\MailerConfig;\nuse EasySwoole\\Smtp\\Message\\Html;\nuse EasySwoole\\Smtp\\Message\\Attach;\n// Must use go function\ngo(function (){\n    $config = new MailerConfig();\n    $config-&gt;setServer('smtp.163.com');\n    $config-&gt;setSsl(false);\n    $config-&gt;setUsername('huizhang');\n    $config-&gt;setPassword('*******');\n    $config-&gt;setMailFrom('xx@163.com');\n    $config-&gt;setTimeout(10);// Set client connection timeout\n    $config-&gt;setMaxPackage(1024*1024*5);//Set the size of the package sent：5M\n\n    //Set text or html\n    $mimeBean = new Html();\n    $mimeBean-&gt;setSubject('Hello Word!');\n    $mimeBean-&gt;setBody('&lt;h1&gt;Hello Word&lt;/h1&gt;');\n\n    //Add attachments\n    $mimeBean-&gt;addAttachment(Attach::create('./test.txt'));\n\n    $mailer = new Mailer($config);\n    $mailer-&gt;sendTo('xx@qq.com', $mimeBean);\n});\n","link":"/Components/Smtp/smtp.html"},{"id":196,"title":"config(mailerconfig)","content":"MailerConfig\nFor mail configuration, it is recommended to know what corresponding information is needed to send mail first, so as to facilitate correspondence with the following methods.\nset\nSet server address\npublic function setServer(string $server): void\nSet server port\npublic function setPort(int $port): void\nSet ssl\npublic function setSsl(bool $ssl): void\nSet username\npublic function setUsername(string $username): void\nSet password\npublic function setPassword(string $password): void\nSet mail sender\npublic function setMailFrom(string $mailFrom): void\nSet timeout\npublic function setTimeout(float $timeout): void\nSet mail size\npublic function setMaxPackage(int $maxPackage)\nget\nGet server address\npublic function getServer(): string\nGet server port\npublic function getPort(): int\nWhether SSL is set\npublic function isSsl(): bool\nGet username\npublic function getUsername(): string\nGet password\npublic function getPassword(): string\nGet mail sender\npublic function getMailFrom(): string\nGet timeout\npublic function getTimeout(): float\nGet email size\npublic function getMaxPackage()","link":"/Components/Smtp/config.html"},{"id":197,"title":"email content","content":"Email content\nSupport two types ofr text and html\nText\nExample\n$mimeBean = new \\EasySwoole\\Smtp\\Message\\Text();\n$mimeBean-&gt;setSubject('Hello Word!');\n$mimeBean-&gt;setBody('&lt;h1&gt;Hello Word&lt;/h1&gt;');\nEffect\n \nHtml\n$mimeBean = new \\EasySwoole\\Smtp\\Message\\Html();\n$mimeBean-&gt;setSubject('Hello Word!');\n$mimeBean-&gt;setBody('&lt;h1&gt;Hello Word&lt;/h1&gt;');\nEffect\n \nAttachments\n$mimeBean = new \\EasySwoole\\Smtp\\Message\\Text();\n//$mimeBean = new \\EasySwoole\\Smtp\\Message\\Html();\n\n...\n\n// Create attachment\n$createAttachment = Attach::create('./test.txt');\n\n// Get attachment\n$mimeBean-&gt;addAttachment($createAttachment);\n\n...","link":"/Components/Smtp/content.html"},{"id":198,"title":"content config","content":"Content configuration\nset\nSet protocol version\npublic function setMimeVersion($mimeVersion): void\nSet contentType\npublic function setContentType($contentType): void\nSetting characters\npublic function setCharset($charset): void\nSet encoding\npublic function setContentTransferEncoding($contentTransferEncoding): void\nSet up themes\npublic function setSubject($subject): void\nSet mail content\npublic function setBody($body): void\nAdd attachments\npublic function addAttachment($attachment)\nget\nGet protocol version\npublic function getMimeVersion()\nGet contenttype\npublic function getContentType()\nGet Character\npublic function getCharset()\nGet Acquisition\npublic function getContentTransferEncoding()\nGet theme\npublic function getSubject()\nGet mail content\npublic function getBody()\nGet attachment\npublic function getAttachments()","link":"/Components/Smtp/contentconfig.html"},{"id":199,"title":"use","content":"Spider\nSpider component can facilitate users to quickly build distributed multi process crawlers. Users only need to care about product and consumer, and product recommends querylist for DOM parsing\nInstall\ncomposer require easyswoole/spider\nRapid use\nTake Baidu search for example, according to search keywords, climb out specific data in the first few pages of each search result\nIt is purely for teaching purpose. If you offend your company, please inform us in time and we will adjust it in time\nProduct\n&lt;?php\nnamespace App\\Spider;\n\nuse EasySwoole\\HttpClient\\HttpClient;\nuse EasySwoole\\Spider\\Config\\ProductConfig;\nuse EasySwoole\\Spider\\Hole\\ProductAbstract;\nuse EasySwoole\\Spider\\ProductResult;\nuse QL\\QueryList;\nuse EasySwoole\\FastCache\\Cache;\n\nclass ProductTest extends ProductAbstract\n{\n\n    public function product():ProductResult\n    {\n        // TODO: Implement product() method.\n        // Get url\n        $httpClient = new HttpClient($this-&gt;productConfig-&gt;getUrl());\n        $httpClient-&gt;setHeader('User-Agent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36');\n        $body = $httpClient-&gt;get()-&gt;getBody();\n\n        $rules = [\n            'search_result' =&gt; ['.c-container .t', 'text', 'a']\n        ];\n        $searchResult = QueryList::rules($rules)-&gt;html($body)-&gt;query()-&gt;getData();\n\n        $data = [];\n        foreach ($searchResult as $result) {\n            $item = [\n                'href' =&gt; QueryList::html($result['search_result'])-&gt;find('a')-&gt;attr('href'),\n                'text' =&gt; QueryList::html($result['search_result'])-&gt;find('a')-&gt;text()\n            ];\n            $data[] = $item;\n        }\n\n        $productJobOtherInfo = $this-&gt;productConfig-&gt;getOtherInfo();\n\n        // Next tasks\n        $productJobConfigs = [];\n        if ($productJobOtherInfo['page'] === 1) {\n            for($i=1;$i&lt;5;$i++) {\n                $pn = $i*10;\n                $productJobConfig = [\n                    'url' =&gt; \"https://www.baidu.com/s?wd={$productJobOtherInfo['word']}&amp;pn={$pn}\",\n                    'otherInfo' =&gt; [\n                        'word' =&gt; $productJobOtherInfo['word'],\n                        'page' =&gt; $i+1\n                    ]\n                ];\n                $productJobConfigs[] = $productJobConfig;\n            }\n\n            $word = Cache::getInstance()-&gt;deQueue(self::SEARCH_WORDS);\n            if (!empty($word)) {\n                $productJobConfigs[] = [\n                    'url' =&gt; \"https://www.baidu.com/s?wd={$word}&amp;pn=0\",\n                    'otherInfo' =&gt; [\n                        'word' =&gt; $word,\n                        'page' =&gt; 1\n                    ]\n                ];\n            }\n\n        }\n\n        $result = new ProductResult();\n        $result-&gt;setProductJobConfigs($productJobConfigs)-&gt;setConsumeData($data);\n        return $result;\n    }\n\n}\nConsume\nI have directly saved the file here, and can customize it according to the demand\n&lt;?php\nnamespace App\\Spider;\n\nuse EasySwoole\\Spider\\ConsumeJob;\nuse EasySwoole\\Spider\\Hole\\ConsumeAbstract;\n\nclass ConsumeTest extends ConsumeAbstract\n{\n\n    public function consume()\n    {\n        // TODO: Implement consume() method.\n        $data = $this-&gt;getJobData();\n\n        $items = '';\n        foreach ($data as $item) {\n            $items .= implode(\"\\t\", $item).\"\\n\";\n        }\n\n        file_put_contents('baidu.txt', $items, FILE_APPEND);\n    }\n}\nRegister spider components\npublic static function mainServerCreate(EventRegister $register)\n{\n        $spiderConfig = [\n            'product' =&gt; ProductTest::class, // Must\n            'consume' =&gt; ConsumeTest::class, // Must\n            'queueType' =&gt; SpiderConfig::QUEUE_TYPE_FAST_CACHE, // The default communication type is fast cache, which does not support distributed. If you need distributed, you can use SpiderConfig::QUEUE_TYPE_REDIS，Or implement communication queue by yourself\n            'queue' =&gt; 'Custom queues are not required if they are built in by components',\n            'queueConfig' =&gt; 'Custom queue configuration, currently only SpiderConfig::QUEUE_TYPE_REDIS need',\n            'maxCurrency' =&gt; 128 // Maximum concurrent number of coroutine\n        ];\n        SpiderServer::getInstance()\n            -&gt;setSpiderConfig($spiderConfig)\n            -&gt;attachProcess(ServerManager::getInstance()-&gt;getSwooleServer());\n}\nDelivery task\n$words = [\n    'php',\n    'java',\n    'go'\n];\n\nforeach ($words as $word) {\n    Cache::getInstance()-&gt;enQueue('SEARCH_WORDS', $word);\n}\n\n$wd = Cache::getInstance()-&gt;deQueue('SEARCH_WORDS');\n\nSpiderClient::getInstance()-&gt;addJob(\n                'https://www.baidu.com/s?wd=php&amp;pn=0',\n                [\n                    'page' =&gt; 1,\n                    'word' =&gt; $wd\n                ]\n);","link":"/Components/Spider/use.html"},{"id":200,"title":"product","content":"Product\nMatters needing attention\n\n\nThe product method return must return the productresult object, because productresult contains a new batch of task configuration and a consumption task data generated by this task\nCallback method\n\n\npublic function product():ProductResult\n{\n    // TODO: Implement product() method.\n\n    // Productconfig stores the configuration information of the current task[\n             'url' =&gt; '',\n             'otherInfo' =&gt; 'Other info'\n         ]\n\n    $this-&gt;productConfig;\n\n    $data = 'Data obtained';\n\n    // Next task configuration\n    $productJobConfigs = [\n        [\n            'url' =&gt; '',\n            'otherInfo' =&gt; 'Other info'\n        ],\n        [\n            'url' =&gt; '',\n            'otherInfo' =&gt; 'Other info'\n        ],\n    ];\n\n    $result = new ProductResult();\n    $result-&gt;setProductJobConfigs($productJobConfigs)-&gt;setConsumeData($data);\n    return $result;\n}","link":"/Components/Spider/product.html"},{"id":201,"title":"consume","content":"Consume\nThe data produced by product will be delivered to the consumer task data in jobdata\n&lt;?php\nnamespace App\\Spider;\n\nuse EasySwoole\\Spider\\ConsumeJob;\nuse EasySwoole\\Spider\\Hole\\ConsumeAbstract;\n\nclass ConsumeTest extends ConsumeAbstract\n{\n\n    public function consume()\n    {\n        // TODO: Implement consume() method.\n        $data = $this-&gt;getJobData();\n\n        $items = '';\n        foreach ($data as $item) {\n            $items .= implode(\"\\t\", $item).\"\\n\";\n        }\n\n        file_put_contents('xx.txt', $items, FILE_APPEND);\n    }\n}","link":"/Components/Spider/consume.html"},{"id":202,"title":"client","content":"Spider Client\nThe client can add task information to spider service for crawling\nSpiderClient::getInstance()-&gt;addJob('https://xxxxx','Other info’);\nSupported methods\nAdd job\n    public function addJob($url, $otherInfo)\nBatch add job\n    public function addJobs(array $jobsConfig)\n    $jobsConfig = [\n      [\n        'url' =&gt; xxx,\n        'otherInfo =&gt; xxx\n      ],\n      [\n        'url' =&gt; xxx,\n        'otherInfo =&gt; xxx\n      ],\n      [\n        'url' =&gt; xxx,\n        'otherInfo =&gt; xxx\n      ]\n    ];","link":"/Components/Spider/client.html"},{"id":203,"title":"custom communication queue","content":"Custom queue\nRealization EasySwoole\\Queue\\QueueDriverInterface;，Take the component's default fast-cache queue as an example\nnamespace EasySwoole\\Spider\\Queue;\n\nuse EasySwoole\\FastCache\\Cache;\nuse EasySwoole\\Queue\\QueueDriverInterface;\nuse EasySwoole\\Queue\\Job;\n\nclass FastCacheQueue implements QueueDriverInterface\n{\n\n    private const FASTCACHE_JOB_QUEUE_KEY='FASTCACHE_JOB_QUEUE_KEY';\n\n    function pop(float $timeout = 3):?Job\n    {\n        // TODO: Implement pop() method.\n        $job =  Cache::getInstance()-&gt;deQueue(self::FASTCACHE_JOB_QUEUE_KEY);\n        if (empty($job)) {\n            return null;\n        }\n        $job = unserialize($job);\n        if (empty($job)) {\n            return null;\n        }\n        return $job;\n    }\n\n    function push(Job $job):bool\n    {\n        // TODO: Implement push() method.\n        $res = Cache::getInstance()-&gt;enQueue(self::FASTCACHE_JOB_QUEUE_KEY, serialize($job));\n        if (empty($res)) {\n            return false;\n        }\n        return true;\n    }\n\n    public function size(): ?int\n    {\n        // TODO: Implement size() method.\n    }\n}\n\nDistributed\nIt can be realized by using the redis communication or custom communication mode of the component","link":"/Components/Spider/consumequeue.html"},{"id":204,"title":"liunxdash","content":"LinuxDash\nLinux dash encapsulates many commands to get Linux information directly.\ninstall:  \ncomposer require easyswoole/linux-dash \nexample\n\n$run = new \\Swoole\\Coroutine\\Scheduler();\n$run-&gt;add(function () {\n    //Get IP address network card buffer information\n    $data = LinuxDash::arpCache();\n    var_dump($data);\n    //Get current bandwidth data\n    $data = LinuxDash::bandWidth();\n    var_dump($data);\n    //Get CPU process occupation ranking information\n    $data = LinuxDash::cpuIntensiveProcesses();\n    var_dump($data);\n    //Get partition information\n    $data = LinuxDash::diskPartitions();\n    var_dump($data);\n    //Get current memory usage information\n    $data = LinuxDash::currentRam();\n    var_dump($data);\n    //Get CPU Information\n    $data = LinuxDash::cpuInfo();\n    var_dump($data);\n    //Get current system information\n    $data = LinuxDash::generalInfo();\n    var_dump($data);\n    //Get the current disk IO statistics\n    $data = LinuxDash::ioStats();\n    var_dump($data);\n    //Get IP address\n    $data = LinuxDash::ipAddresses();\n    var_dump($data);\n    //CPU load information\n    $data = LinuxDash::loadAvg();\n    var_dump($data);\n    //Get memory details\n    $data = LinuxDash::memoryInfo();\n    var_dump($data);\n    //Get the ranking information of process memory usage\n    $data = LinuxDash::ramIntensiveProcesses();\n    var_dump($data);\n    //Get swap space information\n    $data = LinuxDash::swap();\n    var_dump($data);\n    //Get current user name information\n    $data = LinuxDash::userAccounts();\n    var_dump($data);\n\n});\n$run-&gt;start();\n\nNote that the MAC environment is not compatible. But you can use docker to test\n","link":"/Components/linuxDash.html"},{"id":205,"title":"what is microservice？","content":"Microservice\nThe meaning of microservices\nFor example, in a basic shopping mall system, we may be divided into user modules, commodity modules, order modules, activity modules, etc., in the initial stage of system construction,\nFor the sake of fast online and cost savings, we are a direct set of module code, all written in a project code.\nAfter the late traffic comes up, we will find that the entire service is often caused by the failure of the module of a certain module. For example, activity modules, and commodity modules are the easiest to smash under high traffic. For example, in the double eleventh event in 2018,\nA certain shopping mall system spent a lot of money to advertise, resulting in very high traffic directly into the mall system, and before this, there was no service split, then the high flow of the activity module caused the database and bandwidth to be completely unsupportable, the entire mall All of them enter the black hole state, and the user cannot enter the activity page, and even the normal shopping mall homepage cannot be opened.\nLater, under the suggestion of the Easyswoole project team, the mall system is split into modular services. For example, the active system is an independent service. When the user participates in the activity, the active service interface is called directly from the client, and the active service needs to be verified. When goods and user data are used, data interaction between services is performed through RPC calls. in order to fulfill\nThe pressure is no longer allowed to accumulate all service pressures on a single server or database, and in the worst case, even if the active module is paralyzed, it will not cause the entire mall system to be unavailable.\nTherefore, the main significance of microservices is that traffic is divided, the module is highly autonomous, and service isolation is protected.\nWhat is a microservices framework\nIn fact, the so-called microservices framework is a misnomer. Microservices are an architectural concept that has nothing to do with the framework. For example, in the above case, the mutual invocation of our services can be implemented using HTTP or the native TCP protocol, so in fact, there is no semi-finance relationship with the framework. And if it is really far-fetched to say that it is a micro-service framework, then it is nothing more than some frameworks that do some component packaging, making it easier for you to implement RPC calls. For example, Easyswoole provides RCP encapsulation and basic service discovery and registration centers. But in fact, this is just a tool, the real micro-service, the core is actually how to do the minimum granularity between services, which is actually the scope of architectural planning.\nService current limit\nLet's take another example of our lives: some popular tourist attractions often have strict restrictions on the number of daily visitors, such as Gulangyu in Xiamen and the Forbidden City in Beijing, which will only sell a fixed number of tickets per day. You are late, maybe the ticket for the day is already sold out, and you can't go in for the day.\nWhy do tourist attractions have to do this? Is it better to sell more tickets and earn more money?\nIn fact, for tourist attractions, they are also very helpless, because the service resources of the attractions are limited, the number of people who can serve every day is limited. Once the restrictions are released, the staff of the attractions will not be enough, and the health will not be enough. To the protection, there are hidden dangers to safety, and the ultra-intensive people will seriously affect the experience of tourists.\nHowever, due to the famous reputation of the scenic spot, the number of passengers who come to play is endless, far beyond the carrying capacity of the scenic spot. Therefore, the scenic spot has to make measures to limit the daily flow of personnel.\nIn the same way, in the IT software industry, system services are also like this. If your system theory is that you can serve 100W users in the time unit, but today you suddenly come to 300W users. Due to the randomness of user traffic, if you do not limit the flow, it is very likely that the 300W users will suddenly crush the system. Causes everyone to be out of service.\nTherefore, in order to ensure that the system can provide normal services for at least 100W users, we need to limit the flow design of the system.\nSome people may think that since there will be 300W users to visit, why is the system not designed to support such a large number of users?\nThis is a good question. If the system is accessed by a 300W user for a long time, it is definitely to be upgraded, but often the situation is that the daily traffic of the system is 100W, but there are occasional short-term traffic caused by unpredictable specific reasons. The surge, at this time, companies often do not expand our system to the largest size for an uncommon spike for cost-saving reasons.\nHow to limit current\nIn practical applications, the traffic entry should be:\nFirewall --&gt; Api Gateway -&gt; Service\nTherefore, in fact, we have three places to limit the flow. Then, the firewall, and the API gateway, we will not explain it, it is the operation and maintenance. What we are talking about is the self-protection of the API gateway. In Easyswoole, there is a basic AtomicLimit component, the principle is similar to the token bucket, and interested students can go and see. Of course, Easyswoole also supports other methods of current limiting, you can intercept in the onRequest method of the traffic entry.\nFuse protection\nThis mode requires the system to be taken into account at the beginning of the design. When there is a problem in the system, if it cannot be repaired in a short time, the system should automatically make a judgment, turn on the fuse switch, reject the traffic access, and avoid the overload request of the large traffic to the back end. The system should also be able to dynamically monitor the repair of the backend program. When the program has stabilized, the fuse switch can be turned off to resume normal service.\nService downgrade\nAll the functional services of the system are classified. When there is a problem in the system and emergency current limiting is required, the less important functions can be downgraded and the service can be stopped, which can release more resources for the core functions.\nFor example, in the e-commerce platform, if the burst traffic surges, the non-core functions such as commodity reviews and points can be temporarily downgraded, the services are stopped, and resources such as machines and CPUs are released to ensure normal order placement, and these degraded functions are provided. The service can wait for the entire system to return to normal, and then start to perform the replenishment/compensation process.\nIn addition to functional degradation, you can also use the method of not directly operating the database, but all read cache and write cache as a temporary downgrade scheme.\nDelayed processing\nThis mode requires a traffic buffer pool at the front end of the system to buffer all requests into this pool and not process them immediately. Then the backend real business handlers take the requests from this pool in turn, and the common ones can be implemented in queue mode. This is equivalent to reducing the processing pressure of the backend in an asynchronous manner, but when the traffic is large, the processing capacity of the backend is limited, and the request in the buffer pool may not be processed in time, and there is a certain degree of delay.\nPrivilege processing\nThis mode needs to classify users, and through the preset classification, the system prioritizes the user groups that need high security. The requests of other user groups are delayed or not processed directly.\nOf course, there are still many things in microservices. This article is just a basic concept of science. You can ask the architect.","link":"/Distribute/microService.html"},{"id":206,"title":"how to realize distributed？","content":"How to achieve distributed\nRecently, many people are asking how to use EasySwoole for distributed load balancing. If the complexity is not explained, explain how to achieve the simplest load balancing.\nrelated information\nDNS rotation\nA domain name resolves multiple ip A records. The DNS server allocates the resolution requests to different IPs in the order of A records, thus completing simple load balancing.\nAdvantages of DNS polling:\n\nLow cost: Just bind several A records on the DNS server, and domain registrars generally provide resolution services for free.\nSimple deployment: device amplification in the network topology, and then add records on the DNS server.\n\nDisadvantages of DNS polling:\n\n\nLow reliability\nSuppose a domain name DNS polls multiple servers. If one of the servers fails, all requests to access the server will not respond, which is unwilling to be seen by anyone. Even if the IP of the server is removed from the DNS, on the Internet, broadband access providers such as telecommunications and Netcom in various regions store a large number of DNS in the cache to save access time. It takes several hours or more for the DNS records to take effect. Long. Therefore, although DNS polling solves the load balancing problem to a certain extent, it has the disadvantage of low reliability.\n\n\nUneven load distribution (with, but not so much impact)\nDNS load balancing uses a simple polling algorithm. It does not distinguish between server differences. It does not reflect the current running state of the server. It cannot allocate more requests for servers with better performance. It may even result in client requests being concentrated on one server. On the situation. The DNS server is organized according to a certain hierarchical structure. The local DNS server caches the mapping of the resolved domain name to the IP address. This causes the user who uses the DNS server to access the same Web server for a period of time, resulting in the Web server. The load between the two is uneven. In addition, the user's local computer also caches the mapping of resolved domain names to IP addresses. When multiple user computers cache the mapping of a domain name to an IP address, and these users continue to access the web pages under the domain name, the load distribution between different web servers may also be uneven. The consequences of uneven load may be: some servers have low load, while others have high load and slow processing; high-configuration servers allocate fewer requests, while low-configuration servers allocate more requests.\n\n\nUnified gateway design\nAssume that in a system, it can be split into three services: A, B, and C. In order to be uniformly exposed from the architecture layer, a gateway server is generally set up, and all application requests are all from the gateway server as a traffic portal, and the gateway The server distributes the request to the three servers A, B, and C according to the set rules, and returns the result to the client. For the outside world, the gateway is a complete application service.\n\nShield internal implementation\nDo physical work, forward various packages\nLoad balancing and load balancing of broadcast messages (also manual)\nReduce bandwidth requirements. For example, set up multiple gateways to one server. Because the platform of a certain communication is the bandwidth fee for each machine, instead of collecting bandwidth traffic fees together.\nRouting. You can control the direction of client messages to the intranet and distribute them to different servers.\n\nData center\nIn a typical scenario, as a service grows with the number of visits, there is always a high CPU in the stand-alone scenario, and even the risk of crashing. For this reason, the simplest and most rude solution (the database is not a system bottleneck) is Deploy the same code to N machines and use the gateway to evenly distribute requests to each machine.\nAfter doing this, there is another problem: how the user state is shared among multiple machines (random forwarding or a scene where a machine suddenly goes offline). For example, in a classic HTTP application, a user logs in to the A machine. If the token assigned to the A user exists only in the local machine A, then the next time the user request is assigned to the B machine, the token is It will be invalid and requires the user to log in again. Obviously, this is very unreasonable.\nAnd if we let ourselves achieve things like zookeeper, to achieve automatic data scheduling migration, it is obviously unrealistic. Therefore, we introduce the data center model, which is actually the idea of a typical distributed master-slave. Taking php Session as an example, we can design a Session driver for N machines as a redis driver and connect to a redis cluster. In this way, the user's token registered in the A or B machine is stored in the redis data center.\nTherefore, regardless of whether the user request is assigned to the A or B machine, the user's token can be read as it is.\nPractical operation\nHTTP application\nIn fact, I think that most people's HTTP applications basically use the gateway distribution + data center design, basically can be solved, and most of the online also have corresponding tutorials, so I will not elaborate here.\nSOCKET application\nWe take WEB SOCKET as an example. Let's assume that in a large application of a game, in order to achieve a balanced load, we use a gateway, such as Nginx, to randomly distribute user connections to different machines.\nAt the moment, one problem is that in swoole, each link is marked with a self-incrementing fd identifier. In multiple swoole services, fd is repeated. Therefore, in the case of multiple machines, we can store the following data structures in redis or other storage:\n{\n    \"userId\":\"xxxxxx\",\n    \"seerver\":\n    {\n        \"nodeId\":\"nodeId\",\n        \"ip\":\"xxx.xxx.xxx.xxx\",\n        \"rcpPort\":9600\n    },\n    \"fd\":\"fd\"\n}\nAnd our Server, you can open an Http service, receive fd, parameters in the action, and then execute the send (fd, data) operation. Assume that the A and B users are connected to the two machines A1 and B1 respectively, and at this time, the fd assigned by the two people A and B may be the same, for example, all are 1.\nIf you want to send a message to any user at this time, then go to the data center to get the information about the machine where the user is located. So, you can use the Http call or other RPC methods to achieve cross-machine push.","link":"/Distribute/loadbalance.html"},{"id":207,"title":"service restriction","content":"AtomicLimit\nEasyswoole provides a current limiter based on Atomic counters.\nPrinciple\nThe basic current limit is achieved by limiting the total number of requests in a certain time period. For example, if the maximum number of requests allowed is 200 in 5 seconds, then the theoretical average is 40 and the peak is 200.\nInstallation\ncomposer require easyswoole/atomic-limit\nSample code\n/*\n * egUrl http://127.0.0.1:9501/index.html?api=1\n */\n\nuse EasySwoole\\AtomicLimit\\AtomicLimit;\nAtomicLimit::getInstance()-&gt;addItem('default')-&gt;setMax(200);\nAtomicLimit::getInstance()-&gt;addItem('api')-&gt;setMax(2);\n\n$http = new swoole_http_server(\"127.0.0.1\", 9501);\n\nAtomicLimit::getInstance()-&gt;enableProcessAutoRestore($http,10*1000);\n\n$http-&gt;on(\"request\", function ($request, $response) {\n    if(isset($request-&gt;get['api'])){\n        if(AtomicLimit::isAllow('api')){\n            $response-&gt;write('api success');\n        }else{\n            $response-&gt;write('api refuse');\n        }\n    }else{\n        if(AtomicLimit::isAllow('default')){\n            $response-&gt;write('default success');\n        }else{\n            $response-&gt;write('default refuse');\n        }\n    }\n    $response-&gt;end();\n});\n\n$http-&gt;start();\n\nNote that this example uses a custom process plus timer to implement the count timing reset. In fact, it is not worthwhile to use a process to do this. Therefore, the actual production can specify a worker and set a timer to implement.\n","link":"/Distribute/atomicLimit.html"},{"id":208,"title":"ip current limiting","content":"How does swoole restrict access frequency to IP\nIn the process of API development, sometimes we need to consider single user (IP) access frequency control to avoid malicious calls.\nAfter all, there are only two steps：\n\nNumber of user visits to be counted\nBefore executing the operation logic, judge whether the frequency is too high. If it is too high, do not execute it\n\nIP access frequency limitation in easyswoole\nThis article gives an example of the code implemented in the easyswoole framework, which is implemented in the same way in the native swoole.\nJust judge and intercept the corresponding callback event\n\nUse swoole\\table to save user access (or other components and methods can be used)\nUse timer to clear the access of the previous cycle and count the next cycle\n\nFor example, the following iplist class implements initialization of table, statistics of IP access times, and acquisition of records with more than a certain number of times in a cycle\n&lt;?php\n/**\n * IP visit statistics\n * User: Siam\n * Date: 2019/7/8 0008\n * Time: 下午 9:53\n */\n\nnamespace App;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\Component\\TableManager;\nuse Swoole\\Table;\n\nclass IpList\n{\n    use Singleton;\n\n    /** @var Table */\n    protected $table;\n\n    public  function __construct()\n    {\n        TableManager::getInstance()-&gt;add('ipList', [\n            'ip' =&gt; [\n                'type' =&gt; Table::TYPE_STRING,\n                'size' =&gt; 16\n            ],\n            'count' =&gt; [\n                'type' =&gt; Table::TYPE_INT,\n                'size' =&gt; 8\n            ],\n            'lastAccessTime' =&gt; [\n                'type' =&gt; Table::TYPE_INT,\n                'size' =&gt; 8\n            ]\n        ], 1024*128);\n        $this-&gt;table = TableManager::getInstance()-&gt;get('ipList');\n    }\n\n    function access(string $ip):int\n    {\n        $key  = substr(md5($ip), 8,16);\n        $info = $this-&gt;table-&gt;get($key);\n\n        if ($info) {\n            $this-&gt;table-&gt;set($key, [\n                'lastAccessTime' =&gt; time(),\n                'count'          =&gt; $info['count'] + 1,\n            ]);\n            return $info['count'] + 1;\n        }else{\n            $this-&gt;table-&gt;set($key, [\n                'ip'             =&gt; $ip,\n                'lastAccessTime' =&gt; time(),\n                'count'          =&gt; $info['count'] + 1,\n            ]);\n            return 1;\n        }\n    }\n\n    function clear()\n    {\n        foreach ($this-&gt;table as $key =&gt; $item){\n            $this-&gt;table-&gt;del($key);\n        }\n    }\n\n    function accessList($count = 10):array\n    {\n        $ret = [];\n        foreach ($this-&gt;table as $key =&gt; $item){\n            if ($item['count'] &gt;= $count){\n                $ret[] = $item;\n            }\n        }\n        return $ret;\n    }\n\n}\nAfter encapsulating the operation of IP statistics\nWe can initialize the iplist and timer in the mainservercreate callback event of EasySooleEvent.php\n&lt;?php\n\npublic static function mainServerCreate(EventRegister $register)\n{\n    // Turn on IP current limiting\n    IpList::getInstance();\n    $class = new class('IpAccessCount') extends AbstractProcess{\n        protected function run($arg)\n        {\n            $this-&gt;addTick(5*1000, function (){\n                /**\n                 * Normal users will not have more than six API requests in a second\n                 * Make list record and clear\n                 */\n                $list = IpList::getInstance()-&gt;accessList(30);\n                // var_dump($list);\n                IpList::getInstance()-&gt;clear();\n            });\n        }\n    };\n}\nThen we judge and count IP access in onRequest callback\n&lt;?php\n\npublic static function onRequest(Request $request, Response $response): bool\n{\n    $fd = $request-&gt;getSwooleRequest()-&gt;fd;\n    $ip = ServerManager::getInstance()-&gt;getSwooleServer()-&gt;getClientInfo($fd)['remote_ip'];\n\n    // If the access frequency of the current cycle has exceeded the set value, block\n    // When testing, you can change 30 to smaller, such as 3\n    if (IpList::getInstance()-&gt;access($ip) &gt; 30) {\n        /**\n         * Force connection to close directly\n         */\n        ServerManager::getInstance()-&gt;getSwooleServer()-&gt;close($fd);\n        // Debug output can be processed logically\n        echo 'Being intercepted'.PHP_EOL;\n        return false;\n    }\n    // Debug output can be processed logically\n    echo '正常访问'.PHP_EOL;\n}\nThe above implements the operation of limiting the same IP access frequency。\nIt can also be expanded according to its own needs, such as restricting a specific interface.\nEasyswoole provides a current limiter component based on atomic counters. It can be used directly. For the tutorial, please check the document of current limiter step by step.","link":"/Distribute/ipLimit.html"},{"id":209,"title":"service","content":"Server\nIndependent code\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: xcg\n * Date: 2019/5/30\n * Time: 9:17\n */\nrequire_once 'vendor/autoload.php';\n\nuse EasySwoole\\Rpc\\Config;\nuse EasySwoole\\Rpc\\Rpc;\nuse EasySwoole\\Rpc\\NodeManager\\RedisManager;\nuse EasySwoole\\Rpc\\Test\\UserService;\nuse EasySwoole\\Rpc\\Test\\OrderService;\nuse EasySwoole\\Rpc\\Test\\NodeService;\n\n$config = new Config();\n$config-&gt;setServerIp('127.0.0.1');//Register to provide ip service ip\n\n$config-&gt;setNodeManager(new RedisManager('127.0.0.1'));//Register Node Manager\n$config-&gt;getBroadcastConfig()-&gt;setSecretKey('lucky');    //Set key\n\n$config-&gt;getBroadcastConfig()-&gt;setEnableBroadcast(false);     //Whether to enable broadcast (ps: use redis node to close)\n$config-&gt;getBroadcastConfig()-&gt;setEnableListen(false);        //Whether to enable listening broadcast (ps: use redis node to close)\n\n$rpc = new Rpc($config);\n$rpc-&gt;add(new UserService());  //Registration service\n$rpc-&gt;add(new OrderService());\n$rpc-&gt;add(new NodeService());\n\n$list = $rpc-&gt;generateProcess();   \nforeach ($list['worker'] as $p) {//Start the rpc process\n    $p-&gt;getProcess()-&gt;start();\n}\n\nforeach ($list['tickWorker'] as $p) { //Start the timing process (ps: timed broadcast, monitor broadcast)\n    $p-&gt;getProcess()-&gt;start();\n}\n\nwhile ($ret = \\Swoole\\Process::wait()) {//Recycling child process\n    echo \"PID={$ret['pid']}\\n\";\n}\nUsed under the easyswoole framework\n&lt;?php\nuse EasySwoole\\Rpc\\Config;\nuse EasySwoole\\Rpc\\Rpc;\nuse EasySwoole\\Rpc\\NodeManager\\RedisManager;\nuse EasySwoole\\Rpc\\Test\\UserService;\nuse EasySwoole\\Rpc\\Test\\OrderService;\nuse EasySwoole\\Rpc\\Test\\NodeService;\nuse EasySwoole\\EasySwoole\\ServerManager;\n\n#Register in the global mainServerCreate event of EasySwooleEvent.php\n\n$config = new Config();\n$config-&gt;setServerIp('127.0.0.1');//Register to provide ip service ip\n$config-&gt;setNodeManager(new RedisManager('127.0.0.1'));//Register Node Manager\n$config-&gt;getBroadcastConfig()-&gt;setSecretKey('lucky');        //Set key        \n\n$rpc = Rpc::getInstance($config);;\n$rpc-&gt;add(new UserService());  //Registration service\n$rpc-&gt;add(new OrderService());\n$rpc-&gt;add(new NodeService());\n\n$rpc-&gt;attachToServer(ServerManager::getInstance()-&gt;getSwooleServer());\n","link":"/Components/Rpc/server.html"},{"id":210,"title":"client","content":"Client\nCLI independent testing (note the introduction of namespaces and autoloading)\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: xcg\n * Date: 2019/5/30\n * Time: 9:19\n */\nrequire_once 'vendor/autoload.php';\n\nuse EasySwoole\\Rpc\\Config;\nuse EasySwoole\\Rpc\\Rpc;\nuse EasySwoole\\Rpc\\NodeManager\\RedisManager;\nuse EasySwoole\\Rpc\\Response;\n\n//Cli simulation, cross process, renew new rpc object\n$config = new Config();\n$nodeManager = new RedisManager('127.0.0.1');\n$config-&gt;setNodeManager($nodeManager);\n$rpc = new Rpc($config);\n\ngo(function () use ($rpc) {\n    $client = $rpc-&gt;client();\n    $client-&gt;addCall('UserService', 'register', ['arg1', 'arg2'])\n        -&gt;setOnFail(function (Response $response) {\n            print_r($response-&gt;toArray());\n        })\n        -&gt;setOnSuccess(function (Response $response) {\n            print_r($response-&gt;toArray());\n        });\n\n    $client-&gt;exec();\n});\n\nUnder the easyswoole framework\n&lt;?php\n$client=Rpc::getInstance()-&gt;client();\ngo(function () use ($client) {\n    $client-&gt;addCall('UserService', 'register', ['arg1', 'arg2'])\n        -&gt;setOnFail(function (Response $response) {\n            print_r($response-&gt;toArray());\n        })\n        -&gt;setOnSuccess(function (Response $response) {\n            print_r($response-&gt;toArray());\n        });\n    $client-&gt;exec();\n});","link":"/Components/Rpc/client.html"},{"id":211,"title":"cross language","content":"Cross-platform\nRpc's request response is through the tcp protocol, and the service broadcast uses the udp protocol. We only need to implement the network protocol.\nPHP sample code\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: xcg\n * Date: 2019/6/17\n * Time: 14:30\n */\n$data = [\n    'command' =&gt; 1,//1:Request, 2: status rpc status of each service\n    'request' =&gt; [\n        'serviceName' =&gt; 'UserService',\n        'action' =&gt; 'register',//Behavior name\n        'arg' =&gt; [\n            'args1' =&gt; 'args1',\n            'args2' =&gt; 'args2'\n        ]\n    ]\n];\n\n//$raw = serialize($data);//Note the serialization type, you need to agree with the RPC server agreement $serializeType\n\n$raw = json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);\n\n$fp = stream_socket_client('tcp://127.0.0.1:9600');\nfwrite($fp, pack('N', strlen($raw)) . $raw);//Pack data check\n\n$data = fread($fp, 65533);\n//Length check\n$len = unpack('N', $data);\n$data = substr($data, '4');\nif (strlen($data) != $len[1]) {\n    echo 'data error';\n} else {\n    $data = json_decode($data, true);\n    // This is the result returned by the server.，\n    var_dump($data); // By default, a response object will be returned. Modify by $serializeType\n}\nfclose($fp);\nGo sample code\npackage main\n\nimport (\n    \"encoding/binary\"\n    \"net\"\n)\n\nfunc main() {\n    var tcpAddr *net.TCPAddr\n    tcpAddr,_ = net.ResolveTCPAddr(\"tcp\",\"127.0.0.1:9600\")\n    conn,_ := net.DialTCP(\"tcp\",nil,tcpAddr)\n    defer conn.Close()\n    sendEasyswooleMsg(conn)\n}\n\nfunc sendEasyswooleMsg(conn *net.TCPConn) {\n    var sendData []byte\n    data := `{\"command\":1,\"request\":{\"serviceName\":\"UserService\",\"action\":\"register\",\"arg\":{\"args1\":\"args1\",\"args2\":\"args2\"}}}`\n    b := []byte(data)\n    // The big endian (network byte order) big end is to put the high byte to the low address end of the memory, and the low byte to the high address end.\n    // In the network transmission (such as TCP/IP), the low address end (high byte) is placed at the beginning of the stream. For the 2-byte string (AB), the transmission order is:A(0-7bit)、B(8-15bit)。\n    sendData = int32ToBytes8(int32(len(data)))\n    // Assemble the data byte to the back of sendData\n    for _, value := range b {\n        sendData = append(sendData, value)\n    }\n    conn.Write(sendData)\n}\n\nfunc int32ToBytes8(n int32) []byte {\n    var buf = make([]byte, 4)\n    binary.BigEndian.PutUint32(buf, uint32(n))\n    return buf\n}\nJava\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        byte[] msg = \"{\\\"command\\\":1,\\\"request\\\":{\\\"serviceName\\\":\\\"UserService\\\",\\\"action\\\":\\\"register\\\",\\\"arg\\\":{\\\"args1\\\":\\\"args1\\\",\\\"args2\\\":\\\"args2\\\"}}}\".getBytes();\n        byte[] head = Main.toLH(msg.length);\n        byte[] data = Main.mergeByteArr(head, msg);\n\n        //Create a Socket object and connect to the server\n        Socket socket=new Socket(\"127.0.0.1\",9600);\n        //Get the byte output stream and write the data to the server through the socket object Socket method of the client.\n        OutputStream out=socket.getOutputStream();\n        out.write(data);\n\n        //Read the data sent back by the server, using the byte input stream in the socket socket object\n        InputStream in=socket.getInputStream();\n        byte[] response=new byte[1024];\n        int len=in.read(response);\n        System.out.println(new String(response,4, len-4));\n        socket.close();\n    }\n\n    static byte[] toLH(int n) {\n        byte[] b = new byte[4];\n        b[3] = (byte) (n &amp; 0xff);\n        b[2] = (byte) (n &gt;&gt; 8 &amp; 0xff);\n        b[1] = (byte) (n &gt;&gt; 16 &amp; 0xff);\n        b[0] = (byte) (n &gt;&gt; 24 &amp; 0xff);\n        return b;\n    }\n\n    static byte[] mergeByteArr(byte[] a, byte[] b) {\n        byte[] c= new byte[a.length + b.length];\n        System.arraycopy(a, 0, c, 0, a.length);\n        System.arraycopy(b, 0, c, a.length, b.length);\n        return c;\n    }\n}\nOther languages only need to implement the tcp protocol.","link":"/Components/Rpc/otherPlatform.html"},{"id":212,"title":"service registry","content":"EasySwoole RPC Custom Registration Center\nEasySwoole defaults to unaware service discovery through UDP broadcast. However, in some cases, it is not convenient to use UDP broadcast, then EasySwoole supports you to customize a node manager to change the service discovery mode.\nFor example, using Redis to achieve\n&lt;?php\n\nnamespace EasySwoole\\Rpc\\NodeManager;\n\nuse EasySwoole\\Component\\Pool\\PoolConf;\nuse EasySwoole\\Component\\Pool\\PoolManager;\nuse EasySwoole\\Rpc\\ServiceNode;\nuse EasySwoole\\Utility\\Random;\nuse Swoole\\Coroutine\\Channel;\nuse Swoole\\Coroutine\\Redis;\n\nclass RedisManager implements NodeManagerInterface\n{\n    protected $redisKey;\n    /** @var Channel */\n    protected $channel;\n\n    function __construct(string $host, $port = 6379, $auth = null, string $hashKey = '__rpcNodes', int $maxRedisNum = 10)\n    {\n        $this-&gt;redisKey = $hashKey;\n        //Register anonymous connection pool\n        PoolManager::getInstance()-&gt;registerAnonymous('__rpcRedis', function (PoolConf $conf) use ($host, $port, $auth, $maxRedisNum) {\n            $conf-&gt;setMaxObjectNum($maxRedisNum);\n            $redis = new Redis();\n            $redis-&gt;connect($host, $port);\n            if ($auth) {\n                $redis-&gt;auth($auth);\n            }\n            $redis-&gt;setOptions(['serialize' =&gt; true, 'compatibility_mode' =&gt; true]);\n            return $redis;\n        });\n    }\n\n    /**\n    *  Get all available nodes of a service \n    */\n    function getServiceNodes(string $serviceName, ?string $version = null): array\n    {\n        /** @var \\Redis $redis */\n        $redis = PoolManager::getInstance()-&gt;getPool('__rpcRedis')-&gt;getObj(15);//Connection pool to take redis object\n        try {\n            $nodes = $redis-&gt;hGetAll($this-&gt;redisKey . md5($serviceName));\n            $nodes = $nodes ?: [];\n            $ret = [];\n            foreach ($nodes as $nodeId =&gt; $node) {\n                /**\n                 * @var  $nodeId\n                 * @var  ServiceNode $node\n                 */\n                if (time() - $node-&gt;getLastHeartBeat() &gt; 30) {//Check the node's last heartbeat time\n                    $this-&gt;deleteServiceNode($node);\n                }\n                if ($version &amp;&amp; $version != $node-&gt;getServiceVersion()) {\n                    continue;\n                }\n                $ret[$nodeId] = $node;\n            }\n            return $ret;\n        } catch (\\Throwable $throwable) {\n            //If the redis is disconnected, it is destroyed.\n            PoolManager::getInstance()-&gt;getPool('__rpcRedis')-&gt;unsetObj($redis);\n        } finally {\n            //Here you need to test whether an object can be recycled after it is unset.\n            PoolManager::getInstance()-&gt;getPool('__rpcRedis')-&gt;recycleObj($redis);\n        }\n        return [];\n    }\n\n    /**\n    *  Get a random node available for a service \n    */\n    function getServiceNode(string $serviceName, ?string $version = null): ?ServiceNode\n    {\n        $list = $this-&gt;getServiceNodes($serviceName, $version);\n        if (empty($list)) {\n            return null;\n        }\n        return Random::arrayRandOne($list);\n    }\n\n    /**\n    *  Delete node \n    */\n    function deleteServiceNode(ServiceNode $serviceNode): bool\n    {\n        /** @var \\Redis $redis */\n        $redis = PoolManager::getInstance()-&gt;getPool('__rpcRedis')-&gt;getObj(15);\n        try {\n            $redis-&gt;hDel($this-&gt;redisKey . md5($serviceNode-&gt;getServiceName()), $serviceNode-&gt;getNodeId());\n            return true;\n        } catch (\\Throwable $throwable) {\n            PoolManager::getInstance()-&gt;getPool('__rpcRedis')-&gt;unsetObj($redis);\n        } finally {\n            PoolManager::getInstance()-&gt;getPool('__rpcRedis')-&gt;recycleObj($redis);\n        }\n        return false;\n    }\n\n    /**\n    *  Refresh node(\n    *  Ps: refreshed by the tick process process timer (this node) | listen for broadcast messages (other nodes) to refresh node information, redis node manager can)\n    */\n    function serviceNodeHeartBeat(ServiceNode $serviceNode): bool\n    {\n        if (empty($serviceNode-&gt;getLastHeartBeat())) {\n            $serviceNode-&gt;setLastHeartBeat(time());\n        }\n        /** @var \\Redis $redis */\n        $redis = PoolManager::getInstance()-&gt;getPool('__rpcRedis')-&gt;getObj(15);\n        try {\n            $redis-&gt;hSet($this-&gt;redisKey . md5($serviceNode-&gt;getServiceName()), $serviceNode-&gt;getNodeId(), $serviceNode);\n            return true;\n        } catch (\\Throwable $throwable) {\n            //If the redis is disconnected, it is destroyed.\n            PoolManager::getInstance()-&gt;getPool('__rpcRedis')-&gt;unsetObj($redis);\n        } finally {\n            //Here you need to test whether an object can be recycled after it is unset.\n            PoolManager::getInstance()-&gt;getPool('__rpcRedis')-&gt;recycleObj($redis);\n        }\n        return false;\n    }\n}\n\nNote that once the custom node manager is set, it is no longer necessary to enable the UDP scheduled broadcast process. After creating an RPC instance, create a ServiceNode object and refresh it to the registry. The same is true for the node offline. When your service is closed, the node manager is taken offline.","link":"/Components/Rpc/registerCenter.html"},{"id":213,"title":"consul client","content":"Consul\nEasyswoole provides a coroutine secure console version client that facilitates distributed microservice development.\nInstallation\ncomposer require easyswoole/consul\nWay of use\n\nUse the following interface methods, you need to first inject Config configuration into Consul.\nInterfaces only show usage, specific namespaces need to be introduced by developers themselves\n\nuse EasySwoole\\Consul\\Config;\nuse EasySwoole\\Consul\\Consul;\n\n\n// Config default  127.0.0.1:8500/v1\n$config = new Config([\n'IP'       =&gt; '127.0.0.1',\n'port'     =&gt; '8500',\n'version'  =&gt; 'v1',\n]);\n$consul = new Consul($config);\n// Two ways to write the same result\n$config = new Config();\n$config-&gt;setIP('127.0.0.1');\n$config-&gt;setPort('8500');\n$config-&gt;setVersion('v1');    \n$consul = new Consul($config);\n\n## ACLs\n```php\n// Bootstrap ACLs\n$bootstrap = new Bootstrap();\n$this-&gt;consul-&gt;acl()-&gt;bootstrap($bootstrap);\n\n// Check ACL Replication\n$replication = new Replication();\n$this-&gt;consul-&gt;acl()-&gt;replication($replication);\n\n// Translate Rules\n// Translate a Legacy Token's Rules\n$translate = new Translate([\n    'accessor_id' =&gt; $accessor_id\n]);\n$this-&gt;consul-&gt;acl()-&gt;translate($translate);\n\n// Login to Auth Method\n$login = new Login([\n    \"authMethod\" =&gt; $authMethod,\n    \"bearerToken\" =&gt; $bearerToken\n]);\n$this-&gt;consul-&gt;acl()-&gt;login($login);\n\n// Logout from Auth Method\n$logout = new Logout([\n    'token' =&gt; $header['token']\n]);\n$this-&gt;consul-&gt;acl()-&gt;logout($logout);\nTokens\n// Create a Token\n$token = new Token([\n    \"description\" =&gt; \"Agent token for 'node1'\",\n    \"Policies\" =&gt; [\n        [\"ID\" =&gt; \"165d4317-e379-f732-ce70-86278c4558f7\"],\n        [\"Name\" =&gt; \"node-read\"],\n    ],\n    \"Local\" =&gt; false,\n]);\n$this-&gt;consul-&gt;acl()-&gt;token($token);\n\n// Read a Token\n$token = new Token([\n    \"AccessorID\" =&gt; \"6a1253d2-1785-24fd-91c2-f8e78c745511\"\n]);\n$this-&gt;consul-&gt;acl()-&gt;readToken($token);\n\n// Read Self Token\n$self = new Token\\GetSelf([\n    'token' =&gt; \"6a1253d2-1785-24fd-91c2-f8e78c745511\"\n]);\n$this-&gt;consul-&gt;acl()-&gt;self($self);\n\n// Update a Token\n$update = new Token([\n    'accessorID' =&gt; '6a1253d2-1785-24fd-91c2-f8e78c745511',\n    \"Description\" =&gt; \"Agent token for 'node1'\",\n    \"Policies\" =&gt; [],\n    \"local\" =&gt; false\n]);\n$this-&gt;consul-&gt;acl()-&gt;updateToken($update);\n\n// Clone a Token\n$clone = new Token\\CloneToken([\n    'accessorID' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05',\n    \"description\" =&gt; \"Clone of Agent token for 'node1'\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;cloneToken($clone);\n\n// Delete a Token\n$delete = new Token([\n    'AccessorID' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05'\n]);\n$this-&gt;consul-&gt;acl()-&gt;delete($delete);\n\n// List Tokens\n$token = new Tokens();\n$this-&gt;consul-&gt;acl()-&gt;tokens($token);\nLegacy Tokens\n// Create ACL Token\n$create = new Create([\n    \"Name\" =&gt; \"my-app-token\",\n    \"Type\" =&gt; \"client\",\n    \"rules\" =&gt; \"a\"\n]);\n$this-&gt;consul-&gt;acl()-&gt;create($create);\n\n// Update ACL Token\n$update = new Update([\n    \"id\" =&gt; \"adf4238a-882b-9ddc-4a9d-5b6758e4159e\",\n    \"Name\" =&gt; \"my-app-token-updated\",\n    \"Type\" =&gt; \"client\",\n    \"Rules\" =&gt; \"# New Rules\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;update($update);\n\n// Delete ACL Token\n$delete = new Destroy([\n    'uuid' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05'\n]);\n$this-&gt;consul-&gt;acl()-&gt;destroy($delete);\n\n// Read ACL Token\n$info = new Info([\n    'uuid' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05'\n]);\n$this-&gt;consul-&gt;acl()-&gt;info($info);\n\n// Clone ACL Token\n$cloneAclToken = new CloneACLToken([\n    'uuid' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05'\n]);\n$this-&gt;consul-&gt;acl()-&gt;cloneAclToken($cloneAclToken);\n\n// List ACLs\n$getList = new Lists();\n$this-&gt;consul-&gt;acl()-&gt;getList($getList);\n$this-&gt;assertEquals('x','x');\nPolicies\n// Create a Policy\n$policy = new Policy([\n    \"Name\" =&gt; \"node-read\",\n    \"Description\" =&gt; \"Grants read access to all node information\",\n    \"Rules\" =&gt; \"node_prefix \\\"\\\" { policy = \\\"read\\\"}\",\n    \"datacenters\" =&gt; [\"dc1\"]\n]);\n$this-&gt;consul-&gt;acl()-&gt;policy($policy);\n\n// Read a Policy\n$policy = new Policy([\n    'id' =&gt; 'c01a1f82-44be-41b0-a686-685fb6e0f485',\n]);\n$this-&gt;consul-&gt;acl()-&gt;readPolicy($policy);\n\n// Update a Policy\n$policy = new Policy([\n    \"ID\" =&gt; \"c01a1f82-44be-41b0-a686-685fb6e0f485\",\n    \"Name\" =&gt; \"register-app-service\",\n    \"Description\" =&gt; \"Grants write permissions necessary to register the 'app' service\",\n    \"Rules\" =&gt; \"service \\\"app\\\" { policy = \\\"write\\\"}\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;updatePolicy($policy);\n\n// Delete a Policy\n$policy = new Policy([\n    'id' =&gt; 'c01a1f82-44be-41b0-a686-685fb6e0f485'\n]);\n$this-&gt;consul-&gt;acl()-&gt;deletePolicy($policy);\n\n// List Policies\n$policies = new Policies();\n$this-&gt;consul-&gt;acl()-&gt;policies($policies);\nRoles\n// Create a Role\n$role = new Role([\n    \"name\" =&gt; \"example-role\",\n    \"description\" =&gt; \"Showcases all input parameters\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;role($role);\n\n// Read a Role\n$role = new Role([\n    'id' =&gt; 'aa770e5b-8b0b-7fcf-e5a1-8535fcc388b4'\n]);\n$this-&gt;consul-&gt;acl()-&gt;readRole($role);\n\n// Read a Role by Name\n$name = new Role([\n    'name' =&gt; 'example-role'\n]);\n$this-&gt;consul-&gt;acl()-&gt;readRoleByName($name);\n\n// Update a Role\n$role = new Role([\n    'id' =&gt; 'aa770e5b-8b0b-7fcf-e5a1-8535fcc388b4',\n    \"name\" =&gt; \"example-two\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;updateRole($role);\n\n// Delete a Role\n$role = new Role([\n    'id' =&gt; 'aa770e5b-8b0b-7fcf-e5a1-8535fcc388b4'\n]);\n$this-&gt;consul-&gt;acl()-&gt;deleteRole($role);\n\n// List Roles\n$roles = new Roles();\n$this-&gt;consul-&gt;acl()-&gt;roles($roles);\nAuth Method\n// Create an Auth Method\n$method = new AuthMethod([\n    \"Name\" =&gt; \"minikube\",\n    \"Type\" =&gt; \"kubernetes\",\n    \"Description\" =&gt; \"dev minikube cluster\",\n    \"Config\" =&gt; [\n        \"Host\" =&gt; \"https://192.0.2.42:8443\",\n        \"CACert\" =&gt; \"-----BEGIN CERTIFICATE-----\\n...-----END CERTIFICATE-----\\n\",\n        \"ServiceAccountJWT\" =&gt; \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\"\n    ]\n]);\n$this-&gt;consul-&gt;acl()-&gt;authMethod($method);\n\n// Read an Auth Method\n$method = new AuthMethod([\n    'name' =&gt; 'minikube',\n]);\n$this-&gt;consul-&gt;acl()-&gt;readAuthMethod($method);\n\n// Update an Auth Method\n$method = new AuthMethod([\n    \"Name\" =&gt; \"minikube\",\n    \"Type\" =&gt; \"kubernetes\",\n    \"Description\" =&gt; \"dev minikube cluster\",\n    \"Config\" =&gt; [\n        \"Host\" =&gt; \"https://192.0.2.42:8443\",\n        \"CACert\" =&gt; \"-----BEGIN CERTIFICATE-----\\n...-----END CERTIFICATE-----\\n\",\n        \"ServiceAccountJWT\" =&gt; \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\"\n    ]\n]);\n$this-&gt;consul-&gt;acl()-&gt;updateAuthMethod($method);\n\n// Delete an Auth Method\n$method = new AuthMethod([\n    \"Name\" =&gt; \"minikube\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;deleteAuthMethod($method);\n\n// List Auth Methods\n$method = new AuthMethods();\n$this-&gt;consul-&gt;acl()-&gt;authMethods($method);\nBinding Rules\n// Create a Binding Rule\n$bindingRule = new BindingRule([\n    \"description\" =&gt; \"example rule\",\n    \"authMethod\" =&gt; \"minikube\",\n    \"Selector\" =&gt; \"serviceaccount.namespace==default\",\n    \"BindType\" =&gt; \"service\",\n    \"BindName\" =&gt; \"{{ serviceaccount.name }}\"\n]);\n$this-&gt;consul-&gt;acl()-&gt;bindingRule($bindingRule);\n\n// Read a Binding Rule\n$bindingRule = new BindingRule([\n    'id' =&gt; '000ed53c-e2d3-e7e6-31a5-c19bc3518a3d',\n]);\n$this-&gt;consul-&gt;acl()-&gt;readBindingRule($bindingRule);\n\n// Update a Binding Rule\n$bindingRule = new BindingRule([\n    'id' =&gt; '000ed53c-e2d3-e7e6-31a5-c19bc3518a3d',\n    \"Description\" =&gt; \"updated rule\",\n    \"authMethod\" =&gt; \"minikube\",\n    \"Selector\" =&gt; \"serviceaccount.namespace=dev\",\n    \"BindType\" =&gt; \"role\",\n    \"BindName\" =&gt; \"{{ serviceaccount.name }}\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;updateBindingRule($bindingRule);\n\n// Delete a Binding Rule\n$bindingRule = new BindingRule([\n    'id' =&gt; '000ed53c-e2d3-e7e6-31a5-c19bc3518a3d',\n]);\n$this-&gt;consul-&gt;acl()-&gt;deleteBindingRule($bindingRule);\n\n// List Binding Rules\n$bindingRules = new BindingRules();\n$this-&gt;consul-&gt;acl()-&gt;bindingRules($bindingRules);\nAgent\n// List Members\n$this-&gt;consul-&gt;agent()-&gt;members(new Members([\n    'wan' =&gt; 'a',\n    'segment' =&gt; 'b',\n]));\n\n// Read Configuration\n$self = new SelfParams();\n$this-&gt;consul-&gt;agent()-&gt;self($self);\n\n// Reload Agent\n$reload = new Reload();\n$this-&gt;consul-&gt;agent()-&gt;reload($reload);\n\n// Enable Maintenance Mode\n$maintenance = new Maintenance([\n    'enable' =&gt; true,\n    'reason' =&gt; 'whatever',\n]);\n$this-&gt;consul-&gt;agent()-&gt;maintenance($maintenance);\n\n// View Metrics\n$metrics = new Metrics([\n    'format' =&gt; 'prometheus',\n]);\n$this-&gt;consul-&gt;agent()-&gt;metrics($metrics);\n\n// Stream Logs\n$monitor = new Monitor([\n    'loglevel' =&gt; 'info',\n]);\n$this-&gt;consul-&gt;agent()-&gt;monitor($monitor);\n\n// Join Agent\n$join = new Join([\n    'address' =&gt; '1.2.3.4',\n    'wan' =&gt; false\n]);\n$this-&gt;consul-&gt;agent()-&gt;join($join);\n\n// Graceful Leave and Shutdown\n$leave = new Leave();\n$this-&gt;consul-&gt;agent()-&gt;leave($leave);\n\n// Force Leave and Shutdown\n$forceLeave = new ForceLeave([\n    'node' =&gt; 'consul'\n]);\n$this-&gt;consul-&gt;agent()-&gt;forceLeave($forceLeave);\n\n// Update ACL Tokens\n$token = new Token([\n    'action' =&gt; 'acl_agent_token',\n    'token' =&gt; 'token'\n]);\n$this-&gt;consul-&gt;agent()-&gt;token($token);\nChecks\n// List Checks\n$checks = new Checks([\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;agent()-&gt;checks($checks);\n\n// Register Check\n$register = new Register([\n    'name' =&gt; 'Memory_utilization', // No special characters such as spaces or other urls are allowed. Otherwise, the unchecked check_id will report 400 error.\n    \"notes\" =&gt; \"Ensure we don't oversubscribe memory\",\n    \"DeregisterCriticalServiceAfter\" =&gt; \"90m\",\n    \"Args\" =&gt; [\"/usr/local/bin/check_mem.py\"],\n    \"DockerContainerID\" =&gt; \"f972c95ebf0e\",\n    \"Shell\" =&gt; \"/bin/bash\",\n    \"HTTP\" =&gt; \"https://example.com\",\n    \"Method\" =&gt; \"POST\",\n    \"Header\" =&gt; [\"x-foo\" =&gt; [\"bar\", \"baz\"]],\n    \"TCP\" =&gt; \"example.com:22\",\n    \"Interval\" =&gt; \"10s\",\n    \"TTL\" =&gt; \"15s\",\n    \"TLSSkipVerify\" =&gt; true,\n]);\n$this-&gt;consul-&gt;agent()-&gt;register($register);\n\n// Deregister Check\n$deRegister = new DeRegister([\n    'check_id' =&gt; 'Memory_utilization'\n]);\n$this-&gt;consul-&gt;agent()-&gt;deRegister($deRegister);\n\n// TTL Check Pass\n$pass = new Pass([\n    'check_id' =&gt; 'Memory_utilization',\n    'note' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;agent()-&gt;pass($pass);\n\n// TTL Check Warn\n$warn = new Warn([\n    'check_id' =&gt; 'Memory_utilization',\n    'note' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;agent()-&gt;warn($warn);\n\n// TTL Check Fail\n$fail = new Fail([\n    'check_id' =&gt; 'Memory_utilization',\n    'note' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;agent()-&gt;fail($fail);\n\n// TTL Check Update\n$update = new Update([\n    'check_id' =&gt; 'Memory_utilization',\n    'Status' =&gt; 'passing',\n    'Output' =&gt; 'update success'\n]);\n$this-&gt;consul-&gt;agent()-&gt;update($update);\nServices\n// List Services\n$services = new Services([\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;agent()-&gt;services($services);\n\n// Get Service Configuration\n $service = new Service([\n    'service_id' =&gt; \"consul\"\n]);\n$this-&gt;consul-&gt;agent()-&gt;service($service);\n\n// Get local service health\n$name = new Name([\n    'service_name' =&gt; 'consul',\n    'format' =&gt; 'text',\n]);\n$this-&gt;consul-&gt;agent()-&gt;name($name);\n\n// Get local service health by its ID\n$id = new ID([\n    'service_id' =&gt; 'consul',\n    'format' =&gt; 'text',\n]);\n$this-&gt;consul-&gt;agent()-&gt;id($id);\n\n// Register Service\n $register = new Service\\Register([\n    \"ID\" =&gt; \"redis1\",\n    \"name\" =&gt; \"redis\",\n    \"Tags\" =&gt; [\n        \"primary\",\n        \"v1\"\n    ],\n    \"Address\" =&gt; \"127.0.0.1\",\n    \"Port\" =&gt; 8000,\n    \"meta\" =&gt; [\n        \"redis_version\" =&gt; \"4.0\",\n    ],\n    \"EnableTagOverride\" =&gt; false,\n    \"Check\" =&gt; [\n        \"DeregisterCriticalServiceAfter\" =&gt; \"90m\",\n    \"Args\" =&gt; [\"/usr/local/bin/check_redis.py\"],\n    \"HTTP\" =&gt; \"http://localhost:5000/health\",\n    \"Interval\" =&gt; \"10s\",\n    \"TTL\" =&gt; \"15s\"\n    ],\n    \"weights\" =&gt; [\n        \"Passing\" =&gt; 10,\n    \"Warning\" =&gt; 1\n    ]\n]);\n$this-&gt;consul-&gt;agent()-&gt;serviceRegister($register);\n\n// Deregister Service\n$deregister = new Service\\DeRegister([\n    'service_id' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;agent()-&gt;serviceDeregister($deregister);\n\n// Enable Maintenance Mode\n$maintenance= new Service\\Maintenance([\n    'service_id' =&gt; 'consul',\n    'enable' =&gt; true,\n    'reason' =&gt; ''\n]);\n$this-&gt;consul-&gt;agent()-&gt;serviceMaintenance($maintenance);\nConnect\n// Authorize\n$authorize = new Authorize([\n    \"target\" =&gt; \"db\",\n    \"clientCertURI\" =&gt; \"spiffe://dc1-7e567ac2-551d-463f-8497-f78972856fc1.consul/ns/default/dc/dc1/svc/web\",\n    \"clientCertSerial\" =&gt; \"04:00:00:00:00:01:15:4b:5a:c3:94\"\n]);\n$this-&gt;consul-&gt;agent()-&gt;authorize($authorize);\n\n// Certificate Authority (CA) Roots\n$roots = new Roots();\n$this-&gt;consul-&gt;agent()-&gt;roots($roots);\n\n// Service Leaf Certificate\n$leaf = new Leaf([\n    'service' =&gt; 'consul'\n]);\n$this-&gt;consul-&gt;agent()-&gt;leaf($leaf);\nCatalog\n// Register Entity\n$register = new Register([\n    \"datacenter\" =&gt; \"dc1\",\n    \"id\" =&gt; \"40e4a748-2192-161a-0510-9bf59fe950b5\",\n    \"node\" =&gt; \"foobar\",\n    \"Address\" =&gt; \"192.168.10.10\",\n    \"TaggedAddresses\" =&gt; [\n        \"lan\" =&gt; \"192.168.10.10\",\n    \"wan\" =&gt; \"10.0.10.10\"\n    ],\n    \"NodeMeta\" =&gt; [\n        \"somekey\" =&gt; \"somevalue\"\n    ],\n    \"Service\" =&gt; [\n        \"ID\" =&gt; \"redis1\",\n    \"Service\" =&gt; \"redis\",\n    \"Tags\" =&gt; [\n            \"primary\",\n            \"v1\"\n        ],\n    \"Address\" =&gt; \"127.0.0.1\",\n    \"TaggedAddresses\" =&gt; [\n            \"lan\" =&gt; [\n                \"address\" =&gt; \"127.0.0.1\",\n        \"port\" =&gt; 8000,\n      ],\n      \"wan\" =&gt; [\n                \"address\" =&gt; \"198.18.0.1\",\n        \"port\" =&gt; 80\n      ]\n    ],\n    \"Meta\" =&gt; [\n            \"redis_version\" =&gt; \"4.0\"\n    ],\n    \"Port\" =&gt; 8000\n    ],\n    \"Check\" =&gt; [\n        \"Node\" =&gt; \"foobar\",\n    \"CheckID\" =&gt; \"service:redis1\",\n    \"Name\" =&gt; \"Redis health check\",\n    \"Notes\" =&gt; \"Script based health check\",\n    \"Status\" =&gt; \"passing\",\n    \"ServiceID\" =&gt; \"redis1\",\n    \"Definition\" =&gt; [\n            \"TCP\" =&gt; \"localhost:8888\",\n      \"Interval\" =&gt; \"5s\",\n      \"Timeout\" =&gt; \"1s\",\n      \"DeregisterCriticalServiceAfter\" =&gt; \"30s\"\n    ]\n    ],\n    \"SkipNodeUpdate\" =&gt; false\n]);\n$this-&gt;consul-&gt;catalog()-&gt;register($register);\n\n// Deregister Entity\n$deregister = new Deregister([\n    \"datacenter\" =&gt; \"dc1\",\n    \"node\" =&gt; \"foobar\",\n    \"CheckID\" =&gt; \"service:redis1\",\n]);\n$this-&gt;consul-&gt;catalog()-&gt;deRegister($deregister);\n\n// List Datacenters\n$datacenters = new Datacenters();\n$this-&gt;consul-&gt;catalog()-&gt;dataCenters($datacenters);\n\n// List Nodes\n$nodes = new Nodes([\n    'dc' =&gt; 'dc1',\n    'node-meta' =&gt; '',\n    'near' =&gt; '',\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;nodes($nodes);\n\n// List Services\n$nodes = new Nodes([\n$services = new Services([\n    'dc' =&gt; 'dc1',\n    'node-meta' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;services($services);\n]);\n$this-&gt;consul-&gt;catalog()-&gt;nodes($nodes);\n\n// List Nodes for Service\n$services = new Services([\n    'dc' =&gt; 'a',\n    'node-meta' =&gt; 'b',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;services($services);\n\n// List Nodes for Connect-capable Service\n$service = new Service([\n    'service' =&gt; 'consul',\n    'dc' =&gt; 'dc1',\n    'tag' =&gt; '',\n    'near' =&gt; '',\n    'node-meta' =&gt; '',\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;service($service);\n\n// List Services for Node\n$connect = new Connect([\n    'service' =&gt; 'consul',\n    'dc' =&gt; 'dc1',\n    'tag' =&gt; '',\n    'near' =&gt; '',\n    'node-meta' =&gt; '',\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;connect($connect);\n\n// List Services for Node\n$node = new Node([\n    'node' =&gt; '2eb87046a6fe',\n    'dc' =&gt; 'dc1',\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;node($node);\nConfig\n// Apply Configuration\n$config = new \\EasySwoole\\Consul\\Request\\Config([\n    'Kind' =&gt; 'service-defaults',\n    'Name' =&gt; 'web',\n    'Protocol' =&gt; 'Http'\n]);\n$this-&gt;consul-&gt;config()-&gt;config($config);\n\n// Get Configuration\n$config = new \\EasySwoole\\Consul\\Request\\Config([\n    'Kind' =&gt; 'service-defaults',\n    'name' =&gt; 'web',\n]);\n$this-&gt;consul-&gt;config()-&gt;getConfig($config);\n\n// List Configurations\n$config = new \\EasySwoole\\Consul\\Request\\Config([\n    'Kind' =&gt; 'service-defaults'\n]);\n$this-&gt;consul-&gt;config()-&gt;listConfig($config);\n\n// Delete Configuration\n$config = new \\EasySwoole\\Consul\\Request\\Config([\n    'Kind' =&gt; 'service-defaults',\n    'name' =&gt; 'web',\n]);\n$this-&gt;consul-&gt;config()-&gt;deleteConfig($config);\nConnect\nCertificate Authority (CA)\n// List CA Root Certificates\n$roots = new Roots();\n$this-&gt;consul-&gt;connect()-&gt;roots($roots);\n\n// Get CA Configuration\n$configuration = new Configuration();\n$this-&gt;consul-&gt;connect()-&gt;configuration($configuration);\n\n// Update CA Configuration\n$configuration = new Configuration([\n    'Provider' =&gt; 'consul',\n    'Config' =&gt; [\n        'LeafCertTTL' =&gt; '72h'\n    ]\n]);\n$this-&gt;consul-&gt;connect()-&gt;updateConfiguration($configuration);\nIntentions\n// Create Intention\n$intentions = new Intentions([\n    'SourceName' =&gt; 'web',\n    'DestinationName' =&gt; 'db',\n    'SourceType' =&gt; 'consul',\n    'action' =&gt; 'allow'\n]);\n$this-&gt;consul-&gt;connect()-&gt;intentions($intentions);\n\n// Read Specific Intention\n$intentions = new Intentions([\n    'uuid' =&gt; 'e9ebc19f-d481-42b1-4871-4d298d3acd5c',\n]);\n$this-&gt;consul-&gt;connect()-&gt;readIntention($intentions);\n\n// List Intentions\n$intentions = new Intentions();\n$this-&gt;consul-&gt;connect()-&gt;listIntention($intentions);\n\n// Update Intention\n$intentions = new Intentions([\n    'uuid' =&gt; 'b40faaf3-34aa-349f-3cf2-f5d720240662',\n    'description' =&gt; 'just a test description',\n    'SourceName' =&gt; '',\n    'DestinationName' =&gt; '',\n    'Action' =&gt; 'allow'\n]);\n$this-&gt;consul-&gt;connect()-&gt;updateIntention($intentions);\n\n// Delete Intention\n$intentions = new Intentions([\n    'uuid' =&gt; 'b40faaf3-34aa-349f-3cf2-f5d720240662',\n]);\n$this-&gt;consul-&gt;connect()-&gt;deleteIntention($intentions);\n\n// Check Intention Result\n$intentions = new Intentions\\Check([\n    'source' =&gt; 'web',\n    'destination' =&gt; 'db',\n]);\n$this-&gt;consul-&gt;connect()-&gt;check($intentions);\n\n// List Matching Intentions\n$intentions = new Intentions\\Match([\n    'by' =&gt; 'source',\n    'name' =&gt; 'web',\n]);\n$this-&gt;consul-&gt;connect()-&gt;match($intentions);\nCoordinate\n// Read WAN Coordinates\n$datacenters = new Datacenters();\n$this-&gt;consul-&gt;coordinates()-&gt;datacenters($datacenters);\n\n// Read LAN Coordinates for all nodes\n$nodes = new Nodes([]);\n$this-&gt;consul-&gt;coordinates()-&gt;nodes($nodes);\n\n// Read LAN Coordinates for a node\n$node = new Node([\n    'node' =&gt; '2456c2850382',\n]);\n$this-&gt;consul-&gt;coordinates()-&gt;node($node);\n\n// Update LAN Coordinates for a node\n$update = new Update([\n    'dc' =&gt; 'dc1',\n    'node' =&gt; '2456c2850382',\n    'Segment' =&gt; 'update',\n    \"Coord\" =&gt; [\n        \"Adjustment\" =&gt; 0,\n        \"Error\" =&gt; 1.5,\n        \"Height\" =&gt; 0,\n        \"Vec\" =&gt; [0, 0, 0, 0, 0, 0, 0, 0]\n    ]\n]);\n$this-&gt;consul-&gt;coordinates()-&gt;update($update);\nEvents\n// Fire Event\n$fire = new Fire([\n    'name' =&gt; 'consul',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;event()-&gt;fire($fire);\n\n// List Events\n$listEvent = new ListEvent([\n    'name' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;event()-&gt;listEvent($listEvent);\nHealth\n// List Checks for Node\n$node = new Node([\n    'node' =&gt; '2456c2850382',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;health()-&gt;node($node);\n\n// List Checks for Service\n$checks = new Checks([\n   'service' =&gt; 'consul',\n   'node_meta' =&gt; 'node-meta',\n]);\n$this-&gt;consul-&gt;health()-&gt;checks($checks);\n\n// List Nodes for Service\n$service = new Service([\n    'service' =&gt; 'consul',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;health()-&gt;service($service);\n\n// List Nodes for Connect-capable Service\n$connect = new Connect([\n    'service' =&gt; 'consul'\n]);\n$this-&gt;consul-&gt;health()-&gt;connect($connect);\n\n// List Checks in State\n$state = new State([\n    'state' =&gt; 'passing'\n]);\n$this-&gt;consul-&gt;health()-&gt;state($state);\nKV Store\n// Read Key\n$kv = new Kv([\n    'key' =&gt; 'my-key',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;kvStore()-&gt;kv($kv);\n\n// Create Key\n$create = new kv([\n    'key' =&gt; 'my-key',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;kvStore()-&gt;create($create);\n\n// Update Key\n$update = new kv([\n    'key' =&gt; 'my-key',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;kvStore()-&gt;update($update);\n\n// Delete Key\n$delete = new Kv([\n    'key' =&gt; 'my-key',\n    'recurse' =&gt; false,\n]);\n$this-&gt;consul-&gt;kvStore()-&gt;delete($delete);\nOperator\nArea\n// Create Network Area\n$area = new Area([\n    'PeerDatacenter' =&gt; 'dc1',\n    \"RetryJoin\" =&gt; [ \"10.1.2.3\", \"10.1.2.4\", \"10.1.2.5\" ],\n    \"UseTLS\" =&gt; false\n]);\n$this-&gt;consul-&gt;operator()-&gt;area($area);\n\n// List Network Areas\n$area = new Area([\n    'dc' =&gt; 'dc1',\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n]);\n$this-&gt;consul-&gt;operator()-&gt;areaList($area);\n\n// List Specific Network Area\n$area = new Area([\n    'dc' =&gt; 'dc1',\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n]);\n$this-&gt;consul-&gt;operator()-&gt;areaList($area);\n\n// Update Network Area\n$area = new Area([\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n    'UseTLS' =&gt; true,\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;operator()-&gt;updateArea($area);\n\n// Delete Network Area\n$area = new Area([\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n]);\n$this-&gt;consul-&gt;operator()-&gt;deleteArea($area);\n\n// Join Network Area\n$area = new Area([\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n]);\n$this-&gt;consul-&gt;operator()-&gt;joinArea($area);\n\n// List Network Area Members\n$area = new Area([\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902'\n]);\n$this-&gt;consul-&gt;operator()-&gt;membersArea($area);\nAutopilot\n// Read Configuration\n$configuration = new Configuration([\n    'dc' =&gt; 'dc1',\n    'stale' =&gt; true,\n]);\n$this-&gt;consul-&gt;operator()-&gt;getConfiguration($configuration);\n\n// Update Configuration\n$configuration = new Configuration([\n    'dc' =&gt; 'dc1',\n    'stale' =&gt; true,\n    \"cleanupDeadServers\" =&gt; true,\n    \"lastContactThreshold\" =&gt; \"200ms\",\n    \"MaxTrailingLogs\" =&gt; 250,\n    \"ServerStabilizationTime\" =&gt; \"10s\",\n    \"RedundancyZoneTag\" =&gt; \"\",\n    \"DisableUpgradeMigration\" =&gt; false,\n    \"UpgradeVersionTag\" =&gt; \"\",\n\n]);\n$this-&gt;consul-&gt;operator()-&gt;updateConfiguration($configuration);\n\n// Read Health\n$health = new Health([\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;operator()-&gt;health($health);\nKeyring\n// List Gossip Encryption Keys\n$keyring = new Keyring();\n$keyring-&gt;setRelayFactor(0);\n$keyring-&gt;setLocalOnly(false);\n$this-&gt;consul-&gt;operator()-&gt;getKeyring($keyring);\n\n// Add New Gossip Encryption Key\n$keyring = new Keyring([\n    \"Key\" =&gt; \"3lg9DxVfKNzI8O+IQ5Ek+Q==\",\n    'relayFactor' =&gt; 1,\n]);\n$this-&gt;consul-&gt;operator()-&gt;addKeyring($keyring);\n\n// Change Primary Gossip Encryption Key\n$keyring = new Keyring([\n    \"Key\" =&gt; \"3lg9DxVfKNzI8O+IQ5Ek+Q==\",\n]);\n$this-&gt;consul-&gt;operator()-&gt;changeKeyring($keyring);\n\n// Delete Gossip Encryption Key\n$keyring = new Keyring([\n    \"Key\" =&gt; \"3lg9DxVfKNzI8O+IQ5Ek+Q==\",\n    \"relayFactor\" =&gt; 1\n]);\n$this-&gt;consul-&gt;operator()-&gt;deleteKeyring($keyring);\nLicense\n// Getting the Consul License\n$license = new License([\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;operator()-&gt;getLicense($license);\n\n// Updating the Consul License\n$license = new License([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;operator()-&gt;updateLicense($license);\n\n// Resetting the Consul License\n$license = new License([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;operator()-&gt;resetLicense($license);\nRaft\n// Read Configuration\n$raft = new \\EasySwoole\\Consul\\Request\\Operator\\Raft\\Configuration();\n$this-&gt;consul-&gt;operator()-&gt;getRaftConfiguration($raft);\n\n// Delete Raft Peer\n$peer = new Peer([\n    'address' =&gt; '172.17.0.18:8301',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;operator()-&gt;peer($peer);\nSegment\n// List Network Segments\n$segment = new Segment();\n$this-&gt;consul-&gt;operator()-&gt;segment($segment);\nPrepared Query\n// Create Prepared Query\n$query = new Query([\n    \"name\" =&gt; \"my-query\",\n    \"Session\" =&gt; \"adf4238a-882b-9ddc-4a9d-5b6758e4159e\",\n    \"Token\" =&gt; \"11\",\n    \"Service\" =&gt; [\n        \"Service\" =&gt; \"redis\",\n        \"Failover\" =&gt; [\n            \"NearestN\" =&gt; 3,\n            \"Datacenters\" =&gt; [\"dc1\", \"dc2\"]\n         ],\n        \"Near\" =&gt; \"node1\",\n        \"OnlyPassing\" =&gt; false,\n        \"Tags\" =&gt; [\"primary\", \"!experimental\"],\n        \"NodeMeta\" =&gt; [\"instance_type\" =&gt; \"m3.large\"],\n        \"ServiceMeta\" =&gt; [\"environment\" =&gt; \"production\"]\n    ],\n    \"DNS\" =&gt; [\n        \"TTL\" =&gt; \"10s\"\n    ],\n]);\n$this-&gt;consul-&gt;query()-&gt;query($query);\n\n// Read Prepared Query\n$query = new Query([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;query()-&gt;readQuery($query);\n\n// Update Prepared Query\n$query = new Query([\n    'uuid' =&gt; '90dce5ca-5697-ae2f-09ae-51e9542ea58c',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;query()-&gt;updateQuery($query);;\n\n// Read Prepared Query\n$query = new Query([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;query()-&gt;readQuery($query);\n\n// Delete Prepared Query\n$query = new Query([\n    'uuid' =&gt; '90dce5ca-5697-ae2f-09ae-51e9542ea58c'\n]);\n$this-&gt;consul-&gt;query()-&gt;deleteQuery($query);;\n\n// Execute Prepared Query\n$execute = new Query\\Execute([\n    'uuid' =&gt; '90dce5ca-5697-ae2f-09ae-51e9542ea58c',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;query()-&gt;execute($execute);\n\n// Explain Prepared Query\n$execute = new Query\\Explain([\n    'uuid' =&gt; '90dce5ca-5697-ae2f-09ae-51e9542ea58c',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;query()-&gt;explain($execute);\nSessions\n// Create Session\n$create = new Create([\n    'dc' =&gt; 'dc1',\n    \"LockDelay\" =&gt; \"15s\",\n    \"Name\" =&gt; \"my-service-lock\",\n    \"Node\" =&gt; \"foobar\",\n    \"Checks\" =&gt; [\"a\", \"b\", \"c\"],\n    \"Behavior\" =&gt; \"release\",\n    \"TTL\" =&gt; \"30s\",\n]);\n$this-&gt;consul-&gt;session()-&gt;create($create);\n\n// Delete Session\n$destroy = new Destroy([\n    'uuid' =&gt; 'f32a15b3-1baa-c047-bde9-bec3015ea013',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;session()-&gt;destroy($destroy);\n\n// Read Session\n$info = new Info([\n    'uuid' =&gt; 'f32a15b3-1baa-c047-bde9-bec3015ea013',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;session()-&gt;info($info);\n\n// List Sessions for Node\n$node = new Node([\n    'node' =&gt; '2456c2850382',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;session()-&gt;node($node);\n\n// List Sessions\n$sessionList = new SessionList([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;session()-&gt;sessionList($sessionList);\n\n// Renew Session\n$renew = new Renew([\n    'uuid' =&gt; '4f6d1cf6-b60a-c929-eeb8-12f4d7eaff62',\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;session()-&gt;renew($renew);\nSnapshots\n// Generate Snapshot\n$generate = new Snapshot([\n    'dc' =&gt; 'dc1',\n    'stale' =&gt; 'true',\n]);\n$this-&gt;consul-&gt;snapshot()-&gt;generate($generate);\n\n// Restore Snapshot\n$restore = new Snapshot();\n$this-&gt;consul-&gt;snapshot()-&gt;restore($restore);\nStatus\n// Get Raft Leader\n$leader = new Leader();\n$this-&gt;consul-&gt;status()-&gt;leader($leader);\n\n// List Raft Peers\n$peers = new Peers([\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;status()-&gt;peers($peers);\nTransactions\n// Create Transaction\n$transaction = new Txn([]);\n$this-&gt;consul-&gt;transaction()-&gt;create($transaction);\n$node = new Node([\n    'node' =&gt; '44e4656a94cd',\n    'dc' =&gt; 'dc1',\n    'filter' =&gt; '',\n]);\n$consul-&gt;catalog()-&gt;node($node);\n","link":"/Components/consul.html"},{"id":214,"title":"appolo configuration center","content":"Apollo configuration center\nEasySwoole supports apollo data center. Synchronization can be configured according to this component.\napollo\nInstallation\ncomposer require easyswoole/apollo\nUse\ngo(function (){\n    //Configure apollo server information\n    $server = new \\EasySwoole\\Apollo\\Server([\n        'server'=&gt;'http://106.12.25.204:8080',\n        'appId'=&gt;'easyswoole'\n    ]);\n    //Create an apollo client\n    $apollo = new \\EasySwoole\\Apollo\\Apollo($server);\n    //First sync\n    var_dump( $apollo-&gt;sync('mysql'));\n    //The second synchronization, if the server has not changed, then the result returned, isModify marked as fasle, with lastReleaseKey\n    var_dump( $apollo-&gt;sync('mysql'));\n});\nCan start a timer in the process to achieve automatic timing update","link":"/Components/apollo.html"},{"id":215,"title":"how to learn swoole","content":"Learn how Swoole avoids being a programmer crying\nMany phpers who have just switched from the traditional fpm mode to the swoole memory resident mode will always feel grievances and even want to cry. The reason why swoole always makes you doubt life, is this really the php language I have known before? Why are you so pit?\nCommon &quot;pit&quot; under swoole\n\n\nWhy can't global variables be shared?\nFor example, in the following code\n$http = new swoole_http_server(\"127.0.0.1\", 9501);\n$http-&gt;on(\"request\", function ($request, $response) {\n    static $i;\n    $response-&gt;end($i);\n    $i++;\n});\n\n$http-&gt;start();\nSome people will find that the static $i under swoole is inconsistent with the output understood under fpm. This is due to the emergence of process cloning, and the data between each process is inconsistent.\n\n\nEcho var_dump cannot be output to the browser (http response)\nIn fpm mode, echo $a can output the result to the browser. Why can't it be in the swoole? The reason is that the mode change, the swoole mode is no longer fpm, but cli, if You need to respond to the data in the browser. You can only respond with the response object in the Http request callback.\n\n\nHttp request parameter acquisition\nIn the same swoole http service, many people will find that common global variables such as $_GET and $_POST cannot be used. This is because variables such as $_GET and $_POST are global, and there will be problems in the swoole. If you want to get the request parameters, you can use the Request object provided by the Swoole callback to get the result.\n\n\nSwoole can't use die/exit\nPhper is used to debugging code with die/exit. This is because this command will directly exit the current process. For fpm, each request corresponds to a separate process. Exiting the problem is not big, but in the swoole, there may be a process. There will be multiple requests being processed at the same time. If you exit or die to exit the current process, data will be lost.\n\n\nWhy do you need to disconnect after swoole     \nMany programmers are accustomed to single-handling database connections, which obviously has the advantage of saving the overhead of requiring multiple connections per request database. So why is the error in the swoole always prompting me that the database is disconnected? The reason is that under the traditional fpm, the request is over, then the process cleanup will be performed, the database connection will be cleaned up, and the reconnection will be performed the next time it comes in. This ensures that the connection is available. However, in the case of swoole resident memory, after the request ends, the connection will not be cleaned up and remain in the memory space, and if the connection is not used for a long time, or because the network fluctuates, it will be disconnected. The next time the request comes in, you don't judge the connection status, just go to execute the sql statement, then it means that you have operated a disconnected database connection, so it will definitely report an error.\n\n\nMemory leak\nWhen many people use swoole to write services, they always run and run out of memory. This is because swoole is a resident process type model. Under fpm, the variables in the process will be cleaned up after the request ends, and the variables of the swoole process global period will not be cleaned up due to the end of the request, and will be saved. In memory, on the one hand, the efficiency is improved, but also the developer must pay attention to the necessity of variable recycling.\n\n\nCoroutine context access security\nWhen using the swoole coroutine, some people will encounter the value of the variable does not meet the expected situation, which may be the contamination of the variable. In the traditional php synchronous blocking programming mode, all executions are forced to execute sequentially. However, in the swoole, multiple coroutines are alternately executed. It is possible that when a coroutine gives up the execution right, the b coroutine modifies a cross-correlation variable, then when a coroutine resumes the execution right. This cross-correlation variable will not be the value of the timeout (if you have some knowledge of mysql, you will find this situation is not difficult to understand). At the same time, in order to solve this problem, we usually pay attention to the use of cross-correlation variables and the use of coroutine singletons to control variables.\nKnowledge points to learn from using swoole\n\n\nIn the following content, must represents the part that must be learned first. If you do not understand it will lead to learning difficulties and deviations, the code written cannot be applied in the production environment; should represent the knowledge points recommended for learning, but you can just understand ; can represents the recommendation to learn, usually the weakness of the developer.\n\n\nBasic programming knowledge\n\n\nshouldunderstand the difference between blocking and non-blocking\n\n\nMust be clearPHP's GC mechanism' This must be clear, most php developers are not clear\n\nMustclear php object-oriented programming Here must be clear about the object reference mechanism and the relationship between objects and memory\n\nMust be clear about theresources and connection handles' knowledge\n\n\n\nMulti-process programming\n\n\nMust clear the multi-process models of fpm and swoole and their differences\n\nMust understand interprocess communication and process isolation, should understand process semaphore\n\n\n\n\nBasic TCP/UDP awareness\n\n\nshould be clear the difference between TCP and UDP.\n\nshould be clear the difference between client and server\n\nMustUnderstand the upper four layers of the OSI seven-layer model. Learn about common application layer protocols such as http ftp smtp\n\n\n\n\nCoroutine\n\n`Must' clear swoole coroutine working mode\n\nMustclear how to determine if a variable will be used across coroutines\n\n\n\nSummary\nAll in all, most php developers think that the reason for the pit when they learn swoole is from the lack of their own knowledge reserves. For the knowledge that many other language developers must master, php development may not need to be mastered, but this is also a technical debt that is owed, and will encounter bottlenecks when it is further improved; resulting in various uses when using swoole The problem. In fact, swoole is a very powerful php extension,  he redefines php, so that php has a stronger vitality.","link":"/Article/learnSwoole.html"},{"id":216,"title":"how does swoole restrict access frequency to ip","content":"How does swoole limit access frequency to ip\nIn the process of developing our api, sometimes we also need to consider the single user (ip) access frequency control to avoid being maliciously called.\nIn the final analysis, there are only two steps:\n\nUser access statistics\nBefore executing the operation logic, determine whether the frequency is too high. If it is too high, it will not be executed.\n\nIp access frequency limit in easyswoole\nThis article is an example of the code implemented in the easyswoole framework, which is implemented the same way in swoole native.\nJust make a judgment interception process in the corresponding callback event.\n\nUse swoole\\Table to store user access (can also be stored using other components and methods)\nUse the timer to clear the access situation of the previous cycle and count the next cycle.\n\nFor example, the following IpList class implements initialization of the Table, counts the number of IP accesses, and obtains records whose number of times exceeds a certain value within a period.\n&lt;?php\n/**\n * Ip visit statistics\n * User: Siam\n * Date: 2019/7/8 0008\n * Time: 9:53 PM\n */\n\nnamespace App;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\Component\\TableManager;\nuse Swoole\\Table;\n\nclass IpList\n{\n    use Singleton;\n\n    /** @var Table */\n    protected $table;\n\n    public  function __construct()\n    {\n        TableManager::getInstance()-&gt;add('ipList', [\n            'ip' =&gt; [\n                'type' =&gt; Table::TYPE_STRING,\n                'size' =&gt; 16\n            ],\n            'count' =&gt; [\n                'type' =&gt; Table::TYPE_INT,\n                'size' =&gt; 8\n            ],\n            'lastAccessTime' =&gt; [\n                'type' =&gt; Table::TYPE_INT,\n                'size' =&gt; 8\n            ]\n        ], 1024*128);\n        $this-&gt;table = TableManager::getInstance()-&gt;get('ipList');\n    }\n\n    function access(string $ip):int\n    {\n        $key  = substr(md5($ip), 8,16);\n        $info = $this-&gt;table-&gt;get($key);\n\n        if ($info) {\n            $this-&gt;table-&gt;set($key, [\n                'lastAccessTime' =&gt; time(),\n                'count'          =&gt; $info['count'] + 1,\n            ]);\n            return $info['count'] + 1;\n        }else{\n            $this-&gt;table-&gt;set($key, [\n                'ip'             =&gt; $ip,\n                'lastAccessTime' =&gt; time(),\n                'count'          =&gt; $info['count'] + 1,\n            ]);\n            return 1;\n        }\n    }\n\n    function clear()\n    {\n        foreach ($this-&gt;table as $key =&gt; $item){\n            $this-&gt;table-&gt;del($key);\n        }\n    }\n\n    function accessList($count = 10):array\n    {\n        $ret = [];\n        foreach ($this-&gt;table as $key =&gt; $item){\n            if ($item['count'] &gt;= $count){\n                $ret[] = $item;\n            }\n        }\n        return $ret;\n    }\n\n}\nAfter the operation of encapsulating the IP statistics\nWe can initialize IpList and timer in the mainServerCreate callback event of EasySwooleEvent.php\n&lt;?php\n\npublic static function mainServerCreate(EventRegister $register)\n{\n    // Enable IP current limit\n    IpList::getInstance();\n    $class = new class('IpAccessCount') extends AbstractProcess{\n        protected function run($arg)\n        {\n            $this-&gt;addTick(5*1000, function (){\n                /**\n                 * Normal users won't have api requests more than 6 times a second.\n                 * Do list recording and empty\n                 */\n                $list = IpList::getInstance()-&gt;accessList(30);\n                // var_dump($list);\n                IpList::getInstance()-&gt;clear();\n            });\n        }\n    };\n}\nThen we judge and count the access of Ip in the OnRequest callback.\n&lt;?php\n\npublic static function onRequest(Request $request, Response $response): bool\n{\n    $fd = $request-&gt;getSwooleRequest()-&gt;fd;\n    $ip = ServerManager::getInstance()-&gt;getSwooleServer()-&gt;getClientInfo($fd)['remote_ip'];\n\n    // Intercept if the access frequency of the current period has exceeded the set value\n    // When testing, you can change 30, such as 3\n    if (IpList::getInstance()-&gt;access($ip) &gt; 30) {\n        /**\n         * Directly forcibly close the connection\n         */\n        ServerManager::getInstance()-&gt;getSwooleServer()-&gt;close($fd);\n        // Debug output can be logically processed\n        echo 'Blocked'.PHP_EOL;\n        return false;\n    }\n    // Debug output can do logic processing\n    echo 'Normal access'.PHP_EOL;\n}\nThe above implements the restriction operation on the same IP access frequency.\nSpecifically, it can be extended according to its own needs, such as limiting traffic to a specific interface.\nEasyswoole provides a current limiter component based on the Atomic counter. Can be used directly, use the tutorial, please step to view the flow restrictor documentation.","link":"/Article/swooleIpLimit.html"},{"id":217,"title":"service flow restriction and degradation in microservice development","content":"Service blown current limit and downgrade\nThe core idea: just do not get the best, then take a step back and use the general to guarantee the service.\nWhy should fusible current limit\nFirst of all, we can clarify one thing, no matter how the algorithm and operation and maintenance are optimized, the carrying capacity of a single server is limited. For example, in a common game server, suppose that our stand-alone machine can carry a normal game of 100,000 users. One day\nAs the market has been promoted, there have been 200,000 10,000 users coming in at once. So what should we do if we can't expand in a short time? That is the fuse current limit. We are still accepting the top 100,000 users who log in, and the next 100,000 users let them line up. It seems like it will still let\nHalf of the users are not happy, but this is also the best option. If not, it could lead to 200,000, that is, all users have no way to have a good experience.\nWhy are you downgrading?\nFor example, an application scenario has a real-time statistical leaderboard in a game service. Under normal circumstances, the request comes in, and is forwarded to the statistics service in real time for statistics. And one day, because of the activity, the pressure is too large, the statistics server crashes, or because\nOther factors have caused the statistical services to go offline. At this time, the request comes in, then it must return NULL data to the front end, resulting in a poor user experience. Therefore, we can do downgrade services, for example, the simplest, real-time statistics can not be done, then I pull the cache results of the last statistics, always.\nHow to achieve fuse limiting\nWhen it comes to fuse limiting, the most contacted in daily life, it should be the token bucket restrictor. EasySwoole provides a token bucket limiter, you can see the document component library. Under normal circumstances, there will be a pressure test before our service goes online. According to the 28th principle, when the load reaches 80% of the load and the user response time is controlled below 200ms, we define the user load at the moment as the optimal load, so at this time, we will limit the current limiter. The number is limited to this optimal load capacity. The same is true for downgrading services. When a service is accessed multiple times and a service is unavailable, we believe that the service needs to be downgraded.","link":"/Article/degradedService.html"},{"id":218,"title":"swooletracker","content":"Swoole Tracker\nSwoole Trackeris a complete set of enterprise-level PHP and Swoole analysis and debugging tools produced by Swoole. It fully supports the coroutine/non-corridor environment, real-time data visualization, comprehensive analysis of report service status, rapid discovery and accurate positioning of problems and performance bottlenecks. . After installing the swoole_tracker extension, we can bury the points in the various events provided in the EasySwoole for application monitoring.\n\nThe installation of the swoole_tracker extension can be found in the installation documentation https://www.kancloud.cn/swoole-inc/ee-base-wiki/1214079#_24 and can be found at https://www.swoole-cloud.com/ Get support, if you need to customize the local deployment, please contact the framework author or Swoole official customer service.\n\nRendering\nApplication monitoring\n\nDebugger - process list\n\n\nThe following is the debugging toolchain function in the enterprise version. Remote debugging is enabled through PID, which supports detection of blocking IO, memory leak and code performance analysis.\n\nDebugger - blocking detection\n\nDebugger - Memory Leak Detection\n\nDebugger - performance analysis\n\nInterface monitoring\n\nstart up\nAfter installing the swoole_tracker extension, we execute:\n/opt/swoole/script/php/swoole_php /opt/swoole/node-agent/src/node.php &amp; php easyswoole start\nThe EasySwoole can be monitored.\nUse\nNo need to modify the code\nThe v2.5.0 version of Swoole Tracker supports automatic generation of application names and creation of applications without modifying any code. The generated application name format is:\nSwoole: HttpServer：ip:prot\nothersServer：ip(hostname):prot\nModify code\nYou need to modify the code when you need to customize the app name:\nHttp service monitoring\nGlobal monitoring\nIn EasySwooleEvent.php, register the two events onRequest, afterResponse respectively.\n\nonRequest event\npublic static function onRequest(Request $request, Response $response): bool\n{\n$tick = \\SwooleTracker\\Stats::beforeExecRpc($request-&gt;getUri()-&gt;getPath(), 'serviceName', \"192.168.0.1\");\n/*\n    Host the tick generated by the request to the context manager\n*/\nContextManager::getInstance()-&gt;set(\"SWOOLE_TRACKER_TICK\",$tick);\nreturn true;\n}\n\nafterRequest event\npublic static function afterRequest(Request $request, Response $response): void\n{\n$tick = ContextManager::getInstance()-&gt;get('SWOOLE_TRACKER_TICK');\nif($response-&gt;getStatusCode() != 200){\n    $ret = false;\n}else{\n   $ret = true;\n}\n\\SwooleTracker\\Stats::afterExecRpc($tick, $ret, $response-&gt;getStatusCode());\n}\nAfter registering the above events, all the link information of the Http service will be automatically reported to the Swoole Tracker server.\n\n\nHttp group monitoring\nIf you need to do detailed packet monitoring of the Http service, we can define a Base controller.\nclass Base extends Controller\n{\n    public $tick;\n\n    function onRequest(?string $action): ?bool\n    {\n        $this-&gt;tick = \\SwooleTracker\\Stats::beforeExecRpc($request-&gt;getUri()-&gt;getPath(), 'myGroupName', \"192.168.0.1\");\n        return true;\n    }\n\n    function afterAction(?string $actionName): void\n    {\n        \\SwooleTracker\\Stats::afterExecRpc($tick, true, 200);\n        $this-&gt;tick = null;\n    }\n}\nFor example, all the Api controllers need to be monitored, so the corresponding controller inherits the corresponding Base controller.\nRpc, Tcp, WebSocket service monitoring\nEasyswoole's Rpc, Tcp, and WebSocket services also provide onRequest, afterAction methods, and bury the two methods to achieve corresponding monitoring.","link":"/Other/swooleTracker.html"},{"id":219,"title":"queue consumption / custom process issues","content":"How to implement queue consumption / custom process\nMaybe we will often encounter scenarios that require constant consumption of content in the queue. We implement this function in the way of custom processes in EasySwoole.\nImplementation code\nDefine consumption process logic\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2018/10/18 0018\n * Time: 9:43\n */\n\nnamespace App\\Process;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse Swoole\\Process;\n\nclass Consumer extends AbstractProcess\n{\n    private $isRun = false;\n    public function run($arg)\n    {\n        // TODO: Implement run() method.\n        /*\n         * For example, consume queue data in redis\n         * Timed 500ms to detect whether there is a task, and if it is a while loop execution\n         */\n        $this-&gt;addTick(500,function (){\n            if(!$this-&gt;isRun){\n                $this-&gt;isRun = true;\n                $redis = new \\redis();//Here is the pseudo code, please establish a connection or maintain a redis connection.\n                while (true){\n                    try{\n                        $task = $redis-&gt;lPop('task_list');\n                        if($task){\n                            // do you task\n                        }else{\n                            break;\n                        }\n                    }catch (\\Throwable $throwable){\n                        break;\n                    }\n                }\n                $this-&gt;isRun = false;\n            }\n            var_dump($this-&gt;getProcessName().' task run check');\n        });\n    }\n\n    public function onShutDown()\n    {\n        // TODO: Implement onShutDown() method.\n    }\n\n    public function onReceive(string $str, ...$args)\n    {\n        // TODO: Implement onReceive() method.\n    }\n}\nRegistered consumption process\nIn the global event of EasySwoole, register the consumption process.\n&lt;?php\nuse App\\Consumer;\nuse EasySwoole\\EasySwoole\\ServerManager;\n\npublic static function mainServerCreate(EventRegister $register)\n{\n       $allNum = 3;\n           for ($i = 0 ;$i &lt; $allNum;$i++){\n              \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new Consumer(\"consumer_{$i}\"));\n           }\n}\nReptile example: https://github.com/HeKunTong/easyswoole3_demo","link":"/Other/process.html"},{"id":220,"title":"redis/kafka subscribe","content":"Custom process implementation redis subscription\nImplementation code\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2018/10/18 0018\n * Time: 10:28\n */\n\nnamespace App\\Process;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse Swoole\\Process;\n\nclass Subscribe extends AbstractProcess\n{\n    public function run($arg)\n    {\n        // TODO: Implement run() method.\n        $redis = new \\Redis();//Here is the pseudo code, please establish your own connection or maintenance\n        $redis-&gt;connect('127.0.0.1');\n        $redis-&gt;subscribe(['ch1'],function (){\n            var_dump(func_get_args());\n        });\n    }\n\n    public function onShutDown()\n    {\n        // TODO: Implement onShutDown() method.\n    }\n\n    public function onReceive(string $str, ...$args)\n    {\n        // TODO: Implement onReceive() method.\n    }\n\n}\nNext, what needs to be done is to register the process in the main service creation event of EasySwooleEvent.php.\nuse App\\Process;\nuse EasySwoole\\Core\\Swoole\\Process\\ProcessManager;\n\n\\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new Subscribe('sub'));","link":"/Other/redisSubscribe.html"},{"id":221,"title":"kernel optimization","content":"Kernel parameter adjustment\nUlimit setting\nUlimit -n should be adjusted to 100000 or more. Execute ulimit -n 100000 from the command line to modify it. If you can't modify it, you need to set /etc/security/limits.conf to join.\n* soft nofile 262140\n* hard nofile 262140\nroot soft nofile 262140\nroot hard nofile 262140\n* soft core unlimited\n* hard core unlimited\nroot soft core unlimited\nroot hard core unlimited\nNote that after modifying the limits.conf file, you need to restart the system to take effect.\nKernel settings\nThe Linux operating system has three ways to modify kernel parameters:\n\nModify the /etc/sysctl.conf file, add configuration options, the format is key = value, modify the save and call sysctl -p to load the new configuration.\nUse the sysctl command to temporarily modify it, such as: sysctl -w net.ipv4.tcp_mem=\"379008 505344 758016\"\n\nDirectly modify the files in the /proc/sys/ directory, such as: echo \"379008 505344 758016\" &gt; /proc/sys/net/ipv4/tcp_mem\n\n\nThe first method will take effect automatically after the operating system restarts, and the second and third methods will fail after restarting.\nnet.unix.max_dgram_qlen = 100\nSwoole uses unix socket dgram for interprocess communication. If the request volume is large, you need to adjust this parameter. The system defaults to 10 and can be set to 100 or greater.\nOr increase the number of worker processes and reduce the amount of requests allocated by a single worker process.\nnet.core.wmem_max\nModify this parameter to increase the memory size of the socket cache. \nnet.ipv4.tcp_mem  =   379008       505344  758016\nnet.ipv4.tcp_wmem = 4096        16384   4194304\nnet.ipv4.tcp_rmem = 4096          87380   4194304\nnet.core.wmem_default = 8388608\nnet.core.rmem_default = 8388608\nnet.core.rmem_max = 16777216\nnet.core.wmem_max = 16777216\nnet.ipv4.tcp_tw_reuse\nWhether socket reuse, the function of this function is to quickly re-use the listening port when the server restarts. If this parameter is not set, the port will not be released in time and the startup will fail when the server is restarted.\nnet.ipv4.tcp_tw_recycle\nUse socket to quickly recycle. Short connection server needs to enable this parameter. This parameter indicates that the fast recovery of TIME-WAIT sockets in the TCP connection is enabled. In Linux, the default is 0, which means it is closed. Turning on this parameter may cause the NAT user connection to be unstable. Please test it carefully before turning it on.\nMessage queue settings\nThis kernel parameter needs to be adjusted when using Message Queuing as the interprocess communication method.\n\nkernel.msgmnb = 4203520, The maximum number of bytes in the message queue\nkernel.msgmni = 64, How many message queues are allowed to be created\nkernel.msgmax = 8192, Message queue single data maximum length\n\nFreeBSD/MacOS\n\nsysctl -w net.local.dgram.maxdgram=8192\nsysctl -w net.local.dgram.recvspace=200000\nModify the buffer area size of Unix Socket\n\nOpen CoreDump\nSet kernel parameters\nkernel.core_pattern = /data/core_files/core-%e-%p-%t\nView the current limit of the coredump file by using the ulimit -c command\nulimit -c\nIf it is 0, you need to modify /etc/security/limits.conf to set the limit.\nAfter core-dump is turned on, the process is exported to a file once an exception occurs in the program. Great help for investigating procedural issues\nOther important configurations\n\nnet.ipv4.tcp_syncookies=1\nnet.ipv4.tcp_max_syn_backlog=81920\nnet.ipv4.tcp_synack_retries=3\nnet.ipv4.tcp_syn_retries=3\nnet.ipv4.tcp_fin_timeout = 30\nnet.ipv4.tcp_keepalive_time = 300\nnet.ipv4.tcp_tw_reuse = 1\nnet.ipv4.tcp_tw_recycle = 1\nnet.ipv4.ip_local_port_range = 20000    65000\nnet.ipv4.tcp_max_tw_buckets = 200000\nnet.ipv4.route.max_size = 5242880\n\nCheck whether the configuration takes effect\nSuch as: modify net.unix.max_dgram_qlen = 100, through\ncat /proc/sys/net/unix/max_dgram_qlen\nIf the modification is successful, here is the newly set value.","link":"/Other/kernelOptimization.html"},{"id":222,"title":"service hot overload","content":"Service hot restart\nDue to the characteristics of swoole resident memory, after modifying the file, you need to restart the worker process to reload the modified file into memory. We can customize the process to implement file change and automatically perform service overloading.\nHot overload process\nCreate a new file App/Process/HotReload.php and add the following content, or you can put it in another location, please correspond to the namespace.\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: evalor\n * Date: 2018-11-26\n * Time: 23:18\n */\n\nnamespace App\\Process;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\EasySwoole\\ServerManager;\nuse EasySwoole\\Utility\\File;\nuse Swoole\\Process;\nuse Swoole\\Table;\nuse Swoole\\Timer;\n\n/**\n * Violent hot overload\n * Class HotReload\n * @package App\\Process\n */\nclass HotReload extends AbstractProcess\n{\n    /** @var \\swoole_table $table */\n    protected $table;\n    protected $isReady = false;\n\n    protected $monitorDir; // Directory to be monitored\n    protected $monitorExt; // Suffix to be monitored\n\n    /**\n     * Start timer for cyclic scan\n     */\n    public function run($arg)\n    {\n        // Specify the directory to be monitored here. It is recommended to only monitor file changes in the App directory.\n        $this-&gt;monitorDir = !empty($arg['monitorDir']) ? $arg['monitorDir'] : EASYSWOOLE_ROOT . '/App';\n\n        // Specify the extension to be monitored, not the file of the specified type, ignore the change, do not restart\n        $this-&gt;monitorExt = !empty($arg['monitorExt']) &amp;&amp; is_array($arg['monitorExt']) ? $arg['monitorExt'] : ['php'];\n\n        if (extension_loaded('inotify') &amp;&amp; empty($arg['disableInotify'])) {\n            // Extension available, prioritize processing with extensions\n            $this-&gt;registerInotifyEvent();\n            echo \"server hot reload start : use inotify\\n\";\n        } else {\n            // Violent scanning when extensions are not available\n            $this-&gt;table = new Table(512);\n            $this-&gt;table-&gt;column('mtime', Table::TYPE_INT, 4);\n            $this-&gt;table-&gt;create();\n            $this-&gt;runComparison();\n            Timer::tick(1000, function () {\n                $this-&gt;runComparison();\n            });\n            echo \"server hot reload start : use timer tick comparison\\n\";\n        }\n    }\n\n    /**\n     * Scan file change\n     */\n    private function runComparison()\n    {\n        $startTime = microtime(true);\n        $doReload = false;\n\n        $dirIterator = new \\RecursiveDirectoryIterator($this-&gt;monitorDir);\n        $iterator = new \\RecursiveIteratorIterator($dirIterator);\n        $inodeList = array();\n\n        // Iterate through the directory of all files for inspection\n        foreach ($iterator as $file) {\n            /** @var \\SplFileInfo $file */\n            $ext = $file-&gt;getExtension();\n            if (!in_array($ext, $this-&gt;monitorExt)) {\n                continue; // Check only the specified type\n            } else {\n                // Since the file name is modified and does not need to be reloaded, it can be monitored based on the inode\n                $inode = $file-&gt;getInode();\n                $mtime = $file-&gt;getMTime();\n                array_push($inodeList, $inode);\n                if (!$this-&gt;table-&gt;exist($inode)) {\n                    // New file or modified file, changed inode\n                    $this-&gt;table-&gt;set($inode, ['mtime' =&gt; $mtime]);\n                    $doReload = true;\n                } else {\n                    // Modify the file, but no inode changes have occurred\n                    $oldTime = $this-&gt;table-&gt;get($inode)['mtime'];\n                    if ($oldTime != $mtime) {\n                        $this-&gt;table-&gt;set($inode, ['mtime' =&gt; $mtime]);\n                        $doReload = true;\n                    }\n                }\n            }\n        }\n\n        foreach ($this-&gt;table as $inode =&gt; $value) {\n            // Iterating over the table to find the inode that needs to be deleted\n            if (!in_array(intval($inode), $inodeList)) {\n                $this-&gt;table-&gt;del($inode);\n                $doReload = true;\n            }\n        }\n\n        if ($doReload) {\n            $count = $this-&gt;table-&gt;count();\n            $time = date('Y-m-d H:i:s');\n            $usage = round(microtime(true) - $startTime, 3);\n            if (!$this-&gt;isReady == false) {\n                // It is monitored that a hot restart is required\n                echo \"severReload at {$time} use : {$usage} s total: {$count} files\\n\";\n                ServerManager::getInstance()-&gt;getSwooleServer()-&gt;reload();\n            } else {\n                // The first scan does not require a reboot\n                echo \"hot reload ready at {$time} use : {$usage} s total: {$count} files\\n\";\n                $this-&gt;isReady = true;\n            }\n        }\n    }\n\n    /**\n     * Register the Inotify listen event\n     */\n    private function registerInotifyEvent()\n    {\n        // Because the process is independent and is currently a custom process, global variables are only used by the process.\n        // In the case of determining that it will not cause pollution, it is also possible to use global variables reasonably.\n        global $lastReloadTime;\n        global $inotifyResource;\n\n        $lastReloadTime = 0;\n        $files = File::scanDirectory(EASYSWOOLE_ROOT . '/App');\n        $files = array_merge($files['files'], $files['dirs']);\n\n        $inotifyResource = inotify_init();\n\n        // Add event listeners for all current directories and files\n        foreach ($files as $item) {\n            inotify_add_watch($inotifyResource, $item, IN_CREATE | IN_DELETE | IN_MODIFY);\n        }\n\n        // Join the event loop\n        swoole_event_add($inotifyResource, function () {\n            global $lastReloadTime;\n            global $inotifyResource;\n            $events = inotify_read($inotifyResource);\n            if ($lastReloadTime &lt; time() &amp;&amp; !empty($events)) { // Repetitive reload cannot be performed within 1s\n                $lastReloadTime = time();\n                ServerManager::getInstance()-&gt;getSwooleServer()-&gt;reload();\n            }\n        });\n    }\n\n    public function onShutDown()\n    {\n        // TODO: Implement onShutDown() method.\n    }\n\n    public function onReceive(string $str)\n    {\n        // TODO: Implement onReceive() method.\n    }\n}\nAfter adding it, register the custom process in the global EasySwooleEvent.php\npublic static function mainServerCreate(EventRegister $register)\n{\n    \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new HotReload('HotReload', ['disableInotify' =&gt; false]));\n}\nBecause inotify in the virtual machine cannot monitor the file uploading events such as FTP/SFTP, set disableInotify to true, you can disable the hot restart of inotify mode, so that the virtual machine environment will force the file loop scan to trigger the overload operation. In the OSX development environment, there is no Inotify extension, which will automatically use scan overloading.","link":"/Other/hotReload.html"},{"id":223,"title":"random generation problem","content":"Random generation problem\nDue to the Swoole itself, when using random numbers, you need to pay extra attention. If mt_rand is called in the parent process, the result returned by calling mt_rand in different child processes will be the same. So you must call mt_srand to reseek in each child process.\nshuffle and array_rand and other PHP functions that rely on random numbers will also be affected.\nScene example\nIn asynchronous tasks, asynchronous processes, you need to pay attention to the problem of random number seeding, as in the following example.\nmt_rand(0, 1);    // Mt_rand has been called here and has been automatically seeded within the parent process\n$worker_num = 16;\n\n// Fork process\nfor ($i = 0; $i &lt; $worker_num; $i++) {\n    $process = new swoole_process('child_async', false, 2);\n    $pid = $process-&gt;start();\n}\n\nfunction child_async(swoole_process $worker)\n{\n    mt_srand();  // Must be replanted here, otherwise the same result will be obtained\n    echo mt_rand(0, 100) . PHP_EOL;\n    $worker-&gt;exit();\n}","link":"/Other/random.html"},{"id":224,"title":"trait and singleton","content":"Trait and singleton\n\ntrait A{\n    private static $instance;\n    static function getInstance()\n    {\n        if(!isset(self::$instance)){\n            self::$instance = new static();\n        }\n        return self::$instance;\n    }\n}\n\nclass B{\n    use A;\n    function a()\n    {\n        var_dump('call at B');\n    }\n}\n\nclass C extends B{\n    function a()\n    {\n        var_dump('call at c');\n        parent::a(); // TODO: Change the autogenerated stub\n    }\n}\n\nclass D extends B{\n    use A;\n    function a()\n    {\n        var_dump('call at D');\n        parent::a(); // TODO: Change the autogenerated stub\n    }\n}\n$b = B::getInstance();\n$c = C::getInstance();\n$d = D::getInstance();\n\n$c-&gt;a();\n$d-&gt;a();\n\nAbove output:\nstring(9) \"call at B\"\nstring(9) \"call at D\"\nstring(9) \"call at B\"\n","link":"/Other/traitSingleTon.html"},{"id":225,"title":"mysql index dimensionality reduction","content":"Mysql index dimension reduction\nMany people know that mysql has the concept of indexing, but it rarely goes to the truth. How to use indexes to reduce the dimension of data to improve the query speed.\nA common scenario is the user log (order), for example, in China Mobile's call recording system, which needs to be recorded.\nThe phone number, the called number and the outgoing time are called out, and in the system, the most common or used most demand is to query the call history of a certain user within a certain period of time. We made the following data feature simulation:\n\nWithin a month, there are 10,000 accounts, and 30,000 call records are made every day.\n\nData simulation generated code:\n&lt;?php\n\nrequire 'vendor/autoload.php';\n\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n//::: warning \n//&gt;=3.3.7,initialize:`EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()-&gt;globalInitialize();`\n//:::\n\nfunction generatePhoneList()\n{\n    $list = [];\n    for ($i=0;$i &lt;= 10000; $i++){\n        array_push($list,'155'.\\EasySwoole\\Utility\\Random::number(8));\n    }\n    return $list;\n}\n\nfunction generateTimeList(int $startTime,$max = 30000)\n{\n    $list = [];\n    for ($i=0;$i&lt;=$max;$i++){\n        //Simulation from 7 am to early morning\n        $t = mt_rand(\n            25200,86400\n        );\n        array_push($list,$startTime+$t);\n    }\n    sort($list);\n    return $list;\n}\n\n$config = \\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL');\n$db = new \\App\\Utility\\Pools\\MysqlPoolObject($config);\n$phoneList = generatePhoneList();\n//Simulate one month's time data\n$start = strtotime('20180101');\n//\nfor ($i = 0; $i&lt;=30; $i++){\n    $timeList = generateTimeList($start);\n    foreach ($timeList as $time){\n        $phone = $phoneList[mt_rand(0,10000)];\n        $target = $phoneList[mt_rand(0,10000)];\n        $db-&gt;insert('user_phone_record',[\n            'phone'=&gt;$phone,\n            'targetPhone'=&gt;$target,\n            'callTime'=&gt;$time\n        ]);\n\n    }\n    $start += 86400;\n}\nIn this explanation, taking the data volume of 500,000 as an example, I am too lazy to wait for data generation. Phone, callTime is the index field.\nDemand\nQuery all call records for an account within a certain period of time.\nSo at this moment, many people may write directly:\nSELECT * FROM test.user_phone_record where callTime &gt;=  1514768050 and  callTime &lt;= 1514871213 and  phone = 15587575857;\nThe above statement executed 0.26s in my test machine, but if I adjust the order of where:\nSELECT * FROM test.user_phone_record where phone = 15587575857 and callTime &gt;=  1514768050 and  callTime &lt;= 1514871213 ;\nIt only takes 0.1s for a long time, saving half the time. Then these two seemingly similar statements are not the same for the execution time.\nIntuitive interpretation\nFirst, we execute two sql and view the results separately (don't say why not explain and explain), just want to give you the most intuitive explanation.\n\n SELECT count(*) FROM test.user_phone_record where phone = 15587575857 \nThe result was 15 records.\nSELECT count(*) FROM test.user_phone_record where callTime >=  1514768050 and  callTime \nThe result was 76,491 records.\n\nThen the most intuitive explanation comes: first where callTime and then where phone, then what mysql does is:\nFirst find 76,491 records, and then find the record with an account of 15587575857 from 76,491 records. In the same way, the first where phone, and then the screening time, is definitely faster.\nWhy is this happening?\nThis is the same as the specific data structure and scene can be tuned by the preconditions:\n\nWithin one month, there are 10,000 accounts, and 30,000 call records are made every day.\n\nIt can be seen that the frequency of a single user's call is not high. Therefore, the search method of locating the phone index set and then excluding the time is definitely more efficient than setting the account at a predetermined time.\nNote that this is a specific scene! ! ! Specifically, please use explain and profiling to analyze, MYSQL execution interpreter, not so simple.","link":"/Other/mysqlIndexReduce.html"},{"id":226,"title":"tporm usage problems","content":"TP ORM usage problem\nSince the swoole is running in the resident memory + coroutine environment, when using the TP ORM, the TP ORM comes with a lot of static variables, and there will be problems. The specific analysis is as follows:\nNon-co-resident resident memory mode\nIn synchronous, non-co-schedu mode, a worker only processes one request in one time, and will restart the process when it reaches max_request. It can barely operate sql, but the following static variables will have problems:\nThink\\Db static variable:\nprotected static $config = [];\n//Database configuration, almost no impact\n\nprotected static $query;\n//Query class name, no effect\n\nprotected static $queryMap = [\n    'mongo' =&gt; '\\\\think\\\\db\\Mongo',\n];\n//Query class automatic mapping, no effect\n\npublic static $queryTimes = 0;\n//Database query count\n//Resident memory is the number of global queries\n\npublic static $executeTimes = 0;\n//Number of executions\n//Resident memory is actually the number of global executions\n\nprotected static $cacheHandler;\n//Cache object, no effect\n\nThink\\Model static variable:\nprotected static $initialized = [];\n//Initialized model.\n//Original role: ensure that the init method in a model class is only executed once in a single request.\n//Resident in memory: A model only executes this method on the first request, subsequent requests are no longer executed, and it is very likely to cause a bug.\n\nprotected static $readMaster;\n//Whether to read data from the main library\n//Almost no effect\n\nThink\\db\\Connection static variable:\nprotected static $instance = [];\n//PDO operation example\n//Established connection management instance\n//Coroutine mode, high concurrency may cause database operation bugs\n\nprotected static $event = [];\n//Listening callback\n//Original role: event callback set for the model\n//Resident memory: As the running time increases, the running memory will continue to increase, and the event of one request increase will affect another request.\n\nprotected static $info = [];\n// Data sheet information\n// Almost no effect\n\nprotected static $log = [];\n// Database log\n// Original role: Log all log operations for a request\n// Resident memory: As the database continues to operate, this variable will continue to increase, causing memory overflow\n\nThink\\db\\Query static variable:\nprotected static $connections = [];\n// Database Connection object\n// Temporarily not found where to use\n\nprivate static $event = [];\n//Callback event\n//Original role: set a callback event of its own under one request\n//Resident in memory: an event that is added in one request will affect another request\n\nprivate static $extend = [];\n//Extended query method\n//Almost no effect\n\nprivate static $readMaster = [];\n//Need to read the table of the main library\n//Original role: set whether one or all models read data from the main library\n//Resident memory: If a Query::readMaster() method is executed on a request, Query::$readMaster will not be released, which will affect other requests.\n\nThink\\Db\\ModelEvent Static variable:\nprivate static $event = [];\n// Callback event\n//Original role: event callback set for the model\n//Resident memory: As the running time increases, the running memory will continue to increase, and the event of one request increase will affect another request.\n\nprotected static $observe = ['before_write', 'after_write', 'before_insert', 'after_insert', 'before_update', 'after_update', 'before_delete', 'after_delete', 'before_restore', 'after_restore'];\n//Model event observation\n//No effect\n\nCoroutine resident memory mode\nIn the coroutine mode, multiple clients share a database connection, and database operation exceptions will occur.\nE.g:\n\nUser A accesses service A, database opens transaction -&gt; payment logic -&gt; complete transaction\nUser B accesses service B at the same time and inserts n data.\nUser C accesses service A at the same time, the database opens the transaction-&gt;payment logic-&gt;logic error, rollback\n\nIn this logic, since both are sharing a database operation and are affected by coroutine switching, the database execution steps may become:\nUser A database open transaction -&gt; User B inserts n data -&gt; User C opens transaction -&gt; User A payment logic -&gt; User C payment logic -&gt; User C logic error, rollback transaction -&gt; User A completes transaction\nWhen the database is executed like this, all database operations of users A, B, and C will be rolled back, but the front end may return success.\nSimilarly, due to the sharing of static variables, other callback events and other issues also exist.","link":"/Other/tpORM.html"},{"id":227,"title":"curlssl error","content":"CURL SSL error\nIn the lower version of CURL, if the CURL is executed before the service is started, an ssl connection is executed. Then, after executing the curl again in the callback function, an error will be reported:\nA PKCS #11 module returned CKR_DEVICE_ERROR, indicating that a problem has occurred with the token or slot.\nIf the CURL SSL connection is not executed before the service is started, no error is reported.\nRelated code\n$a = function (){\n    $ch = curl_init(\"https://www.baidu.com\");\n    $curlOPt = array(\n        CURLOPT_CONNECTTIMEOUT=&gt;3,\n        CURLOPT_TIMEOUT=&gt;10,\n        CURLOPT_AUTOREFERER=&gt;true,\n        CURLOPT_USERAGENT=&gt;\"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C; .NET4.0E)\",\n        CURLOPT_FOLLOWLOCATION=&gt;true,\n        CURLOPT_RETURNTRANSFER=&gt;true,\n        CURLOPT_SSL_VERIFYPEER=&gt;false,\n        CURLOPT_SSL_VERIFYHOST=&gt;false,\n        CURLOPT_HEADER=&gt;true,\n    );\n    curl_setopt_array($ch,$curlOPt);\n    $result = curl_exec($ch);\n    var_dump(curl_error($ch));\n    curl_close($ch);\n};\n\n$a();\n\nif(pcntl_fork()){\n    $a();\n}else{\n    $a();\n}\n\nThe same is true in swoole.\nsolution\nUpdate libcurl to the latest 7.5.x and recompile php curl extension.\nView the expanded version:\nphp --ri curl","link":"/Other/curlSsl.html"},{"id":228,"title":"chromeheadless","content":"Chrome Headless\nWhat is Chrome Headless\nHeadless Chrome is Chrome's no-interface form that lets you run your programs with all Chrome-supported features without opening your browser. In short, headless chrome has all modern browsers except for no graphical interface. Features, can render the target page as in other modern browsers, and can take screenshots, get cookies, get html and other operations.\nFor the students who write reptiles, many of them will face a problem, that is, the data is obtained through dynamic rendering or even encryption. The common analytic interface mode can no longer meet the demand, so we introduce Chrome Headless to solve the data rendering problem.\nDeploy Chrome Headless\nBecause environment deployment is not the focus of this article, we recommend docker directly.\ndocker pull alpeware/chrome-headless-trunk\ndocker run -d -p 9222:9222 alpeware/chrome-headless-trunk\nAccess the debug address to get the interface information\ncurl http://{HOST}:9222/josn\nIn the following example, the IP host defined by {HOST} rings.\nDrive Chrome Headless\nChrome Headless can remotely drive debug via the websocket protocol. First we introduce the websocket client of easyswoole.\ncomposer require easyswoole/http-client\nWe take the website https://datacenter.jin10.com/price as an example. We can find out that the data in it is refreshed in real time through websocket. At this time, the means of grasping the interface by traditional means is difficult to achieve. The simulation is implemented as follows:\nuse EasySwoole\\HttpClient\\HttpClient;\nuse EasySwoole\\Spl\\SplBean;\nuse Swoole\\WebSocket\\Frame;\n\nstatic $i = 0;\n\n//Define the command bean. The specific protocol format can be seen in the Chrome Headless document.\n\nclass Command extends SplBean{\n    protected $method;\n    protected $id;\n    protected $params;\n    protected function initialize(): void\n    {\n        if(empty($this-&gt;id)){\n            global $i;\n            $i++;\n            $this-&gt;id = $i;\n        }\n    }\n}\n//Use the websocket protocol to drive Chrome Headless\ngo(function (){\n    $targetUrl = 'https://datacenter.jin10.com/price';\n    $ch = curl_init('http://{HOST}:9222/json');\n    curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);\n    $data = json_decode( curl_exec($ch) ,true);\n    $client = new HttpClient($data[0]['webSocketDebuggerUrl']);\n    if($client-&gt;upgrade()){\n        //Open URL\n        $command = new Command([\n            'method'=&gt;'Page.navigate',\n            'params'=&gt;[\n                'url'=&gt;$targetUrl\n            ]\n        ]);\n        $client-&gt;getClient()-&gt;push($command-&gt;__toString());\n        $client-&gt;recv(1);\n        //Simulation waiting for rendering\n        \\co::sleep(2);\n        //Implement the js statement\n        $command = new Command([\n            'method'=&gt;'Runtime.evaluate',\n            'params'=&gt;[\n                'expression'=&gt;\"var p = document.querySelector('#J_pricewall &gt; div:nth-child(1) &gt; ul &gt; li:nth-child(1)').innerHTML;p;\"\n            ]\n        ]);\n        $client-&gt;getClient()-&gt;push($command-&gt;__toString());\n        //Here you can get the rendered data.\n        $data = json_decode($client-&gt;recv()-&gt;data,true)['result']['result']['value'];\n        var_dump($data);\n\n    }else{\n        var_dump('handshake fail');\n    }\n});\n\nThe above tutorial is for learning purposes only, please do not use it for illegal purposes.","link":"/Other/chromeHeadless.html"},{"id":229,"title":"graphql","content":"GraphQL\nThis document assumes that you are familiar with the concept of GraphQL. If this is not the case, please first understand GraphQL on the official website.\nDependent class library\ncomposer require webonyx/graphql-php\nUsed in EasySwoole Http\nIn fact, the essence of the use in the EasySwoole Http server is how to get the json data from RAW_POST. We paste the code directly:\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\GraphQL;\nuse GraphQL\\Type\\Schema;\n\nclass Index extends Controller\n{\n\n    function index()\n    {\n        $queryType = new ObjectType([\n            'name' =&gt; 'Query',\n            'fields' =&gt; [\n                'echo' =&gt; [\n                    'type' =&gt; Type::string(),\n                    'args' =&gt; [\n                        'message' =&gt; Type::nonNull(Type::string()),\n                    ],\n                    'resolve' =&gt; function ($root, $args) {\n                        return $root['prefix'] . $args['message'];\n                    }\n                ],\n            ],\n        ]);\n        $schema = new Schema([\n            'query' =&gt; $queryType\n        ]);\n\n        $input = $this-&gt;json();\n        $query = $input['query'];\n        $variableValues = isset($input['variables']) ? $input['variables'] : null;\n        try {\n            $rootValue = ['prefix' =&gt; 'You said: '];\n            $result = GraphQL::executeQuery($schema, $query, $rootValue, null, $variableValues);\n            $output = $result-&gt;toArray();\n        } catch (\\Exception $e) {\n            $output = [\n                'errors' =&gt; [\n                    [\n                        'message' =&gt; $e-&gt;getMessage()\n                    ]\n                ]\n            ];\n        }\n\n        $this-&gt;writeJson(200,$output);\n    }\n}","link":"/Other/graphQL.html"},{"id":231,"title":"ritaswcipaddress-ip address locations(offline version)","content":"IP address home, support IPv6 address (offline database, regularly updated)\nLink\nGithub\nPackagist\nBlog\nUse\ncomposer require ritaswc/zx-ip-address\n$result = \\Ritaswc\\ZxIPAddress\\IPv4Tool::query('114.114.114.114');\n/*\n$result = [\n    \"start\" =&gt; \"114.114.114.114\"\n    \"end\" =&gt; \"114.114.114.114\"\n    \"addr\" =&gt; array:2 [\n        0 =&gt; \"Nanjing, Jiangsu Province\"\n        1 =&gt; \"Greatbit DNS server of Nanjing trade wind Network Technology Co., Ltd\"\n    ]\n    \"disp\" =&gt; \"Greatbit DNS server of Nanjing trade wind Network Technology Co., Ltd\"\n]\n */\n$result = \\Ritaswc\\ZxIPAddress\\IPv6Tool::query('240e:e9:8819:0:3::3f9');\n/*\n$result = [\n    \"start\" =&gt; \"240e:e9:8800::\"\n    \"end\" =&gt; \"240e:e9:8fff:ffff::\"\n    \"addr\" =&gt; array:2 [\n        0 =&gt; \"Suzhou City, Jiangsu Province, China\"\n        1 =&gt; \"China Telecom IDC\"\n    ]\n    \"disp\" =&gt; \"China Telecom IDC, Suzhou City, Jiangsu Province, China\"\n]\n */","link":"/OpenSource/ritaswcIpAddress.html"},{"id":232,"title":"docker","content":"Docker deployment\n`Docker is an open source application container engine, which allows developers to package their applications and dependency packages into a portable image, and then publish them to any popular 'Linux' or 'windows' machine. It can also realize virtualization. Containers use sandbox mechanism completely, and there is no interface between them.\n\nBefore using dockerfor deployment, users need to install [docker] by themselves（ https://www.docker.com/get-started ).:::\nPull image\nPlease execute the following command on the terminal\n\ndocker pull easyswoole/easyswoole3\n\nThe environment on the hub is php7.2 + swoole4.4.17 + easyswoole 3.3.x\nFramework startup\n\ndocker run -ti -p 9501:9501 easyswoole/easyswoole3\n\nThe default working directory is: /easyswoole\nAfter the command is executed, the system will automatically enter the working directory, execute PHP easywoole start and access the host browser\nHow to develop\nThe mapping function of docker can be used to map the host directory to the container. In the mapped directory, re install easywoole according to the framework installation document. In the host development, synchronous testing is carried out in the container.\n\nNote that in some environments, such as the docker environment of the win10 system.\nYou can't use the virtual machine shared directory as the 'temp' directory of easysoole. Because of insufficient permissions, you can't create socket. This will result in an error: listen xxxxxx.sock  To do this, you can manually dev.php In the configuration file, change the 'temp' directory to another path, such as:/ tmp`:::\nDockerfile\nDockerfile It is a text file used to build an image. The text content contains instructions and instructions for building an image.\nFROM centos:8\n\n#version defined\nENV SWOOLE_VERSION 4.4.17\nENV EASYSWOOLE_VERSION 3.x\n\n#install libs\nRUN yum install -y curl zip unzip  wget openssl-devel gcc-c++ make autoconf git\n#install php\nRUN yum install -y php-devel php-openssl php-mbstring php-json php-simplexml\n# composer\nRUN curl -sS https://getcomposer.org/installer | php \\\n    && mv composer.phar /usr/bin/composer && chmod +x /use/bin/composer\n# use aliyun composer\nRUN composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\n\n# swoole ext\nRUN wget https://github.com/swoole/swoole-src/archive/v${SWOOLE_VERSION}.tar.gz -O swoole.tar.gz \\\n    && mkdir -p swoole \\\n    && tar -xf swoole.tar.gz -C swoole --strip-components=1 \\\n    && rm swoole.tar.gz \\\n    && ( \\\n    cd swoole \\\n    && phpize \\\n    && ./configure --enable-openssl \\\n    && make \\\n    && make install \\\n    ) \\\n    && sed -i \"2i extension=swoole.so\" /etc/php.ini \\\n    && rm -r swoole\n\n# Dir\nWORKDIR /easyswoole\n# install easyswoole\nRUN cd /easyswoole \\\n    && composer require easyswoole/easyswoole=${EASYSWOOLE_VERSION} \\\n    && php vendor/easyswoole/easyswoole/bin/easyswoole install\n\nEXPOSE 9501\n\n","link":"/Deploy/docker.html"},{"id":233,"title":"nginx","content":"Nginx deployment\n[Nginx](http://nginx.org/）Is a lightweight Web server/reverse proxy server and e-mail (IMAP / POP3) proxy server. It is characterized by less memory and strong concurrency. It can be used as the front server of easysoole to realize load balancing.\nhttp proxy\n# At least one is required to configure the easysoole node\nupstream easyswoole {\n    server 127.0.0.1:9501;\n    server 127.0.0.1:9502;\n    server 127.0.0.1:9503;\n}\n\nserver {\n    # Port monitored by nginx\n    listen 80; \n    # domain name\n    server_name proxy.easyswoole.com;\n\n    location / {\n        # Forward the host and IP information of the client to the corresponding node \n        proxy_set_header Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n        # Forward cookie, set samesite\n        proxy_cookie_path / \"/; secure; HttpOnly; SameSite=strict\";\n\n        # Proxy access to real servers\n        proxy_pass http://easyswoole;\n    }\n}\nwebsocket proxy\n#At least one is required to configure the easysoole node\nupstream easyswoole {\n    # The load balancing mode is set to IP hash. The function is that different clients will interact with the same node every time they request.\n    ip_hash;\n    server 127.0.0.1:9501;\n    server 127.0.0.1:9502;\n    server 127.0.0.1:9503;\n}\n\nserver {\n    listen 80;\n    server_name websocket.easyswoole.com;\n\n    location / {\n        # websocket的header\n        proxy_http_version 1.1;\n        # Upgrade HTTP1.1 to websocket protocol\n        proxy_set_header Upgrade websocket;\n        proxy_set_header Connection \"Upgrade\";\n\n        # Forward the host and IP information of the client to the corresponding node\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Host $http_host;\n\n        # If there is no interaction between the client and the server within 60 seconds, the connection will be disconnected automatically.\n        proxy_read_timeout 60s ;\n\n        # Proxy access to real servers\n        proxy_pass http://easyswoole;\n    }\n}","link":"/Deploy/nginx.html"},{"id":234,"title":"supervisor","content":"Supervisor deployment\n[Supervisor]( http://supervisord.org ）It is a client / server service developed with Python. It is a process management tool under Linux / Unix system and does not support windows system. It is convenient to monitor, start, stop and restart one or more processes. For processes managed by supervisor, when a process is accidentally killed, it will be automatically pulled up again. Developers do not need to write their own shell for process management to maintain their own services.\nInstall Supervisor\nUse the installation method under the 'Ubuntu' system to demonstrate:\n\napt-get -y install supervisor\n\nCreate profile\n\nvim /etc/supervisor/conf.d/easyswoole.conf\n\nThe contents of the document are as follows：\n# Set the app name to easywoole\n[program:easyswoole]\n# Set running directory\ndirectory=/data/wwwroot/EasySwoole3.4.x\n# Start command for project\ncommand=php easyswoole server start\n# Set the user to run the process\nuser=www-data\n# Do you want to start the application automatically when supervisor starts\nautostart=true\n# Does the process exit and restart automatically\nautorestart=true\n# How many seconds after the process starts is considered to be successful. The default is 1s\nstartsecs=1\n# The maximum number of failed attempts is 3 by default\nstartretries=3\n# stderr\nstderr_logfile=/data/wwwlog/easyswoole-stderr.log\n# stdout\nstdout_logfile=/data/wwwlog/easyswoole-stdout.log\n启动Supervisor\n\nservice supervisor start\n\nSupervisorctl\nStart EasySwoole\n\nsupervisorctl start easyswoole\n\nStop EasySwoole\n\nsupervisorctl stop easyswoole\n\nRestart EasySwoole\n\nsupervisorctl restart easyswoole\n\nView all monitored apps\n\nsupervisorctl status\n\nReload configuration file\n\nsupervisorctl update\n\nRestart all apps\n\nsupervisorctl reload\n","link":"/Deploy/supervisor.html"}]